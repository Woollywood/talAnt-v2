(() => {
    var __webpack_modules__ = {
        490: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var window = __webpack_require__(908);
            var httpResponseHandler = function httpResponseHandler(callback, decodeResponseBody) {
                if (decodeResponseBody === void 0) decodeResponseBody = false;
                return function(err, response, responseBody) {
                    if (err) {
                        callback(err);
                        return;
                    }
                    if (response.statusCode >= 400 && response.statusCode <= 599) {
                        var cause = responseBody;
                        if (decodeResponseBody) if (window.TextDecoder) {
                            var charset = getCharset(response.headers && response.headers["content-type"]);
                            try {
                                cause = new TextDecoder(charset).decode(responseBody);
                            } catch (e) {}
                        } else cause = String.fromCharCode.apply(null, new Uint8Array(responseBody));
                        callback({
                            cause
                        });
                        return;
                    }
                    callback(null, responseBody);
                };
            };
            function getCharset(contentTypeHeader) {
                if (contentTypeHeader === void 0) contentTypeHeader = "";
                return contentTypeHeader.toLowerCase().split(";").reduce((function(charset, contentType) {
                    var _contentType$split = contentType.split("="), type = _contentType$split[0], value = _contentType$split[1];
                    if (type.trim() === "charset") return value.trim();
                    return charset;
                }), "utf-8");
            }
            module.exports = httpResponseHandler;
        },
        603: (module, __unused_webpack_exports, __webpack_require__) => {
            "use strict";
            var window = __webpack_require__(908);
            var _extends = __webpack_require__(434);
            var isFunction = __webpack_require__(376);
            createXHR.httpHandler = __webpack_require__(490);
            /**
 * @license
 * slighly modified parse-headers 2.0.2 <https://github.com/kesla/parse-headers/>
 * Copyright (c) 2014 David Bj√∂rklund
 * Available under the MIT license
 * <https://github.com/kesla/parse-headers/blob/master/LICENCE>
 */            var parseHeaders = function parseHeaders(headers) {
                var result = {};
                if (!headers) return result;
                headers.trim().split("\n").forEach((function(row) {
                    var index = row.indexOf(":");
                    var key = row.slice(0, index).trim().toLowerCase();
                    var value = row.slice(index + 1).trim();
                    if (typeof result[key] === "undefined") result[key] = value; else if (Array.isArray(result[key])) result[key].push(value); else result[key] = [ result[key], value ];
                }));
                return result;
            };
            module.exports = createXHR;
            module.exports["default"] = createXHR;
            createXHR.XMLHttpRequest = window.XMLHttpRequest || noop;
            createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest ? createXHR.XMLHttpRequest : window.XDomainRequest;
            forEachArray([ "get", "put", "post", "patch", "head", "delete" ], (function(method) {
                createXHR[method === "delete" ? "del" : method] = function(uri, options, callback) {
                    options = initParams(uri, options, callback);
                    options.method = method.toUpperCase();
                    return _createXHR(options);
                };
            }));
            function forEachArray(array, iterator) {
                for (var i = 0; i < array.length; i++) iterator(array[i]);
            }
            function isEmpty(obj) {
                for (var i in obj) if (obj.hasOwnProperty(i)) return false;
                return true;
            }
            function initParams(uri, options, callback) {
                var params = uri;
                if (isFunction(options)) {
                    callback = options;
                    if (typeof uri === "string") params = {
                        uri
                    };
                } else params = _extends({}, options, {
                    uri
                });
                params.callback = callback;
                return params;
            }
            function createXHR(uri, options, callback) {
                options = initParams(uri, options, callback);
                return _createXHR(options);
            }
            function _createXHR(options) {
                if (typeof options.callback === "undefined") throw new Error("callback argument missing");
                var called = false;
                var callback = function cbOnce(err, response, body) {
                    if (!called) {
                        called = true;
                        options.callback(err, response, body);
                    }
                };
                function readystatechange() {
                    if (xhr.readyState === 4) setTimeout(loadFunc, 0);
                }
                function getBody() {
                    var body = void 0;
                    if (xhr.response) body = xhr.response; else body = xhr.responseText || getXml(xhr);
                    if (isJson) try {
                        body = JSON.parse(body);
                    } catch (e) {}
                    return body;
                }
                function errorFunc(evt) {
                    clearTimeout(timeoutTimer);
                    if (!(evt instanceof Error)) evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"));
                    evt.statusCode = 0;
                    return callback(evt, failureResponse);
                }
                function loadFunc() {
                    if (aborted) return;
                    var status;
                    clearTimeout(timeoutTimer);
                    if (options.useXDR && xhr.status === void 0) status = 200; else status = xhr.status === 1223 ? 204 : xhr.status;
                    var response = failureResponse;
                    var err = null;
                    if (status !== 0) {
                        response = {
                            body: getBody(),
                            statusCode: status,
                            method,
                            headers: {},
                            url: uri,
                            rawRequest: xhr
                        };
                        if (xhr.getAllResponseHeaders) response.headers = parseHeaders(xhr.getAllResponseHeaders());
                    } else err = new Error("Internal XMLHttpRequest Error");
                    return callback(err, response, response.body);
                }
                var xhr = options.xhr || null;
                if (!xhr) if (options.cors || options.useXDR) xhr = new createXHR.XDomainRequest; else xhr = new createXHR.XMLHttpRequest;
                var key;
                var aborted;
                var uri = xhr.url = options.uri || options.url;
                var method = xhr.method = options.method || "GET";
                var body = options.body || options.data;
                var headers = xhr.headers = options.headers || {};
                var sync = !!options.sync;
                var isJson = false;
                var timeoutTimer;
                var failureResponse = {
                    body: void 0,
                    headers: {},
                    statusCode: 0,
                    method,
                    url: uri,
                    rawRequest: xhr
                };
                if ("json" in options && options.json !== false) {
                    isJson = true;
                    headers["accept"] || headers["Accept"] || (headers["Accept"] = "application/json");
                    if (method !== "GET" && method !== "HEAD") {
                        headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json");
                        body = JSON.stringify(options.json === true ? body : options.json);
                    }
                }
                xhr.onreadystatechange = readystatechange;
                xhr.onload = loadFunc;
                xhr.onerror = errorFunc;
                xhr.onprogress = function() {};
                xhr.onabort = function() {
                    aborted = true;
                };
                xhr.ontimeout = errorFunc;
                xhr.open(method, uri, !sync, options.username, options.password);
                if (!sync) xhr.withCredentials = !!options.withCredentials;
                if (!sync && options.timeout > 0) timeoutTimer = setTimeout((function() {
                    if (aborted) return;
                    aborted = true;
                    xhr.abort("timeout");
                    var e = new Error("XMLHttpRequest timeout");
                    e.code = "ETIMEDOUT";
                    errorFunc(e);
                }), options.timeout);
                if (xhr.setRequestHeader) {
                    for (key in headers) if (headers.hasOwnProperty(key)) xhr.setRequestHeader(key, headers[key]);
                } else if (options.headers && !isEmpty(options.headers)) throw new Error("Headers cannot be set on an XDomainRequest object");
                if ("responseType" in options) xhr.responseType = options.responseType;
                if ("beforeSend" in options && typeof options.beforeSend === "function") options.beforeSend(xhr);
                xhr.send(body || null);
                return xhr;
            }
            function getXml(xhr) {
                try {
                    if (xhr.responseType === "document") return xhr.responseXML;
                    var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === "parsererror";
                    if (xhr.responseType === "" && !firefoxBugTakenEffect) return xhr.responseXML;
                } catch (e) {}
                return null;
            }
            function noop() {}
        },
        167: (__unused_webpack_module, exports) => {
            "use strict";
            function find(list, predicate, ac) {
                if (ac === void 0) ac = Array.prototype;
                if (list && typeof ac.find === "function") return ac.find.call(list, predicate);
                for (var i = 0; i < list.length; i++) if (Object.prototype.hasOwnProperty.call(list, i)) {
                    var item = list[i];
                    if (predicate.call(void 0, item, i, list)) return item;
                }
            }
            function freeze(object, oc) {
                if (oc === void 0) oc = Object;
                return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
            }
            function assign(target, source) {
                if (target === null || typeof target !== "object") throw new TypeError("target is not an object");
                for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                return target;
            }
            var MIME_TYPE = freeze({
                HTML: "text/html",
                isHTML: function(value) {
                    return value === MIME_TYPE.HTML;
                },
                XML_APPLICATION: "application/xml",
                XML_TEXT: "text/xml",
                XML_XHTML_APPLICATION: "application/xhtml+xml",
                XML_SVG_IMAGE: "image/svg+xml"
            });
            var NAMESPACE = freeze({
                HTML: "http://www.w3.org/1999/xhtml",
                isHTML: function(uri) {
                    return uri === NAMESPACE.HTML;
                },
                SVG: "http://www.w3.org/2000/svg",
                XML: "http://www.w3.org/XML/1998/namespace",
                XMLNS: "http://www.w3.org/2000/xmlns/"
            });
            exports.assign = assign;
            exports.find = find;
            exports.freeze = freeze;
            exports.MIME_TYPE = MIME_TYPE;
            exports.NAMESPACE = NAMESPACE;
        },
        129: (__unused_webpack_module, exports, __webpack_require__) => {
            var conventions = __webpack_require__(167);
            var dom = __webpack_require__(146);
            var entities = __webpack_require__(45);
            var sax = __webpack_require__(925);
            var DOMImplementation = dom.DOMImplementation;
            var NAMESPACE = conventions.NAMESPACE;
            var ParseError = sax.ParseError;
            var XMLReader = sax.XMLReader;
            function normalizeLineEndings(input) {
                return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
            }
            function DOMParser(options) {
                this.options = options || {
                    locator: {}
                };
            }
            DOMParser.prototype.parseFromString = function(source, mimeType) {
                var options = this.options;
                var sax = new XMLReader;
                var domBuilder = options.domBuilder || new DOMHandler;
                var errorHandler = options.errorHandler;
                var locator = options.locator;
                var defaultNSMap = options.xmlns || {};
                var isHTML = /\/x?html?$/.test(mimeType);
                var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
                if (locator) domBuilder.setDocumentLocator(locator);
                sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
                sax.domBuilder = options.domBuilder || domBuilder;
                if (isHTML) defaultNSMap[""] = NAMESPACE.HTML;
                defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
                var normalize = options.normalizeLineEndings || normalizeLineEndings;
                if (source && typeof source === "string") sax.parse(normalize(source), defaultNSMap, entityMap); else sax.errorHandler.error("invalid doc source");
                return domBuilder.doc;
            };
            function buildErrorHandler(errorImpl, domBuilder, locator) {
                if (!errorImpl) {
                    if (domBuilder instanceof DOMHandler) return domBuilder;
                    errorImpl = domBuilder;
                }
                var errorHandler = {};
                var isCallback = errorImpl instanceof Function;
                locator = locator || {};
                function build(key) {
                    var fn = errorImpl[key];
                    if (!fn && isCallback) fn = errorImpl.length == 2 ? function(msg) {
                        errorImpl(key, msg);
                    } : errorImpl;
                    errorHandler[key] = fn && function(msg) {
                        fn("[xmldom " + key + "]\t" + msg + _locator(locator));
                    } || function() {};
                }
                build("warning");
                build("error");
                build("fatalError");
                return errorHandler;
            }
            function DOMHandler() {
                this.cdata = false;
            }
            function position(locator, node) {
                node.lineNumber = locator.lineNumber;
                node.columnNumber = locator.columnNumber;
            }
            DOMHandler.prototype = {
                startDocument: function() {
                    this.doc = (new DOMImplementation).createDocument(null, null, null);
                    if (this.locator) this.doc.documentURI = this.locator.systemId;
                },
                startElement: function(namespaceURI, localName, qName, attrs) {
                    var doc = this.doc;
                    var el = doc.createElementNS(namespaceURI, qName || localName);
                    var len = attrs.length;
                    appendElement(this, el);
                    this.currentElement = el;
                    this.locator && position(this.locator, el);
                    for (var i = 0; i < len; i++) {
                        namespaceURI = attrs.getURI(i);
                        var value = attrs.getValue(i);
                        qName = attrs.getQName(i);
                        var attr = doc.createAttributeNS(namespaceURI, qName);
                        this.locator && position(attrs.getLocator(i), attr);
                        attr.value = attr.nodeValue = value;
                        el.setAttributeNode(attr);
                    }
                },
                endElement: function(namespaceURI, localName, qName) {
                    var current = this.currentElement;
                    current.tagName;
                    this.currentElement = current.parentNode;
                },
                startPrefixMapping: function(prefix, uri) {},
                endPrefixMapping: function(prefix) {},
                processingInstruction: function(target, data) {
                    var ins = this.doc.createProcessingInstruction(target, data);
                    this.locator && position(this.locator, ins);
                    appendElement(this, ins);
                },
                ignorableWhitespace: function(ch, start, length) {},
                characters: function(chars, start, length) {
                    chars = _toString.apply(this, arguments);
                    if (chars) {
                        if (this.cdata) var charNode = this.doc.createCDATASection(chars); else charNode = this.doc.createTextNode(chars);
                        if (this.currentElement) this.currentElement.appendChild(charNode); else if (/^\s*$/.test(chars)) this.doc.appendChild(charNode);
                        this.locator && position(this.locator, charNode);
                    }
                },
                skippedEntity: function(name) {},
                endDocument: function() {
                    this.doc.normalize();
                },
                setDocumentLocator: function(locator) {
                    if (this.locator = locator) locator.lineNumber = 0;
                },
                comment: function(chars, start, length) {
                    chars = _toString.apply(this, arguments);
                    var comm = this.doc.createComment(chars);
                    this.locator && position(this.locator, comm);
                    appendElement(this, comm);
                },
                startCDATA: function() {
                    this.cdata = true;
                },
                endCDATA: function() {
                    this.cdata = false;
                },
                startDTD: function(name, publicId, systemId) {
                    var impl = this.doc.implementation;
                    if (impl && impl.createDocumentType) {
                        var dt = impl.createDocumentType(name, publicId, systemId);
                        this.locator && position(this.locator, dt);
                        appendElement(this, dt);
                        this.doc.doctype = dt;
                    }
                },
                warning: function(error) {
                    console.warn("[xmldom warning]\t" + error, _locator(this.locator));
                },
                error: function(error) {
                    console.error("[xmldom error]\t" + error, _locator(this.locator));
                },
                fatalError: function(error) {
                    throw new ParseError(error, this.locator);
                }
            };
            function _locator(l) {
                if (l) return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
            }
            function _toString(chars, start, length) {
                if (typeof chars == "string") return chars.substr(start, length); else {
                    if (chars.length >= start + length || start) return new java.lang.String(chars, start, length) + "";
                    return chars;
                }
            }
            "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, (function(key) {
                DOMHandler.prototype[key] = function() {
                    return null;
                };
            }));
            function appendElement(hander, node) {
                if (!hander.currentElement) hander.doc.appendChild(node); else hander.currentElement.appendChild(node);
            }
            DOMHandler;
            normalizeLineEndings;
            exports.DOMParser = DOMParser;
        },
        146: (__unused_webpack_module, exports, __webpack_require__) => {
            var conventions = __webpack_require__(167);
            var find = conventions.find;
            var NAMESPACE = conventions.NAMESPACE;
            function notEmptyString(input) {
                return input !== "";
            }
            function splitOnASCIIWhitespace(input) {
                return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
            }
            function orderedSetReducer(current, element) {
                if (!current.hasOwnProperty(element)) current[element] = true;
                return current;
            }
            function toOrderedSet(input) {
                if (!input) return [];
                var list = splitOnASCIIWhitespace(input);
                return Object.keys(list.reduce(orderedSetReducer, {}));
            }
            function arrayIncludes(list) {
                return function(element) {
                    return list && list.indexOf(element) !== -1;
                };
            }
            function copy(src, dest) {
                for (var p in src) if (Object.prototype.hasOwnProperty.call(src, p)) dest[p] = src[p];
            }
            function _extends(Class, Super) {
                var pt = Class.prototype;
                if (!(pt instanceof Super)) {
                    function t() {}
                    t.prototype = Super.prototype;
                    t = new t;
                    copy(pt, t);
                    Class.prototype = pt = t;
                }
                if (pt.constructor != Class) {
                    if (typeof Class != "function") console.error("unknown Class:" + Class);
                    pt.constructor = Class;
                }
            }
            var NodeType = {};
            var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
            var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
            var TEXT_NODE = NodeType.TEXT_NODE = 3;
            var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
            var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
            var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
            var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
            var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
            var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
            var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
            var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
            var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
            var ExceptionCode = {};
            var ExceptionMessage = {};
            ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
            ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 
            2);
            var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 
            3);
            ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
            ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 
            5);
            ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
            ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 
            7);
            var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 
            8);
            ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
            var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 
            10);
            ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
            ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
            ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 
            13);
            ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
            ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
            function DOMException(code, message) {
                if (message instanceof Error) var error = message; else {
                    error = this;
                    Error.call(this, ExceptionMessage[code]);
                    this.message = ExceptionMessage[code];
                    if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
                }
                error.code = code;
                if (message) this.message = this.message + ": " + message;
                return error;
            }
            DOMException.prototype = Error.prototype;
            copy(ExceptionCode, DOMException);
            function NodeList() {}
            NodeList.prototype = {
                length: 0,
                item: function(index) {
                    return this[index] || null;
                },
                toString: function(isHTML, nodeFilter) {
                    for (var buf = [], i = 0; i < this.length; i++) serializeToString(this[i], buf, isHTML, nodeFilter);
                    return buf.join("");
                },
                filter: function(predicate) {
                    return Array.prototype.filter.call(this, predicate);
                },
                indexOf: function(item) {
                    return Array.prototype.indexOf.call(this, item);
                }
            };
            function LiveNodeList(node, refresh) {
                this._node = node;
                this._refresh = refresh;
                _updateLiveList(this);
            }
            function _updateLiveList(list) {
                var inc = list._node._inc || list._node.ownerDocument._inc;
                if (list._inc != inc) {
                    var ls = list._refresh(list._node);
                    __set__(list, "length", ls.length);
                    copy(ls, list);
                    list._inc = inc;
                }
            }
            LiveNodeList.prototype.item = function(i) {
                _updateLiveList(this);
                return this[i];
            };
            _extends(LiveNodeList, NodeList);
            function NamedNodeMap() {}
            function _findNodeIndex(list, node) {
                var i = list.length;
                while (i--) if (list[i] === node) return i;
            }
            function _addNamedNode(el, list, newAttr, oldAttr) {
                if (oldAttr) list[_findNodeIndex(list, oldAttr)] = newAttr; else list[list.length++] = newAttr;
                if (el) {
                    newAttr.ownerElement = el;
                    var doc = el.ownerDocument;
                    if (doc) {
                        oldAttr && _onRemoveAttribute(doc, el, oldAttr);
                        _onAddAttribute(doc, el, newAttr);
                    }
                }
            }
            function _removeNamedNode(el, list, attr) {
                var i = _findNodeIndex(list, attr);
                if (i >= 0) {
                    var lastIndex = list.length - 1;
                    while (i < lastIndex) list[i] = list[++i];
                    list.length = lastIndex;
                    if (el) {
                        var doc = el.ownerDocument;
                        if (doc) {
                            _onRemoveAttribute(doc, el, attr);
                            attr.ownerElement = null;
                        }
                    }
                } else throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
            }
            NamedNodeMap.prototype = {
                length: 0,
                item: NodeList.prototype.item,
                getNamedItem: function(key) {
                    var i = this.length;
                    while (i--) {
                        var attr = this[i];
                        if (attr.nodeName == key) return attr;
                    }
                },
                setNamedItem: function(attr) {
                    var el = attr.ownerElement;
                    if (el && el != this._ownerElement) throw new DOMException(INUSE_ATTRIBUTE_ERR);
                    var oldAttr = this.getNamedItem(attr.nodeName);
                    _addNamedNode(this._ownerElement, this, attr, oldAttr);
                    return oldAttr;
                },
                setNamedItemNS: function(attr) {
                    var oldAttr, el = attr.ownerElement;
                    if (el && el != this._ownerElement) throw new DOMException(INUSE_ATTRIBUTE_ERR);
                    oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
                    _addNamedNode(this._ownerElement, this, attr, oldAttr);
                    return oldAttr;
                },
                removeNamedItem: function(key) {
                    var attr = this.getNamedItem(key);
                    _removeNamedNode(this._ownerElement, this, attr);
                    return attr;
                },
                removeNamedItemNS: function(namespaceURI, localName) {
                    var attr = this.getNamedItemNS(namespaceURI, localName);
                    _removeNamedNode(this._ownerElement, this, attr);
                    return attr;
                },
                getNamedItemNS: function(namespaceURI, localName) {
                    var i = this.length;
                    while (i--) {
                        var node = this[i];
                        if (node.localName == localName && node.namespaceURI == namespaceURI) return node;
                    }
                    return null;
                }
            };
            function DOMImplementation() {}
            DOMImplementation.prototype = {
                hasFeature: function(feature, version) {
                    return true;
                },
                createDocument: function(namespaceURI, qualifiedName, doctype) {
                    var doc = new Document;
                    doc.implementation = this;
                    doc.childNodes = new NodeList;
                    doc.doctype = doctype || null;
                    if (doctype) doc.appendChild(doctype);
                    if (qualifiedName) {
                        var root = doc.createElementNS(namespaceURI, qualifiedName);
                        doc.appendChild(root);
                    }
                    return doc;
                },
                createDocumentType: function(qualifiedName, publicId, systemId) {
                    var node = new DocumentType;
                    node.name = qualifiedName;
                    node.nodeName = qualifiedName;
                    node.publicId = publicId || "";
                    node.systemId = systemId || "";
                    return node;
                }
            };
            function Node() {}
            Node.prototype = {
                firstChild: null,
                lastChild: null,
                previousSibling: null,
                nextSibling: null,
                attributes: null,
                parentNode: null,
                childNodes: null,
                ownerDocument: null,
                nodeValue: null,
                namespaceURI: null,
                prefix: null,
                localName: null,
                insertBefore: function(newChild, refChild) {
                    return _insertBefore(this, newChild, refChild);
                },
                replaceChild: function(newChild, oldChild) {
                    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
                    if (oldChild) this.removeChild(oldChild);
                },
                removeChild: function(oldChild) {
                    return _removeChild(this, oldChild);
                },
                appendChild: function(newChild) {
                    return this.insertBefore(newChild, null);
                },
                hasChildNodes: function() {
                    return this.firstChild != null;
                },
                cloneNode: function(deep) {
                    return cloneNode(this.ownerDocument || this, this, deep);
                },
                normalize: function() {
                    var child = this.firstChild;
                    while (child) {
                        var next = child.nextSibling;
                        if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
                            this.removeChild(next);
                            child.appendData(next.data);
                        } else {
                            child.normalize();
                            child = next;
                        }
                    }
                },
                isSupported: function(feature, version) {
                    return this.ownerDocument.implementation.hasFeature(feature, version);
                },
                hasAttributes: function() {
                    return this.attributes.length > 0;
                },
                lookupPrefix: function(namespaceURI) {
                    var el = this;
                    while (el) {
                        var map = el._nsMap;
                        if (map) for (var n in map) if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) return n;
                        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
                    }
                    return null;
                },
                lookupNamespaceURI: function(prefix) {
                    var el = this;
                    while (el) {
                        var map = el._nsMap;
                        if (map) if (Object.prototype.hasOwnProperty.call(map, prefix)) return map[prefix];
                        el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
                    }
                    return null;
                },
                isDefaultNamespace: function(namespaceURI) {
                    var prefix = this.lookupPrefix(namespaceURI);
                    return prefix == null;
                }
            };
            function _xmlEncoder(c) {
                return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
            }
            copy(NodeType, Node);
            copy(NodeType, Node.prototype);
            function _visitNode(node, callback) {
                if (callback(node)) return true;
                if (node = node.firstChild) do {
                    if (_visitNode(node, callback)) return true;
                } while (node = node.nextSibling);
            }
            function Document() {
                this.ownerDocument = this;
            }
            function _onAddAttribute(doc, el, newAttr) {
                doc && doc._inc++;
                var ns = newAttr.namespaceURI;
                if (ns === NAMESPACE.XMLNS) el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
            }
            function _onRemoveAttribute(doc, el, newAttr, remove) {
                doc && doc._inc++;
                var ns = newAttr.namespaceURI;
                if (ns === NAMESPACE.XMLNS) delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
            }
            function _onUpdateChild(doc, el, newChild) {
                if (doc && doc._inc) {
                    doc._inc++;
                    var cs = el.childNodes;
                    if (newChild) cs[cs.length++] = newChild; else {
                        var child = el.firstChild;
                        var i = 0;
                        while (child) {
                            cs[i++] = child;
                            child = child.nextSibling;
                        }
                        cs.length = i;
                        delete cs[cs.length];
                    }
                }
            }
            function _removeChild(parentNode, child) {
                var previous = child.previousSibling;
                var next = child.nextSibling;
                if (previous) previous.nextSibling = next; else parentNode.firstChild = next;
                if (next) next.previousSibling = previous; else parentNode.lastChild = previous;
                child.parentNode = null;
                child.previousSibling = null;
                child.nextSibling = null;
                _onUpdateChild(parentNode.ownerDocument, parentNode);
                return child;
            }
            function hasValidParentNodeType(node) {
                return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
            }
            function hasInsertableNodeType(node) {
                return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
            }
            function isDocTypeNode(node) {
                return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
            }
            function isElementNode(node) {
                return node && node.nodeType === Node.ELEMENT_NODE;
            }
            function isTextNode(node) {
                return node && node.nodeType === Node.TEXT_NODE;
            }
            function isElementInsertionPossible(doc, child) {
                var parentChildNodes = doc.childNodes || [];
                if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) return false;
                var docTypeNode = find(parentChildNodes, isDocTypeNode);
                return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
            }
            function isElementReplacementPossible(doc, child) {
                var parentChildNodes = doc.childNodes || [];
                function hasElementChildThatIsNotChild(node) {
                    return isElementNode(node) && node !== child;
                }
                if (find(parentChildNodes, hasElementChildThatIsNotChild)) return false;
                var docTypeNode = find(parentChildNodes, isDocTypeNode);
                return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
            }
            function assertPreInsertionValidity1to5(parent, node, child) {
                if (!hasValidParentNodeType(parent)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
                if (child && child.parentNode !== parent) throw new DOMException(NOT_FOUND_ERR, "child not in parent");
                if (!hasInsertableNodeType(node) || isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE) throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType);
            }
            function assertPreInsertionValidityInDocument(parent, node, child) {
                var parentChildNodes = parent.childNodes || [];
                var nodeChildNodes = node.childNodes || [];
                if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    var nodeChildElements = nodeChildNodes.filter(isElementNode);
                    if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
                    if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
                }
                if (isElementNode(node)) if (!isElementInsertionPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
                if (isDocTypeNode(node)) {
                    if (find(parentChildNodes, isDocTypeNode)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
                    var parentElementChild = find(parentChildNodes, isElementNode);
                    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
                    if (!child && parentElementChild) throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
                }
            }
            function assertPreReplacementValidityInDocument(parent, node, child) {
                var parentChildNodes = parent.childNodes || [];
                var nodeChildNodes = node.childNodes || [];
                if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                    var nodeChildElements = nodeChildNodes.filter(isElementNode);
                    if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
                    if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
                }
                if (isElementNode(node)) if (!isElementReplacementPossible(parent, child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
                if (isDocTypeNode(node)) {
                    function hasDoctypeChildThatIsNotChild(node) {
                        return isDocTypeNode(node) && node !== child;
                    }
                    if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
                    var parentElementChild = find(parentChildNodes, isElementNode);
                    if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
                }
            }
            function _insertBefore(parent, node, child, _inDocumentAssertion) {
                assertPreInsertionValidity1to5(parent, node, child);
                if (parent.nodeType === Node.DOCUMENT_NODE) (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
                var cp = node.parentNode;
                if (cp) cp.removeChild(node);
                if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
                    var newFirst = node.firstChild;
                    if (newFirst == null) return node;
                    var newLast = node.lastChild;
                } else newFirst = newLast = node;
                var pre = child ? child.previousSibling : parent.lastChild;
                newFirst.previousSibling = pre;
                newLast.nextSibling = child;
                if (pre) pre.nextSibling = newFirst; else parent.firstChild = newFirst;
                if (child == null) parent.lastChild = newLast; else child.previousSibling = newLast;
                do {
                    newFirst.parentNode = parent;
                } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
                _onUpdateChild(parent.ownerDocument || parent, parent);
                if (node.nodeType == DOCUMENT_FRAGMENT_NODE) node.firstChild = node.lastChild = null;
                return node;
            }
            function _appendSingleChild(parentNode, newChild) {
                if (newChild.parentNode) newChild.parentNode.removeChild(newChild);
                newChild.parentNode = parentNode;
                newChild.previousSibling = parentNode.lastChild;
                newChild.nextSibling = null;
                if (newChild.previousSibling) newChild.previousSibling.nextSibling = newChild; else parentNode.firstChild = newChild;
                parentNode.lastChild = newChild;
                _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
                return newChild;
            }
            Document.prototype = {
                nodeName: "#document",
                nodeType: DOCUMENT_NODE,
                doctype: null,
                documentElement: null,
                _inc: 1,
                insertBefore: function(newChild, refChild) {
                    if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
                        var child = newChild.firstChild;
                        while (child) {
                            var next = child.nextSibling;
                            this.insertBefore(child, refChild);
                            child = next;
                        }
                        return newChild;
                    }
                    _insertBefore(this, newChild, refChild);
                    newChild.ownerDocument = this;
                    if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) this.documentElement = newChild;
                    return newChild;
                },
                removeChild: function(oldChild) {
                    if (this.documentElement == oldChild) this.documentElement = null;
                    return _removeChild(this, oldChild);
                },
                replaceChild: function(newChild, oldChild) {
                    _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
                    newChild.ownerDocument = this;
                    if (oldChild) this.removeChild(oldChild);
                    if (isElementNode(newChild)) this.documentElement = newChild;
                },
                importNode: function(importedNode, deep) {
                    return importNode(this, importedNode, deep);
                },
                getElementById: function(id) {
                    var rtv = null;
                    _visitNode(this.documentElement, (function(node) {
                        if (node.nodeType == ELEMENT_NODE) if (node.getAttribute("id") == id) {
                            rtv = node;
                            return true;
                        }
                    }));
                    return rtv;
                },
                getElementsByClassName: function(classNames) {
                    var classNamesSet = toOrderedSet(classNames);
                    return new LiveNodeList(this, (function(base) {
                        var ls = [];
                        if (classNamesSet.length > 0) _visitNode(base.documentElement, (function(node) {
                            if (node !== base && node.nodeType === ELEMENT_NODE) {
                                var nodeClassNames = node.getAttribute("class");
                                if (nodeClassNames) {
                                    var matches = classNames === nodeClassNames;
                                    if (!matches) {
                                        var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                                        matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                                    }
                                    if (matches) ls.push(node);
                                }
                            }
                        }));
                        return ls;
                    }));
                },
                createElement: function(tagName) {
                    var node = new Element;
                    node.ownerDocument = this;
                    node.nodeName = tagName;
                    node.tagName = tagName;
                    node.localName = tagName;
                    node.childNodes = new NodeList;
                    var attrs = node.attributes = new NamedNodeMap;
                    attrs._ownerElement = node;
                    return node;
                },
                createDocumentFragment: function() {
                    var node = new DocumentFragment;
                    node.ownerDocument = this;
                    node.childNodes = new NodeList;
                    return node;
                },
                createTextNode: function(data) {
                    var node = new Text;
                    node.ownerDocument = this;
                    node.appendData(data);
                    return node;
                },
                createComment: function(data) {
                    var node = new Comment;
                    node.ownerDocument = this;
                    node.appendData(data);
                    return node;
                },
                createCDATASection: function(data) {
                    var node = new CDATASection;
                    node.ownerDocument = this;
                    node.appendData(data);
                    return node;
                },
                createProcessingInstruction: function(target, data) {
                    var node = new ProcessingInstruction;
                    node.ownerDocument = this;
                    node.tagName = node.target = target;
                    node.nodeValue = node.data = data;
                    return node;
                },
                createAttribute: function(name) {
                    var node = new Attr;
                    node.ownerDocument = this;
                    node.name = name;
                    node.nodeName = name;
                    node.localName = name;
                    node.specified = true;
                    return node;
                },
                createEntityReference: function(name) {
                    var node = new EntityReference;
                    node.ownerDocument = this;
                    node.nodeName = name;
                    return node;
                },
                createElementNS: function(namespaceURI, qualifiedName) {
                    var node = new Element;
                    var pl = qualifiedName.split(":");
                    var attrs = node.attributes = new NamedNodeMap;
                    node.childNodes = new NodeList;
                    node.ownerDocument = this;
                    node.nodeName = qualifiedName;
                    node.tagName = qualifiedName;
                    node.namespaceURI = namespaceURI;
                    if (pl.length == 2) {
                        node.prefix = pl[0];
                        node.localName = pl[1];
                    } else node.localName = qualifiedName;
                    attrs._ownerElement = node;
                    return node;
                },
                createAttributeNS: function(namespaceURI, qualifiedName) {
                    var node = new Attr;
                    var pl = qualifiedName.split(":");
                    node.ownerDocument = this;
                    node.nodeName = qualifiedName;
                    node.name = qualifiedName;
                    node.namespaceURI = namespaceURI;
                    node.specified = true;
                    if (pl.length == 2) {
                        node.prefix = pl[0];
                        node.localName = pl[1];
                    } else node.localName = qualifiedName;
                    return node;
                }
            };
            _extends(Document, Node);
            function Element() {
                this._nsMap = {};
            }
            Element.prototype = {
                nodeType: ELEMENT_NODE,
                hasAttribute: function(name) {
                    return this.getAttributeNode(name) != null;
                },
                getAttribute: function(name) {
                    var attr = this.getAttributeNode(name);
                    return attr && attr.value || "";
                },
                getAttributeNode: function(name) {
                    return this.attributes.getNamedItem(name);
                },
                setAttribute: function(name, value) {
                    var attr = this.ownerDocument.createAttribute(name);
                    attr.value = attr.nodeValue = "" + value;
                    this.setAttributeNode(attr);
                },
                removeAttribute: function(name) {
                    var attr = this.getAttributeNode(name);
                    attr && this.removeAttributeNode(attr);
                },
                appendChild: function(newChild) {
                    if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) return this.insertBefore(newChild, null); else return _appendSingleChild(this, newChild);
                },
                setAttributeNode: function(newAttr) {
                    return this.attributes.setNamedItem(newAttr);
                },
                setAttributeNodeNS: function(newAttr) {
                    return this.attributes.setNamedItemNS(newAttr);
                },
                removeAttributeNode: function(oldAttr) {
                    return this.attributes.removeNamedItem(oldAttr.nodeName);
                },
                removeAttributeNS: function(namespaceURI, localName) {
                    var old = this.getAttributeNodeNS(namespaceURI, localName);
                    old && this.removeAttributeNode(old);
                },
                hasAttributeNS: function(namespaceURI, localName) {
                    return this.getAttributeNodeNS(namespaceURI, localName) != null;
                },
                getAttributeNS: function(namespaceURI, localName) {
                    var attr = this.getAttributeNodeNS(namespaceURI, localName);
                    return attr && attr.value || "";
                },
                setAttributeNS: function(namespaceURI, qualifiedName, value) {
                    var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
                    attr.value = attr.nodeValue = "" + value;
                    this.setAttributeNode(attr);
                },
                getAttributeNodeNS: function(namespaceURI, localName) {
                    return this.attributes.getNamedItemNS(namespaceURI, localName);
                },
                getElementsByTagName: function(tagName) {
                    return new LiveNodeList(this, (function(base) {
                        var ls = [];
                        _visitNode(base, (function(node) {
                            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) ls.push(node);
                        }));
                        return ls;
                    }));
                },
                getElementsByTagNameNS: function(namespaceURI, localName) {
                    return new LiveNodeList(this, (function(base) {
                        var ls = [];
                        _visitNode(base, (function(node) {
                            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) ls.push(node);
                        }));
                        return ls;
                    }));
                }
            };
            Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
            Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
            _extends(Element, Node);
            function Attr() {}
            Attr.prototype.nodeType = ATTRIBUTE_NODE;
            _extends(Attr, Node);
            function CharacterData() {}
            CharacterData.prototype = {
                data: "",
                substringData: function(offset, count) {
                    return this.data.substring(offset, offset + count);
                },
                appendData: function(text) {
                    text = this.data + text;
                    this.nodeValue = this.data = text;
                    this.length = text.length;
                },
                insertData: function(offset, text) {
                    this.replaceData(offset, 0, text);
                },
                appendChild: function(newChild) {
                    throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
                },
                deleteData: function(offset, count) {
                    this.replaceData(offset, count, "");
                },
                replaceData: function(offset, count, text) {
                    var start = this.data.substring(0, offset);
                    var end = this.data.substring(offset + count);
                    text = start + text + end;
                    this.nodeValue = this.data = text;
                    this.length = text.length;
                }
            };
            _extends(CharacterData, Node);
            function Text() {}
            Text.prototype = {
                nodeName: "#text",
                nodeType: TEXT_NODE,
                splitText: function(offset) {
                    var text = this.data;
                    var newText = text.substring(offset);
                    text = text.substring(0, offset);
                    this.data = this.nodeValue = text;
                    this.length = text.length;
                    var newNode = this.ownerDocument.createTextNode(newText);
                    if (this.parentNode) this.parentNode.insertBefore(newNode, this.nextSibling);
                    return newNode;
                }
            };
            _extends(Text, CharacterData);
            function Comment() {}
            Comment.prototype = {
                nodeName: "#comment",
                nodeType: COMMENT_NODE
            };
            _extends(Comment, CharacterData);
            function CDATASection() {}
            CDATASection.prototype = {
                nodeName: "#cdata-section",
                nodeType: CDATA_SECTION_NODE
            };
            _extends(CDATASection, CharacterData);
            function DocumentType() {}
            DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
            _extends(DocumentType, Node);
            function Notation() {}
            Notation.prototype.nodeType = NOTATION_NODE;
            _extends(Notation, Node);
            function Entity() {}
            Entity.prototype.nodeType = ENTITY_NODE;
            _extends(Entity, Node);
            function EntityReference() {}
            EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
            _extends(EntityReference, Node);
            function DocumentFragment() {}
            DocumentFragment.prototype.nodeName = "#document-fragment";
            DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
            _extends(DocumentFragment, Node);
            function ProcessingInstruction() {}
            ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
            _extends(ProcessingInstruction, Node);
            function XMLSerializer() {}
            XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
                return nodeSerializeToString.call(node, isHtml, nodeFilter);
            };
            Node.prototype.toString = nodeSerializeToString;
            function nodeSerializeToString(isHtml, nodeFilter) {
                var buf = [];
                var refNode = this.nodeType == 9 && this.documentElement || this;
                var prefix = refNode.prefix;
                var uri = refNode.namespaceURI;
                if (uri && prefix == null) {
                    prefix = refNode.lookupPrefix(uri);
                    if (prefix == null) var visibleNamespaces = [ {
                        namespace: uri,
                        prefix: null
                    } ];
                }
                serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
                return buf.join("");
            }
            function needNamespaceDefine(node, isHTML, visibleNamespaces) {
                var prefix = node.prefix || "";
                var uri = node.namespaceURI;
                if (!uri) return false;
                if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) return false;
                var i = visibleNamespaces.length;
                while (i--) {
                    var ns = visibleNamespaces[i];
                    if (ns.prefix === prefix) return ns.namespace !== uri;
                }
                return true;
            }
            function addSerializedAttribute(buf, qualifiedName, value) {
                buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
            }
            function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
                if (!visibleNamespaces) visibleNamespaces = [];
                if (nodeFilter) {
                    node = nodeFilter(node);
                    if (node) {
                        if (typeof node == "string") {
                            buf.push(node);
                            return;
                        }
                    } else return;
                }
                switch (node.nodeType) {
                  case ELEMENT_NODE:
                    var attrs = node.attributes;
                    var len = attrs.length;
                    var child = node.firstChild;
                    var nodeName = node.tagName;
                    isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
                    var prefixedNodeName = nodeName;
                    if (!isHTML && !node.prefix && node.namespaceURI) {
                        var defaultNS;
                        for (var ai = 0; ai < attrs.length; ai++) if (attrs.item(ai).name === "xmlns") {
                            defaultNS = attrs.item(ai).value;
                            break;
                        }
                        if (!defaultNS) for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                            var namespace = visibleNamespaces[nsi];
                            if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                                defaultNS = namespace.namespace;
                                break;
                            }
                        }
                        if (defaultNS !== node.namespaceURI) for (nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                            namespace = visibleNamespaces[nsi];
                            if (namespace.namespace === node.namespaceURI) {
                                if (namespace.prefix) prefixedNodeName = namespace.prefix + ":" + nodeName;
                                break;
                            }
                        }
                    }
                    buf.push("<", prefixedNodeName);
                    for (var i = 0; i < len; i++) {
                        var attr = attrs.item(i);
                        if (attr.prefix == "xmlns") visibleNamespaces.push({
                            prefix: attr.localName,
                            namespace: attr.value
                        }); else if (attr.nodeName == "xmlns") visibleNamespaces.push({
                            prefix: "",
                            namespace: attr.value
                        });
                    }
                    for (i = 0; i < len; i++) {
                        attr = attrs.item(i);
                        if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
                            var prefix = attr.prefix || "";
                            var uri = attr.namespaceURI;
                            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                            visibleNamespaces.push({
                                prefix,
                                namespace: uri
                            });
                        }
                        serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
                    }
                    if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
                        prefix = node.prefix || "";
                        uri = node.namespaceURI;
                        addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
                        visibleNamespaces.push({
                            prefix,
                            namespace: uri
                        });
                    }
                    if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
                        buf.push(">");
                        if (isHTML && /^script$/i.test(nodeName)) while (child) {
                            if (child.data) buf.push(child.data); else serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                            child = child.nextSibling;
                        } else while (child) {
                            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                            child = child.nextSibling;
                        }
                        buf.push("</", prefixedNodeName, ">");
                    } else buf.push("/>");
                    return;

                  case DOCUMENT_NODE:
                  case DOCUMENT_FRAGMENT_NODE:
                    child = node.firstChild;
                    while (child) {
                        serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                        child = child.nextSibling;
                    }
                    return;

                  case ATTRIBUTE_NODE:
                    return addSerializedAttribute(buf, node.name, node.value);

                  case TEXT_NODE:
                    return buf.push(node.data.replace(/[<&>]/g, _xmlEncoder));

                  case CDATA_SECTION_NODE:
                    return buf.push("<![CDATA[", node.data, "]]>");

                  case COMMENT_NODE:
                    return buf.push("\x3c!--", node.data, "--\x3e");

                  case DOCUMENT_TYPE_NODE:
                    var pubid = node.publicId;
                    var sysid = node.systemId;
                    buf.push("<!DOCTYPE ", node.name);
                    if (pubid) {
                        buf.push(" PUBLIC ", pubid);
                        if (sysid && sysid != ".") buf.push(" ", sysid);
                        buf.push(">");
                    } else if (sysid && sysid != ".") buf.push(" SYSTEM ", sysid, ">"); else {
                        var sub = node.internalSubset;
                        if (sub) buf.push(" [", sub, "]");
                        buf.push(">");
                    }
                    return;

                  case PROCESSING_INSTRUCTION_NODE:
                    return buf.push("<?", node.target, " ", node.data, "?>");

                  case ENTITY_REFERENCE_NODE:
                    return buf.push("&", node.nodeName, ";");

                  default:
                    buf.push("??", node.nodeName);
                }
            }
            function importNode(doc, node, deep) {
                var node2;
                switch (node.nodeType) {
                  case ELEMENT_NODE:
                    node2 = node.cloneNode(false);
                    node2.ownerDocument = doc;

                  case DOCUMENT_FRAGMENT_NODE:
                    break;

                  case ATTRIBUTE_NODE:
                    deep = true;
                    break;
                }
                if (!node2) node2 = node.cloneNode(false);
                node2.ownerDocument = doc;
                node2.parentNode = null;
                if (deep) {
                    var child = node.firstChild;
                    while (child) {
                        node2.appendChild(importNode(doc, child, deep));
                        child = child.nextSibling;
                    }
                }
                return node2;
            }
            function cloneNode(doc, node, deep) {
                var node2 = new node.constructor;
                for (var n in node) if (Object.prototype.hasOwnProperty.call(node, n)) {
                    var v = node[n];
                    if (typeof v != "object") if (v != node2[n]) node2[n] = v;
                }
                if (node.childNodes) node2.childNodes = new NodeList;
                node2.ownerDocument = doc;
                switch (node2.nodeType) {
                  case ELEMENT_NODE:
                    var attrs = node.attributes;
                    var attrs2 = node2.attributes = new NamedNodeMap;
                    var len = attrs.length;
                    attrs2._ownerElement = node2;
                    for (var i = 0; i < len; i++) node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
                    break;

                  case ATTRIBUTE_NODE:
                    deep = true;
                }
                if (deep) {
                    var child = node.firstChild;
                    while (child) {
                        node2.appendChild(cloneNode(doc, child, deep));
                        child = child.nextSibling;
                    }
                }
                return node2;
            }
            function __set__(object, key, value) {
                object[key] = value;
            }
            try {
                if (Object.defineProperty) {
                    Object.defineProperty(LiveNodeList.prototype, "length", {
                        get: function() {
                            _updateLiveList(this);
                            return this.$$length;
                        }
                    });
                    Object.defineProperty(Node.prototype, "textContent", {
                        get: function() {
                            return getTextContent(this);
                        },
                        set: function(data) {
                            switch (this.nodeType) {
                              case ELEMENT_NODE:
                              case DOCUMENT_FRAGMENT_NODE:
                                while (this.firstChild) this.removeChild(this.firstChild);
                                if (data || String(data)) this.appendChild(this.ownerDocument.createTextNode(data));
                                break;

                              default:
                                this.data = data;
                                this.value = data;
                                this.nodeValue = data;
                            }
                        }
                    });
                    function getTextContent(node) {
                        switch (node.nodeType) {
                          case ELEMENT_NODE:
                          case DOCUMENT_FRAGMENT_NODE:
                            var buf = [];
                            node = node.firstChild;
                            while (node) {
                                if (node.nodeType !== 7 && node.nodeType !== 8) buf.push(getTextContent(node));
                                node = node.nextSibling;
                            }
                            return buf.join("");

                          default:
                            return node.nodeValue;
                        }
                    }
                    __set__ = function(object, key, value) {
                        object["$$" + key] = value;
                    };
                }
            } catch (e) {}
            exports.DocumentType = DocumentType;
            exports.DOMException = DOMException;
            exports.DOMImplementation = DOMImplementation;
            exports.Element = Element;
            exports.Node = Node;
            exports.NodeList = NodeList;
            exports.XMLSerializer = XMLSerializer;
        },
        45: (__unused_webpack_module, exports, __webpack_require__) => {
            "use strict";
            var freeze = __webpack_require__(167).freeze;
            exports.XML_ENTITIES = freeze({
                amp: "&",
                apos: "'",
                gt: ">",
                lt: "<",
                quot: '"'
            });
            exports.HTML_ENTITIES = freeze({
                Aacute: "√Å",
                aacute: "√°",
                Abreve: "ƒÇ",
                abreve: "ƒÉ",
                ac: "‚àæ",
                acd: "‚àø",
                acE: "‚àæÃ≥",
                Acirc: "√Ç",
                acirc: "√¢",
                acute: "¬¥",
                Acy: "–ê",
                acy: "–∞",
                AElig: "√Ü",
                aelig: "√¶",
                af: "‚Å°",
                Afr: "ùîÑ",
                afr: "ùîû",
                Agrave: "√Ä",
                agrave: "√†",
                alefsym: "‚Ñµ",
                aleph: "‚Ñµ",
                Alpha: "Œë",
                alpha: "Œ±",
                Amacr: "ƒÄ",
                amacr: "ƒÅ",
                amalg: "‚®ø",
                AMP: "&",
                amp: "&",
                And: "‚©ì",
                and: "‚àß",
                andand: "‚©ï",
                andd: "‚©ú",
                andslope: "‚©ò",
                andv: "‚©ö",
                ang: "‚à†",
                ange: "‚¶§",
                angle: "‚à†",
                angmsd: "‚à°",
                angmsdaa: "‚¶®",
                angmsdab: "‚¶©",
                angmsdac: "‚¶™",
                angmsdad: "‚¶´",
                angmsdae: "‚¶¨",
                angmsdaf: "‚¶≠",
                angmsdag: "‚¶Æ",
                angmsdah: "‚¶Ø",
                angrt: "‚àü",
                angrtvb: "‚äæ",
                angrtvbd: "‚¶ù",
                angsph: "‚à¢",
                angst: "√Ö",
                angzarr: "‚çº",
                Aogon: "ƒÑ",
                aogon: "ƒÖ",
                Aopf: "ùî∏",
                aopf: "ùïí",
                ap: "‚âà",
                apacir: "‚©Ø",
                apE: "‚©∞",
                ape: "‚âä",
                apid: "‚âã",
                apos: "'",
                ApplyFunction: "‚Å°",
                approx: "‚âà",
                approxeq: "‚âä",
                Aring: "√Ö",
                aring: "√•",
                Ascr: "ùíú",
                ascr: "ùí∂",
                Assign: "‚âî",
                ast: "*",
                asymp: "‚âà",
                asympeq: "‚âç",
                Atilde: "√É",
                atilde: "√£",
                Auml: "√Ñ",
                auml: "√§",
                awconint: "‚à≥",
                awint: "‚®ë",
                backcong: "‚âå",
                backepsilon: "œ∂",
                backprime: "‚Äµ",
                backsim: "‚àΩ",
                backsimeq: "‚ãç",
                Backslash: "‚àñ",
                Barv: "‚´ß",
                barvee: "‚äΩ",
                Barwed: "‚åÜ",
                barwed: "‚åÖ",
                barwedge: "‚åÖ",
                bbrk: "‚éµ",
                bbrktbrk: "‚é∂",
                bcong: "‚âå",
                Bcy: "–ë",
                bcy: "–±",
                bdquo: "‚Äû",
                becaus: "‚àµ",
                Because: "‚àµ",
                because: "‚àµ",
                bemptyv: "‚¶∞",
                bepsi: "œ∂",
                bernou: "‚Ñ¨",
                Bernoullis: "‚Ñ¨",
                Beta: "Œí",
                beta: "Œ≤",
                beth: "‚Ñ∂",
                between: "‚â¨",
                Bfr: "ùîÖ",
                bfr: "ùîü",
                bigcap: "‚ãÇ",
                bigcirc: "‚óØ",
                bigcup: "‚ãÉ",
                bigodot: "‚®Ä",
                bigoplus: "‚®Å",
                bigotimes: "‚®Ç",
                bigsqcup: "‚®Ü",
                bigstar: "‚òÖ",
                bigtriangledown: "‚ñΩ",
                bigtriangleup: "‚ñ≥",
                biguplus: "‚®Ñ",
                bigvee: "‚ãÅ",
                bigwedge: "‚ãÄ",
                bkarow: "‚§ç",
                blacklozenge: "‚ß´",
                blacksquare: "‚ñ™",
                blacktriangle: "‚ñ¥",
                blacktriangledown: "‚ñæ",
                blacktriangleleft: "‚óÇ",
                blacktriangleright: "‚ñ∏",
                blank: "‚ê£",
                blk12: "‚ñí",
                blk14: "‚ñë",
                blk34: "‚ñì",
                block: "‚ñà",
                bne: "=‚É•",
                bnequiv: "‚â°‚É•",
                bNot: "‚´≠",
                bnot: "‚åê",
                Bopf: "ùîπ",
                bopf: "ùïì",
                bot: "‚ä•",
                bottom: "‚ä•",
                bowtie: "‚ãà",
                boxbox: "‚ßâ",
                boxDL: "‚ïó",
                boxDl: "‚ïñ",
                boxdL: "‚ïï",
                boxdl: "‚îê",
                boxDR: "‚ïî",
                boxDr: "‚ïì",
                boxdR: "‚ïí",
                boxdr: "‚îå",
                boxH: "‚ïê",
                boxh: "‚îÄ",
                boxHD: "‚ï¶",
                boxHd: "‚ï§",
                boxhD: "‚ï•",
                boxhd: "‚î¨",
                boxHU: "‚ï©",
                boxHu: "‚ïß",
                boxhU: "‚ï®",
                boxhu: "‚î¥",
                boxminus: "‚äü",
                boxplus: "‚äû",
                boxtimes: "‚ä†",
                boxUL: "‚ïù",
                boxUl: "‚ïú",
                boxuL: "‚ïõ",
                boxul: "‚îò",
                boxUR: "‚ïö",
                boxUr: "‚ïô",
                boxuR: "‚ïò",
                boxur: "‚îî",
                boxV: "‚ïë",
                boxv: "‚îÇ",
                boxVH: "‚ï¨",
                boxVh: "‚ï´",
                boxvH: "‚ï™",
                boxvh: "‚îº",
                boxVL: "‚ï£",
                boxVl: "‚ï¢",
                boxvL: "‚ï°",
                boxvl: "‚î§",
                boxVR: "‚ï†",
                boxVr: "‚ïü",
                boxvR: "‚ïû",
                boxvr: "‚îú",
                bprime: "‚Äµ",
                Breve: "Àò",
                breve: "Àò",
                brvbar: "¬¶",
                Bscr: "‚Ñ¨",
                bscr: "ùí∑",
                bsemi: "‚Åè",
                bsim: "‚àΩ",
                bsime: "‚ãç",
                bsol: "\\",
                bsolb: "‚ßÖ",
                bsolhsub: "‚üà",
                bull: "‚Ä¢",
                bullet: "‚Ä¢",
                bump: "‚âé",
                bumpE: "‚™Æ",
                bumpe: "‚âè",
                Bumpeq: "‚âé",
                bumpeq: "‚âè",
                Cacute: "ƒÜ",
                cacute: "ƒá",
                Cap: "‚ãí",
                cap: "‚à©",
                capand: "‚©Ñ",
                capbrcup: "‚©â",
                capcap: "‚©ã",
                capcup: "‚©á",
                capdot: "‚©Ä",
                CapitalDifferentialD: "‚ÖÖ",
                caps: "‚à©Ô∏Ä",
                caret: "‚ÅÅ",
                caron: "Àá",
                Cayleys: "‚Ñ≠",
                ccaps: "‚©ç",
                Ccaron: "ƒå",
                ccaron: "ƒç",
                Ccedil: "√á",
                ccedil: "√ß",
                Ccirc: "ƒà",
                ccirc: "ƒâ",
                Cconint: "‚à∞",
                ccups: "‚©å",
                ccupssm: "‚©ê",
                Cdot: "ƒä",
                cdot: "ƒã",
                cedil: "¬∏",
                Cedilla: "¬∏",
                cemptyv: "‚¶≤",
                cent: "¬¢",
                CenterDot: "¬∑",
                centerdot: "¬∑",
                Cfr: "‚Ñ≠",
                cfr: "ùî†",
                CHcy: "–ß",
                chcy: "—á",
                check: "‚úì",
                checkmark: "‚úì",
                Chi: "Œß",
                chi: "œá",
                cir: "‚óã",
                circ: "ÀÜ",
                circeq: "‚âó",
                circlearrowleft: "‚Ü∫",
                circlearrowright: "‚Üª",
                circledast: "‚äõ",
                circledcirc: "‚äö",
                circleddash: "‚äù",
                CircleDot: "‚äô",
                circledR: "¬Æ",
                circledS: "‚ìà",
                CircleMinus: "‚äñ",
                CirclePlus: "‚äï",
                CircleTimes: "‚äó",
                cirE: "‚ßÉ",
                cire: "‚âó",
                cirfnint: "‚®ê",
                cirmid: "‚´Ø",
                cirscir: "‚ßÇ",
                ClockwiseContourIntegral: "‚à≤",
                CloseCurlyDoubleQuote: "‚Äù",
                CloseCurlyQuote: "‚Äô",
                clubs: "‚ô£",
                clubsuit: "‚ô£",
                Colon: "‚à∑",
                colon: ":",
                Colone: "‚©¥",
                colone: "‚âî",
                coloneq: "‚âî",
                comma: ",",
                commat: "@",
                comp: "‚àÅ",
                compfn: "‚àò",
                complement: "‚àÅ",
                complexes: "‚ÑÇ",
                cong: "‚âÖ",
                congdot: "‚©≠",
                Congruent: "‚â°",
                Conint: "‚àØ",
                conint: "‚àÆ",
                ContourIntegral: "‚àÆ",
                Copf: "‚ÑÇ",
                copf: "ùïî",
                coprod: "‚àê",
                Coproduct: "‚àê",
                COPY: "¬©",
                copy: "¬©",
                copysr: "‚Ñó",
                CounterClockwiseContourIntegral: "‚à≥",
                crarr: "‚Üµ",
                Cross: "‚®Ø",
                cross: "‚úó",
                Cscr: "ùíû",
                cscr: "ùí∏",
                csub: "‚´è",
                csube: "‚´ë",
                csup: "‚´ê",
                csupe: "‚´í",
                ctdot: "‚ãØ",
                cudarrl: "‚§∏",
                cudarrr: "‚§µ",
                cuepr: "‚ãû",
                cuesc: "‚ãü",
                cularr: "‚Ü∂",
                cularrp: "‚§Ω",
                Cup: "‚ãì",
                cup: "‚à™",
                cupbrcap: "‚©à",
                CupCap: "‚âç",
                cupcap: "‚©Ü",
                cupcup: "‚©ä",
                cupdot: "‚äç",
                cupor: "‚©Ö",
                cups: "‚à™Ô∏Ä",
                curarr: "‚Ü∑",
                curarrm: "‚§º",
                curlyeqprec: "‚ãû",
                curlyeqsucc: "‚ãü",
                curlyvee: "‚ãé",
                curlywedge: "‚ãè",
                curren: "¬§",
                curvearrowleft: "‚Ü∂",
                curvearrowright: "‚Ü∑",
                cuvee: "‚ãé",
                cuwed: "‚ãè",
                cwconint: "‚à≤",
                cwint: "‚à±",
                cylcty: "‚å≠",
                Dagger: "‚Ä°",
                dagger: "‚Ä†",
                daleth: "‚Ñ∏",
                Darr: "‚Ü°",
                dArr: "‚áì",
                darr: "‚Üì",
                dash: "‚Äê",
                Dashv: "‚´§",
                dashv: "‚ä£",
                dbkarow: "‚§è",
                dblac: "Àù",
                Dcaron: "ƒé",
                dcaron: "ƒè",
                Dcy: "–î",
                dcy: "–¥",
                DD: "‚ÖÖ",
                dd: "‚ÖÜ",
                ddagger: "‚Ä°",
                ddarr: "‚áä",
                DDotrahd: "‚§ë",
                ddotseq: "‚©∑",
                deg: "¬∞",
                Del: "‚àá",
                Delta: "Œî",
                delta: "Œ¥",
                demptyv: "‚¶±",
                dfisht: "‚•ø",
                Dfr: "ùîá",
                dfr: "ùî°",
                dHar: "‚••",
                dharl: "‚áÉ",
                dharr: "‚áÇ",
                DiacriticalAcute: "¬¥",
                DiacriticalDot: "Àô",
                DiacriticalDoubleAcute: "Àù",
                DiacriticalGrave: "`",
                DiacriticalTilde: "Àú",
                diam: "‚ãÑ",
                Diamond: "‚ãÑ",
                diamond: "‚ãÑ",
                diamondsuit: "‚ô¶",
                diams: "‚ô¶",
                die: "¬®",
                DifferentialD: "‚ÖÜ",
                digamma: "œù",
                disin: "‚ã≤",
                div: "√∑",
                divide: "√∑",
                divideontimes: "‚ãá",
                divonx: "‚ãá",
                DJcy: "–Ç",
                djcy: "—í",
                dlcorn: "‚åû",
                dlcrop: "‚åç",
                dollar: "$",
                Dopf: "ùîª",
                dopf: "ùïï",
                Dot: "¬®",
                dot: "Àô",
                DotDot: "‚Éú",
                doteq: "‚âê",
                doteqdot: "‚âë",
                DotEqual: "‚âê",
                dotminus: "‚à∏",
                dotplus: "‚àî",
                dotsquare: "‚ä°",
                doublebarwedge: "‚åÜ",
                DoubleContourIntegral: "‚àØ",
                DoubleDot: "¬®",
                DoubleDownArrow: "‚áì",
                DoubleLeftArrow: "‚áê",
                DoubleLeftRightArrow: "‚áî",
                DoubleLeftTee: "‚´§",
                DoubleLongLeftArrow: "‚ü∏",
                DoubleLongLeftRightArrow: "‚ü∫",
                DoubleLongRightArrow: "‚üπ",
                DoubleRightArrow: "‚áí",
                DoubleRightTee: "‚ä®",
                DoubleUpArrow: "‚áë",
                DoubleUpDownArrow: "‚áï",
                DoubleVerticalBar: "‚à•",
                DownArrow: "‚Üì",
                Downarrow: "‚áì",
                downarrow: "‚Üì",
                DownArrowBar: "‚§ì",
                DownArrowUpArrow: "‚áµ",
                DownBreve: "Ãë",
                downdownarrows: "‚áä",
                downharpoonleft: "‚áÉ",
                downharpoonright: "‚áÇ",
                DownLeftRightVector: "‚•ê",
                DownLeftTeeVector: "‚•û",
                DownLeftVector: "‚ÜΩ",
                DownLeftVectorBar: "‚•ñ",
                DownRightTeeVector: "‚•ü",
                DownRightVector: "‚áÅ",
                DownRightVectorBar: "‚•ó",
                DownTee: "‚ä§",
                DownTeeArrow: "‚Üß",
                drbkarow: "‚§ê",
                drcorn: "‚åü",
                drcrop: "‚åå",
                Dscr: "ùíü",
                dscr: "ùíπ",
                DScy: "–Ö",
                dscy: "—ï",
                dsol: "‚ß∂",
                Dstrok: "ƒê",
                dstrok: "ƒë",
                dtdot: "‚ã±",
                dtri: "‚ñø",
                dtrif: "‚ñæ",
                duarr: "‚áµ",
                duhar: "‚•Ø",
                dwangle: "‚¶¶",
                DZcy: "–è",
                dzcy: "—ü",
                dzigrarr: "‚üø",
                Eacute: "√â",
                eacute: "√©",
                easter: "‚©Æ",
                Ecaron: "ƒö",
                ecaron: "ƒõ",
                ecir: "‚âñ",
                Ecirc: "√ä",
                ecirc: "√™",
                ecolon: "‚âï",
                Ecy: "–≠",
                ecy: "—ç",
                eDDot: "‚©∑",
                Edot: "ƒñ",
                eDot: "‚âë",
                edot: "ƒó",
                ee: "‚Öá",
                efDot: "‚âí",
                Efr: "ùîà",
                efr: "ùî¢",
                eg: "‚™ö",
                Egrave: "√à",
                egrave: "√®",
                egs: "‚™ñ",
                egsdot: "‚™ò",
                el: "‚™ô",
                Element: "‚àà",
                elinters: "‚èß",
                ell: "‚Ñì",
                els: "‚™ï",
                elsdot: "‚™ó",
                Emacr: "ƒí",
                emacr: "ƒì",
                empty: "‚àÖ",
                emptyset: "‚àÖ",
                EmptySmallSquare: "‚óª",
                emptyv: "‚àÖ",
                EmptyVerySmallSquare: "‚ñ´",
                emsp: "‚ÄÉ",
                emsp13: "‚ÄÑ",
                emsp14: "‚ÄÖ",
                ENG: "≈ä",
                eng: "≈ã",
                ensp: "‚ÄÇ",
                Eogon: "ƒò",
                eogon: "ƒô",
                Eopf: "ùîº",
                eopf: "ùïñ",
                epar: "‚ãï",
                eparsl: "‚ß£",
                eplus: "‚©±",
                epsi: "Œµ",
                Epsilon: "Œï",
                epsilon: "Œµ",
                epsiv: "œµ",
                eqcirc: "‚âñ",
                eqcolon: "‚âï",
                eqsim: "‚âÇ",
                eqslantgtr: "‚™ñ",
                eqslantless: "‚™ï",
                Equal: "‚©µ",
                equals: "=",
                EqualTilde: "‚âÇ",
                equest: "‚âü",
                Equilibrium: "‚áå",
                equiv: "‚â°",
                equivDD: "‚©∏",
                eqvparsl: "‚ß•",
                erarr: "‚•±",
                erDot: "‚âì",
                Escr: "‚Ñ∞",
                escr: "‚ÑØ",
                esdot: "‚âê",
                Esim: "‚©≥",
                esim: "‚âÇ",
                Eta: "Œó",
                eta: "Œ∑",
                ETH: "√ê",
                eth: "√∞",
                Euml: "√ã",
                euml: "√´",
                euro: "‚Ç¨",
                excl: "!",
                exist: "‚àÉ",
                Exists: "‚àÉ",
                expectation: "‚Ñ∞",
                ExponentialE: "‚Öá",
                exponentiale: "‚Öá",
                fallingdotseq: "‚âí",
                Fcy: "–§",
                fcy: "—Ñ",
                female: "‚ôÄ",
                ffilig: "Ô¨É",
                fflig: "Ô¨Ä",
                ffllig: "Ô¨Ñ",
                Ffr: "ùîâ",
                ffr: "ùî£",
                filig: "Ô¨Å",
                FilledSmallSquare: "‚óº",
                FilledVerySmallSquare: "‚ñ™",
                fjlig: "fj",
                flat: "‚ô≠",
                fllig: "Ô¨Ç",
                fltns: "‚ñ±",
                fnof: "∆í",
                Fopf: "ùîΩ",
                fopf: "ùïó",
                ForAll: "‚àÄ",
                forall: "‚àÄ",
                fork: "‚ãî",
                forkv: "‚´ô",
                Fouriertrf: "‚Ñ±",
                fpartint: "‚®ç",
                frac12: "¬Ω",
                frac13: "‚Öì",
                frac14: "¬º",
                frac15: "‚Öï",
                frac16: "‚Öô",
                frac18: "‚Öõ",
                frac23: "‚Öî",
                frac25: "‚Öñ",
                frac34: "¬æ",
                frac35: "‚Öó",
                frac38: "‚Öú",
                frac45: "‚Öò",
                frac56: "‚Öö",
                frac58: "‚Öù",
                frac78: "‚Öû",
                frasl: "‚ÅÑ",
                frown: "‚å¢",
                Fscr: "‚Ñ±",
                fscr: "ùíª",
                gacute: "«µ",
                Gamma: "Œì",
                gamma: "Œ≥",
                Gammad: "œú",
                gammad: "œù",
                gap: "‚™Ü",
                Gbreve: "ƒû",
                gbreve: "ƒü",
                Gcedil: "ƒ¢",
                Gcirc: "ƒú",
                gcirc: "ƒù",
                Gcy: "–ì",
                gcy: "–≥",
                Gdot: "ƒ†",
                gdot: "ƒ°",
                gE: "‚âß",
                ge: "‚â•",
                gEl: "‚™å",
                gel: "‚ãõ",
                geq: "‚â•",
                geqq: "‚âß",
                geqslant: "‚©æ",
                ges: "‚©æ",
                gescc: "‚™©",
                gesdot: "‚™Ä",
                gesdoto: "‚™Ç",
                gesdotol: "‚™Ñ",
                gesl: "‚ãõÔ∏Ä",
                gesles: "‚™î",
                Gfr: "ùîä",
                gfr: "ùî§",
                Gg: "‚ãô",
                gg: "‚â´",
                ggg: "‚ãô",
                gimel: "‚Ñ∑",
                GJcy: "–É",
                gjcy: "—ì",
                gl: "‚â∑",
                gla: "‚™•",
                glE: "‚™í",
                glj: "‚™§",
                gnap: "‚™ä",
                gnapprox: "‚™ä",
                gnE: "‚â©",
                gne: "‚™à",
                gneq: "‚™à",
                gneqq: "‚â©",
                gnsim: "‚ãß",
                Gopf: "ùîæ",
                gopf: "ùïò",
                grave: "`",
                GreaterEqual: "‚â•",
                GreaterEqualLess: "‚ãõ",
                GreaterFullEqual: "‚âß",
                GreaterGreater: "‚™¢",
                GreaterLess: "‚â∑",
                GreaterSlantEqual: "‚©æ",
                GreaterTilde: "‚â≥",
                Gscr: "ùí¢",
                gscr: "‚Ñä",
                gsim: "‚â≥",
                gsime: "‚™é",
                gsiml: "‚™ê",
                Gt: "‚â´",
                GT: ">",
                gt: ">",
                gtcc: "‚™ß",
                gtcir: "‚©∫",
                gtdot: "‚ãó",
                gtlPar: "‚¶ï",
                gtquest: "‚©º",
                gtrapprox: "‚™Ü",
                gtrarr: "‚•∏",
                gtrdot: "‚ãó",
                gtreqless: "‚ãõ",
                gtreqqless: "‚™å",
                gtrless: "‚â∑",
                gtrsim: "‚â≥",
                gvertneqq: "‚â©Ô∏Ä",
                gvnE: "‚â©Ô∏Ä",
                Hacek: "Àá",
                hairsp: "‚Ää",
                half: "¬Ω",
                hamilt: "‚Ñã",
                HARDcy: "–™",
                hardcy: "—ä",
                hArr: "‚áî",
                harr: "‚Üî",
                harrcir: "‚•à",
                harrw: "‚Ü≠",
                Hat: "^",
                hbar: "‚Ñè",
                Hcirc: "ƒ§",
                hcirc: "ƒ•",
                hearts: "‚ô•",
                heartsuit: "‚ô•",
                hellip: "‚Ä¶",
                hercon: "‚äπ",
                Hfr: "‚Ñå",
                hfr: "ùî•",
                HilbertSpace: "‚Ñã",
                hksearow: "‚§•",
                hkswarow: "‚§¶",
                hoarr: "‚áø",
                homtht: "‚àª",
                hookleftarrow: "‚Ü©",
                hookrightarrow: "‚Ü™",
                Hopf: "‚Ñç",
                hopf: "ùïô",
                horbar: "‚Äï",
                HorizontalLine: "‚îÄ",
                Hscr: "‚Ñã",
                hscr: "ùíΩ",
                hslash: "‚Ñè",
                Hstrok: "ƒ¶",
                hstrok: "ƒß",
                HumpDownHump: "‚âé",
                HumpEqual: "‚âè",
                hybull: "‚ÅÉ",
                hyphen: "‚Äê",
                Iacute: "√ç",
                iacute: "√≠",
                ic: "‚Å£",
                Icirc: "√é",
                icirc: "√Æ",
                Icy: "–ò",
                icy: "–∏",
                Idot: "ƒ∞",
                IEcy: "–ï",
                iecy: "–µ",
                iexcl: "¬°",
                iff: "‚áî",
                Ifr: "‚Ñë",
                ifr: "ùî¶",
                Igrave: "√å",
                igrave: "√¨",
                ii: "‚Öà",
                iiiint: "‚®å",
                iiint: "‚à≠",
                iinfin: "‚ßú",
                iiota: "‚Ñ©",
                IJlig: "ƒ≤",
                ijlig: "ƒ≥",
                Im: "‚Ñë",
                Imacr: "ƒ™",
                imacr: "ƒ´",
                image: "‚Ñë",
                ImaginaryI: "‚Öà",
                imagline: "‚Ñê",
                imagpart: "‚Ñë",
                imath: "ƒ±",
                imof: "‚ä∑",
                imped: "∆µ",
                Implies: "‚áí",
                in: "‚àà",
                incare: "‚ÑÖ",
                infin: "‚àû",
                infintie: "‚ßù",
                inodot: "ƒ±",
                Int: "‚à¨",
                int: "‚à´",
                intcal: "‚ä∫",
                integers: "‚Ñ§",
                Integral: "‚à´",
                intercal: "‚ä∫",
                Intersection: "‚ãÇ",
                intlarhk: "‚®ó",
                intprod: "‚®º",
                InvisibleComma: "‚Å£",
                InvisibleTimes: "‚Å¢",
                IOcy: "–Å",
                iocy: "—ë",
                Iogon: "ƒÆ",
                iogon: "ƒØ",
                Iopf: "ùïÄ",
                iopf: "ùïö",
                Iota: "Œô",
                iota: "Œπ",
                iprod: "‚®º",
                iquest: "¬ø",
                Iscr: "‚Ñê",
                iscr: "ùíæ",
                isin: "‚àà",
                isindot: "‚ãµ",
                isinE: "‚ãπ",
                isins: "‚ã¥",
                isinsv: "‚ã≥",
                isinv: "‚àà",
                it: "‚Å¢",
                Itilde: "ƒ®",
                itilde: "ƒ©",
                Iukcy: "–Ü",
                iukcy: "—ñ",
                Iuml: "√è",
                iuml: "√Ø",
                Jcirc: "ƒ¥",
                jcirc: "ƒµ",
                Jcy: "–ô",
                jcy: "–π",
                Jfr: "ùîç",
                jfr: "ùîß",
                jmath: "»∑",
                Jopf: "ùïÅ",
                jopf: "ùïõ",
                Jscr: "ùí•",
                jscr: "ùíø",
                Jsercy: "–à",
                jsercy: "—ò",
                Jukcy: "–Ñ",
                jukcy: "—î",
                Kappa: "Œö",
                kappa: "Œ∫",
                kappav: "œ∞",
                Kcedil: "ƒ∂",
                kcedil: "ƒ∑",
                Kcy: "–ö",
                kcy: "–∫",
                Kfr: "ùîé",
                kfr: "ùî®",
                kgreen: "ƒ∏",
                KHcy: "–•",
                khcy: "—Ö",
                KJcy: "–å",
                kjcy: "—ú",
                Kopf: "ùïÇ",
                kopf: "ùïú",
                Kscr: "ùí¶",
                kscr: "ùìÄ",
                lAarr: "‚áö",
                Lacute: "ƒπ",
                lacute: "ƒ∫",
                laemptyv: "‚¶¥",
                lagran: "‚Ñí",
                Lambda: "Œõ",
                lambda: "Œª",
                Lang: "‚ü™",
                lang: "‚ü®",
                langd: "‚¶ë",
                langle: "‚ü®",
                lap: "‚™Ö",
                Laplacetrf: "‚Ñí",
                laquo: "¬´",
                Larr: "‚Üû",
                lArr: "‚áê",
                larr: "‚Üê",
                larrb: "‚á§",
                larrbfs: "‚§ü",
                larrfs: "‚§ù",
                larrhk: "‚Ü©",
                larrlp: "‚Ü´",
                larrpl: "‚§π",
                larrsim: "‚•≥",
                larrtl: "‚Ü¢",
                lat: "‚™´",
                lAtail: "‚§õ",
                latail: "‚§ô",
                late: "‚™≠",
                lates: "‚™≠Ô∏Ä",
                lBarr: "‚§é",
                lbarr: "‚§å",
                lbbrk: "‚ù≤",
                lbrace: "{",
                lbrack: "[",
                lbrke: "‚¶ã",
                lbrksld: "‚¶è",
                lbrkslu: "‚¶ç",
                Lcaron: "ƒΩ",
                lcaron: "ƒæ",
                Lcedil: "ƒª",
                lcedil: "ƒº",
                lceil: "‚åà",
                lcub: "{",
                Lcy: "–õ",
                lcy: "–ª",
                ldca: "‚§∂",
                ldquo: "‚Äú",
                ldquor: "‚Äû",
                ldrdhar: "‚•ß",
                ldrushar: "‚•ã",
                ldsh: "‚Ü≤",
                lE: "‚â¶",
                le: "‚â§",
                LeftAngleBracket: "‚ü®",
                LeftArrow: "‚Üê",
                Leftarrow: "‚áê",
                leftarrow: "‚Üê",
                LeftArrowBar: "‚á§",
                LeftArrowRightArrow: "‚áÜ",
                leftarrowtail: "‚Ü¢",
                LeftCeiling: "‚åà",
                LeftDoubleBracket: "‚ü¶",
                LeftDownTeeVector: "‚•°",
                LeftDownVector: "‚áÉ",
                LeftDownVectorBar: "‚•ô",
                LeftFloor: "‚åä",
                leftharpoondown: "‚ÜΩ",
                leftharpoonup: "‚Üº",
                leftleftarrows: "‚áá",
                LeftRightArrow: "‚Üî",
                Leftrightarrow: "‚áî",
                leftrightarrow: "‚Üî",
                leftrightarrows: "‚áÜ",
                leftrightharpoons: "‚áã",
                leftrightsquigarrow: "‚Ü≠",
                LeftRightVector: "‚•é",
                LeftTee: "‚ä£",
                LeftTeeArrow: "‚Ü§",
                LeftTeeVector: "‚•ö",
                leftthreetimes: "‚ãã",
                LeftTriangle: "‚ä≤",
                LeftTriangleBar: "‚ßè",
                LeftTriangleEqual: "‚ä¥",
                LeftUpDownVector: "‚•ë",
                LeftUpTeeVector: "‚•†",
                LeftUpVector: "‚Üø",
                LeftUpVectorBar: "‚•ò",
                LeftVector: "‚Üº",
                LeftVectorBar: "‚•í",
                lEg: "‚™ã",
                leg: "‚ãö",
                leq: "‚â§",
                leqq: "‚â¶",
                leqslant: "‚©Ω",
                les: "‚©Ω",
                lescc: "‚™®",
                lesdot: "‚©ø",
                lesdoto: "‚™Å",
                lesdotor: "‚™É",
                lesg: "‚ãöÔ∏Ä",
                lesges: "‚™ì",
                lessapprox: "‚™Ö",
                lessdot: "‚ãñ",
                lesseqgtr: "‚ãö",
                lesseqqgtr: "‚™ã",
                LessEqualGreater: "‚ãö",
                LessFullEqual: "‚â¶",
                LessGreater: "‚â∂",
                lessgtr: "‚â∂",
                LessLess: "‚™°",
                lesssim: "‚â≤",
                LessSlantEqual: "‚©Ω",
                LessTilde: "‚â≤",
                lfisht: "‚•º",
                lfloor: "‚åä",
                Lfr: "ùîè",
                lfr: "ùî©",
                lg: "‚â∂",
                lgE: "‚™ë",
                lHar: "‚•¢",
                lhard: "‚ÜΩ",
                lharu: "‚Üº",
                lharul: "‚•™",
                lhblk: "‚ñÑ",
                LJcy: "–â",
                ljcy: "—ô",
                Ll: "‚ãò",
                ll: "‚â™",
                llarr: "‚áá",
                llcorner: "‚åû",
                Lleftarrow: "‚áö",
                llhard: "‚•´",
                lltri: "‚ó∫",
                Lmidot: "ƒø",
                lmidot: "≈Ä",
                lmoust: "‚é∞",
                lmoustache: "‚é∞",
                lnap: "‚™â",
                lnapprox: "‚™â",
                lnE: "‚â®",
                lne: "‚™á",
                lneq: "‚™á",
                lneqq: "‚â®",
                lnsim: "‚ã¶",
                loang: "‚ü¨",
                loarr: "‚áΩ",
                lobrk: "‚ü¶",
                LongLeftArrow: "‚üµ",
                Longleftarrow: "‚ü∏",
                longleftarrow: "‚üµ",
                LongLeftRightArrow: "‚ü∑",
                Longleftrightarrow: "‚ü∫",
                longleftrightarrow: "‚ü∑",
                longmapsto: "‚üº",
                LongRightArrow: "‚ü∂",
                Longrightarrow: "‚üπ",
                longrightarrow: "‚ü∂",
                looparrowleft: "‚Ü´",
                looparrowright: "‚Ü¨",
                lopar: "‚¶Ö",
                Lopf: "ùïÉ",
                lopf: "ùïù",
                loplus: "‚®≠",
                lotimes: "‚®¥",
                lowast: "‚àó",
                lowbar: "_",
                LowerLeftArrow: "‚Üô",
                LowerRightArrow: "‚Üò",
                loz: "‚óä",
                lozenge: "‚óä",
                lozf: "‚ß´",
                lpar: "(",
                lparlt: "‚¶ì",
                lrarr: "‚áÜ",
                lrcorner: "‚åü",
                lrhar: "‚áã",
                lrhard: "‚•≠",
                lrm: "‚Äé",
                lrtri: "‚äø",
                lsaquo: "‚Äπ",
                Lscr: "‚Ñí",
                lscr: "ùìÅ",
                Lsh: "‚Ü∞",
                lsh: "‚Ü∞",
                lsim: "‚â≤",
                lsime: "‚™ç",
                lsimg: "‚™è",
                lsqb: "[",
                lsquo: "‚Äò",
                lsquor: "‚Äö",
                Lstrok: "≈Å",
                lstrok: "≈Ç",
                Lt: "‚â™",
                LT: "<",
                lt: "<",
                ltcc: "‚™¶",
                ltcir: "‚©π",
                ltdot: "‚ãñ",
                lthree: "‚ãã",
                ltimes: "‚ãâ",
                ltlarr: "‚•∂",
                ltquest: "‚©ª",
                ltri: "‚óÉ",
                ltrie: "‚ä¥",
                ltrif: "‚óÇ",
                ltrPar: "‚¶ñ",
                lurdshar: "‚•ä",
                luruhar: "‚•¶",
                lvertneqq: "‚â®Ô∏Ä",
                lvnE: "‚â®Ô∏Ä",
                macr: "¬Ø",
                male: "‚ôÇ",
                malt: "‚ú†",
                maltese: "‚ú†",
                Map: "‚§Ö",
                map: "‚Ü¶",
                mapsto: "‚Ü¶",
                mapstodown: "‚Üß",
                mapstoleft: "‚Ü§",
                mapstoup: "‚Ü•",
                marker: "‚ñÆ",
                mcomma: "‚®©",
                Mcy: "–ú",
                mcy: "–º",
                mdash: "‚Äî",
                mDDot: "‚à∫",
                measuredangle: "‚à°",
                MediumSpace: "‚Åü",
                Mellintrf: "‚Ñ≥",
                Mfr: "ùîê",
                mfr: "ùî™",
                mho: "‚Ñß",
                micro: "¬µ",
                mid: "‚à£",
                midast: "*",
                midcir: "‚´∞",
                middot: "¬∑",
                minus: "‚àí",
                minusb: "‚äü",
                minusd: "‚à∏",
                minusdu: "‚®™",
                MinusPlus: "‚àì",
                mlcp: "‚´õ",
                mldr: "‚Ä¶",
                mnplus: "‚àì",
                models: "‚äß",
                Mopf: "ùïÑ",
                mopf: "ùïû",
                mp: "‚àì",
                Mscr: "‚Ñ≥",
                mscr: "ùìÇ",
                mstpos: "‚àæ",
                Mu: "Œú",
                mu: "Œº",
                multimap: "‚ä∏",
                mumap: "‚ä∏",
                nabla: "‚àá",
                Nacute: "≈É",
                nacute: "≈Ñ",
                nang: "‚à†‚Éí",
                nap: "‚ââ",
                napE: "‚©∞Ã∏",
                napid: "‚âãÃ∏",
                napos: "≈â",
                napprox: "‚ââ",
                natur: "‚ôÆ",
                natural: "‚ôÆ",
                naturals: "‚Ñï",
                nbsp: "¬†",
                nbump: "‚âéÃ∏",
                nbumpe: "‚âèÃ∏",
                ncap: "‚©É",
                Ncaron: "≈á",
                ncaron: "≈à",
                Ncedil: "≈Ö",
                ncedil: "≈Ü",
                ncong: "‚âá",
                ncongdot: "‚©≠Ã∏",
                ncup: "‚©Ç",
                Ncy: "–ù",
                ncy: "–Ω",
                ndash: "‚Äì",
                ne: "‚â†",
                nearhk: "‚§§",
                neArr: "‚áó",
                nearr: "‚Üó",
                nearrow: "‚Üó",
                nedot: "‚âêÃ∏",
                NegativeMediumSpace: "‚Äã",
                NegativeThickSpace: "‚Äã",
                NegativeThinSpace: "‚Äã",
                NegativeVeryThinSpace: "‚Äã",
                nequiv: "‚â¢",
                nesear: "‚§®",
                nesim: "‚âÇÃ∏",
                NestedGreaterGreater: "‚â´",
                NestedLessLess: "‚â™",
                NewLine: "\n",
                nexist: "‚àÑ",
                nexists: "‚àÑ",
                Nfr: "ùîë",
                nfr: "ùî´",
                ngE: "‚âßÃ∏",
                nge: "‚â±",
                ngeq: "‚â±",
                ngeqq: "‚âßÃ∏",
                ngeqslant: "‚©æÃ∏",
                nges: "‚©æÃ∏",
                nGg: "‚ãôÃ∏",
                ngsim: "‚âµ",
                nGt: "‚â´‚Éí",
                ngt: "‚âØ",
                ngtr: "‚âØ",
                nGtv: "‚â´Ã∏",
                nhArr: "‚áé",
                nharr: "‚ÜÆ",
                nhpar: "‚´≤",
                ni: "‚àã",
                nis: "‚ãº",
                nisd: "‚ã∫",
                niv: "‚àã",
                NJcy: "–ä",
                njcy: "—ö",
                nlArr: "‚áç",
                nlarr: "‚Üö",
                nldr: "‚Ä•",
                nlE: "‚â¶Ã∏",
                nle: "‚â∞",
                nLeftarrow: "‚áç",
                nleftarrow: "‚Üö",
                nLeftrightarrow: "‚áé",
                nleftrightarrow: "‚ÜÆ",
                nleq: "‚â∞",
                nleqq: "‚â¶Ã∏",
                nleqslant: "‚©ΩÃ∏",
                nles: "‚©ΩÃ∏",
                nless: "‚âÆ",
                nLl: "‚ãòÃ∏",
                nlsim: "‚â¥",
                nLt: "‚â™‚Éí",
                nlt: "‚âÆ",
                nltri: "‚ã™",
                nltrie: "‚ã¨",
                nLtv: "‚â™Ã∏",
                nmid: "‚à§",
                NoBreak: "‚Å†",
                NonBreakingSpace: "¬†",
                Nopf: "‚Ñï",
                nopf: "ùïü",
                Not: "‚´¨",
                not: "¬¨",
                NotCongruent: "‚â¢",
                NotCupCap: "‚â≠",
                NotDoubleVerticalBar: "‚à¶",
                NotElement: "‚àâ",
                NotEqual: "‚â†",
                NotEqualTilde: "‚âÇÃ∏",
                NotExists: "‚àÑ",
                NotGreater: "‚âØ",
                NotGreaterEqual: "‚â±",
                NotGreaterFullEqual: "‚âßÃ∏",
                NotGreaterGreater: "‚â´Ã∏",
                NotGreaterLess: "‚âπ",
                NotGreaterSlantEqual: "‚©æÃ∏",
                NotGreaterTilde: "‚âµ",
                NotHumpDownHump: "‚âéÃ∏",
                NotHumpEqual: "‚âèÃ∏",
                notin: "‚àâ",
                notindot: "‚ãµÃ∏",
                notinE: "‚ãπÃ∏",
                notinva: "‚àâ",
                notinvb: "‚ã∑",
                notinvc: "‚ã∂",
                NotLeftTriangle: "‚ã™",
                NotLeftTriangleBar: "‚ßèÃ∏",
                NotLeftTriangleEqual: "‚ã¨",
                NotLess: "‚âÆ",
                NotLessEqual: "‚â∞",
                NotLessGreater: "‚â∏",
                NotLessLess: "‚â™Ã∏",
                NotLessSlantEqual: "‚©ΩÃ∏",
                NotLessTilde: "‚â¥",
                NotNestedGreaterGreater: "‚™¢Ã∏",
                NotNestedLessLess: "‚™°Ã∏",
                notni: "‚àå",
                notniva: "‚àå",
                notnivb: "‚ãæ",
                notnivc: "‚ãΩ",
                NotPrecedes: "‚äÄ",
                NotPrecedesEqual: "‚™ØÃ∏",
                NotPrecedesSlantEqual: "‚ã†",
                NotReverseElement: "‚àå",
                NotRightTriangle: "‚ã´",
                NotRightTriangleBar: "‚ßêÃ∏",
                NotRightTriangleEqual: "‚ã≠",
                NotSquareSubset: "‚äèÃ∏",
                NotSquareSubsetEqual: "‚ã¢",
                NotSquareSuperset: "‚äêÃ∏",
                NotSquareSupersetEqual: "‚ã£",
                NotSubset: "‚äÇ‚Éí",
                NotSubsetEqual: "‚äà",
                NotSucceeds: "‚äÅ",
                NotSucceedsEqual: "‚™∞Ã∏",
                NotSucceedsSlantEqual: "‚ã°",
                NotSucceedsTilde: "‚âøÃ∏",
                NotSuperset: "‚äÉ‚Éí",
                NotSupersetEqual: "‚äâ",
                NotTilde: "‚âÅ",
                NotTildeEqual: "‚âÑ",
                NotTildeFullEqual: "‚âá",
                NotTildeTilde: "‚ââ",
                NotVerticalBar: "‚à§",
                npar: "‚à¶",
                nparallel: "‚à¶",
                nparsl: "‚´Ω‚É•",
                npart: "‚àÇÃ∏",
                npolint: "‚®î",
                npr: "‚äÄ",
                nprcue: "‚ã†",
                npre: "‚™ØÃ∏",
                nprec: "‚äÄ",
                npreceq: "‚™ØÃ∏",
                nrArr: "‚áè",
                nrarr: "‚Üõ",
                nrarrc: "‚§≥Ã∏",
                nrarrw: "‚ÜùÃ∏",
                nRightarrow: "‚áè",
                nrightarrow: "‚Üõ",
                nrtri: "‚ã´",
                nrtrie: "‚ã≠",
                nsc: "‚äÅ",
                nsccue: "‚ã°",
                nsce: "‚™∞Ã∏",
                Nscr: "ùí©",
                nscr: "ùìÉ",
                nshortmid: "‚à§",
                nshortparallel: "‚à¶",
                nsim: "‚âÅ",
                nsime: "‚âÑ",
                nsimeq: "‚âÑ",
                nsmid: "‚à§",
                nspar: "‚à¶",
                nsqsube: "‚ã¢",
                nsqsupe: "‚ã£",
                nsub: "‚äÑ",
                nsubE: "‚´ÖÃ∏",
                nsube: "‚äà",
                nsubset: "‚äÇ‚Éí",
                nsubseteq: "‚äà",
                nsubseteqq: "‚´ÖÃ∏",
                nsucc: "‚äÅ",
                nsucceq: "‚™∞Ã∏",
                nsup: "‚äÖ",
                nsupE: "‚´ÜÃ∏",
                nsupe: "‚äâ",
                nsupset: "‚äÉ‚Éí",
                nsupseteq: "‚äâ",
                nsupseteqq: "‚´ÜÃ∏",
                ntgl: "‚âπ",
                Ntilde: "√ë",
                ntilde: "√±",
                ntlg: "‚â∏",
                ntriangleleft: "‚ã™",
                ntrianglelefteq: "‚ã¨",
                ntriangleright: "‚ã´",
                ntrianglerighteq: "‚ã≠",
                Nu: "Œù",
                nu: "ŒΩ",
                num: "#",
                numero: "‚Ññ",
                numsp: "‚Äá",
                nvap: "‚âç‚Éí",
                nVDash: "‚äØ",
                nVdash: "‚äÆ",
                nvDash: "‚ä≠",
                nvdash: "‚ä¨",
                nvge: "‚â•‚Éí",
                nvgt: ">‚Éí",
                nvHarr: "‚§Ñ",
                nvinfin: "‚ßû",
                nvlArr: "‚§Ç",
                nvle: "‚â§‚Éí",
                nvlt: "<‚Éí",
                nvltrie: "‚ä¥‚Éí",
                nvrArr: "‚§É",
                nvrtrie: "‚äµ‚Éí",
                nvsim: "‚àº‚Éí",
                nwarhk: "‚§£",
                nwArr: "‚áñ",
                nwarr: "‚Üñ",
                nwarrow: "‚Üñ",
                nwnear: "‚§ß",
                Oacute: "√ì",
                oacute: "√≥",
                oast: "‚äõ",
                ocir: "‚äö",
                Ocirc: "√î",
                ocirc: "√¥",
                Ocy: "–û",
                ocy: "–æ",
                odash: "‚äù",
                Odblac: "≈ê",
                odblac: "≈ë",
                odiv: "‚®∏",
                odot: "‚äô",
                odsold: "‚¶º",
                OElig: "≈í",
                oelig: "≈ì",
                ofcir: "‚¶ø",
                Ofr: "ùîí",
                ofr: "ùî¨",
                ogon: "Àõ",
                Ograve: "√í",
                ograve: "√≤",
                ogt: "‚ßÅ",
                ohbar: "‚¶µ",
                ohm: "Œ©",
                oint: "‚àÆ",
                olarr: "‚Ü∫",
                olcir: "‚¶æ",
                olcross: "‚¶ª",
                oline: "‚Äæ",
                olt: "‚ßÄ",
                Omacr: "≈å",
                omacr: "≈ç",
                Omega: "Œ©",
                omega: "œâ",
                Omicron: "Œü",
                omicron: "Œø",
                omid: "‚¶∂",
                ominus: "‚äñ",
                Oopf: "ùïÜ",
                oopf: "ùï†",
                opar: "‚¶∑",
                OpenCurlyDoubleQuote: "‚Äú",
                OpenCurlyQuote: "‚Äò",
                operp: "‚¶π",
                oplus: "‚äï",
                Or: "‚©î",
                or: "‚à®",
                orarr: "‚Üª",
                ord: "‚©ù",
                order: "‚Ñ¥",
                orderof: "‚Ñ¥",
                ordf: "¬™",
                ordm: "¬∫",
                origof: "‚ä∂",
                oror: "‚©ñ",
                orslope: "‚©ó",
                orv: "‚©õ",
                oS: "‚ìà",
                Oscr: "ùí™",
                oscr: "‚Ñ¥",
                Oslash: "√ò",
                oslash: "√∏",
                osol: "‚äò",
                Otilde: "√ï",
                otilde: "√µ",
                Otimes: "‚®∑",
                otimes: "‚äó",
                otimesas: "‚®∂",
                Ouml: "√ñ",
                ouml: "√∂",
                ovbar: "‚åΩ",
                OverBar: "‚Äæ",
                OverBrace: "‚èû",
                OverBracket: "‚é¥",
                OverParenthesis: "‚èú",
                par: "‚à•",
                para: "¬∂",
                parallel: "‚à•",
                parsim: "‚´≥",
                parsl: "‚´Ω",
                part: "‚àÇ",
                PartialD: "‚àÇ",
                Pcy: "–ü",
                pcy: "–ø",
                percnt: "%",
                period: ".",
                permil: "‚Ä∞",
                perp: "‚ä•",
                pertenk: "‚Ä±",
                Pfr: "ùîì",
                pfr: "ùî≠",
                Phi: "Œ¶",
                phi: "œÜ",
                phiv: "œï",
                phmmat: "‚Ñ≥",
                phone: "‚òé",
                Pi: "Œ†",
                pi: "œÄ",
                pitchfork: "‚ãî",
                piv: "œñ",
                planck: "‚Ñè",
                planckh: "‚Ñé",
                plankv: "‚Ñè",
                plus: "+",
                plusacir: "‚®£",
                plusb: "‚äû",
                pluscir: "‚®¢",
                plusdo: "‚àî",
                plusdu: "‚®•",
                pluse: "‚©≤",
                PlusMinus: "¬±",
                plusmn: "¬±",
                plussim: "‚®¶",
                plustwo: "‚®ß",
                pm: "¬±",
                Poincareplane: "‚Ñå",
                pointint: "‚®ï",
                Popf: "‚Ñô",
                popf: "ùï°",
                pound: "¬£",
                Pr: "‚™ª",
                pr: "‚â∫",
                prap: "‚™∑",
                prcue: "‚âº",
                prE: "‚™≥",
                pre: "‚™Ø",
                prec: "‚â∫",
                precapprox: "‚™∑",
                preccurlyeq: "‚âº",
                Precedes: "‚â∫",
                PrecedesEqual: "‚™Ø",
                PrecedesSlantEqual: "‚âº",
                PrecedesTilde: "‚âæ",
                preceq: "‚™Ø",
                precnapprox: "‚™π",
                precneqq: "‚™µ",
                precnsim: "‚ã®",
                precsim: "‚âæ",
                Prime: "‚Ä≥",
                prime: "‚Ä≤",
                primes: "‚Ñô",
                prnap: "‚™π",
                prnE: "‚™µ",
                prnsim: "‚ã®",
                prod: "‚àè",
                Product: "‚àè",
                profalar: "‚åÆ",
                profline: "‚åí",
                profsurf: "‚åì",
                prop: "‚àù",
                Proportion: "‚à∑",
                Proportional: "‚àù",
                propto: "‚àù",
                prsim: "‚âæ",
                prurel: "‚ä∞",
                Pscr: "ùí´",
                pscr: "ùìÖ",
                Psi: "Œ®",
                psi: "œà",
                puncsp: "‚Äà",
                Qfr: "ùîî",
                qfr: "ùîÆ",
                qint: "‚®å",
                Qopf: "‚Ñö",
                qopf: "ùï¢",
                qprime: "‚Åó",
                Qscr: "ùí¨",
                qscr: "ùìÜ",
                quaternions: "‚Ñç",
                quatint: "‚®ñ",
                quest: "?",
                questeq: "‚âü",
                QUOT: '"',
                quot: '"',
                rAarr: "‚áõ",
                race: "‚àΩÃ±",
                Racute: "≈î",
                racute: "≈ï",
                radic: "‚àö",
                raemptyv: "‚¶≥",
                Rang: "‚ü´",
                rang: "‚ü©",
                rangd: "‚¶í",
                range: "‚¶•",
                rangle: "‚ü©",
                raquo: "¬ª",
                Rarr: "‚Ü†",
                rArr: "‚áí",
                rarr: "‚Üí",
                rarrap: "‚•µ",
                rarrb: "‚á•",
                rarrbfs: "‚§†",
                rarrc: "‚§≥",
                rarrfs: "‚§û",
                rarrhk: "‚Ü™",
                rarrlp: "‚Ü¨",
                rarrpl: "‚•Ö",
                rarrsim: "‚•¥",
                Rarrtl: "‚§ñ",
                rarrtl: "‚Ü£",
                rarrw: "‚Üù",
                rAtail: "‚§ú",
                ratail: "‚§ö",
                ratio: "‚à∂",
                rationals: "‚Ñö",
                RBarr: "‚§ê",
                rBarr: "‚§è",
                rbarr: "‚§ç",
                rbbrk: "‚ù≥",
                rbrace: "}",
                rbrack: "]",
                rbrke: "‚¶å",
                rbrksld: "‚¶é",
                rbrkslu: "‚¶ê",
                Rcaron: "≈ò",
                rcaron: "≈ô",
                Rcedil: "≈ñ",
                rcedil: "≈ó",
                rceil: "‚åâ",
                rcub: "}",
                Rcy: "–†",
                rcy: "—Ä",
                rdca: "‚§∑",
                rdldhar: "‚•©",
                rdquo: "‚Äù",
                rdquor: "‚Äù",
                rdsh: "‚Ü≥",
                Re: "‚Ñú",
                real: "‚Ñú",
                realine: "‚Ñõ",
                realpart: "‚Ñú",
                reals: "‚Ñù",
                rect: "‚ñ≠",
                REG: "¬Æ",
                reg: "¬Æ",
                ReverseElement: "‚àã",
                ReverseEquilibrium: "‚áã",
                ReverseUpEquilibrium: "‚•Ø",
                rfisht: "‚•Ω",
                rfloor: "‚åã",
                Rfr: "‚Ñú",
                rfr: "ùîØ",
                rHar: "‚•§",
                rhard: "‚áÅ",
                rharu: "‚áÄ",
                rharul: "‚•¨",
                Rho: "Œ°",
                rho: "œÅ",
                rhov: "œ±",
                RightAngleBracket: "‚ü©",
                RightArrow: "‚Üí",
                Rightarrow: "‚áí",
                rightarrow: "‚Üí",
                RightArrowBar: "‚á•",
                RightArrowLeftArrow: "‚áÑ",
                rightarrowtail: "‚Ü£",
                RightCeiling: "‚åâ",
                RightDoubleBracket: "‚üß",
                RightDownTeeVector: "‚•ù",
                RightDownVector: "‚áÇ",
                RightDownVectorBar: "‚•ï",
                RightFloor: "‚åã",
                rightharpoondown: "‚áÅ",
                rightharpoonup: "‚áÄ",
                rightleftarrows: "‚áÑ",
                rightleftharpoons: "‚áå",
                rightrightarrows: "‚áâ",
                rightsquigarrow: "‚Üù",
                RightTee: "‚ä¢",
                RightTeeArrow: "‚Ü¶",
                RightTeeVector: "‚•õ",
                rightthreetimes: "‚ãå",
                RightTriangle: "‚ä≥",
                RightTriangleBar: "‚ßê",
                RightTriangleEqual: "‚äµ",
                RightUpDownVector: "‚•è",
                RightUpTeeVector: "‚•ú",
                RightUpVector: "‚Üæ",
                RightUpVectorBar: "‚•î",
                RightVector: "‚áÄ",
                RightVectorBar: "‚•ì",
                ring: "Àö",
                risingdotseq: "‚âì",
                rlarr: "‚áÑ",
                rlhar: "‚áå",
                rlm: "‚Äè",
                rmoust: "‚é±",
                rmoustache: "‚é±",
                rnmid: "‚´Æ",
                roang: "‚ü≠",
                roarr: "‚áæ",
                robrk: "‚üß",
                ropar: "‚¶Ü",
                Ropf: "‚Ñù",
                ropf: "ùï£",
                roplus: "‚®Æ",
                rotimes: "‚®µ",
                RoundImplies: "‚•∞",
                rpar: ")",
                rpargt: "‚¶î",
                rppolint: "‚®í",
                rrarr: "‚áâ",
                Rrightarrow: "‚áõ",
                rsaquo: "‚Ä∫",
                Rscr: "‚Ñõ",
                rscr: "ùìá",
                Rsh: "‚Ü±",
                rsh: "‚Ü±",
                rsqb: "]",
                rsquo: "‚Äô",
                rsquor: "‚Äô",
                rthree: "‚ãå",
                rtimes: "‚ãä",
                rtri: "‚ñπ",
                rtrie: "‚äµ",
                rtrif: "‚ñ∏",
                rtriltri: "‚ßé",
                RuleDelayed: "‚ß¥",
                ruluhar: "‚•®",
                rx: "‚Ñû",
                Sacute: "≈ö",
                sacute: "≈õ",
                sbquo: "‚Äö",
                Sc: "‚™º",
                sc: "‚âª",
                scap: "‚™∏",
                Scaron: "≈†",
                scaron: "≈°",
                sccue: "‚âΩ",
                scE: "‚™¥",
                sce: "‚™∞",
                Scedil: "≈û",
                scedil: "≈ü",
                Scirc: "≈ú",
                scirc: "≈ù",
                scnap: "‚™∫",
                scnE: "‚™∂",
                scnsim: "‚ã©",
                scpolint: "‚®ì",
                scsim: "‚âø",
                Scy: "–°",
                scy: "—Å",
                sdot: "‚ãÖ",
                sdotb: "‚ä°",
                sdote: "‚©¶",
                searhk: "‚§•",
                seArr: "‚áò",
                searr: "‚Üò",
                searrow: "‚Üò",
                sect: "¬ß",
                semi: ";",
                seswar: "‚§©",
                setminus: "‚àñ",
                setmn: "‚àñ",
                sext: "‚ú∂",
                Sfr: "ùîñ",
                sfr: "ùî∞",
                sfrown: "‚å¢",
                sharp: "‚ôØ",
                SHCHcy: "–©",
                shchcy: "—â",
                SHcy: "–®",
                shcy: "—à",
                ShortDownArrow: "‚Üì",
                ShortLeftArrow: "‚Üê",
                shortmid: "‚à£",
                shortparallel: "‚à•",
                ShortRightArrow: "‚Üí",
                ShortUpArrow: "‚Üë",
                shy: "¬≠",
                Sigma: "Œ£",
                sigma: "œÉ",
                sigmaf: "œÇ",
                sigmav: "œÇ",
                sim: "‚àº",
                simdot: "‚©™",
                sime: "‚âÉ",
                simeq: "‚âÉ",
                simg: "‚™û",
                simgE: "‚™†",
                siml: "‚™ù",
                simlE: "‚™ü",
                simne: "‚âÜ",
                simplus: "‚®§",
                simrarr: "‚•≤",
                slarr: "‚Üê",
                SmallCircle: "‚àò",
                smallsetminus: "‚àñ",
                smashp: "‚®≥",
                smeparsl: "‚ß§",
                smid: "‚à£",
                smile: "‚å£",
                smt: "‚™™",
                smte: "‚™¨",
                smtes: "‚™¨Ô∏Ä",
                SOFTcy: "–¨",
                softcy: "—å",
                sol: "/",
                solb: "‚ßÑ",
                solbar: "‚åø",
                Sopf: "ùïä",
                sopf: "ùï§",
                spades: "‚ô†",
                spadesuit: "‚ô†",
                spar: "‚à•",
                sqcap: "‚äì",
                sqcaps: "‚äìÔ∏Ä",
                sqcup: "‚äî",
                sqcups: "‚äîÔ∏Ä",
                Sqrt: "‚àö",
                sqsub: "‚äè",
                sqsube: "‚äë",
                sqsubset: "‚äè",
                sqsubseteq: "‚äë",
                sqsup: "‚äê",
                sqsupe: "‚äí",
                sqsupset: "‚äê",
                sqsupseteq: "‚äí",
                squ: "‚ñ°",
                Square: "‚ñ°",
                square: "‚ñ°",
                SquareIntersection: "‚äì",
                SquareSubset: "‚äè",
                SquareSubsetEqual: "‚äë",
                SquareSuperset: "‚äê",
                SquareSupersetEqual: "‚äí",
                SquareUnion: "‚äî",
                squarf: "‚ñ™",
                squf: "‚ñ™",
                srarr: "‚Üí",
                Sscr: "ùíÆ",
                sscr: "ùìà",
                ssetmn: "‚àñ",
                ssmile: "‚å£",
                sstarf: "‚ãÜ",
                Star: "‚ãÜ",
                star: "‚òÜ",
                starf: "‚òÖ",
                straightepsilon: "œµ",
                straightphi: "œï",
                strns: "¬Ø",
                Sub: "‚ãê",
                sub: "‚äÇ",
                subdot: "‚™Ω",
                subE: "‚´Ö",
                sube: "‚äÜ",
                subedot: "‚´É",
                submult: "‚´Å",
                subnE: "‚´ã",
                subne: "‚ää",
                subplus: "‚™ø",
                subrarr: "‚•π",
                Subset: "‚ãê",
                subset: "‚äÇ",
                subseteq: "‚äÜ",
                subseteqq: "‚´Ö",
                SubsetEqual: "‚äÜ",
                subsetneq: "‚ää",
                subsetneqq: "‚´ã",
                subsim: "‚´á",
                subsub: "‚´ï",
                subsup: "‚´ì",
                succ: "‚âª",
                succapprox: "‚™∏",
                succcurlyeq: "‚âΩ",
                Succeeds: "‚âª",
                SucceedsEqual: "‚™∞",
                SucceedsSlantEqual: "‚âΩ",
                SucceedsTilde: "‚âø",
                succeq: "‚™∞",
                succnapprox: "‚™∫",
                succneqq: "‚™∂",
                succnsim: "‚ã©",
                succsim: "‚âø",
                SuchThat: "‚àã",
                Sum: "‚àë",
                sum: "‚àë",
                sung: "‚ô™",
                Sup: "‚ãë",
                sup: "‚äÉ",
                sup1: "¬π",
                sup2: "¬≤",
                sup3: "¬≥",
                supdot: "‚™æ",
                supdsub: "‚´ò",
                supE: "‚´Ü",
                supe: "‚äá",
                supedot: "‚´Ñ",
                Superset: "‚äÉ",
                SupersetEqual: "‚äá",
                suphsol: "‚üâ",
                suphsub: "‚´ó",
                suplarr: "‚•ª",
                supmult: "‚´Ç",
                supnE: "‚´å",
                supne: "‚äã",
                supplus: "‚´Ä",
                Supset: "‚ãë",
                supset: "‚äÉ",
                supseteq: "‚äá",
                supseteqq: "‚´Ü",
                supsetneq: "‚äã",
                supsetneqq: "‚´å",
                supsim: "‚´à",
                supsub: "‚´î",
                supsup: "‚´ñ",
                swarhk: "‚§¶",
                swArr: "‚áô",
                swarr: "‚Üô",
                swarrow: "‚Üô",
                swnwar: "‚§™",
                szlig: "√ü",
                Tab: "\t",
                target: "‚åñ",
                Tau: "Œ§",
                tau: "œÑ",
                tbrk: "‚é¥",
                Tcaron: "≈§",
                tcaron: "≈•",
                Tcedil: "≈¢",
                tcedil: "≈£",
                Tcy: "–¢",
                tcy: "—Ç",
                tdot: "‚Éõ",
                telrec: "‚åï",
                Tfr: "ùîó",
                tfr: "ùî±",
                there4: "‚à¥",
                Therefore: "‚à¥",
                therefore: "‚à¥",
                Theta: "Œò",
                theta: "Œ∏",
                thetasym: "œë",
                thetav: "œë",
                thickapprox: "‚âà",
                thicksim: "‚àº",
                ThickSpace: "‚Åü‚Ää",
                thinsp: "‚Äâ",
                ThinSpace: "‚Äâ",
                thkap: "‚âà",
                thksim: "‚àº",
                THORN: "√û",
                thorn: "√æ",
                Tilde: "‚àº",
                tilde: "Àú",
                TildeEqual: "‚âÉ",
                TildeFullEqual: "‚âÖ",
                TildeTilde: "‚âà",
                times: "√ó",
                timesb: "‚ä†",
                timesbar: "‚®±",
                timesd: "‚®∞",
                tint: "‚à≠",
                toea: "‚§®",
                top: "‚ä§",
                topbot: "‚å∂",
                topcir: "‚´±",
                Topf: "ùïã",
                topf: "ùï•",
                topfork: "‚´ö",
                tosa: "‚§©",
                tprime: "‚Ä¥",
                TRADE: "‚Ñ¢",
                trade: "‚Ñ¢",
                triangle: "‚ñµ",
                triangledown: "‚ñø",
                triangleleft: "‚óÉ",
                trianglelefteq: "‚ä¥",
                triangleq: "‚âú",
                triangleright: "‚ñπ",
                trianglerighteq: "‚äµ",
                tridot: "‚ó¨",
                trie: "‚âú",
                triminus: "‚®∫",
                TripleDot: "‚Éõ",
                triplus: "‚®π",
                trisb: "‚ßç",
                tritime: "‚®ª",
                trpezium: "‚è¢",
                Tscr: "ùíØ",
                tscr: "ùìâ",
                TScy: "–¶",
                tscy: "—Ü",
                TSHcy: "–ã",
                tshcy: "—õ",
                Tstrok: "≈¶",
                tstrok: "≈ß",
                twixt: "‚â¨",
                twoheadleftarrow: "‚Üû",
                twoheadrightarrow: "‚Ü†",
                Uacute: "√ö",
                uacute: "√∫",
                Uarr: "‚Üü",
                uArr: "‚áë",
                uarr: "‚Üë",
                Uarrocir: "‚•â",
                Ubrcy: "–é",
                ubrcy: "—û",
                Ubreve: "≈¨",
                ubreve: "≈≠",
                Ucirc: "√õ",
                ucirc: "√ª",
                Ucy: "–£",
                ucy: "—É",
                udarr: "‚áÖ",
                Udblac: "≈∞",
                udblac: "≈±",
                udhar: "‚•Æ",
                ufisht: "‚•æ",
                Ufr: "ùîò",
                ufr: "ùî≤",
                Ugrave: "√ô",
                ugrave: "√π",
                uHar: "‚•£",
                uharl: "‚Üø",
                uharr: "‚Üæ",
                uhblk: "‚ñÄ",
                ulcorn: "‚åú",
                ulcorner: "‚åú",
                ulcrop: "‚åè",
                ultri: "‚ó∏",
                Umacr: "≈™",
                umacr: "≈´",
                uml: "¬®",
                UnderBar: "_",
                UnderBrace: "‚èü",
                UnderBracket: "‚éµ",
                UnderParenthesis: "‚èù",
                Union: "‚ãÉ",
                UnionPlus: "‚äé",
                Uogon: "≈≤",
                uogon: "≈≥",
                Uopf: "ùïå",
                uopf: "ùï¶",
                UpArrow: "‚Üë",
                Uparrow: "‚áë",
                uparrow: "‚Üë",
                UpArrowBar: "‚§í",
                UpArrowDownArrow: "‚áÖ",
                UpDownArrow: "‚Üï",
                Updownarrow: "‚áï",
                updownarrow: "‚Üï",
                UpEquilibrium: "‚•Æ",
                upharpoonleft: "‚Üø",
                upharpoonright: "‚Üæ",
                uplus: "‚äé",
                UpperLeftArrow: "‚Üñ",
                UpperRightArrow: "‚Üó",
                Upsi: "œí",
                upsi: "œÖ",
                upsih: "œí",
                Upsilon: "Œ•",
                upsilon: "œÖ",
                UpTee: "‚ä•",
                UpTeeArrow: "‚Ü•",
                upuparrows: "‚áà",
                urcorn: "‚åù",
                urcorner: "‚åù",
                urcrop: "‚åé",
                Uring: "≈Æ",
                uring: "≈Ø",
                urtri: "‚óπ",
                Uscr: "ùí∞",
                uscr: "ùìä",
                utdot: "‚ã∞",
                Utilde: "≈®",
                utilde: "≈©",
                utri: "‚ñµ",
                utrif: "‚ñ¥",
                uuarr: "‚áà",
                Uuml: "√ú",
                uuml: "√º",
                uwangle: "‚¶ß",
                vangrt: "‚¶ú",
                varepsilon: "œµ",
                varkappa: "œ∞",
                varnothing: "‚àÖ",
                varphi: "œï",
                varpi: "œñ",
                varpropto: "‚àù",
                vArr: "‚áï",
                varr: "‚Üï",
                varrho: "œ±",
                varsigma: "œÇ",
                varsubsetneq: "‚ääÔ∏Ä",
                varsubsetneqq: "‚´ãÔ∏Ä",
                varsupsetneq: "‚äãÔ∏Ä",
                varsupsetneqq: "‚´åÔ∏Ä",
                vartheta: "œë",
                vartriangleleft: "‚ä≤",
                vartriangleright: "‚ä≥",
                Vbar: "‚´´",
                vBar: "‚´®",
                vBarv: "‚´©",
                Vcy: "–í",
                vcy: "–≤",
                VDash: "‚ä´",
                Vdash: "‚ä©",
                vDash: "‚ä®",
                vdash: "‚ä¢",
                Vdashl: "‚´¶",
                Vee: "‚ãÅ",
                vee: "‚à®",
                veebar: "‚äª",
                veeeq: "‚âö",
                vellip: "‚ãÆ",
                Verbar: "‚Äñ",
                verbar: "|",
                Vert: "‚Äñ",
                vert: "|",
                VerticalBar: "‚à£",
                VerticalLine: "|",
                VerticalSeparator: "‚ùò",
                VerticalTilde: "‚âÄ",
                VeryThinSpace: "‚Ää",
                Vfr: "ùîô",
                vfr: "ùî≥",
                vltri: "‚ä≤",
                vnsub: "‚äÇ‚Éí",
                vnsup: "‚äÉ‚Éí",
                Vopf: "ùïç",
                vopf: "ùïß",
                vprop: "‚àù",
                vrtri: "‚ä≥",
                Vscr: "ùí±",
                vscr: "ùìã",
                vsubnE: "‚´ãÔ∏Ä",
                vsubne: "‚ääÔ∏Ä",
                vsupnE: "‚´åÔ∏Ä",
                vsupne: "‚äãÔ∏Ä",
                Vvdash: "‚ä™",
                vzigzag: "‚¶ö",
                Wcirc: "≈¥",
                wcirc: "≈µ",
                wedbar: "‚©ü",
                Wedge: "‚ãÄ",
                wedge: "‚àß",
                wedgeq: "‚âô",
                weierp: "‚Ñò",
                Wfr: "ùîö",
                wfr: "ùî¥",
                Wopf: "ùïé",
                wopf: "ùï®",
                wp: "‚Ñò",
                wr: "‚âÄ",
                wreath: "‚âÄ",
                Wscr: "ùí≤",
                wscr: "ùìå",
                xcap: "‚ãÇ",
                xcirc: "‚óØ",
                xcup: "‚ãÉ",
                xdtri: "‚ñΩ",
                Xfr: "ùîõ",
                xfr: "ùîµ",
                xhArr: "‚ü∫",
                xharr: "‚ü∑",
                Xi: "Œû",
                xi: "Œæ",
                xlArr: "‚ü∏",
                xlarr: "‚üµ",
                xmap: "‚üº",
                xnis: "‚ãª",
                xodot: "‚®Ä",
                Xopf: "ùïè",
                xopf: "ùï©",
                xoplus: "‚®Å",
                xotime: "‚®Ç",
                xrArr: "‚üπ",
                xrarr: "‚ü∂",
                Xscr: "ùí≥",
                xscr: "ùìç",
                xsqcup: "‚®Ü",
                xuplus: "‚®Ñ",
                xutri: "‚ñ≥",
                xvee: "‚ãÅ",
                xwedge: "‚ãÄ",
                Yacute: "√ù",
                yacute: "√Ω",
                YAcy: "–Ø",
                yacy: "—è",
                Ycirc: "≈∂",
                ycirc: "≈∑",
                Ycy: "–´",
                ycy: "—ã",
                yen: "¬•",
                Yfr: "ùîú",
                yfr: "ùî∂",
                YIcy: "–á",
                yicy: "—ó",
                Yopf: "ùïê",
                yopf: "ùï™",
                Yscr: "ùí¥",
                yscr: "ùìé",
                YUcy: "–Æ",
                yucy: "—é",
                Yuml: "≈∏",
                yuml: "√ø",
                Zacute: "≈π",
                zacute: "≈∫",
                Zcaron: "≈Ω",
                zcaron: "≈æ",
                Zcy: "–ó",
                zcy: "–∑",
                Zdot: "≈ª",
                zdot: "≈º",
                zeetrf: "‚Ñ®",
                ZeroWidthSpace: "‚Äã",
                Zeta: "Œñ",
                zeta: "Œ∂",
                Zfr: "‚Ñ®",
                zfr: "ùî∑",
                ZHcy: "–ñ",
                zhcy: "–∂",
                zigrarr: "‚áù",
                Zopf: "‚Ñ§",
                zopf: "ùï´",
                Zscr: "ùíµ",
                zscr: "ùìè",
                zwj: "‚Äç",
                zwnj: "‚Äå"
            });
            exports.entityMap = exports.HTML_ENTITIES;
        },
        969: (__unused_webpack_module, exports, __webpack_require__) => {
            var dom = __webpack_require__(146);
            dom.DOMImplementation;
            dom.XMLSerializer;
            exports.DOMParser = __webpack_require__(129).DOMParser;
        },
        925: (__unused_webpack_module, exports, __webpack_require__) => {
            var NAMESPACE = __webpack_require__(167).NAMESPACE;
            var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
            var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
            var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
            var S_TAG = 0;
            var S_ATTR = 1;
            var S_ATTR_SPACE = 2;
            var S_EQ = 3;
            var S_ATTR_NOQUOT_VALUE = 4;
            var S_ATTR_END = 5;
            var S_TAG_SPACE = 6;
            var S_TAG_CLOSE = 7;
            function ParseError(message, locator) {
                this.message = message;
                this.locator = locator;
                if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
            }
            ParseError.prototype = new Error;
            ParseError.prototype.name = ParseError.name;
            function XMLReader() {}
            XMLReader.prototype = {
                parse: function(source, defaultNSMap, entityMap) {
                    var domBuilder = this.domBuilder;
                    domBuilder.startDocument();
                    _copy(defaultNSMap, defaultNSMap = {});
                    parse(source, defaultNSMap, entityMap, domBuilder, this.errorHandler);
                    domBuilder.endDocument();
                }
            };
            function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
                function fixedFromCharCode(code) {
                    if (code > 65535) {
                        code -= 65536;
                        var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
                        return String.fromCharCode(surrogate1, surrogate2);
                    } else return String.fromCharCode(code);
                }
                function entityReplacer(a) {
                    var k = a.slice(1, -1);
                    if (Object.hasOwnProperty.call(entityMap, k)) return entityMap[k]; else if (k.charAt(0) === "#") return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x"))); else {
                        errorHandler.error("entity not found:" + a);
                        return a;
                    }
                }
                function appendText(end) {
                    if (end > start) {
                        var xt = source.substring(start, end).replace(/&#?\w+;/g, entityReplacer);
                        locator && position(start);
                        domBuilder.characters(xt, 0, end - start);
                        start = end;
                    }
                }
                function position(p, m) {
                    while (p >= lineEnd && (m = linePattern.exec(source))) {
                        lineStart = m.index;
                        lineEnd = lineStart + m[0].length;
                        locator.lineNumber++;
                    }
                    locator.columnNumber = p - lineStart + 1;
                }
                var lineStart = 0;
                var lineEnd = 0;
                var linePattern = /.*(?:\r\n?|\n)|.*$/g;
                var locator = domBuilder.locator;
                var parseStack = [ {
                    currentNSMap: defaultNSMapCopy
                } ];
                var closeMap = {};
                var start = 0;
                while (true) {
                    try {
                        var tagStart = source.indexOf("<", start);
                        if (tagStart < 0) {
                            if (!source.substr(start).match(/^\s*$/)) {
                                var doc = domBuilder.doc;
                                var text = doc.createTextNode(source.substr(start));
                                doc.appendChild(text);
                                domBuilder.currentElement = text;
                            }
                            return;
                        }
                        if (tagStart > start) appendText(tagStart);
                        switch (source.charAt(tagStart + 1)) {
                          case "/":
                            var end = source.indexOf(">", tagStart + 3);
                            var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
                            var config = parseStack.pop();
                            if (end < 0) {
                                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                                end = tagStart + 1 + tagName.length;
                            } else if (tagName.match(/\s</)) {
                                tagName = tagName.replace(/[\s<].*/, "");
                                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                                end = tagStart + 1 + tagName.length;
                            }
                            var localNSMap = config.localNSMap;
                            var endMatch = config.tagName == tagName;
                            var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
                            if (endIgnoreCaseMach) {
                                domBuilder.endElement(config.uri, config.localName, tagName);
                                if (localNSMap) for (var prefix in localNSMap) if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) domBuilder.endPrefixMapping(prefix);
                                if (!endMatch) errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                            } else parseStack.push(config);
                            end++;
                            break;

                          case "?":
                            locator && position(tagStart);
                            end = parseInstruction(source, tagStart, domBuilder);
                            break;

                          case "!":
                            locator && position(tagStart);
                            end = parseDCC(source, tagStart, domBuilder, errorHandler);
                            break;

                          default:
                            locator && position(tagStart);
                            var el = new ElementAttributes;
                            var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
                            end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
                            var len = el.length;
                            if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                                el.closed = true;
                                if (!entityMap.nbsp) errorHandler.warning("unclosed xml attribute");
                            }
                            if (locator && len) {
                                var locator2 = copyLocator(locator, {});
                                for (var i = 0; i < len; i++) {
                                    var a = el[i];
                                    position(a.offset);
                                    a.locator = copyLocator(locator, {});
                                }
                                domBuilder.locator = locator2;
                                if (appendElement(el, domBuilder, currentNSMap)) parseStack.push(el);
                                domBuilder.locator = locator;
                            } else if (appendElement(el, domBuilder, currentNSMap)) parseStack.push(el);
                            if (NAMESPACE.isHTML(el.uri) && !el.closed) end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder); else end++;
                        }
                    } catch (e) {
                        if (e instanceof ParseError) throw e;
                        errorHandler.error("element parse error: " + e);
                        end = -1;
                    }
                    if (end > start) start = end; else appendText(Math.max(tagStart, start) + 1);
                }
            }
            function copyLocator(f, t) {
                t.lineNumber = f.lineNumber;
                t.columnNumber = f.columnNumber;
                return t;
            }
            function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
                function addAttribute(qname, value, startIndex) {
                    if (el.attributeNames.hasOwnProperty(qname)) errorHandler.fatalError("Attribute " + qname + " redefined");
                    el.addValue(qname, value.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer), startIndex);
                }
                var attrName;
                var p = ++start;
                var s = S_TAG;
                while (true) {
                    var c = source.charAt(p);
                    switch (c) {
                      case "=":
                        if (s === S_ATTR) {
                            attrName = source.slice(start, p);
                            s = S_EQ;
                        } else if (s === S_ATTR_SPACE) s = S_EQ; else throw new Error("attribute equal must after attrName");
                        break;

                      case "'":
                      case '"':
                        if (s === S_EQ || s === S_ATTR) {
                            if (s === S_ATTR) {
                                errorHandler.warning('attribute value must after "="');
                                attrName = source.slice(start, p);
                            }
                            start = p + 1;
                            p = source.indexOf(c, start);
                            if (p > 0) {
                                value = source.slice(start, p);
                                addAttribute(attrName, value, start - 1);
                                s = S_ATTR_END;
                            } else throw new Error("attribute value no end '" + c + "' match");
                        } else if (s == S_ATTR_NOQUOT_VALUE) {
                            value = source.slice(start, p);
                            addAttribute(attrName, value, start);
                            errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
                            start = p + 1;
                            s = S_ATTR_END;
                        } else throw new Error('attribute value must after "="');
                        break;

                      case "/":
                        switch (s) {
                          case S_TAG:
                            el.setTagName(source.slice(start, p));

                          case S_ATTR_END:
                          case S_TAG_SPACE:
                          case S_TAG_CLOSE:
                            s = S_TAG_CLOSE;
                            el.closed = true;

                          case S_ATTR_NOQUOT_VALUE:
                          case S_ATTR:
                            break;

                          case S_ATTR_SPACE:
                            el.closed = true;
                            break;

                          default:
                            throw new Error("attribute invalid close char('/')");
                        }
                        break;

                      case "":
                        errorHandler.error("unexpected end of input");
                        if (s == S_TAG) el.setTagName(source.slice(start, p));
                        return p;

                      case ">":
                        switch (s) {
                          case S_TAG:
                            el.setTagName(source.slice(start, p));

                          case S_ATTR_END:
                          case S_TAG_SPACE:
                          case S_TAG_CLOSE:
                            break;

                          case S_ATTR_NOQUOT_VALUE:
                          case S_ATTR:
                            value = source.slice(start, p);
                            if (value.slice(-1) === "/") {
                                el.closed = true;
                                value = value.slice(0, -1);
                            }

                          case S_ATTR_SPACE:
                            if (s === S_ATTR_SPACE) value = attrName;
                            if (s == S_ATTR_NOQUOT_VALUE) {
                                errorHandler.warning('attribute "' + value + '" missed quot(")!');
                                addAttribute(attrName, value, start);
                            } else {
                                if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                                addAttribute(value, value, start);
                            }
                            break;

                          case S_EQ:
                            throw new Error("attribute value missed!!");
                        }
                        return p;

                      case "¬Ä":
                        c = " ";

                      default:
                        if (c <= " ") switch (s) {
                          case S_TAG:
                            el.setTagName(source.slice(start, p));
                            s = S_TAG_SPACE;
                            break;

                          case S_ATTR:
                            attrName = source.slice(start, p);
                            s = S_ATTR_SPACE;
                            break;

                          case S_ATTR_NOQUOT_VALUE:
                            var value = source.slice(start, p);
                            errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                            addAttribute(attrName, value, start);

                          case S_ATTR_END:
                            s = S_TAG_SPACE;
                            break;
                        } else switch (s) {
                          case S_ATTR_SPACE:
                            el.tagName;
                            if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                            addAttribute(attrName, attrName, start);
                            start = p;
                            s = S_ATTR;
                            break;

                          case S_ATTR_END:
                            errorHandler.warning('attribute space is required"' + attrName + '"!!');

                          case S_TAG_SPACE:
                            s = S_ATTR;
                            start = p;
                            break;

                          case S_EQ:
                            s = S_ATTR_NOQUOT_VALUE;
                            start = p;
                            break;

                          case S_TAG_CLOSE:
                            throw new Error("elements closed character '/' and '>' must be connected to");
                        }
                    }
                    p++;
                }
            }
            function appendElement(el, domBuilder, currentNSMap) {
                var tagName = el.tagName;
                var localNSMap = null;
                var i = el.length;
                while (i--) {
                    var a = el[i];
                    var qName = a.qName;
                    var value = a.value;
                    var nsp = qName.indexOf(":");
                    if (nsp > 0) {
                        var prefix = a.prefix = qName.slice(0, nsp);
                        var localName = qName.slice(nsp + 1);
                        var nsPrefix = prefix === "xmlns" && localName;
                    } else {
                        localName = qName;
                        prefix = null;
                        nsPrefix = qName === "xmlns" && "";
                    }
                    a.localName = localName;
                    if (nsPrefix !== false) {
                        if (localNSMap == null) {
                            localNSMap = {};
                            _copy(currentNSMap, currentNSMap = {});
                        }
                        currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
                        a.uri = NAMESPACE.XMLNS;
                        domBuilder.startPrefixMapping(nsPrefix, value);
                    }
                }
                i = el.length;
                while (i--) {
                    a = el[i];
                    prefix = a.prefix;
                    if (prefix) {
                        if (prefix === "xml") a.uri = NAMESPACE.XML;
                        if (prefix !== "xmlns") a.uri = currentNSMap[prefix || ""];
                    }
                }
                nsp = tagName.indexOf(":");
                if (nsp > 0) {
                    prefix = el.prefix = tagName.slice(0, nsp);
                    localName = el.localName = tagName.slice(nsp + 1);
                } else {
                    prefix = null;
                    localName = el.localName = tagName;
                }
                var ns = el.uri = currentNSMap[prefix || ""];
                domBuilder.startElement(ns, localName, tagName, el);
                if (el.closed) {
                    domBuilder.endElement(ns, localName, tagName);
                    if (localNSMap) for (prefix in localNSMap) if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) domBuilder.endPrefixMapping(prefix);
                } else {
                    el.currentNSMap = currentNSMap;
                    el.localNSMap = localNSMap;
                    return true;
                }
            }
            function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
                if (/^(?:script|textarea)$/i.test(tagName)) {
                    var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
                    var text = source.substring(elStartEnd + 1, elEndStart);
                    if (/[&<]/.test(text)) {
                        if (/^script$/i.test(tagName)) {
                            domBuilder.characters(text, 0, text.length);
                            return elEndStart;
                        }
                        text = text.replace(/&#?\w+;/g, entityReplacer);
                        domBuilder.characters(text, 0, text.length);
                        return elEndStart;
                    }
                }
                return elStartEnd + 1;
            }
            function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
                var pos = closeMap[tagName];
                if (pos == null) {
                    pos = source.lastIndexOf("</" + tagName + ">");
                    if (pos < elStartEnd) pos = source.lastIndexOf("</" + tagName);
                    closeMap[tagName] = pos;
                }
                return pos < elStartEnd;
            }
            function _copy(source, target) {
                for (var n in source) if (Object.prototype.hasOwnProperty.call(source, n)) target[n] = source[n];
            }
            function parseDCC(source, start, domBuilder, errorHandler) {
                var next = source.charAt(start + 2);
                switch (next) {
                  case "-":
                    if (source.charAt(start + 3) === "-") {
                        var end = source.indexOf("--\x3e", start + 4);
                        if (end > start) {
                            domBuilder.comment(source, start + 4, end - start - 4);
                            return end + 3;
                        } else {
                            errorHandler.error("Unclosed comment");
                            return -1;
                        }
                    } else return -1;

                  default:
                    if (source.substr(start + 3, 6) == "CDATA[") {
                        end = source.indexOf("]]>", start + 9);
                        domBuilder.startCDATA();
                        domBuilder.characters(source, start + 9, end - start - 9);
                        domBuilder.endCDATA();
                        return end + 3;
                    }
                    var matchs = split(source, start);
                    var len = matchs.length;
                    if (len > 1 && /!doctype/i.test(matchs[0][0])) {
                        var name = matchs[1][0];
                        var pubid = false;
                        var sysid = false;
                        if (len > 3) if (/^public$/i.test(matchs[2][0])) {
                            pubid = matchs[3][0];
                            sysid = len > 4 && matchs[4][0];
                        } else if (/^system$/i.test(matchs[2][0])) sysid = matchs[3][0];
                        var lastMatch = matchs[len - 1];
                        domBuilder.startDTD(name, pubid, sysid);
                        domBuilder.endDTD();
                        return lastMatch.index + lastMatch[0].length;
                    }
                }
                return -1;
            }
            function parseInstruction(source, start, domBuilder) {
                var end = source.indexOf("?>", start);
                if (end) {
                    var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
                    if (match) {
                        match[0].length;
                        domBuilder.processingInstruction(match[1], match[2]);
                        return end + 2;
                    } else return -1;
                }
                return -1;
            }
            function ElementAttributes() {
                this.attributeNames = {};
            }
            ElementAttributes.prototype = {
                setTagName: function(tagName) {
                    if (!tagNamePattern.test(tagName)) throw new Error("invalid tagName:" + tagName);
                    this.tagName = tagName;
                },
                addValue: function(qName, value, offset) {
                    if (!tagNamePattern.test(qName)) throw new Error("invalid attribute:" + qName);
                    this.attributeNames[qName] = this.length;
                    this[this.length++] = {
                        qName,
                        value,
                        offset
                    };
                },
                length: 0,
                getLocalName: function(i) {
                    return this[i].localName;
                },
                getLocator: function(i) {
                    return this[i].locator;
                },
                getQName: function(i) {
                    return this[i].qName;
                },
                getURI: function(i) {
                    return this[i].uri;
                },
                getValue: function(i) {
                    return this[i].value;
                }
            };
            function split(source, start) {
                var match;
                var buf = [];
                var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
                reg.lastIndex = start;
                reg.exec(source);
                while (match = reg.exec(source)) {
                    buf.push(match);
                    if (match[1]) return buf;
                }
            }
            exports.XMLReader = XMLReader;
            exports.ParseError = ParseError;
        },
        144: (module, __unused_webpack_exports, __webpack_require__) => {
            var topLevel = typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof window !== "undefined" ? window : {};
            var minDoc = __webpack_require__(893);
            var doccy;
            if (typeof document !== "undefined") doccy = document; else {
                doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"];
                if (!doccy) doccy = topLevel["__GLOBAL_DOCUMENT_CACHE@4"] = minDoc;
            }
            module.exports = doccy;
        },
        908: (module, __unused_webpack_exports, __webpack_require__) => {
            var win;
            if (typeof window !== "undefined") win = window; else if (typeof __webpack_require__.g !== "undefined") win = __webpack_require__.g; else if (typeof self !== "undefined") win = self; else win = {};
            module.exports = win;
        },
        376: module => {
            module.exports = isFunction;
            var toString = Object.prototype.toString;
            function isFunction(fn) {
                if (!fn) return false;
                var string = toString.call(fn);
                return string === "[object Function]" || typeof fn === "function" && string !== "[object RegExp]" || typeof window !== "undefined" && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
            }
        },
        537: (module, exports) => {
            function keyCode(searchInput) {
                if (searchInput && "object" === typeof searchInput) {
                    var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
                    if (hasKeyCode) searchInput = hasKeyCode;
                }
                if ("number" === typeof searchInput) return names[searchInput];
                var search = String(searchInput);
                var foundNamedKey = codes[search.toLowerCase()];
                if (foundNamedKey) return foundNamedKey;
                foundNamedKey = aliases[search.toLowerCase()];
                if (foundNamedKey) return foundNamedKey;
                if (search.length === 1) return search.charCodeAt(0);
                return;
            }
            keyCode.isEventKey = function isEventKey(event, nameOrCode) {
                if (event && "object" === typeof event) {
                    var keyCode = event.which || event.keyCode || event.charCode;
                    if (keyCode === null || keyCode === void 0) return false;
                    if (typeof nameOrCode === "string") {
                        var foundNamedKey = codes[nameOrCode.toLowerCase()];
                        if (foundNamedKey) return foundNamedKey === keyCode;
                        foundNamedKey = aliases[nameOrCode.toLowerCase()];
                        if (foundNamedKey) return foundNamedKey === keyCode;
                    } else if (typeof nameOrCode === "number") return nameOrCode === keyCode;
                    return false;
                }
            };
            exports = module.exports = keyCode;
            var codes = exports.code = exports.codes = {
                backspace: 8,
                tab: 9,
                enter: 13,
                shift: 16,
                ctrl: 17,
                alt: 18,
                "pause/break": 19,
                "caps lock": 20,
                esc: 27,
                space: 32,
                "page up": 33,
                "page down": 34,
                end: 35,
                home: 36,
                left: 37,
                up: 38,
                right: 39,
                down: 40,
                insert: 45,
                delete: 46,
                command: 91,
                "left command": 91,
                "right command": 93,
                "numpad *": 106,
                "numpad +": 107,
                "numpad -": 109,
                "numpad .": 110,
                "numpad /": 111,
                "num lock": 144,
                "scroll lock": 145,
                "my computer": 182,
                "my calculator": 183,
                ";": 186,
                "=": 187,
                ",": 188,
                "-": 189,
                ".": 190,
                "/": 191,
                "`": 192,
                "[": 219,
                "\\": 220,
                "]": 221,
                "'": 222
            };
            var aliases = exports.aliases = {
                windows: 91,
                "‚áß": 16,
                "‚å•": 18,
                "‚åÉ": 17,
                "‚åò": 91,
                ctl: 17,
                control: 17,
                option: 18,
                pause: 19,
                break: 19,
                caps: 20,
                return: 13,
                escape: 27,
                spc: 32,
                spacebar: 32,
                pgup: 33,
                pgdn: 34,
                ins: 45,
                del: 46,
                cmd: 91
            };
            /*!
 * Programatically add the following
 */            for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32;
            for (var i = 48; i < 58; i++) codes[i - 48] = i;
            for (i = 1; i < 13; i++) codes["f" + i] = i + 111;
            for (i = 0; i < 10; i++) codes["numpad " + i] = i + 96;
            var names = exports.names = exports.title = {};
            for (i in codes) names[codes[i]] = i;
            for (var alias in aliases) codes[alias] = aliases[alias];
        },
        221: (module, __unused_webpack_exports, __webpack_require__) => {
            var getUint64 = __webpack_require__(894).getUint64;
            var parseSidx = function(data) {
                var view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                    version: data[0],
                    flags: new Uint8Array(data.subarray(1, 4)),
                    references: [],
                    referenceId: view.getUint32(4),
                    timescale: view.getUint32(8)
                }, i = 12;
                if (result.version === 0) {
                    result.earliestPresentationTime = view.getUint32(i);
                    result.firstOffset = view.getUint32(i + 4);
                    i += 8;
                } else {
                    result.earliestPresentationTime = getUint64(data.subarray(i));
                    result.firstOffset = getUint64(data.subarray(i + 8));
                    i += 16;
                }
                i += 2;
                var referenceCount = view.getUint16(i);
                i += 2;
                for (;referenceCount > 0; i += 12, referenceCount--) result.references.push({
                    referenceType: (data[i] & 128) >>> 7,
                    referencedSize: view.getUint32(i) & 2147483647,
                    subsegmentDuration: view.getUint32(i + 4),
                    startsWithSap: !!(data[i + 8] & 128),
                    sapType: (data[i + 8] & 112) >>> 4,
                    sapDeltaTime: view.getUint32(i + 8) & 268435455
                });
                return result;
            };
            module.exports = parseSidx;
        },
        489: module => {
            var secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, audioTsToVideoTs, videoTsToAudioTs, metadataTsToSeconds, ONE_SECOND_IN_TS = 9e4;
            secondsToVideoTs = function(seconds) {
                return seconds * ONE_SECOND_IN_TS;
            };
            secondsToAudioTs = function(seconds, sampleRate) {
                return seconds * sampleRate;
            };
            videoTsToSeconds = function(timestamp) {
                return timestamp / ONE_SECOND_IN_TS;
            };
            audioTsToSeconds = function(timestamp, sampleRate) {
                return timestamp / sampleRate;
            };
            audioTsToVideoTs = function(timestamp, sampleRate) {
                return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
            };
            videoTsToAudioTs = function(timestamp, sampleRate) {
                return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
            };
            metadataTsToSeconds = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
                return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
            };
            module.exports = {
                ONE_SECOND_IN_TS,
                secondsToVideoTs,
                secondsToAudioTs,
                videoTsToSeconds,
                audioTsToSeconds,
                audioTsToVideoTs,
                videoTsToAudioTs,
                metadataTsToSeconds
            };
        },
        894: module => {
            var MAX_UINT32 = Math.pow(2, 32);
            var getUint64 = function(uint8) {
                var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
                var value;
                if (dv.getBigUint64) {
                    value = dv.getBigUint64(0);
                    if (value < Number.MAX_SAFE_INTEGER) return Number(value);
                    return value;
                }
                return dv.getUint32(0) * MAX_UINT32 + dv.getUint32(4);
            };
            module.exports = {
                getUint64,
                MAX_UINT32
            };
        },
        974: module => {
            module.exports = SafeParseTuple;
            function SafeParseTuple(obj, reviver) {
                var json;
                var error = null;
                try {
                    json = JSON.parse(obj, reviver);
                } catch (err) {
                    error = err;
                }
                return [ error, json ];
            }
        },
        945: function(module) {
            (function(root) {
                var URL_REGEX = /^(?=((?:[a-zA-Z0-9+\-.]+:)?))\1(?=((?:\/\/[^\/?#]*)?))\2(?=((?:(?:[^?#\/]*\/)*[^;?#\/]*)?))\3((?:;[^?#]*)?)(\?[^#]*)?(#[^]*)?$/;
                var FIRST_SEGMENT_REGEX = /^(?=([^\/?#]*))\1([^]*)$/;
                var SLASH_DOT_REGEX = /(?:\/|^)\.(?=\/)/g;
                var SLASH_DOT_DOT_REGEX = /(?:\/|^)\.\.\/(?!\.\.\/)[^\/]*(?=\/)/g;
                var URLToolkit = {
                    buildAbsoluteURL: function(baseURL, relativeURL, opts) {
                        opts = opts || {};
                        baseURL = baseURL.trim();
                        relativeURL = relativeURL.trim();
                        if (!relativeURL) {
                            if (!opts.alwaysNormalize) return baseURL;
                            var basePartsForNormalise = URLToolkit.parseURL(baseURL);
                            if (!basePartsForNormalise) throw new Error("Error trying to parse base URL.");
                            basePartsForNormalise.path = URLToolkit.normalizePath(basePartsForNormalise.path);
                            return URLToolkit.buildURLFromParts(basePartsForNormalise);
                        }
                        var relativeParts = URLToolkit.parseURL(relativeURL);
                        if (!relativeParts) throw new Error("Error trying to parse relative URL.");
                        if (relativeParts.scheme) {
                            if (!opts.alwaysNormalize) return relativeURL;
                            relativeParts.path = URLToolkit.normalizePath(relativeParts.path);
                            return URLToolkit.buildURLFromParts(relativeParts);
                        }
                        var baseParts = URLToolkit.parseURL(baseURL);
                        if (!baseParts) throw new Error("Error trying to parse base URL.");
                        if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== "/") {
                            var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);
                            baseParts.netLoc = pathParts[1];
                            baseParts.path = pathParts[2];
                        }
                        if (baseParts.netLoc && !baseParts.path) baseParts.path = "/";
                        var builtParts = {
                            scheme: baseParts.scheme,
                            netLoc: relativeParts.netLoc,
                            path: null,
                            params: relativeParts.params,
                            query: relativeParts.query,
                            fragment: relativeParts.fragment
                        };
                        if (!relativeParts.netLoc) {
                            builtParts.netLoc = baseParts.netLoc;
                            if (relativeParts.path[0] !== "/") if (!relativeParts.path) {
                                builtParts.path = baseParts.path;
                                if (!relativeParts.params) {
                                    builtParts.params = baseParts.params;
                                    if (!relativeParts.query) builtParts.query = baseParts.query;
                                }
                            } else {
                                var baseURLPath = baseParts.path;
                                var newPath = baseURLPath.substring(0, baseURLPath.lastIndexOf("/") + 1) + relativeParts.path;
                                builtParts.path = URLToolkit.normalizePath(newPath);
                            }
                        }
                        if (builtParts.path === null) builtParts.path = opts.alwaysNormalize ? URLToolkit.normalizePath(relativeParts.path) : relativeParts.path;
                        return URLToolkit.buildURLFromParts(builtParts);
                    },
                    parseURL: function(url) {
                        var parts = URL_REGEX.exec(url);
                        if (!parts) return null;
                        return {
                            scheme: parts[1] || "",
                            netLoc: parts[2] || "",
                            path: parts[3] || "",
                            params: parts[4] || "",
                            query: parts[5] || "",
                            fragment: parts[6] || ""
                        };
                    },
                    normalizePath: function(path) {
                        path = path.split("").reverse().join("").replace(SLASH_DOT_REGEX, "");
                        while (path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, "")).length) ;
                        return path.split("").reverse().join("");
                    },
                    buildURLFromParts: function(parts) {
                        return parts.scheme + parts.netLoc + parts.path + parts.params + parts.query + parts.fragment;
                    }
                };
                if (true) module.exports = URLToolkit;
            })();
        },
        732: function(module) {
            !function(n, t) {
                true ? module.exports = t() : 0;
            }(0, (function() {
                "use strict";
                function n() {
                    return n = Object.assign || function(n) {
                        for (var t = 1; t < arguments.length; t++) {
                            var e = arguments[t];
                            for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (n[i] = e[i]);
                        }
                        return n;
                    }, n.apply(this, arguments);
                }
                var t = "undefined" != typeof window, e = t && !("onscroll" in window) || "undefined" != typeof navigator && /(gle|ing|ro)bot|crawl|spider/i.test(navigator.userAgent), i = t && "IntersectionObserver" in window, o = t && "classList" in document.createElement("p"), a = t && window.devicePixelRatio > 1, r = {
                    elements_selector: ".lazy",
                    container: e || t ? document : null,
                    threshold: 300,
                    thresholds: null,
                    data_src: "src",
                    data_srcset: "srcset",
                    data_sizes: "sizes",
                    data_bg: "bg",
                    data_bg_hidpi: "bg-hidpi",
                    data_bg_multi: "bg-multi",
                    data_bg_multi_hidpi: "bg-multi-hidpi",
                    data_bg_set: "bg-set",
                    data_poster: "poster",
                    class_applied: "applied",
                    class_loading: "loading",
                    class_loaded: "loaded",
                    class_error: "error",
                    class_entered: "entered",
                    class_exited: "exited",
                    unobserve_completed: !0,
                    unobserve_entered: !1,
                    cancel_on_exit: !0,
                    callback_enter: null,
                    callback_exit: null,
                    callback_applied: null,
                    callback_loading: null,
                    callback_loaded: null,
                    callback_error: null,
                    callback_finish: null,
                    callback_cancel: null,
                    use_native: !1,
                    restore_on_error: !1
                }, c = function(t) {
                    return n({}, r, t);
                }, l = function(n, t) {
                    var e, i = "LazyLoad::Initialized", o = new n(t);
                    try {
                        e = new CustomEvent(i, {
                            detail: {
                                instance: o
                            }
                        });
                    } catch (n) {
                        (e = document.createEvent("CustomEvent")).initCustomEvent(i, !1, !1, {
                            instance: o
                        });
                    }
                    window.dispatchEvent(e);
                }, u = "src", s = "srcset", d = "sizes", f = "poster", _ = "llOriginalAttrs", g = "data", v = "loading", b = "loaded", m = "applied", p = "error", h = "native", E = "data-", I = "ll-status", y = function(n, t) {
                    return n.getAttribute(E + t);
                }, k = function(n) {
                    return y(n, I);
                }, w = function(n, t) {
                    return function(n, t, e) {
                        var i = "data-ll-status";
                        null !== e ? n.setAttribute(i, e) : n.removeAttribute(i);
                    }(n, 0, t);
                }, A = function(n) {
                    return w(n, null);
                }, L = function(n) {
                    return null === k(n);
                }, O = function(n) {
                    return k(n) === h;
                }, x = [ v, b, m, p ], C = function(n, t, e, i) {
                    n && (void 0 === i ? void 0 === e ? n(t) : n(t, e) : n(t, e, i));
                }, N = function(n, t) {
                    o ? n.classList.add(t) : n.className += (n.className ? " " : "") + t;
                }, M = function(n, t) {
                    o ? n.classList.remove(t) : n.className = n.className.replace(new RegExp("(^|\\s+)" + t + "(\\s+|$)"), " ").replace(/^\s+/, "").replace(/\s+$/, "");
                }, z = function(n) {
                    return n.llTempImage;
                }, T = function(n, t) {
                    if (t) {
                        var e = t._observer;
                        e && e.unobserve(n);
                    }
                }, R = function(n, t) {
                    n && (n.loadingCount += t);
                }, G = function(n, t) {
                    n && (n.toLoadCount = t);
                }, j = function(n) {
                    for (var t, e = [], i = 0; t = n.children[i]; i += 1) "SOURCE" === t.tagName && e.push(t);
                    return e;
                }, D = function(n, t) {
                    var e = n.parentNode;
                    e && "PICTURE" === e.tagName && j(e).forEach(t);
                }, H = function(n, t) {
                    j(n).forEach(t);
                }, V = [ u ], F = [ u, f ], B = [ u, s, d ], J = [ g ], P = function(n) {
                    return !!n[_];
                }, S = function(n) {
                    return n[_];
                }, U = function(n) {
                    return delete n[_];
                }, $ = function(n, t) {
                    if (!P(n)) {
                        var e = {};
                        t.forEach((function(t) {
                            e[t] = n.getAttribute(t);
                        })), n[_] = e;
                    }
                }, q = function(n, t) {
                    if (P(n)) {
                        var e = S(n);
                        t.forEach((function(t) {
                            !function(n, t, e) {
                                e ? n.setAttribute(t, e) : n.removeAttribute(t);
                            }(n, t, e[t]);
                        }));
                    }
                }, K = function(n, t, e) {
                    N(n, t.class_applied), w(n, m), e && (t.unobserve_completed && T(n, t), C(t.callback_applied, n, e));
                }, Q = function(n, t, e) {
                    N(n, t.class_loading), w(n, v), e && (R(e, 1), C(t.callback_loading, n, e));
                }, W = function(n, t, e) {
                    e && n.setAttribute(t, e);
                }, X = function(n, t) {
                    W(n, d, y(n, t.data_sizes)), W(n, s, y(n, t.data_srcset)), W(n, u, y(n, t.data_src));
                }, Y = {
                    IMG: function(n, t) {
                        D(n, (function(n) {
                            $(n, B), X(n, t);
                        })), $(n, B), X(n, t);
                    },
                    IFRAME: function(n, t) {
                        $(n, V), W(n, u, y(n, t.data_src));
                    },
                    VIDEO: function(n, t) {
                        H(n, (function(n) {
                            $(n, V), W(n, u, y(n, t.data_src));
                        })), $(n, F), W(n, f, y(n, t.data_poster)), W(n, u, y(n, t.data_src)), n.load();
                    },
                    OBJECT: function(n, t) {
                        $(n, J), W(n, g, y(n, t.data_src));
                    }
                }, Z = [ "IMG", "IFRAME", "VIDEO", "OBJECT" ], nn = function(n, t) {
                    !t || function(n) {
                        return n.loadingCount > 0;
                    }(t) || function(n) {
                        return n.toLoadCount > 0;
                    }(t) || C(n.callback_finish, t);
                }, tn = function(n, t, e) {
                    n.addEventListener(t, e), n.llEvLisnrs[t] = e;
                }, en = function(n, t, e) {
                    n.removeEventListener(t, e);
                }, on = function(n) {
                    return !!n.llEvLisnrs;
                }, an = function(n) {
                    if (on(n)) {
                        var t = n.llEvLisnrs;
                        for (var e in t) {
                            var i = t[e];
                            en(n, e, i);
                        }
                        delete n.llEvLisnrs;
                    }
                }, rn = function(n, t, e) {
                    !function(n) {
                        delete n.llTempImage;
                    }(n), R(e, -1), function(n) {
                        n && (n.toLoadCount -= 1);
                    }(e), M(n, t.class_loading), t.unobserve_completed && T(n, e);
                }, cn = function(n, t, e) {
                    var i = z(n) || n;
                    on(i) || function(n, t, e) {
                        on(n) || (n.llEvLisnrs = {});
                        var i = "VIDEO" === n.tagName ? "loadeddata" : "load";
                        tn(n, i, t), tn(n, "error", e);
                    }(i, (function(o) {
                        !function(n, t, e, i) {
                            var o = O(t);
                            rn(t, e, i), N(t, e.class_loaded), w(t, b), C(e.callback_loaded, t, i), o || nn(e, i);
                        }(0, n, t, e), an(i);
                    }), (function(o) {
                        !function(n, t, e, i) {
                            var o = O(t);
                            rn(t, e, i), N(t, e.class_error), w(t, p), C(e.callback_error, t, i), e.restore_on_error && q(t, B), 
                            o || nn(e, i);
                        }(0, n, t, e), an(i);
                    }));
                }, ln = function(n, t, e) {
                    !function(n) {
                        return Z.indexOf(n.tagName) > -1;
                    }(n) ? function(n, t, e) {
                        !function(n) {
                            n.llTempImage = document.createElement("IMG");
                        }(n), cn(n, t, e), function(n) {
                            P(n) || (n[_] = {
                                backgroundImage: n.style.backgroundImage
                            });
                        }(n), function(n, t, e) {
                            var i = y(n, t.data_bg), o = y(n, t.data_bg_hidpi), r = a && o ? o : i;
                            r && (n.style.backgroundImage = 'url("'.concat(r, '")'), z(n).setAttribute(u, r), 
                            Q(n, t, e));
                        }(n, t, e), function(n, t, e) {
                            var i = y(n, t.data_bg_multi), o = y(n, t.data_bg_multi_hidpi), r = a && o ? o : i;
                            r && (n.style.backgroundImage = r, K(n, t, e));
                        }(n, t, e), function(n, t, e) {
                            var i = y(n, t.data_bg_set);
                            if (i) {
                                var o = i.split("|"), a = o.map((function(n) {
                                    return "image-set(".concat(n, ")");
                                }));
                                n.style.backgroundImage = a.join(), "" === n.style.backgroundImage && (a = o.map((function(n) {
                                    return "-webkit-image-set(".concat(n, ")");
                                })), n.style.backgroundImage = a.join()), K(n, t, e);
                            }
                        }(n, t, e);
                    }(n, t, e) : function(n, t, e) {
                        cn(n, t, e), function(n, t, e) {
                            var i = Y[n.tagName];
                            i && (i(n, t), Q(n, t, e));
                        }(n, t, e);
                    }(n, t, e);
                }, un = function(n) {
                    n.removeAttribute(u), n.removeAttribute(s), n.removeAttribute(d);
                }, sn = function(n) {
                    D(n, (function(n) {
                        q(n, B);
                    })), q(n, B);
                }, dn = {
                    IMG: sn,
                    IFRAME: function(n) {
                        q(n, V);
                    },
                    VIDEO: function(n) {
                        H(n, (function(n) {
                            q(n, V);
                        })), q(n, F), n.load();
                    },
                    OBJECT: function(n) {
                        q(n, J);
                    }
                }, fn = function(n, t) {
                    (function(n) {
                        var t = dn[n.tagName];
                        t ? t(n) : function(n) {
                            if (P(n)) {
                                var t = S(n);
                                n.style.backgroundImage = t.backgroundImage;
                            }
                        }(n);
                    })(n), function(n, t) {
                        L(n) || O(n) || (M(n, t.class_entered), M(n, t.class_exited), M(n, t.class_applied), 
                        M(n, t.class_loading), M(n, t.class_loaded), M(n, t.class_error));
                    }(n, t), A(n), U(n);
                }, _n = [ "IMG", "IFRAME", "VIDEO" ], gn = function(n) {
                    return n.use_native && "loading" in HTMLImageElement.prototype;
                }, vn = function(n, t, e) {
                    n.forEach((function(n) {
                        return function(n) {
                            return n.isIntersecting || n.intersectionRatio > 0;
                        }(n) ? function(n, t, e, i) {
                            var o = function(n) {
                                return x.indexOf(k(n)) >= 0;
                            }(n);
                            w(n, "entered"), N(n, e.class_entered), M(n, e.class_exited), function(n, t, e) {
                                t.unobserve_entered && T(n, e);
                            }(n, e, i), C(e.callback_enter, n, t, i), o || ln(n, e, i);
                        }(n.target, n, t, e) : function(n, t, e, i) {
                            L(n) || (N(n, e.class_exited), function(n, t, e, i) {
                                e.cancel_on_exit && function(n) {
                                    return k(n) === v;
                                }(n) && "IMG" === n.tagName && (an(n), function(n) {
                                    D(n, (function(n) {
                                        un(n);
                                    })), un(n);
                                }(n), sn(n), M(n, e.class_loading), R(i, -1), A(n), C(e.callback_cancel, n, t, i));
                            }(n, t, e, i), C(e.callback_exit, n, t, i));
                        }(n.target, n, t, e);
                    }));
                }, bn = function(n) {
                    return Array.prototype.slice.call(n);
                }, mn = function(n) {
                    return n.container.querySelectorAll(n.elements_selector);
                }, pn = function(n) {
                    return function(n) {
                        return k(n) === p;
                    }(n);
                }, hn = function(n, t) {
                    return function(n) {
                        return bn(n).filter(L);
                    }(n || mn(t));
                }, En = function(n, e) {
                    var o = c(n);
                    this._settings = o, this.loadingCount = 0, function(n, t) {
                        i && !gn(n) && (t._observer = new IntersectionObserver((function(e) {
                            vn(e, n, t);
                        }), function(n) {
                            return {
                                root: n.container === document ? null : n.container,
                                rootMargin: n.thresholds || n.threshold + "px"
                            };
                        }(n)));
                    }(o, this), function(n, e) {
                        t && (e._onlineHandler = function() {
                            !function(n, t) {
                                var e;
                                (e = mn(n), bn(e).filter(pn)).forEach((function(t) {
                                    M(t, n.class_error), A(t);
                                })), t.update();
                            }(n, e);
                        }, window.addEventListener("online", e._onlineHandler));
                    }(o, this), this.update(e);
                };
                return En.prototype = {
                    update: function(n) {
                        var t, o, a = this._settings, r = hn(n, a);
                        G(this, r.length), !e && i ? gn(a) ? function(n, t, e) {
                            n.forEach((function(n) {
                                -1 !== _n.indexOf(n.tagName) && function(n, t, e) {
                                    n.setAttribute("loading", "lazy"), cn(n, t, e), function(n, t) {
                                        var e = Y[n.tagName];
                                        e && e(n, t);
                                    }(n, t), w(n, h);
                                }(n, t, e);
                            })), G(e, 0);
                        }(r, a, this) : (o = r, function(n) {
                            n.disconnect();
                        }(t = this._observer), function(n, t) {
                            t.forEach((function(t) {
                                n.observe(t);
                            }));
                        }(t, o)) : this.loadAll(r);
                    },
                    destroy: function() {
                        this._observer && this._observer.disconnect(), t && window.removeEventListener("online", this._onlineHandler), 
                        mn(this._settings).forEach((function(n) {
                            U(n);
                        })), delete this._observer, delete this._settings, delete this._onlineHandler, delete this.loadingCount, 
                        delete this.toLoadCount;
                    },
                    loadAll: function(n) {
                        var t = this, e = this._settings;
                        hn(n, e).forEach((function(n) {
                            T(n, t), ln(n, e, t);
                        }));
                    },
                    restoreAll: function() {
                        var n = this._settings;
                        mn(n).forEach((function(t) {
                            fn(t, n);
                        }));
                    }
                }, En.load = function(n, t) {
                    var e = c(t);
                    ln(n, e);
                }, En.resetStatus = function(n) {
                    A(n);
                }, t && function(n, t) {
                    if (t) if (t.length) for (var e, i = 0; e = t[i]; i += 1) l(n, e); else l(n, t);
                }(En, window.lazyLoadOptions), En;
            }));
        },
        407: (module, __unused_webpack_exports, __webpack_require__) => {
            var window = __webpack_require__(908);
            var vttjs = module.exports = {
                WebVTT: __webpack_require__(706),
                VTTCue: __webpack_require__(230),
                VTTRegion: __webpack_require__(710)
            };
            window.vttjs = vttjs;
            window.WebVTT = vttjs.WebVTT;
            var cueShim = vttjs.VTTCue;
            var regionShim = vttjs.VTTRegion;
            var nativeVTTCue = window.VTTCue;
            var nativeVTTRegion = window.VTTRegion;
            vttjs.shim = function() {
                window.VTTCue = cueShim;
                window.VTTRegion = regionShim;
            };
            vttjs.restore = function() {
                window.VTTCue = nativeVTTCue;
                window.VTTRegion = nativeVTTRegion;
            };
            if (!window.VTTCue) vttjs.shim();
        },
        706: (module, __unused_webpack_exports, __webpack_require__) => {
            var document = __webpack_require__(144);
            var _objCreate = Object.create || function() {
                function F() {}
                return function(o) {
                    if (arguments.length !== 1) throw new Error("Object.create shim only accepts one parameter.");
                    F.prototype = o;
                    return new F;
                };
            }();
            function ParsingError(errorData, message) {
                this.name = "ParsingError";
                this.code = errorData.code;
                this.message = message || errorData.message;
            }
            ParsingError.prototype = _objCreate(Error.prototype);
            ParsingError.prototype.constructor = ParsingError;
            ParsingError.Errors = {
                BadSignature: {
                    code: 0,
                    message: "Malformed WebVTT signature."
                },
                BadTimeStamp: {
                    code: 1,
                    message: "Malformed time stamp."
                }
            };
            function parseTimeStamp(input) {
                function computeSeconds(h, m, s, f) {
                    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + (f | 0) / 1e3;
                }
                var m = input.match(/^(\d+):(\d{1,2})(:\d{1,2})?\.(\d{3})/);
                if (!m) return null;
                if (m[3]) return computeSeconds(m[1], m[2], m[3].replace(":", ""), m[4]); else if (m[1] > 59) return computeSeconds(m[1], m[2], 0, m[4]); else return computeSeconds(0, m[1], m[2], m[4]);
            }
            function Settings() {
                this.values = _objCreate(null);
            }
            Settings.prototype = {
                set: function(k, v) {
                    if (!this.get(k) && v !== "") this.values[k] = v;
                },
                get: function(k, dflt, defaultKey) {
                    if (defaultKey) return this.has(k) ? this.values[k] : dflt[defaultKey];
                    return this.has(k) ? this.values[k] : dflt;
                },
                has: function(k) {
                    return k in this.values;
                },
                alt: function(k, v, a) {
                    for (var n = 0; n < a.length; ++n) if (v === a[n]) {
                        this.set(k, v);
                        break;
                    }
                },
                integer: function(k, v) {
                    if (/^-?\d+$/.test(v)) this.set(k, parseInt(v, 10));
                },
                percent: function(k, v) {
                    if (v.match(/^([\d]{1,3})(\.[\d]*)?%$/)) {
                        v = parseFloat(v);
                        if (v >= 0 && v <= 100) {
                            this.set(k, v);
                            return true;
                        }
                    }
                    return false;
                }
            };
            function parseOptions(input, callback, keyValueDelim, groupDelim) {
                var groups = groupDelim ? input.split(groupDelim) : [ input ];
                for (var i in groups) {
                    if (typeof groups[i] !== "string") continue;
                    var kv = groups[i].split(keyValueDelim);
                    if (kv.length !== 2) continue;
                    var k = kv[0].trim();
                    var v = kv[1].trim();
                    callback(k, v);
                }
            }
            function parseCue(input, cue, regionList) {
                var oInput = input;
                function consumeTimeStamp() {
                    var ts = parseTimeStamp(input);
                    if (ts === null) throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed timestamp: " + oInput);
                    input = input.replace(/^[^\sa-zA-Z-]+/, "");
                    return ts;
                }
                function consumeCueSettings(input, cue) {
                    var settings = new Settings;
                    parseOptions(input, (function(k, v) {
                        switch (k) {
                          case "region":
                            for (var i = regionList.length - 1; i >= 0; i--) if (regionList[i].id === v) {
                                settings.set(k, regionList[i].region);
                                break;
                            }
                            break;

                          case "vertical":
                            settings.alt(k, v, [ "rl", "lr" ]);
                            break;

                          case "line":
                            var vals = v.split(","), vals0 = vals[0];
                            settings.integer(k, vals0);
                            settings.percent(k, vals0) ? settings.set("snapToLines", false) : null;
                            settings.alt(k, vals0, [ "auto" ]);
                            if (vals.length === 2) settings.alt("lineAlign", vals[1], [ "start", "center", "end" ]);
                            break;

                          case "position":
                            vals = v.split(",");
                            settings.percent(k, vals[0]);
                            if (vals.length === 2) settings.alt("positionAlign", vals[1], [ "start", "center", "end" ]);
                            break;

                          case "size":
                            settings.percent(k, v);
                            break;

                          case "align":
                            settings.alt(k, v, [ "start", "center", "end", "left", "right" ]);
                            break;
                        }
                    }), /:/, /\s/);
                    cue.region = settings.get("region", null);
                    cue.vertical = settings.get("vertical", "");
                    try {
                        cue.line = settings.get("line", "auto");
                    } catch (e) {}
                    cue.lineAlign = settings.get("lineAlign", "start");
                    cue.snapToLines = settings.get("snapToLines", true);
                    cue.size = settings.get("size", 100);
                    try {
                        cue.align = settings.get("align", "center");
                    } catch (e) {
                        cue.align = settings.get("align", "middle");
                    }
                    try {
                        cue.position = settings.get("position", "auto");
                    } catch (e) {
                        cue.position = settings.get("position", {
                            start: 0,
                            left: 0,
                            center: 50,
                            middle: 50,
                            end: 100,
                            right: 100
                        }, cue.align);
                    }
                    cue.positionAlign = settings.get("positionAlign", {
                        start: "start",
                        left: "start",
                        center: "center",
                        middle: "center",
                        end: "end",
                        right: "end"
                    }, cue.align);
                }
                function skipWhitespace() {
                    input = input.replace(/^\s+/, "");
                }
                skipWhitespace();
                cue.startTime = consumeTimeStamp();
                skipWhitespace();
                if (input.substr(0, 3) !== "--\x3e") throw new ParsingError(ParsingError.Errors.BadTimeStamp, "Malformed time stamp (time stamps must be separated by '--\x3e'): " + oInput);
                input = input.substr(3);
                skipWhitespace();
                cue.endTime = consumeTimeStamp();
                skipWhitespace();
                consumeCueSettings(input, cue);
            }
            var TEXTAREA_ELEMENT = document.createElement && document.createElement("textarea");
            var TAG_NAME = {
                c: "span",
                i: "i",
                b: "b",
                u: "u",
                ruby: "ruby",
                rt: "rt",
                v: "span",
                lang: "span"
            };
            var DEFAULT_COLOR_CLASS = {
                white: "rgba(255,255,255,1)",
                lime: "rgba(0,255,0,1)",
                cyan: "rgba(0,255,255,1)",
                red: "rgba(255,0,0,1)",
                yellow: "rgba(255,255,0,1)",
                magenta: "rgba(255,0,255,1)",
                blue: "rgba(0,0,255,1)",
                black: "rgba(0,0,0,1)"
            };
            var TAG_ANNOTATION = {
                v: "title",
                lang: "lang"
            };
            var NEEDS_PARENT = {
                rt: "ruby"
            };
            function parseContent(window, input) {
                function nextToken() {
                    if (!input) return null;
                    function consume(result) {
                        input = input.substr(result.length);
                        return result;
                    }
                    var m = input.match(/^([^<]*)(<[^>]*>?)?/);
                    return consume(m[1] ? m[1] : m[2]);
                }
                function unescape(s) {
                    TEXTAREA_ELEMENT.innerHTML = s;
                    s = TEXTAREA_ELEMENT.textContent;
                    TEXTAREA_ELEMENT.textContent = "";
                    return s;
                }
                function shouldAdd(current, element) {
                    return !NEEDS_PARENT[element.localName] || NEEDS_PARENT[element.localName] === current.localName;
                }
                function createElement(type, annotation) {
                    var tagName = TAG_NAME[type];
                    if (!tagName) return null;
                    var element = window.document.createElement(tagName);
                    var name = TAG_ANNOTATION[type];
                    if (name && annotation) element[name] = annotation.trim();
                    return element;
                }
                var t, rootDiv = window.document.createElement("div"), current = rootDiv, tagStack = [];
                while ((t = nextToken()) !== null) {
                    if (t[0] === "<") {
                        if (t[1] === "/") {
                            if (tagStack.length && tagStack[tagStack.length - 1] === t.substr(2).replace(">", "")) {
                                tagStack.pop();
                                current = current.parentNode;
                            }
                            continue;
                        }
                        var ts = parseTimeStamp(t.substr(1, t.length - 2));
                        var node;
                        if (ts) {
                            node = window.document.createProcessingInstruction("timestamp", ts);
                            current.appendChild(node);
                            continue;
                        }
                        var m = t.match(/^<([^.\s/0-9>]+)(\.[^\s\\>]+)?([^>\\]+)?(\\?)>?$/);
                        if (!m) continue;
                        node = createElement(m[1], m[3]);
                        if (!node) continue;
                        if (!shouldAdd(current, node)) continue;
                        if (m[2]) {
                            var classes = m[2].split(".");
                            classes.forEach((function(cl) {
                                var bgColor = /^bg_/.test(cl);
                                var colorName = bgColor ? cl.slice(3) : cl;
                                if (DEFAULT_COLOR_CLASS.hasOwnProperty(colorName)) {
                                    var propName = bgColor ? "background-color" : "color";
                                    var propValue = DEFAULT_COLOR_CLASS[colorName];
                                    node.style[propName] = propValue;
                                }
                            }));
                            node.className = classes.join(" ");
                        }
                        tagStack.push(m[1]);
                        current.appendChild(node);
                        current = node;
                        continue;
                    }
                    current.appendChild(window.document.createTextNode(unescape(t)));
                }
                return rootDiv;
            }
            var strongRTLRanges = [ [ 1470, 1470 ], [ 1472, 1472 ], [ 1475, 1475 ], [ 1478, 1478 ], [ 1488, 1514 ], [ 1520, 1524 ], [ 1544, 1544 ], [ 1547, 1547 ], [ 1549, 1549 ], [ 1563, 1563 ], [ 1566, 1610 ], [ 1645, 1647 ], [ 1649, 1749 ], [ 1765, 1766 ], [ 1774, 1775 ], [ 1786, 1805 ], [ 1807, 1808 ], [ 1810, 1839 ], [ 1869, 1957 ], [ 1969, 1969 ], [ 1984, 2026 ], [ 2036, 2037 ], [ 2042, 2042 ], [ 2048, 2069 ], [ 2074, 2074 ], [ 2084, 2084 ], [ 2088, 2088 ], [ 2096, 2110 ], [ 2112, 2136 ], [ 2142, 2142 ], [ 2208, 2208 ], [ 2210, 2220 ], [ 8207, 8207 ], [ 64285, 64285 ], [ 64287, 64296 ], [ 64298, 64310 ], [ 64312, 64316 ], [ 64318, 64318 ], [ 64320, 64321 ], [ 64323, 64324 ], [ 64326, 64449 ], [ 64467, 64829 ], [ 64848, 64911 ], [ 64914, 64967 ], [ 65008, 65020 ], [ 65136, 65140 ], [ 65142, 65276 ], [ 67584, 67589 ], [ 67592, 67592 ], [ 67594, 67637 ], [ 67639, 67640 ], [ 67644, 67644 ], [ 67647, 67669 ], [ 67671, 67679 ], [ 67840, 67867 ], [ 67872, 67897 ], [ 67903, 67903 ], [ 67968, 68023 ], [ 68030, 68031 ], [ 68096, 68096 ], [ 68112, 68115 ], [ 68117, 68119 ], [ 68121, 68147 ], [ 68160, 68167 ], [ 68176, 68184 ], [ 68192, 68223 ], [ 68352, 68405 ], [ 68416, 68437 ], [ 68440, 68466 ], [ 68472, 68479 ], [ 68608, 68680 ], [ 126464, 126467 ], [ 126469, 126495 ], [ 126497, 126498 ], [ 126500, 126500 ], [ 126503, 126503 ], [ 126505, 126514 ], [ 126516, 126519 ], [ 126521, 126521 ], [ 126523, 126523 ], [ 126530, 126530 ], [ 126535, 126535 ], [ 126537, 126537 ], [ 126539, 126539 ], [ 126541, 126543 ], [ 126545, 126546 ], [ 126548, 126548 ], [ 126551, 126551 ], [ 126553, 126553 ], [ 126555, 126555 ], [ 126557, 126557 ], [ 126559, 126559 ], [ 126561, 126562 ], [ 126564, 126564 ], [ 126567, 126570 ], [ 126572, 126578 ], [ 126580, 126583 ], [ 126585, 126588 ], [ 126590, 126590 ], [ 126592, 126601 ], [ 126603, 126619 ], [ 126625, 126627 ], [ 126629, 126633 ], [ 126635, 126651 ], [ 1114109, 1114109 ] ];
            function isStrongRTLChar(charCode) {
                for (var i = 0; i < strongRTLRanges.length; i++) {
                    var currentRange = strongRTLRanges[i];
                    if (charCode >= currentRange[0] && charCode <= currentRange[1]) return true;
                }
                return false;
            }
            function determineBidi(cueDiv) {
                var charCode, nodeStack = [], text = "";
                if (!cueDiv || !cueDiv.childNodes) return "ltr";
                function pushNodes(nodeStack, node) {
                    for (var i = node.childNodes.length - 1; i >= 0; i--) nodeStack.push(node.childNodes[i]);
                }
                function nextTextNode(nodeStack) {
                    if (!nodeStack || !nodeStack.length) return null;
                    var node = nodeStack.pop(), text = node.textContent || node.innerText;
                    if (text) {
                        var m = text.match(/^.*(\n|\r)/);
                        if (m) {
                            nodeStack.length = 0;
                            return m[0];
                        }
                        return text;
                    }
                    if (node.tagName === "ruby") return nextTextNode(nodeStack);
                    if (node.childNodes) {
                        pushNodes(nodeStack, node);
                        return nextTextNode(nodeStack);
                    }
                }
                pushNodes(nodeStack, cueDiv);
                while (text = nextTextNode(nodeStack)) for (var i = 0; i < text.length; i++) {
                    charCode = text.charCodeAt(i);
                    if (isStrongRTLChar(charCode)) return "rtl";
                }
                return "ltr";
            }
            function computeLinePos(cue) {
                if (typeof cue.line === "number" && (cue.snapToLines || cue.line >= 0 && cue.line <= 100)) return cue.line;
                if (!cue.track || !cue.track.textTrackList || !cue.track.textTrackList.mediaElement) return -1;
                var track = cue.track, trackList = track.textTrackList, count = 0;
                for (var i = 0; i < trackList.length && trackList[i] !== track; i++) if (trackList[i].mode === "showing") count++;
                return ++count * -1;
            }
            function StyleBox() {}
            StyleBox.prototype.applyStyles = function(styles, div) {
                div = div || this.div;
                for (var prop in styles) if (styles.hasOwnProperty(prop)) div.style[prop] = styles[prop];
            };
            StyleBox.prototype.formatStyle = function(val, unit) {
                return val === 0 ? 0 : val + unit;
            };
            function CueStyleBox(window, cue, styleOptions) {
                StyleBox.call(this);
                this.cue = cue;
                this.cueDiv = parseContent(window, cue.text);
                var styles = {
                    color: "rgba(255, 255, 255, 1)",
                    backgroundColor: "rgba(0, 0, 0, 0.8)",
                    position: "relative",
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0,
                    display: "inline",
                    writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
                    unicodeBidi: "plaintext"
                };
                this.applyStyles(styles, this.cueDiv);
                this.div = window.document.createElement("div");
                styles = {
                    direction: determineBidi(this.cueDiv),
                    writingMode: cue.vertical === "" ? "horizontal-tb" : cue.vertical === "lr" ? "vertical-lr" : "vertical-rl",
                    unicodeBidi: "plaintext",
                    textAlign: cue.align === "middle" ? "center" : cue.align,
                    font: styleOptions.font,
                    whiteSpace: "pre-line",
                    position: "absolute"
                };
                this.applyStyles(styles);
                this.div.appendChild(this.cueDiv);
                var textPos = 0;
                switch (cue.positionAlign) {
                  case "start":
                    textPos = cue.position;
                    break;

                  case "center":
                    textPos = cue.position - cue.size / 2;
                    break;

                  case "end":
                    textPos = cue.position - cue.size;
                    break;
                }
                if (cue.vertical === "") this.applyStyles({
                    left: this.formatStyle(textPos, "%"),
                    width: this.formatStyle(cue.size, "%")
                }); else this.applyStyles({
                    top: this.formatStyle(textPos, "%"),
                    height: this.formatStyle(cue.size, "%")
                });
                this.move = function(box) {
                    this.applyStyles({
                        top: this.formatStyle(box.top, "px"),
                        bottom: this.formatStyle(box.bottom, "px"),
                        left: this.formatStyle(box.left, "px"),
                        right: this.formatStyle(box.right, "px"),
                        height: this.formatStyle(box.height, "px"),
                        width: this.formatStyle(box.width, "px")
                    });
                };
            }
            CueStyleBox.prototype = _objCreate(StyleBox.prototype);
            CueStyleBox.prototype.constructor = CueStyleBox;
            function BoxPosition(obj) {
                var lh, height, width, top;
                if (obj.div) {
                    height = obj.div.offsetHeight;
                    width = obj.div.offsetWidth;
                    top = obj.div.offsetTop;
                    var rects = (rects = obj.div.childNodes) && (rects = rects[0]) && rects.getClientRects && rects.getClientRects();
                    obj = obj.div.getBoundingClientRect();
                    lh = rects ? Math.max(rects[0] && rects[0].height || 0, obj.height / rects.length) : 0;
                }
                this.left = obj.left;
                this.right = obj.right;
                this.top = obj.top || top;
                this.height = obj.height || height;
                this.bottom = obj.bottom || top + (obj.height || height);
                this.width = obj.width || width;
                this.lineHeight = lh !== void 0 ? lh : obj.lineHeight;
            }
            BoxPosition.prototype.move = function(axis, toMove) {
                toMove = toMove !== void 0 ? toMove : this.lineHeight;
                switch (axis) {
                  case "+x":
                    this.left += toMove;
                    this.right += toMove;
                    break;

                  case "-x":
                    this.left -= toMove;
                    this.right -= toMove;
                    break;

                  case "+y":
                    this.top += toMove;
                    this.bottom += toMove;
                    break;

                  case "-y":
                    this.top -= toMove;
                    this.bottom -= toMove;
                    break;
                }
            };
            BoxPosition.prototype.overlaps = function(b2) {
                return this.left < b2.right && this.right > b2.left && this.top < b2.bottom && this.bottom > b2.top;
            };
            BoxPosition.prototype.overlapsAny = function(boxes) {
                for (var i = 0; i < boxes.length; i++) if (this.overlaps(boxes[i])) return true;
                return false;
            };
            BoxPosition.prototype.within = function(container) {
                return this.top >= container.top && this.bottom <= container.bottom && this.left >= container.left && this.right <= container.right;
            };
            BoxPosition.prototype.overlapsOppositeAxis = function(container, axis) {
                switch (axis) {
                  case "+x":
                    return this.left < container.left;

                  case "-x":
                    return this.right > container.right;

                  case "+y":
                    return this.top < container.top;

                  case "-y":
                    return this.bottom > container.bottom;
                }
            };
            BoxPosition.prototype.intersectPercentage = function(b2) {
                var x = Math.max(0, Math.min(this.right, b2.right) - Math.max(this.left, b2.left)), y = Math.max(0, Math.min(this.bottom, b2.bottom) - Math.max(this.top, b2.top)), intersectArea = x * y;
                return intersectArea / (this.height * this.width);
            };
            BoxPosition.prototype.toCSSCompatValues = function(reference) {
                return {
                    top: this.top - reference.top,
                    bottom: reference.bottom - this.bottom,
                    left: this.left - reference.left,
                    right: reference.right - this.right,
                    height: this.height,
                    width: this.width
                };
            };
            BoxPosition.getSimpleBoxPosition = function(obj) {
                var height = obj.div ? obj.div.offsetHeight : obj.tagName ? obj.offsetHeight : 0;
                var width = obj.div ? obj.div.offsetWidth : obj.tagName ? obj.offsetWidth : 0;
                var top = obj.div ? obj.div.offsetTop : obj.tagName ? obj.offsetTop : 0;
                obj = obj.div ? obj.div.getBoundingClientRect() : obj.tagName ? obj.getBoundingClientRect() : obj;
                var ret = {
                    left: obj.left,
                    right: obj.right,
                    top: obj.top || top,
                    height: obj.height || height,
                    bottom: obj.bottom || top + (obj.height || height),
                    width: obj.width || width
                };
                return ret;
            };
            function moveBoxToLinePosition(window, styleBox, containerBox, boxPositions) {
                function findBestPosition(b, axis) {
                    var bestPosition, specifiedPosition = new BoxPosition(b), percentage = 1;
                    for (var i = 0; i < axis.length; i++) {
                        while (b.overlapsOppositeAxis(containerBox, axis[i]) || b.within(containerBox) && b.overlapsAny(boxPositions)) b.move(axis[i]);
                        if (b.within(containerBox)) return b;
                        var p = b.intersectPercentage(containerBox);
                        if (percentage > p) {
                            bestPosition = new BoxPosition(b);
                            percentage = p;
                        }
                        b = new BoxPosition(specifiedPosition);
                    }
                    return bestPosition || specifiedPosition;
                }
                var boxPosition = new BoxPosition(styleBox), cue = styleBox.cue, linePos = computeLinePos(cue), axis = [];
                if (cue.snapToLines) {
                    var size;
                    switch (cue.vertical) {
                      case "":
                        axis = [ "+y", "-y" ];
                        size = "height";
                        break;

                      case "rl":
                        axis = [ "+x", "-x" ];
                        size = "width";
                        break;

                      case "lr":
                        axis = [ "-x", "+x" ];
                        size = "width";
                        break;
                    }
                    var step = boxPosition.lineHeight, position = step * Math.round(linePos), maxPosition = containerBox[size] + step, initialAxis = axis[0];
                    if (Math.abs(position) > maxPosition) {
                        position = position < 0 ? -1 : 1;
                        position *= Math.ceil(maxPosition / step) * step;
                    }
                    if (linePos < 0) {
                        position += cue.vertical === "" ? containerBox.height : containerBox.width;
                        axis = axis.reverse();
                    }
                    boxPosition.move(initialAxis, position);
                } else {
                    var calculatedPercentage = boxPosition.lineHeight / containerBox.height * 100;
                    switch (cue.lineAlign) {
                      case "center":
                        linePos -= calculatedPercentage / 2;
                        break;

                      case "end":
                        linePos -= calculatedPercentage;
                        break;
                    }
                    switch (cue.vertical) {
                      case "":
                        styleBox.applyStyles({
                            top: styleBox.formatStyle(linePos, "%")
                        });
                        break;

                      case "rl":
                        styleBox.applyStyles({
                            left: styleBox.formatStyle(linePos, "%")
                        });
                        break;

                      case "lr":
                        styleBox.applyStyles({
                            right: styleBox.formatStyle(linePos, "%")
                        });
                        break;
                    }
                    axis = [ "+y", "-x", "+x", "-y" ];
                    boxPosition = new BoxPosition(styleBox);
                }
                var bestPosition = findBestPosition(boxPosition, axis);
                styleBox.move(bestPosition.toCSSCompatValues(containerBox));
            }
            function WebVTT() {}
            WebVTT.StringDecoder = function() {
                return {
                    decode: function(data) {
                        if (!data) return "";
                        if (typeof data !== "string") throw new Error("Error - expected string data.");
                        return decodeURIComponent(encodeURIComponent(data));
                    }
                };
            };
            WebVTT.convertCueToDOMTree = function(window, cuetext) {
                if (!window || !cuetext) return null;
                return parseContent(window, cuetext);
            };
            var FONT_SIZE_PERCENT = .05;
            var FONT_STYLE = "sans-serif";
            var CUE_BACKGROUND_PADDING = "1.5%";
            WebVTT.processCues = function(window, cues, overlay) {
                if (!window || !cues || !overlay) return null;
                while (overlay.firstChild) overlay.removeChild(overlay.firstChild);
                var paddedOverlay = window.document.createElement("div");
                paddedOverlay.style.position = "absolute";
                paddedOverlay.style.left = "0";
                paddedOverlay.style.right = "0";
                paddedOverlay.style.top = "0";
                paddedOverlay.style.bottom = "0";
                paddedOverlay.style.margin = CUE_BACKGROUND_PADDING;
                overlay.appendChild(paddedOverlay);
                function shouldCompute(cues) {
                    for (var i = 0; i < cues.length; i++) if (cues[i].hasBeenReset || !cues[i].displayState) return true;
                    return false;
                }
                if (!shouldCompute(cues)) {
                    for (var i = 0; i < cues.length; i++) paddedOverlay.appendChild(cues[i].displayState);
                    return;
                }
                var boxPositions = [], containerBox = BoxPosition.getSimpleBoxPosition(paddedOverlay), fontSize = Math.round(containerBox.height * FONT_SIZE_PERCENT * 100) / 100;
                var styleOptions = {
                    font: fontSize + "px " + FONT_STYLE
                };
                (function() {
                    var styleBox, cue;
                    for (var i = 0; i < cues.length; i++) {
                        cue = cues[i];
                        styleBox = new CueStyleBox(window, cue, styleOptions);
                        paddedOverlay.appendChild(styleBox.div);
                        moveBoxToLinePosition(window, styleBox, containerBox, boxPositions);
                        cue.displayState = styleBox.div;
                        boxPositions.push(BoxPosition.getSimpleBoxPosition(styleBox));
                    }
                })();
            };
            WebVTT.Parser = function(window, vttjs, decoder) {
                if (!decoder) {
                    decoder = vttjs;
                    vttjs = {};
                }
                if (!vttjs) vttjs = {};
                this.window = window;
                this.vttjs = vttjs;
                this.state = "INITIAL";
                this.buffer = "";
                this.decoder = decoder || new TextDecoder("utf8");
                this.regionList = [];
            };
            WebVTT.Parser.prototype = {
                reportOrThrowError: function(e) {
                    if (e instanceof ParsingError) this.onparsingerror && this.onparsingerror(e); else throw e;
                },
                parse: function(data) {
                    var self = this;
                    if (data) self.buffer += self.decoder.decode(data, {
                        stream: true
                    });
                    function collectNextLine() {
                        var buffer = self.buffer;
                        var pos = 0;
                        while (pos < buffer.length && buffer[pos] !== "\r" && buffer[pos] !== "\n") ++pos;
                        var line = buffer.substr(0, pos);
                        if (buffer[pos] === "\r") ++pos;
                        if (buffer[pos] === "\n") ++pos;
                        self.buffer = buffer.substr(pos);
                        return line;
                    }
                    function parseRegion(input) {
                        var settings = new Settings;
                        parseOptions(input, (function(k, v) {
                            switch (k) {
                              case "id":
                                settings.set(k, v);
                                break;

                              case "width":
                                settings.percent(k, v);
                                break;

                              case "lines":
                                settings.integer(k, v);
                                break;

                              case "regionanchor":
                              case "viewportanchor":
                                var xy = v.split(",");
                                if (xy.length !== 2) break;
                                var anchor = new Settings;
                                anchor.percent("x", xy[0]);
                                anchor.percent("y", xy[1]);
                                if (!anchor.has("x") || !anchor.has("y")) break;
                                settings.set(k + "X", anchor.get("x"));
                                settings.set(k + "Y", anchor.get("y"));
                                break;

                              case "scroll":
                                settings.alt(k, v, [ "up" ]);
                                break;
                            }
                        }), /=/, /\s/);
                        if (settings.has("id")) {
                            var region = new (self.vttjs.VTTRegion || self.window.VTTRegion);
                            region.width = settings.get("width", 100);
                            region.lines = settings.get("lines", 3);
                            region.regionAnchorX = settings.get("regionanchorX", 0);
                            region.regionAnchorY = settings.get("regionanchorY", 100);
                            region.viewportAnchorX = settings.get("viewportanchorX", 0);
                            region.viewportAnchorY = settings.get("viewportanchorY", 100);
                            region.scroll = settings.get("scroll", "");
                            self.onregion && self.onregion(region);
                            self.regionList.push({
                                id: settings.get("id"),
                                region
                            });
                        }
                    }
                    function parseTimestampMap(input) {
                        var settings = new Settings;
                        parseOptions(input, (function(k, v) {
                            switch (k) {
                              case "MPEGT":
                                settings.integer(k + "S", v);
                                break;

                              case "LOCA":
                                settings.set(k + "L", parseTimeStamp(v));
                                break;
                            }
                        }), /[^\d]:/, /,/);
                        self.ontimestampmap && self.ontimestampmap({
                            MPEGTS: settings.get("MPEGTS"),
                            LOCAL: settings.get("LOCAL")
                        });
                    }
                    function parseHeader(input) {
                        if (input.match(/X-TIMESTAMP-MAP/)) parseOptions(input, (function(k, v) {
                            switch (k) {
                              case "X-TIMESTAMP-MAP":
                                parseTimestampMap(v);
                                break;
                            }
                        }), /=/); else parseOptions(input, (function(k, v) {
                            switch (k) {
                              case "Region":
                                parseRegion(v);
                                break;
                            }
                        }), /:/);
                    }
                    try {
                        var line;
                        if (self.state === "INITIAL") {
                            if (!/\r\n|\n/.test(self.buffer)) return this;
                            line = collectNextLine();
                            var m = line.match(/^WEBVTT([ \t].*)?$/);
                            if (!m || !m[0]) throw new ParsingError(ParsingError.Errors.BadSignature);
                            self.state = "HEADER";
                        }
                        var alreadyCollectedLine = false;
                        while (self.buffer) {
                            if (!/\r\n|\n/.test(self.buffer)) return this;
                            if (!alreadyCollectedLine) line = collectNextLine(); else alreadyCollectedLine = false;
                            switch (self.state) {
                              case "HEADER":
                                if (/:/.test(line)) parseHeader(line); else if (!line) self.state = "ID";
                                continue;

                              case "NOTE":
                                if (!line) self.state = "ID";
                                continue;

                              case "ID":
                                if (/^NOTE($|[ \t])/.test(line)) {
                                    self.state = "NOTE";
                                    break;
                                }
                                if (!line) continue;
                                self.cue = new (self.vttjs.VTTCue || self.window.VTTCue)(0, 0, "");
                                try {
                                    self.cue.align = "center";
                                } catch (e) {
                                    self.cue.align = "middle";
                                }
                                self.state = "CUE";
                                if (line.indexOf("--\x3e") === -1) {
                                    self.cue.id = line;
                                    continue;
                                }

                              case "CUE":
                                try {
                                    parseCue(line, self.cue, self.regionList);
                                } catch (e) {
                                    self.reportOrThrowError(e);
                                    self.cue = null;
                                    self.state = "BADCUE";
                                    continue;
                                }
                                self.state = "CUETEXT";
                                continue;

                              case "CUETEXT":
                                var hasSubstring = line.indexOf("--\x3e") !== -1;
                                if (!line || hasSubstring && (alreadyCollectedLine = true)) {
                                    self.oncue && self.oncue(self.cue);
                                    self.cue = null;
                                    self.state = "ID";
                                    continue;
                                }
                                if (self.cue.text) self.cue.text += "\n";
                                self.cue.text += line.replace(/\u2028/g, "\n").replace(/u2029/g, "\n");
                                continue;

                              case "BADCUE":
                                if (!line) self.state = "ID";
                                continue;
                            }
                        }
                    } catch (e) {
                        self.reportOrThrowError(e);
                        if (self.state === "CUETEXT" && self.cue && self.oncue) self.oncue(self.cue);
                        self.cue = null;
                        self.state = self.state === "INITIAL" ? "BADWEBVTT" : "BADCUE";
                    }
                    return this;
                },
                flush: function() {
                    var self = this;
                    try {
                        self.buffer += self.decoder.decode();
                        if (self.cue || self.state === "HEADER") {
                            self.buffer += "\n\n";
                            self.parse();
                        }
                        if (self.state === "INITIAL") throw new ParsingError(ParsingError.Errors.BadSignature);
                    } catch (e) {
                        self.reportOrThrowError(e);
                    }
                    self.onflush && self.onflush();
                    return this;
                }
            };
            module.exports = WebVTT;
        },
        230: module => {
            var autoKeyword = "auto";
            var directionSetting = {
                "": 1,
                lr: 1,
                rl: 1
            };
            var alignSetting = {
                start: 1,
                center: 1,
                end: 1,
                left: 1,
                right: 1,
                auto: 1,
                "line-left": 1,
                "line-right": 1
            };
            function findDirectionSetting(value) {
                if (typeof value !== "string") return false;
                var dir = directionSetting[value.toLowerCase()];
                return dir ? value.toLowerCase() : false;
            }
            function findAlignSetting(value) {
                if (typeof value !== "string") return false;
                var align = alignSetting[value.toLowerCase()];
                return align ? value.toLowerCase() : false;
            }
            function VTTCue(startTime, endTime, text) {
                this.hasBeenReset = false;
                var _id = "";
                var _pauseOnExit = false;
                var _startTime = startTime;
                var _endTime = endTime;
                var _text = text;
                var _region = null;
                var _vertical = "";
                var _snapToLines = true;
                var _line = "auto";
                var _lineAlign = "start";
                var _position = "auto";
                var _positionAlign = "auto";
                var _size = 100;
                var _align = "center";
                Object.defineProperties(this, {
                    id: {
                        enumerable: true,
                        get: function() {
                            return _id;
                        },
                        set: function(value) {
                            _id = "" + value;
                        }
                    },
                    pauseOnExit: {
                        enumerable: true,
                        get: function() {
                            return _pauseOnExit;
                        },
                        set: function(value) {
                            _pauseOnExit = !!value;
                        }
                    },
                    startTime: {
                        enumerable: true,
                        get: function() {
                            return _startTime;
                        },
                        set: function(value) {
                            if (typeof value !== "number") throw new TypeError("Start time must be set to a number.");
                            _startTime = value;
                            this.hasBeenReset = true;
                        }
                    },
                    endTime: {
                        enumerable: true,
                        get: function() {
                            return _endTime;
                        },
                        set: function(value) {
                            if (typeof value !== "number") throw new TypeError("End time must be set to a number.");
                            _endTime = value;
                            this.hasBeenReset = true;
                        }
                    },
                    text: {
                        enumerable: true,
                        get: function() {
                            return _text;
                        },
                        set: function(value) {
                            _text = "" + value;
                            this.hasBeenReset = true;
                        }
                    },
                    region: {
                        enumerable: true,
                        get: function() {
                            return _region;
                        },
                        set: function(value) {
                            _region = value;
                            this.hasBeenReset = true;
                        }
                    },
                    vertical: {
                        enumerable: true,
                        get: function() {
                            return _vertical;
                        },
                        set: function(value) {
                            var setting = findDirectionSetting(value);
                            if (setting === false) throw new SyntaxError("Vertical: an invalid or illegal direction string was specified.");
                            _vertical = setting;
                            this.hasBeenReset = true;
                        }
                    },
                    snapToLines: {
                        enumerable: true,
                        get: function() {
                            return _snapToLines;
                        },
                        set: function(value) {
                            _snapToLines = !!value;
                            this.hasBeenReset = true;
                        }
                    },
                    line: {
                        enumerable: true,
                        get: function() {
                            return _line;
                        },
                        set: function(value) {
                            if (typeof value !== "number" && value !== autoKeyword) throw new SyntaxError("Line: an invalid number or illegal string was specified.");
                            _line = value;
                            this.hasBeenReset = true;
                        }
                    },
                    lineAlign: {
                        enumerable: true,
                        get: function() {
                            return _lineAlign;
                        },
                        set: function(value) {
                            var setting = findAlignSetting(value);
                            if (!setting) console.warn("lineAlign: an invalid or illegal string was specified."); else {
                                _lineAlign = setting;
                                this.hasBeenReset = true;
                            }
                        }
                    },
                    position: {
                        enumerable: true,
                        get: function() {
                            return _position;
                        },
                        set: function(value) {
                            if (value < 0 || value > 100) throw new Error("Position must be between 0 and 100.");
                            _position = value;
                            this.hasBeenReset = true;
                        }
                    },
                    positionAlign: {
                        enumerable: true,
                        get: function() {
                            return _positionAlign;
                        },
                        set: function(value) {
                            var setting = findAlignSetting(value);
                            if (!setting) console.warn("positionAlign: an invalid or illegal string was specified."); else {
                                _positionAlign = setting;
                                this.hasBeenReset = true;
                            }
                        }
                    },
                    size: {
                        enumerable: true,
                        get: function() {
                            return _size;
                        },
                        set: function(value) {
                            if (value < 0 || value > 100) throw new Error("Size must be between 0 and 100.");
                            _size = value;
                            this.hasBeenReset = true;
                        }
                    },
                    align: {
                        enumerable: true,
                        get: function() {
                            return _align;
                        },
                        set: function(value) {
                            var setting = findAlignSetting(value);
                            if (!setting) throw new SyntaxError("align: an invalid or illegal alignment string was specified.");
                            _align = setting;
                            this.hasBeenReset = true;
                        }
                    }
                });
                this.displayState = void 0;
            }
            VTTCue.prototype.getCueAsHTML = function() {
                return WebVTT.convertCueToDOMTree(window, this.text);
            };
            module.exports = VTTCue;
        },
        710: module => {
            var scrollSetting = {
                "": true,
                up: true
            };
            function findScrollSetting(value) {
                if (typeof value !== "string") return false;
                var scroll = scrollSetting[value.toLowerCase()];
                return scroll ? value.toLowerCase() : false;
            }
            function isValidPercentValue(value) {
                return typeof value === "number" && value >= 0 && value <= 100;
            }
            function VTTRegion() {
                var _width = 100;
                var _lines = 3;
                var _regionAnchorX = 0;
                var _regionAnchorY = 100;
                var _viewportAnchorX = 0;
                var _viewportAnchorY = 100;
                var _scroll = "";
                Object.defineProperties(this, {
                    width: {
                        enumerable: true,
                        get: function() {
                            return _width;
                        },
                        set: function(value) {
                            if (!isValidPercentValue(value)) throw new Error("Width must be between 0 and 100.");
                            _width = value;
                        }
                    },
                    lines: {
                        enumerable: true,
                        get: function() {
                            return _lines;
                        },
                        set: function(value) {
                            if (typeof value !== "number") throw new TypeError("Lines must be set to a number.");
                            _lines = value;
                        }
                    },
                    regionAnchorY: {
                        enumerable: true,
                        get: function() {
                            return _regionAnchorY;
                        },
                        set: function(value) {
                            if (!isValidPercentValue(value)) throw new Error("RegionAnchorX must be between 0 and 100.");
                            _regionAnchorY = value;
                        }
                    },
                    regionAnchorX: {
                        enumerable: true,
                        get: function() {
                            return _regionAnchorX;
                        },
                        set: function(value) {
                            if (!isValidPercentValue(value)) throw new Error("RegionAnchorY must be between 0 and 100.");
                            _regionAnchorX = value;
                        }
                    },
                    viewportAnchorY: {
                        enumerable: true,
                        get: function() {
                            return _viewportAnchorY;
                        },
                        set: function(value) {
                            if (!isValidPercentValue(value)) throw new Error("ViewportAnchorY must be between 0 and 100.");
                            _viewportAnchorY = value;
                        }
                    },
                    viewportAnchorX: {
                        enumerable: true,
                        get: function() {
                            return _viewportAnchorX;
                        },
                        set: function(value) {
                            if (!isValidPercentValue(value)) throw new Error("ViewportAnchorX must be between 0 and 100.");
                            _viewportAnchorX = value;
                        }
                    },
                    scroll: {
                        enumerable: true,
                        get: function() {
                            return _scroll;
                        },
                        set: function(value) {
                            var setting = findScrollSetting(value);
                            if (setting === false) console.warn("Scroll: an invalid or illegal string was specified."); else _scroll = setting;
                        }
                    }
                });
            }
            module.exports = VTTRegion;
        },
        893: () => {},
        434: module => {
            function _extends() {
                module.exports = _extends = Object.assign ? Object.assign.bind() : function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                    }
                    return target;
                }, module.exports.__esModule = true, module.exports["default"] = module.exports;
                return _extends.apply(this, arguments);
            }
            module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        return module.exports;
    }
    (() => {
        __webpack_require__.n = module => {
            var getter = module && module.__esModule ? () => module["default"] : () => module;
            __webpack_require__.d(getter, {
                a: getter
            });
            return getter;
        };
    })();
    (() => {
        __webpack_require__.d = (exports, definition) => {
            for (var key in definition) if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
                enumerable: true,
                get: definition[key]
            });
        };
    })();
    (() => {
        __webpack_require__.g = function() {
            if (typeof globalThis === "object") return globalThis;
            try {
                return this || new Function("return this")();
            } catch (e) {
                if (typeof window === "object") return window;
            }
        }();
    })();
    (() => {
        __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
    })();
    (() => {
        "use strict";
        const flsModules = {};
        function isWebp() {
            function testWebP(callback) {
                let webP = new Image;
                webP.onload = webP.onerror = function() {
                    callback(webP.height == 2);
                };
                webP.src = "data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA";
            }
            testWebP((function(support) {
                let className = support === true ? "webp" : "no-webp";
                document.documentElement.classList.add(className);
            }));
        }
        function getHash() {
            if (location.hash) return location.hash.replace("#", "");
        }
        let _slideUp = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = `${target.offsetHeight}px`;
                target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                window.setTimeout((() => {
                    target.hidden = !showmore ? true : false;
                    !showmore ? target.style.removeProperty("height") : null;
                    target.style.removeProperty("padding-top");
                    target.style.removeProperty("padding-bottom");
                    target.style.removeProperty("margin-top");
                    target.style.removeProperty("margin-bottom");
                    !showmore ? target.style.removeProperty("overflow") : null;
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideUpDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideDown = (target, duration = 500, showmore = 0) => {
            if (!target.classList.contains("_slide")) {
                target.classList.add("_slide");
                target.hidden = target.hidden ? false : null;
                showmore ? target.style.removeProperty("height") : null;
                let height = target.offsetHeight;
                target.style.overflow = "hidden";
                target.style.height = showmore ? `${showmore}px` : `0px`;
                target.style.paddingTop = 0;
                target.style.paddingBottom = 0;
                target.style.marginTop = 0;
                target.style.marginBottom = 0;
                target.offsetHeight;
                target.style.transitionProperty = "height, margin, padding";
                target.style.transitionDuration = duration + "ms";
                target.style.height = height + "px";
                target.style.removeProperty("padding-top");
                target.style.removeProperty("padding-bottom");
                target.style.removeProperty("margin-top");
                target.style.removeProperty("margin-bottom");
                window.setTimeout((() => {
                    target.style.removeProperty("height");
                    target.style.removeProperty("overflow");
                    target.style.removeProperty("transition-duration");
                    target.style.removeProperty("transition-property");
                    target.classList.remove("_slide");
                    document.dispatchEvent(new CustomEvent("slideDownDone", {
                        detail: {
                            target
                        }
                    }));
                }), duration);
            }
        };
        let _slideToggle = (target, duration = 500) => {
            if (target.hidden) return _slideDown(target, duration); else return _slideUp(target, duration);
        };
        let bodyLockStatus = true;
        let bodyLockToggle = (delay = 500) => {
            if (document.documentElement.classList.contains("lock")) bodyUnlock(delay); else bodyLock(delay);
        };
        let bodyUnlock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                setTimeout((() => {
                    for (let index = 0; index < lock_padding.length; index++) {
                        const el = lock_padding[index];
                        el.style.paddingRight = "0px";
                    }
                    body.style.paddingRight = "0px";
                    document.documentElement.classList.remove("lock");
                }), delay);
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        let bodyLock = (delay = 500) => {
            let body = document.querySelector("body");
            if (bodyLockStatus) {
                let lock_padding = document.querySelectorAll("[data-lp]");
                for (let index = 0; index < lock_padding.length; index++) {
                    const el = lock_padding[index];
                    el.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                }
                body.style.paddingRight = window.innerWidth - document.querySelector(".wrapper").offsetWidth + "px";
                document.documentElement.classList.add("lock");
                bodyLockStatus = false;
                setTimeout((function() {
                    bodyLockStatus = true;
                }), delay);
            }
        };
        function spollers() {
            const spollersArray = document.querySelectorAll("[data-spollers]");
            if (spollersArray.length > 0) {
                document.addEventListener("click", setSpollerAction);
                const spollersRegular = Array.from(spollersArray).filter((function(item, index, self) {
                    return !item.dataset.spollers.split(",")[0];
                }));
                if (spollersRegular.length) initSpollers(spollersRegular);
                let mdQueriesArray = dataMediaQueries(spollersArray, "spollers");
                if (mdQueriesArray && mdQueriesArray.length) mdQueriesArray.forEach((mdQueriesItem => {
                    mdQueriesItem.matchMedia.addEventListener("change", (function() {
                        initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                    }));
                    initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia);
                }));
                function initSpollers(spollersArray, matchMedia = false) {
                    spollersArray.forEach((spollersBlock => {
                        spollersBlock = matchMedia ? spollersBlock.item : spollersBlock;
                        if (matchMedia.matches || !matchMedia) {
                            spollersBlock.classList.add("_spoller-init");
                            initSpollerBody(spollersBlock);
                        } else {
                            spollersBlock.classList.remove("_spoller-init");
                            initSpollerBody(spollersBlock, false);
                        }
                    }));
                }
                function initSpollerBody(spollersBlock, hideSpollerBody = true) {
                    let spollerItems = spollersBlock.querySelectorAll("details");
                    if (spollerItems.length) {
                        spollerItems = Array.from(spollerItems).filter((item => item.closest("[data-spollers]") === spollersBlock));
                        spollerItems.forEach((spollerItem => {
                            let spollerTitle = spollerItem.querySelector("summary");
                            if (hideSpollerBody) {
                                spollerTitle.removeAttribute("tabindex");
                                if (!spollerItem.hasAttribute("data-open")) {
                                    spollerItem.open = false;
                                    spollerTitle.nextElementSibling.hidden = true;
                                } else {
                                    spollerTitle.classList.add("_spoller-active");
                                    spollerItem.open = true;
                                }
                            } else {
                                spollerTitle.setAttribute("tabindex", "-1");
                                spollerTitle.classList.remove("_spoller-active");
                                spollerItem.open = true;
                                spollerTitle.nextElementSibling.hidden = false;
                            }
                        }));
                    }
                }
                function setSpollerAction(e) {
                    const el = e.target;
                    if (el.closest("summary") && el.closest("[data-spollers]")) {
                        if (el.closest("[data-spollers]").classList.contains("_spoller-init")) {
                            const spollerTitle = el.closest("summary");
                            const spollerBlock = spollerTitle.closest("details");
                            const spollersBlock = spollerTitle.closest("[data-spollers]");
                            const oneSpoller = spollersBlock.hasAttribute("data-one-spoller");
                            const spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
                            if (!spollersBlock.querySelectorAll("._slide").length) {
                                if (oneSpoller && !spollerBlock.open) hideSpollersBody(spollersBlock);
                                spollerTitle.classList.toggle("_spoller-active");
                                _slideToggle(spollerTitle.nextElementSibling, spollerSpeed);
                                !spollerBlock.open ? spollerBlock.open = true : setTimeout((() => {
                                    spollerBlock.open = false;
                                }), spollerSpeed);
                            }
                        }
                        e.preventDefault();
                    }
                    if (!el.closest("[data-spollers]")) {
                        const spollersClose = document.querySelectorAll("[data-spoller-close]");
                        if (spollersClose.length) spollersClose.forEach((spollerClose => {
                            const spollersBlock = spollerClose.closest("[data-spollers]");
                            const spollerCloseBlock = spollerClose.parentNode;
                            if (spollersBlock.classList.contains("_spoller-init")) {
                                const spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
                                spollerClose.classList.remove("_spoller-active");
                                _slideUp(spollerClose.nextElementSibling, spollerSpeed);
                                setTimeout((() => {
                                    spollerCloseBlock.open = false;
                                }), spollerSpeed);
                            }
                        }));
                    }
                }
                function hideSpollersBody(spollersBlock) {
                    const spollerActiveBlock = spollersBlock.querySelector("details[open]");
                    if (spollerActiveBlock && !spollersBlock.querySelectorAll("._slide").length) {
                        const spollerActiveTitle = spollerActiveBlock.querySelector("summary");
                        const spollerSpeed = spollersBlock.dataset.spollersSpeed ? parseInt(spollersBlock.dataset.spollersSpeed) : 500;
                        spollerActiveTitle.classList.remove("_spoller-active");
                        _slideUp(spollerActiveTitle.nextElementSibling, spollerSpeed);
                        setTimeout((() => {
                            spollerActiveBlock.open = false;
                        }), spollerSpeed);
                    }
                }
            }
        }
        function menuInit() {
            if (document.querySelector(".icon-menu")) document.addEventListener("click", (function(e) {
                if (bodyLockStatus && e.target.closest(".icon-menu")) {
                    bodyLockToggle();
                    document.documentElement.classList.toggle("menu-open");
                }
            }));
        }
        function menuClose() {
            bodyUnlock();
            document.documentElement.classList.remove("menu-open");
        }
        function FLS(message) {
            setTimeout((() => {
                if (window.FLS) console.log(message);
            }), 0);
        }
        function uniqArray(array) {
            return array.filter((function(item, index, self) {
                return self.indexOf(item) === index;
            }));
        }
        function dataMediaQueries(array, dataSetValue) {
            const media = Array.from(array).filter((function(item, index, self) {
                if (item.dataset[dataSetValue]) return item.dataset[dataSetValue].split(",")[0];
            }));
            if (media.length) {
                const breakpointsArray = [];
                media.forEach((item => {
                    const params = item.dataset[dataSetValue];
                    const breakpoint = {};
                    const paramsArray = params.split(",");
                    breakpoint.value = paramsArray[0];
                    breakpoint.type = paramsArray[1] ? paramsArray[1].trim() : "max";
                    breakpoint.item = item;
                    breakpointsArray.push(breakpoint);
                }));
                let mdQueries = breakpointsArray.map((function(item) {
                    return "(" + item.type + "-width: " + item.value + "px)," + item.value + "," + item.type;
                }));
                mdQueries = uniqArray(mdQueries);
                const mdQueriesArray = [];
                if (mdQueries.length) {
                    mdQueries.forEach((breakpoint => {
                        const paramsArray = breakpoint.split(",");
                        const mediaBreakpoint = paramsArray[1];
                        const mediaType = paramsArray[2];
                        const matchMedia = window.matchMedia(paramsArray[0]);
                        const itemsArray = breakpointsArray.filter((function(item) {
                            if (item.value === mediaBreakpoint && item.type === mediaType) return true;
                        }));
                        mdQueriesArray.push({
                            itemsArray,
                            matchMedia
                        });
                    }));
                    return mdQueriesArray;
                }
            }
        }
        function isString(str) {
            return typeof str === "string" || str instanceof String;
        }
        function utils_isObject(obj) {
            var _obj$constructor;
            return typeof obj === "object" && obj != null && (obj == null ? void 0 : (_obj$constructor = obj.constructor) == null ? void 0 : _obj$constructor.name) === "Object";
        }
        function pick(obj, keys) {
            if (Array.isArray(keys)) return pick(obj, ((_, k) => keys.includes(k)));
            return Object.entries(obj).reduce(((acc, _ref) => {
                let [k, v] = _ref;
                if (keys(v, k)) acc[k] = v;
                return acc;
            }), {});
        }
        const DIRECTION = {
            NONE: "NONE",
            LEFT: "LEFT",
            FORCE_LEFT: "FORCE_LEFT",
            RIGHT: "RIGHT",
            FORCE_RIGHT: "FORCE_RIGHT"
        };
        function forceDirection(direction) {
            switch (direction) {
              case DIRECTION.LEFT:
                return DIRECTION.FORCE_LEFT;

              case DIRECTION.RIGHT:
                return DIRECTION.FORCE_RIGHT;

              default:
                return direction;
            }
        }
        function escapeRegExp(str) {
            return str.replace(/([.*+?^=!:${}()|[\]/\\])/g, "\\$1");
        }
        function objectIncludes(b, a) {
            if (a === b) return true;
            const arrA = Array.isArray(a), arrB = Array.isArray(b);
            let i;
            if (arrA && arrB) {
                if (a.length != b.length) return false;
                for (i = 0; i < a.length; i++) if (!objectIncludes(a[i], b[i])) return false;
                return true;
            }
            if (arrA != arrB) return false;
            if (a && b && typeof a === "object" && typeof b === "object") {
                const dateA = a instanceof Date, dateB = b instanceof Date;
                if (dateA && dateB) return a.getTime() == b.getTime();
                if (dateA != dateB) return false;
                const regexpA = a instanceof RegExp, regexpB = b instanceof RegExp;
                if (regexpA && regexpB) return a.toString() == b.toString();
                if (regexpA != regexpB) return false;
                const keys = Object.keys(a);
                for (i = 0; i < keys.length; i++) if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
                for (i = 0; i < keys.length; i++) if (!objectIncludes(b[keys[i]], a[keys[i]])) return false;
                return true;
            } else if (a && b && typeof a === "function" && typeof b === "function") return a.toString() === b.toString();
            return false;
        }
        class ActionDetails {
            constructor(opts) {
                Object.assign(this, opts);
                while (this.value.slice(0, this.startChangePos) !== this.oldValue.slice(0, this.startChangePos)) --this.oldSelection.start;
            }
            get startChangePos() {
                return Math.min(this.cursorPos, this.oldSelection.start);
            }
            get insertedCount() {
                return this.cursorPos - this.startChangePos;
            }
            get inserted() {
                return this.value.substr(this.startChangePos, this.insertedCount);
            }
            get removedCount() {
                return Math.max(this.oldSelection.end - this.startChangePos || this.oldValue.length - this.value.length, 0);
            }
            get removed() {
                return this.oldValue.substr(this.startChangePos, this.removedCount);
            }
            get head() {
                return this.value.substring(0, this.startChangePos);
            }
            get tail() {
                return this.value.substring(this.startChangePos + this.insertedCount);
            }
            get removeDirection() {
                if (!this.removedCount || this.insertedCount) return DIRECTION.NONE;
                return (this.oldSelection.end === this.cursorPos || this.oldSelection.start === this.cursorPos) && this.oldSelection.end === this.oldSelection.start ? DIRECTION.RIGHT : DIRECTION.LEFT;
            }
        }
        function holder_IMask(el, opts) {
            return new holder_IMask.InputMask(el, opts);
        }
        function maskedClass(mask) {
            if (mask == null) throw new Error("mask property should be defined");
            if (mask instanceof RegExp) return holder_IMask.MaskedRegExp;
            if (isString(mask)) return holder_IMask.MaskedPattern;
            if (mask === Date) return holder_IMask.MaskedDate;
            if (mask === Number) return holder_IMask.MaskedNumber;
            if (Array.isArray(mask) || mask === Array) return holder_IMask.MaskedDynamic;
            if (holder_IMask.Masked && mask.prototype instanceof holder_IMask.Masked) return mask;
            if (holder_IMask.Masked && mask instanceof holder_IMask.Masked) return mask.constructor;
            if (mask instanceof Function) return holder_IMask.MaskedFunction;
            console.warn("Mask not found for mask", mask);
            return holder_IMask.Masked;
        }
        function normalizeOpts(opts) {
            if (!opts) throw new Error("Options in not defined");
            if (holder_IMask.Masked) {
                if (opts.prototype instanceof holder_IMask.Masked) return {
                    mask: opts
                };
                const {mask = void 0, ...instanceOpts} = opts instanceof holder_IMask.Masked ? {
                    mask: opts
                } : utils_isObject(opts) && opts.mask instanceof holder_IMask.Masked ? opts : {};
                if (mask) {
                    const _mask = mask.mask;
                    return {
                        ...pick(mask, ((_, k) => !k.startsWith("_"))),
                        mask: mask.constructor,
                        _mask,
                        ...instanceOpts
                    };
                }
            }
            if (!utils_isObject(opts)) return {
                mask: opts
            };
            return {
                ...opts
            };
        }
        function createMask(opts) {
            if (holder_IMask.Masked && opts instanceof holder_IMask.Masked) return opts;
            const nOpts = normalizeOpts(opts);
            const MaskedClass = maskedClass(nOpts.mask);
            if (!MaskedClass) throw new Error("Masked class is not found for provided mask, appropriate module needs to be imported manually before creating mask.");
            if (nOpts.mask === MaskedClass) delete nOpts.mask;
            if (nOpts._mask) {
                nOpts.mask = nOpts._mask;
                delete nOpts._mask;
            }
            return new MaskedClass(nOpts);
        }
        holder_IMask.createMask = createMask;
        class MaskElement {
            get selectionStart() {
                let start;
                try {
                    start = this._unsafeSelectionStart;
                } catch {}
                return start != null ? start : this.value.length;
            }
            get selectionEnd() {
                let end;
                try {
                    end = this._unsafeSelectionEnd;
                } catch {}
                return end != null ? end : this.value.length;
            }
            select(start, end) {
                if (start == null || end == null || start === this.selectionStart && end === this.selectionEnd) return;
                try {
                    this._unsafeSelect(start, end);
                } catch {}
            }
            get isActive() {
                return false;
            }
        }
        holder_IMask.MaskElement = MaskElement;
        class HTMLMaskElement extends MaskElement {
            constructor(input) {
                super();
                this.input = input;
                this._handlers = {};
            }
            get rootElement() {
                var _this$input$getRootNo, _this$input$getRootNo2, _this$input;
                return (_this$input$getRootNo = (_this$input$getRootNo2 = (_this$input = this.input).getRootNode) == null ? void 0 : _this$input$getRootNo2.call(_this$input)) != null ? _this$input$getRootNo : document;
            }
            get isActive() {
                return this.input === this.rootElement.activeElement;
            }
            bindEvents(handlers) {
                Object.keys(handlers).forEach((event => this._toggleEventHandler(HTMLMaskElement.EVENTS_MAP[event], handlers[event])));
            }
            unbindEvents() {
                Object.keys(this._handlers).forEach((event => this._toggleEventHandler(event)));
            }
            _toggleEventHandler(event, handler) {
                if (this._handlers[event]) {
                    this.input.removeEventListener(event, this._handlers[event]);
                    delete this._handlers[event];
                }
                if (handler) {
                    this.input.addEventListener(event, handler);
                    this._handlers[event] = handler;
                }
            }
        }
        HTMLMaskElement.EVENTS_MAP = {
            selectionChange: "keydown",
            input: "input",
            drop: "drop",
            click: "click",
            focus: "focus",
            commit: "blur"
        };
        holder_IMask.HTMLMaskElement = HTMLMaskElement;
        class HTMLInputMaskElement extends HTMLMaskElement {
            constructor(input) {
                super(input);
                this.input = input;
                this._handlers = {};
            }
            get _unsafeSelectionStart() {
                return this.input.selectionStart != null ? this.input.selectionStart : this.value.length;
            }
            get _unsafeSelectionEnd() {
                return this.input.selectionEnd;
            }
            _unsafeSelect(start, end) {
                this.input.setSelectionRange(start, end);
            }
            get value() {
                return this.input.value;
            }
            set value(value) {
                this.input.value = value;
            }
        }
        holder_IMask.HTMLMaskElement = HTMLMaskElement;
        class HTMLContenteditableMaskElement extends HTMLMaskElement {
            get _unsafeSelectionStart() {
                const root = this.rootElement;
                const selection = root.getSelection && root.getSelection();
                const anchorOffset = selection && selection.anchorOffset;
                const focusOffset = selection && selection.focusOffset;
                if (focusOffset == null || anchorOffset == null || anchorOffset < focusOffset) return anchorOffset;
                return focusOffset;
            }
            get _unsafeSelectionEnd() {
                const root = this.rootElement;
                const selection = root.getSelection && root.getSelection();
                const anchorOffset = selection && selection.anchorOffset;
                const focusOffset = selection && selection.focusOffset;
                if (focusOffset == null || anchorOffset == null || anchorOffset > focusOffset) return anchorOffset;
                return focusOffset;
            }
            _unsafeSelect(start, end) {
                if (!this.rootElement.createRange) return;
                const range = this.rootElement.createRange();
                range.setStart(this.input.firstChild || this.input, start);
                range.setEnd(this.input.lastChild || this.input, end);
                const root = this.rootElement;
                const selection = root.getSelection && root.getSelection();
                if (selection) {
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
            get value() {
                return this.input.textContent || "";
            }
            set value(value) {
                this.input.textContent = value;
            }
        }
        holder_IMask.HTMLContenteditableMaskElement = HTMLContenteditableMaskElement;
        class InputMask {
            constructor(el, opts) {
                this.el = el instanceof MaskElement ? el : el.isContentEditable && el.tagName !== "INPUT" && el.tagName !== "TEXTAREA" ? new HTMLContenteditableMaskElement(el) : new HTMLInputMaskElement(el);
                this.masked = createMask(opts);
                this._listeners = {};
                this._value = "";
                this._unmaskedValue = "";
                this._saveSelection = this._saveSelection.bind(this);
                this._onInput = this._onInput.bind(this);
                this._onChange = this._onChange.bind(this);
                this._onDrop = this._onDrop.bind(this);
                this._onFocus = this._onFocus.bind(this);
                this._onClick = this._onClick.bind(this);
                this.alignCursor = this.alignCursor.bind(this);
                this.alignCursorFriendly = this.alignCursorFriendly.bind(this);
                this._bindEvents();
                this.updateValue();
                this._onChange();
            }
            maskEquals(mask) {
                var _this$masked;
                return mask == null || ((_this$masked = this.masked) == null ? void 0 : _this$masked.maskEquals(mask));
            }
            get mask() {
                return this.masked.mask;
            }
            set mask(mask) {
                if (this.maskEquals(mask)) return;
                if (!(mask instanceof holder_IMask.Masked) && this.masked.constructor === maskedClass(mask)) {
                    this.masked.updateOptions({
                        mask
                    });
                    return;
                }
                const masked = mask instanceof holder_IMask.Masked ? mask : createMask({
                    mask
                });
                masked.unmaskedValue = this.masked.unmaskedValue;
                this.masked = masked;
            }
            get value() {
                return this._value;
            }
            set value(str) {
                if (this.value === str) return;
                this.masked.value = str;
                this.updateControl();
                this.alignCursor();
            }
            get unmaskedValue() {
                return this._unmaskedValue;
            }
            set unmaskedValue(str) {
                if (this.unmaskedValue === str) return;
                this.masked.unmaskedValue = str;
                this.updateControl();
                this.alignCursor();
            }
            get typedValue() {
                return this.masked.typedValue;
            }
            set typedValue(val) {
                if (this.masked.typedValueEquals(val)) return;
                this.masked.typedValue = val;
                this.updateControl();
                this.alignCursor();
            }
            get displayValue() {
                return this.masked.displayValue;
            }
            _bindEvents() {
                this.el.bindEvents({
                    selectionChange: this._saveSelection,
                    input: this._onInput,
                    drop: this._onDrop,
                    click: this._onClick,
                    focus: this._onFocus,
                    commit: this._onChange
                });
            }
            _unbindEvents() {
                if (this.el) this.el.unbindEvents();
            }
            _fireEvent(ev, e) {
                const listeners = this._listeners[ev];
                if (!listeners) return;
                listeners.forEach((l => l(e)));
            }
            get selectionStart() {
                return this._cursorChanging ? this._changingCursorPos : this.el.selectionStart;
            }
            get cursorPos() {
                return this._cursorChanging ? this._changingCursorPos : this.el.selectionEnd;
            }
            set cursorPos(pos) {
                if (!this.el || !this.el.isActive) return;
                this.el.select(pos, pos);
                this._saveSelection();
            }
            _saveSelection() {
                if (this.displayValue !== this.el.value) console.warn("Element value was changed outside of mask. Syncronize mask using `mask.updateValue()` to work properly.");
                this._selection = {
                    start: this.selectionStart,
                    end: this.cursorPos
                };
            }
            updateValue() {
                this.masked.value = this.el.value;
                this._value = this.masked.value;
            }
            updateControl() {
                const newUnmaskedValue = this.masked.unmaskedValue;
                const newValue = this.masked.value;
                const newDisplayValue = this.displayValue;
                const isChanged = this.unmaskedValue !== newUnmaskedValue || this.value !== newValue;
                this._unmaskedValue = newUnmaskedValue;
                this._value = newValue;
                if (this.el.value !== newDisplayValue) this.el.value = newDisplayValue;
                if (isChanged) this._fireChangeEvents();
            }
            updateOptions(opts) {
                const {mask, ...restOpts} = opts;
                const updateMask = !this.maskEquals(mask);
                const updateOpts = !objectIncludes(this.masked, restOpts);
                if (updateMask) this.mask = mask;
                if (updateOpts) this.masked.updateOptions(restOpts);
                if (updateMask || updateOpts) this.updateControl();
            }
            updateCursor(cursorPos) {
                if (cursorPos == null) return;
                this.cursorPos = cursorPos;
                this._delayUpdateCursor(cursorPos);
            }
            _delayUpdateCursor(cursorPos) {
                this._abortUpdateCursor();
                this._changingCursorPos = cursorPos;
                this._cursorChanging = setTimeout((() => {
                    if (!this.el) return;
                    this.cursorPos = this._changingCursorPos;
                    this._abortUpdateCursor();
                }), 10);
            }
            _fireChangeEvents() {
                this._fireEvent("accept", this._inputEvent);
                if (this.masked.isComplete) this._fireEvent("complete", this._inputEvent);
            }
            _abortUpdateCursor() {
                if (this._cursorChanging) {
                    clearTimeout(this._cursorChanging);
                    delete this._cursorChanging;
                }
            }
            alignCursor() {
                this.cursorPos = this.masked.nearestInputPos(this.masked.nearestInputPos(this.cursorPos, DIRECTION.LEFT));
            }
            alignCursorFriendly() {
                if (this.selectionStart !== this.cursorPos) return;
                this.alignCursor();
            }
            on(ev, handler) {
                if (!this._listeners[ev]) this._listeners[ev] = [];
                this._listeners[ev].push(handler);
                return this;
            }
            off(ev, handler) {
                if (!this._listeners[ev]) return this;
                if (!handler) {
                    delete this._listeners[ev];
                    return this;
                }
                const hIndex = this._listeners[ev].indexOf(handler);
                if (hIndex >= 0) this._listeners[ev].splice(hIndex, 1);
                return this;
            }
            _onInput(e) {
                this._inputEvent = e;
                this._abortUpdateCursor();
                if (!this._selection) return this.updateValue();
                const details = new ActionDetails({
                    value: this.el.value,
                    cursorPos: this.cursorPos,
                    oldValue: this.displayValue,
                    oldSelection: this._selection
                });
                const oldRawValue = this.masked.rawInputValue;
                const offset = this.masked.splice(details.startChangePos, details.removed.length, details.inserted, details.removeDirection, {
                    input: true,
                    raw: true
                }).offset;
                const removeDirection = oldRawValue === this.masked.rawInputValue ? details.removeDirection : DIRECTION.NONE;
                let cursorPos = this.masked.nearestInputPos(details.startChangePos + offset, removeDirection);
                if (removeDirection !== DIRECTION.NONE) cursorPos = this.masked.nearestInputPos(cursorPos, DIRECTION.NONE);
                this.updateControl();
                this.updateCursor(cursorPos);
                delete this._inputEvent;
            }
            _onChange() {
                if (this.displayValue !== this.el.value) this.updateValue();
                this.masked.doCommit();
                this.updateControl();
                this._saveSelection();
            }
            _onDrop(ev) {
                ev.preventDefault();
                ev.stopPropagation();
            }
            _onFocus(ev) {
                this.alignCursorFriendly();
            }
            _onClick(ev) {
                this.alignCursorFriendly();
            }
            destroy() {
                this._unbindEvents();
                this._listeners.length = 0;
                delete this.el;
            }
        }
        holder_IMask.InputMask = InputMask;
        class ChangeDetails {
            static normalize(prep) {
                return Array.isArray(prep) ? prep : [ prep, new ChangeDetails ];
            }
            constructor(details) {
                Object.assign(this, {
                    inserted: "",
                    rawInserted: "",
                    skip: false,
                    tailShift: 0
                }, details);
            }
            aggregate(details) {
                this.rawInserted += details.rawInserted;
                this.skip = this.skip || details.skip;
                this.inserted += details.inserted;
                this.tailShift += details.tailShift;
                return this;
            }
            get offset() {
                return this.tailShift + this.inserted.length;
            }
        }
        holder_IMask.ChangeDetails = ChangeDetails;
        class ContinuousTailDetails {
            constructor(value, from, stop) {
                if (value === void 0) value = "";
                if (from === void 0) from = 0;
                this.value = value;
                this.from = from;
                this.stop = stop;
            }
            toString() {
                return this.value;
            }
            extend(tail) {
                this.value += String(tail);
            }
            appendTo(masked) {
                return masked.append(this.toString(), {
                    tail: true
                }).aggregate(masked._appendPlaceholder());
            }
            get state() {
                return {
                    value: this.value,
                    from: this.from,
                    stop: this.stop
                };
            }
            set state(state) {
                Object.assign(this, state);
            }
            unshift(beforePos) {
                if (!this.value.length || beforePos != null && this.from >= beforePos) return "";
                const shiftChar = this.value[0];
                this.value = this.value.slice(1);
                return shiftChar;
            }
            shift() {
                if (!this.value.length) return "";
                const shiftChar = this.value[this.value.length - 1];
                this.value = this.value.slice(0, -1);
                return shiftChar;
            }
        }
        class Masked {
            constructor(opts) {
                this._value = "";
                this._update({
                    ...Masked.DEFAULTS,
                    ...opts
                });
                this._initialized = true;
            }
            updateOptions(opts) {
                if (!Object.keys(opts).length) return;
                this.withValueRefresh(this._update.bind(this, opts));
            }
            _update(opts) {
                Object.assign(this, opts);
            }
            get state() {
                return {
                    _value: this.value,
                    _rawInputValue: this.rawInputValue
                };
            }
            set state(state) {
                this._value = state._value;
            }
            reset() {
                this._value = "";
            }
            get value() {
                return this._value;
            }
            set value(value) {
                this.resolve(value, {
                    input: true
                });
            }
            resolve(value, flags) {
                if (flags === void 0) flags = {
                    input: true
                };
                this.reset();
                this.append(value, flags, "");
                this.doCommit();
            }
            get unmaskedValue() {
                return this.value;
            }
            set unmaskedValue(value) {
                this.resolve(value, {});
            }
            get typedValue() {
                return this.parse ? this.parse(this.value, this) : this.unmaskedValue;
            }
            set typedValue(value) {
                if (this.format) this.value = this.format(value, this); else this.unmaskedValue = String(value);
            }
            get rawInputValue() {
                return this.extractInput(0, this.displayValue.length, {
                    raw: true
                });
            }
            set rawInputValue(value) {
                this.resolve(value, {
                    raw: true
                });
            }
            get displayValue() {
                return this.value;
            }
            get isComplete() {
                return true;
            }
            get isFilled() {
                return this.isComplete;
            }
            nearestInputPos(cursorPos, direction) {
                return cursorPos;
            }
            totalInputPositions(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.displayValue.length;
                return Math.min(this.displayValue.length, toPos - fromPos);
            }
            extractInput(fromPos, toPos, flags) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.displayValue.length;
                return this.displayValue.slice(fromPos, toPos);
            }
            extractTail(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.displayValue.length;
                return new ContinuousTailDetails(this.extractInput(fromPos, toPos), fromPos);
            }
            appendTail(tail) {
                if (isString(tail)) tail = new ContinuousTailDetails(String(tail));
                return tail.appendTo(this);
            }
            _appendCharRaw(ch, flags) {
                if (!ch) return new ChangeDetails;
                this._value += ch;
                return new ChangeDetails({
                    inserted: ch,
                    rawInserted: ch
                });
            }
            _appendChar(ch, flags, checkTail) {
                if (flags === void 0) flags = {};
                const consistentState = this.state;
                let details;
                [ch, details] = this.doPrepareChar(ch, flags);
                details = details.aggregate(this._appendCharRaw(ch, flags));
                if (details.inserted) {
                    let consistentTail;
                    let appended = this.doValidate(flags) !== false;
                    if (appended && checkTail != null) {
                        const beforeTailState = this.state;
                        if (this.overwrite === true) {
                            consistentTail = checkTail.state;
                            checkTail.unshift(this.displayValue.length - details.tailShift);
                        }
                        let tailDetails = this.appendTail(checkTail);
                        appended = tailDetails.rawInserted === checkTail.toString();
                        if (!(appended && tailDetails.inserted) && this.overwrite === "shift") {
                            this.state = beforeTailState;
                            consistentTail = checkTail.state;
                            checkTail.shift();
                            tailDetails = this.appendTail(checkTail);
                            appended = tailDetails.rawInserted === checkTail.toString();
                        }
                        if (appended && tailDetails.inserted) this.state = beforeTailState;
                    }
                    if (!appended) {
                        details = new ChangeDetails;
                        this.state = consistentState;
                        if (checkTail && consistentTail) checkTail.state = consistentTail;
                    }
                }
                return details;
            }
            _appendPlaceholder() {
                return new ChangeDetails;
            }
            _appendEager() {
                return new ChangeDetails;
            }
            append(str, flags, tail) {
                if (!isString(str)) throw new Error("value should be string");
                const checkTail = isString(tail) ? new ContinuousTailDetails(String(tail)) : tail;
                if (flags != null && flags.tail) flags._beforeTailState = this.state;
                let details;
                [str, details] = this.doPrepare(str, flags);
                for (let ci = 0; ci < str.length; ++ci) {
                    const d = this._appendChar(str[ci], flags, checkTail);
                    if (!d.rawInserted && !this.doSkipInvalid(str[ci], flags, checkTail)) break;
                    details.aggregate(d);
                }
                if ((this.eager === true || this.eager === "append") && flags != null && flags.input && str) details.aggregate(this._appendEager());
                if (checkTail != null) details.tailShift += this.appendTail(checkTail).tailShift;
                return details;
            }
            remove(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.displayValue.length;
                this._value = this.displayValue.slice(0, fromPos) + this.displayValue.slice(toPos);
                return new ChangeDetails;
            }
            withValueRefresh(fn) {
                if (this._refreshing || !this._initialized) return fn();
                this._refreshing = true;
                const rawInput = this.rawInputValue;
                const value = this.value;
                const ret = fn();
                this.rawInputValue = rawInput;
                if (this.value && this.value !== value && value.indexOf(this.value) === 0) this.append(value.slice(this.displayValue.length), {}, "");
                delete this._refreshing;
                return ret;
            }
            runIsolated(fn) {
                if (this._isolated || !this._initialized) return fn(this);
                this._isolated = true;
                const state = this.state;
                const ret = fn(this);
                this.state = state;
                delete this._isolated;
                return ret;
            }
            doSkipInvalid(ch, flags, checkTail) {
                return Boolean(this.skipInvalid);
            }
            doPrepare(str, flags) {
                if (flags === void 0) flags = {};
                return ChangeDetails.normalize(this.prepare ? this.prepare(str, this, flags) : str);
            }
            doPrepareChar(str, flags) {
                if (flags === void 0) flags = {};
                return ChangeDetails.normalize(this.prepareChar ? this.prepareChar(str, this, flags) : str);
            }
            doValidate(flags) {
                return (!this.validate || this.validate(this.value, this, flags)) && (!this.parent || this.parent.doValidate(flags));
            }
            doCommit() {
                if (this.commit) this.commit(this.value, this);
            }
            splice(start, deleteCount, inserted, removeDirection, flags) {
                if (removeDirection === void 0) removeDirection = DIRECTION.NONE;
                if (flags === void 0) flags = {
                    input: true
                };
                const tailPos = start + deleteCount;
                const tail = this.extractTail(tailPos);
                const eagerRemove = this.eager === true || this.eager === "remove";
                let oldRawValue;
                if (eagerRemove) {
                    removeDirection = forceDirection(removeDirection);
                    oldRawValue = this.extractInput(0, tailPos, {
                        raw: true
                    });
                }
                let startChangePos = start;
                const details = new ChangeDetails;
                if (removeDirection !== DIRECTION.NONE) {
                    startChangePos = this.nearestInputPos(start, deleteCount > 1 && start !== 0 && !eagerRemove ? DIRECTION.NONE : removeDirection);
                    details.tailShift = startChangePos - start;
                }
                details.aggregate(this.remove(startChangePos));
                if (eagerRemove && removeDirection !== DIRECTION.NONE && oldRawValue === this.rawInputValue) if (removeDirection === DIRECTION.FORCE_LEFT) {
                    let valLength;
                    while (oldRawValue === this.rawInputValue && (valLength = this.displayValue.length)) details.aggregate(new ChangeDetails({
                        tailShift: -1
                    })).aggregate(this.remove(valLength - 1));
                } else if (removeDirection === DIRECTION.FORCE_RIGHT) tail.unshift();
                return details.aggregate(this.append(inserted, flags, tail));
            }
            maskEquals(mask) {
                return this.mask === mask;
            }
            typedValueEquals(value) {
                const tval = this.typedValue;
                return value === tval || Masked.EMPTY_VALUES.includes(value) && Masked.EMPTY_VALUES.includes(tval) || (this.format ? this.format(value, this) === this.format(this.typedValue, this) : false);
            }
        }
        Masked.DEFAULTS = {
            skipInvalid: true
        };
        Masked.EMPTY_VALUES = [ void 0, null, "" ];
        holder_IMask.Masked = Masked;
        class ChunksTailDetails {
            constructor(chunks, from) {
                if (chunks === void 0) chunks = [];
                if (from === void 0) from = 0;
                this.chunks = chunks;
                this.from = from;
            }
            toString() {
                return this.chunks.map(String).join("");
            }
            extend(tailChunk) {
                if (!String(tailChunk)) return;
                tailChunk = isString(tailChunk) ? new ContinuousTailDetails(String(tailChunk)) : tailChunk;
                const lastChunk = this.chunks[this.chunks.length - 1];
                const extendLast = lastChunk && (lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && tailChunk.from === lastChunk.from + lastChunk.toString().length;
                if (tailChunk instanceof ContinuousTailDetails) if (extendLast) lastChunk.extend(tailChunk.toString()); else this.chunks.push(tailChunk); else if (tailChunk instanceof ChunksTailDetails) {
                    if (tailChunk.stop == null) {
                        let firstTailChunk;
                        while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {
                            firstTailChunk = tailChunk.chunks.shift();
                            firstTailChunk.from += tailChunk.from;
                            this.extend(firstTailChunk);
                        }
                    }
                    if (tailChunk.toString()) {
                        tailChunk.stop = tailChunk.blockIndex;
                        this.chunks.push(tailChunk);
                    }
                }
            }
            appendTo(masked) {
                if (!(masked instanceof holder_IMask.MaskedPattern)) {
                    const tail = new ContinuousTailDetails(this.toString());
                    return tail.appendTo(masked);
                }
                const details = new ChangeDetails;
                for (let ci = 0; ci < this.chunks.length && !details.skip; ++ci) {
                    const chunk = this.chunks[ci];
                    const lastBlockIter = masked._mapPosToBlock(masked.displayValue.length);
                    const stop = chunk.stop;
                    let chunkBlock;
                    if (stop != null && (!lastBlockIter || lastBlockIter.index <= stop)) {
                        if (chunk instanceof ChunksTailDetails || masked._stops.indexOf(stop) >= 0) {
                            const phDetails = masked._appendPlaceholder(stop);
                            details.aggregate(phDetails);
                        }
                        chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];
                    }
                    if (chunkBlock) {
                        const tailDetails = chunkBlock.appendTail(chunk);
                        tailDetails.skip = false;
                        details.aggregate(tailDetails);
                        masked._value += tailDetails.inserted;
                        const remainChars = chunk.toString().slice(tailDetails.rawInserted.length);
                        if (remainChars) details.aggregate(masked.append(remainChars, {
                            tail: true
                        }));
                    } else details.aggregate(masked.append(chunk.toString(), {
                        tail: true
                    }));
                }
                return details;
            }
            get state() {
                return {
                    chunks: this.chunks.map((c => c.state)),
                    from: this.from,
                    stop: this.stop,
                    blockIndex: this.blockIndex
                };
            }
            set state(state) {
                const {chunks, ...props} = state;
                Object.assign(this, props);
                this.chunks = chunks.map((cstate => {
                    const chunk = "chunks" in cstate ? new ChunksTailDetails : new ContinuousTailDetails;
                    chunk.state = cstate;
                    return chunk;
                }));
            }
            unshift(beforePos) {
                if (!this.chunks.length || beforePos != null && this.from >= beforePos) return "";
                const chunkShiftPos = beforePos != null ? beforePos - this.from : beforePos;
                let ci = 0;
                while (ci < this.chunks.length) {
                    const chunk = this.chunks[ci];
                    const shiftChar = chunk.unshift(chunkShiftPos);
                    if (chunk.toString()) {
                        if (!shiftChar) break;
                        ++ci;
                    } else this.chunks.splice(ci, 1);
                    if (shiftChar) return shiftChar;
                }
                return "";
            }
            shift() {
                if (!this.chunks.length) return "";
                let ci = this.chunks.length - 1;
                while (0 <= ci) {
                    const chunk = this.chunks[ci];
                    const shiftChar = chunk.shift();
                    if (chunk.toString()) {
                        if (!shiftChar) break;
                        --ci;
                    } else this.chunks.splice(ci, 1);
                    if (shiftChar) return shiftChar;
                }
                return "";
            }
        }
        class PatternCursor {
            constructor(masked, pos) {
                this.masked = masked;
                this._log = [];
                const {offset, index} = masked._mapPosToBlock(pos) || (pos < 0 ? {
                    index: 0,
                    offset: 0
                } : {
                    index: this.masked._blocks.length,
                    offset: 0
                });
                this.offset = offset;
                this.index = index;
                this.ok = false;
            }
            get block() {
                return this.masked._blocks[this.index];
            }
            get pos() {
                return this.masked._blockStartPos(this.index) + this.offset;
            }
            get state() {
                return {
                    index: this.index,
                    offset: this.offset,
                    ok: this.ok
                };
            }
            set state(s) {
                Object.assign(this, s);
            }
            pushState() {
                this._log.push(this.state);
            }
            popState() {
                const s = this._log.pop();
                if (s) this.state = s;
                return s;
            }
            bindBlock() {
                if (this.block) return;
                if (this.index < 0) {
                    this.index = 0;
                    this.offset = 0;
                }
                if (this.index >= this.masked._blocks.length) {
                    this.index = this.masked._blocks.length - 1;
                    this.offset = this.block.displayValue.length;
                }
            }
            _pushLeft(fn) {
                this.pushState();
                for (this.bindBlock(); 0 <= this.index; --this.index, this.offset = ((_this$block = this.block) == null ? void 0 : _this$block.displayValue.length) || 0) {
                    var _this$block;
                    if (fn()) return this.ok = true;
                }
                return this.ok = false;
            }
            _pushRight(fn) {
                this.pushState();
                for (this.bindBlock(); this.index < this.masked._blocks.length; ++this.index, this.offset = 0) if (fn()) return this.ok = true;
                return this.ok = false;
            }
            pushLeftBeforeFilled() {
                return this._pushLeft((() => {
                    if (this.block.isFixed || !this.block.value) return;
                    this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_LEFT);
                    if (this.offset !== 0) return true;
                }));
            }
            pushLeftBeforeInput() {
                return this._pushLeft((() => {
                    if (this.block.isFixed) return;
                    this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);
                    return true;
                }));
            }
            pushLeftBeforeRequired() {
                return this._pushLeft((() => {
                    if (this.block.isFixed || this.block.isOptional && !this.block.value) return;
                    this.offset = this.block.nearestInputPos(this.offset, DIRECTION.LEFT);
                    return true;
                }));
            }
            pushRightBeforeFilled() {
                return this._pushRight((() => {
                    if (this.block.isFixed || !this.block.value) return;
                    this.offset = this.block.nearestInputPos(this.offset, DIRECTION.FORCE_RIGHT);
                    if (this.offset !== this.block.value.length) return true;
                }));
            }
            pushRightBeforeInput() {
                return this._pushRight((() => {
                    if (this.block.isFixed) return;
                    this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);
                    return true;
                }));
            }
            pushRightBeforeRequired() {
                return this._pushRight((() => {
                    if (this.block.isFixed || this.block.isOptional && !this.block.value) return;
                    this.offset = this.block.nearestInputPos(this.offset, DIRECTION.NONE);
                    return true;
                }));
            }
        }
        class PatternFixedDefinition {
            constructor(opts) {
                Object.assign(this, opts);
                this._value = "";
                this.isFixed = true;
            }
            get value() {
                return this._value;
            }
            get unmaskedValue() {
                return this.isUnmasking ? this.value : "";
            }
            get rawInputValue() {
                return this._isRawInput ? this.value : "";
            }
            get displayValue() {
                return this.value;
            }
            reset() {
                this._isRawInput = false;
                this._value = "";
            }
            remove(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this._value.length;
                this._value = this._value.slice(0, fromPos) + this._value.slice(toPos);
                if (!this._value) this._isRawInput = false;
                return new ChangeDetails;
            }
            nearestInputPos(cursorPos, direction) {
                if (direction === void 0) direction = DIRECTION.NONE;
                const minPos = 0;
                const maxPos = this._value.length;
                switch (direction) {
                  case DIRECTION.LEFT:
                  case DIRECTION.FORCE_LEFT:
                    return minPos;

                  case DIRECTION.NONE:
                  case DIRECTION.RIGHT:
                  case DIRECTION.FORCE_RIGHT:
                  default:
                    return maxPos;
                }
            }
            totalInputPositions(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this._value.length;
                return this._isRawInput ? toPos - fromPos : 0;
            }
            extractInput(fromPos, toPos, flags) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this._value.length;
                if (flags === void 0) flags = {};
                return flags.raw && this._isRawInput && this._value.slice(fromPos, toPos) || "";
            }
            get isComplete() {
                return true;
            }
            get isFilled() {
                return Boolean(this._value);
            }
            _appendChar(ch, flags) {
                if (flags === void 0) flags = {};
                const details = new ChangeDetails;
                if (this.isFilled) return details;
                const appendEager = this.eager === true || this.eager === "append";
                const appended = this.char === ch;
                const isResolved = appended && (this.isUnmasking || flags.input || flags.raw) && (!flags.raw || !appendEager) && !flags.tail;
                if (isResolved) details.rawInserted = this.char;
                this._value = details.inserted = this.char;
                this._isRawInput = isResolved && (flags.raw || flags.input);
                return details;
            }
            _appendEager() {
                return this._appendChar(this.char, {
                    tail: true
                });
            }
            _appendPlaceholder() {
                const details = new ChangeDetails;
                if (this.isFilled) return details;
                this._value = details.inserted = this.char;
                return details;
            }
            extractTail() {
                return new ContinuousTailDetails("");
            }
            appendTail(tail) {
                if (isString(tail)) tail = new ContinuousTailDetails(String(tail));
                return tail.appendTo(this);
            }
            append(str, flags, tail) {
                const details = this._appendChar(str[0], flags);
                if (tail != null) details.tailShift += this.appendTail(tail).tailShift;
                return details;
            }
            doCommit() {}
            get state() {
                return {
                    _value: this._value,
                    _rawInputValue: this.rawInputValue
                };
            }
            set state(state) {
                this._value = state._value;
                this._isRawInput = Boolean(state._rawInputValue);
            }
        }
        class PatternInputDefinition {
            constructor(opts) {
                const {parent, isOptional, placeholderChar, displayChar, lazy, eager, ...maskOpts} = opts;
                this.masked = createMask(maskOpts);
                Object.assign(this, {
                    parent,
                    isOptional,
                    placeholderChar,
                    displayChar,
                    lazy,
                    eager
                });
            }
            reset() {
                this.isFilled = false;
                this.masked.reset();
            }
            remove(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.value.length;
                if (fromPos === 0 && toPos >= 1) {
                    this.isFilled = false;
                    return this.masked.remove(fromPos, toPos);
                }
                return new ChangeDetails;
            }
            get value() {
                return this.masked.value || (this.isFilled && !this.isOptional ? this.placeholderChar : "");
            }
            get unmaskedValue() {
                return this.masked.unmaskedValue;
            }
            get rawInputValue() {
                return this.masked.rawInputValue;
            }
            get displayValue() {
                return this.masked.value && this.displayChar || this.value;
            }
            get isComplete() {
                return Boolean(this.masked.value) || this.isOptional;
            }
            _appendChar(ch, flags) {
                if (flags === void 0) flags = {};
                if (this.isFilled) return new ChangeDetails;
                const state = this.masked.state;
                const details = this.masked._appendChar(ch, this.currentMaskFlags(flags));
                if (details.inserted && this.doValidate(flags) === false) {
                    details.inserted = details.rawInserted = "";
                    this.masked.state = state;
                }
                if (!details.inserted && !this.isOptional && !this.lazy && !flags.input) details.inserted = this.placeholderChar;
                details.skip = !details.inserted && !this.isOptional;
                this.isFilled = Boolean(details.inserted);
                return details;
            }
            append(str, flags, tail) {
                return this.masked.append(str, this.currentMaskFlags(flags), tail);
            }
            _appendPlaceholder() {
                const details = new ChangeDetails;
                if (this.isFilled || this.isOptional) return details;
                this.isFilled = true;
                details.inserted = this.placeholderChar;
                return details;
            }
            _appendEager() {
                return new ChangeDetails;
            }
            extractTail(fromPos, toPos) {
                return this.masked.extractTail(fromPos, toPos);
            }
            appendTail(tail) {
                return this.masked.appendTail(tail);
            }
            extractInput(fromPos, toPos, flags) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.value.length;
                return this.masked.extractInput(fromPos, toPos, flags);
            }
            nearestInputPos(cursorPos, direction) {
                if (direction === void 0) direction = DIRECTION.NONE;
                const minPos = 0;
                const maxPos = this.value.length;
                const boundPos = Math.min(Math.max(cursorPos, minPos), maxPos);
                switch (direction) {
                  case DIRECTION.LEFT:
                  case DIRECTION.FORCE_LEFT:
                    return this.isComplete ? boundPos : minPos;

                  case DIRECTION.RIGHT:
                  case DIRECTION.FORCE_RIGHT:
                    return this.isComplete ? boundPos : maxPos;

                  case DIRECTION.NONE:
                  default:
                    return boundPos;
                }
            }
            totalInputPositions(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.value.length;
                return this.value.slice(fromPos, toPos).length;
            }
            doValidate(flags) {
                return this.masked.doValidate(this.currentMaskFlags(flags)) && (!this.parent || this.parent.doValidate(this.currentMaskFlags(flags)));
            }
            doCommit() {
                this.masked.doCommit();
            }
            get state() {
                return {
                    _value: this.value,
                    _rawInputValue: this.rawInputValue,
                    masked: this.masked.state,
                    isFilled: this.isFilled
                };
            }
            set state(state) {
                this.masked.state = state.masked;
                this.isFilled = state.isFilled;
            }
            currentMaskFlags(flags) {
                var _flags$_beforeTailSta;
                return {
                    ...flags,
                    _beforeTailState: (flags == null ? void 0 : (_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.masked) || (flags == null ? void 0 : flags._beforeTailState)
                };
            }
        }
        PatternInputDefinition.DEFAULT_DEFINITIONS = {
            0: /\d/,
            a: /[\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
            "*": /./
        };
        class MaskedRegExp extends Masked {
            updateOptions(opts) {
                super.updateOptions(opts);
            }
            _update(opts) {
                const mask = opts.mask;
                if (mask) opts.validate = value => value.search(mask) >= 0;
                super._update(opts);
            }
        }
        holder_IMask.MaskedRegExp = MaskedRegExp;
        class MaskedPattern extends Masked {
            constructor(opts) {
                super({
                    ...MaskedPattern.DEFAULTS,
                    ...opts,
                    definitions: Object.assign({}, PatternInputDefinition.DEFAULT_DEFINITIONS, opts == null ? void 0 : opts.definitions)
                });
            }
            updateOptions(opts) {
                super.updateOptions(opts);
            }
            _update(opts) {
                opts.definitions = Object.assign({}, this.definitions, opts.definitions);
                super._update(opts);
                this._rebuildMask();
            }
            _rebuildMask() {
                const defs = this.definitions;
                this._blocks = [];
                this.exposeBlock = void 0;
                this._stops = [];
                this._maskedBlocks = {};
                const pattern = this.mask;
                if (!pattern || !defs) return;
                let unmaskingBlock = false;
                let optionalBlock = false;
                for (let i = 0; i < pattern.length; ++i) {
                    if (this.blocks) {
                        const p = pattern.slice(i);
                        const bNames = Object.keys(this.blocks).filter((bName => p.indexOf(bName) === 0));
                        bNames.sort(((a, b) => b.length - a.length));
                        const bName = bNames[0];
                        if (bName) {
                            const {expose, ...blockOpts} = normalizeOpts(this.blocks[bName]);
                            const maskedBlock = createMask({
                                lazy: this.lazy,
                                eager: this.eager,
                                placeholderChar: this.placeholderChar,
                                displayChar: this.displayChar,
                                overwrite: this.overwrite,
                                ...blockOpts,
                                parent: this
                            });
                            if (maskedBlock) {
                                this._blocks.push(maskedBlock);
                                if (expose) this.exposeBlock = maskedBlock;
                                if (!this._maskedBlocks[bName]) this._maskedBlocks[bName] = [];
                                this._maskedBlocks[bName].push(this._blocks.length - 1);
                            }
                            i += bName.length - 1;
                            continue;
                        }
                    }
                    let char = pattern[i];
                    let isInput = char in defs;
                    if (char === MaskedPattern.STOP_CHAR) {
                        this._stops.push(this._blocks.length);
                        continue;
                    }
                    if (char === "{" || char === "}") {
                        unmaskingBlock = !unmaskingBlock;
                        continue;
                    }
                    if (char === "[" || char === "]") {
                        optionalBlock = !optionalBlock;
                        continue;
                    }
                    if (char === MaskedPattern.ESCAPE_CHAR) {
                        ++i;
                        char = pattern[i];
                        if (!char) break;
                        isInput = false;
                    }
                    const def = isInput ? new PatternInputDefinition({
                        isOptional: optionalBlock,
                        lazy: this.lazy,
                        eager: this.eager,
                        placeholderChar: this.placeholderChar,
                        displayChar: this.displayChar,
                        ...normalizeOpts(defs[char]),
                        parent: this
                    }) : new PatternFixedDefinition({
                        char,
                        eager: this.eager,
                        isUnmasking: unmaskingBlock
                    });
                    this._blocks.push(def);
                }
            }
            get state() {
                return {
                    ...super.state,
                    _blocks: this._blocks.map((b => b.state))
                };
            }
            set state(state) {
                const {_blocks, ...maskedState} = state;
                this._blocks.forEach(((b, bi) => b.state = _blocks[bi]));
                super.state = maskedState;
            }
            reset() {
                super.reset();
                this._blocks.forEach((b => b.reset()));
            }
            get isComplete() {
                return this.exposeBlock ? this.exposeBlock.isComplete : this._blocks.every((b => b.isComplete));
            }
            get isFilled() {
                return this._blocks.every((b => b.isFilled));
            }
            get isFixed() {
                return this._blocks.every((b => b.isFixed));
            }
            get isOptional() {
                return this._blocks.every((b => b.isOptional));
            }
            doCommit() {
                this._blocks.forEach((b => b.doCommit()));
                super.doCommit();
            }
            get unmaskedValue() {
                return this.exposeBlock ? this.exposeBlock.unmaskedValue : this._blocks.reduce(((str, b) => str += b.unmaskedValue), "");
            }
            set unmaskedValue(unmaskedValue) {
                if (this.exposeBlock) {
                    const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
                    this.exposeBlock.unmaskedValue = unmaskedValue;
                    this.appendTail(tail);
                    this.doCommit();
                } else super.unmaskedValue = unmaskedValue;
            }
            get value() {
                return this.exposeBlock ? this.exposeBlock.value : this._blocks.reduce(((str, b) => str += b.value), "");
            }
            set value(value) {
                if (this.exposeBlock) {
                    const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
                    this.exposeBlock.value = value;
                    this.appendTail(tail);
                    this.doCommit();
                } else super.value = value;
            }
            get typedValue() {
                return this.exposeBlock ? this.exposeBlock.typedValue : super.typedValue;
            }
            set typedValue(value) {
                if (this.exposeBlock) {
                    const tail = this.extractTail(this._blockStartPos(this._blocks.indexOf(this.exposeBlock)) + this.exposeBlock.displayValue.length);
                    this.exposeBlock.typedValue = value;
                    this.appendTail(tail);
                    this.doCommit();
                } else super.typedValue = value;
            }
            get displayValue() {
                return this._blocks.reduce(((str, b) => str += b.displayValue), "");
            }
            appendTail(tail) {
                return super.appendTail(tail).aggregate(this._appendPlaceholder());
            }
            _appendEager() {
                var _this$_mapPosToBlock;
                const details = new ChangeDetails;
                let startBlockIndex = (_this$_mapPosToBlock = this._mapPosToBlock(this.displayValue.length)) == null ? void 0 : _this$_mapPosToBlock.index;
                if (startBlockIndex == null) return details;
                if (this._blocks[startBlockIndex].isFilled) ++startBlockIndex;
                for (let bi = startBlockIndex; bi < this._blocks.length; ++bi) {
                    const d = this._blocks[bi]._appendEager();
                    if (!d.inserted) break;
                    details.aggregate(d);
                }
                return details;
            }
            _appendCharRaw(ch, flags) {
                if (flags === void 0) flags = {};
                const blockIter = this._mapPosToBlock(this.displayValue.length);
                const details = new ChangeDetails;
                if (!blockIter) return details;
                for (let bi = blockIter.index; ;++bi) {
                    var _flags$_beforeTailSta, _flags$_beforeTailSta2;
                    const block = this._blocks[bi];
                    if (!block) break;
                    const blockDetails = block._appendChar(ch, {
                        ...flags,
                        _beforeTailState: (_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : (_flags$_beforeTailSta2 = _flags$_beforeTailSta._blocks) == null ? void 0 : _flags$_beforeTailSta2[bi]
                    });
                    const skip = blockDetails.skip;
                    details.aggregate(blockDetails);
                    if (skip || blockDetails.rawInserted) break;
                }
                return details;
            }
            extractTail(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.displayValue.length;
                const chunkTail = new ChunksTailDetails;
                if (fromPos === toPos) return chunkTail;
                this._forEachBlocksInRange(fromPos, toPos, ((b, bi, bFromPos, bToPos) => {
                    const blockChunk = b.extractTail(bFromPos, bToPos);
                    blockChunk.stop = this._findStopBefore(bi);
                    blockChunk.from = this._blockStartPos(bi);
                    if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;
                    chunkTail.extend(blockChunk);
                }));
                return chunkTail;
            }
            extractInput(fromPos, toPos, flags) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.displayValue.length;
                if (flags === void 0) flags = {};
                if (fromPos === toPos) return "";
                let input = "";
                this._forEachBlocksInRange(fromPos, toPos, ((b, _, fromPos, toPos) => {
                    input += b.extractInput(fromPos, toPos, flags);
                }));
                return input;
            }
            _findStopBefore(blockIndex) {
                let stopBefore;
                for (let si = 0; si < this._stops.length; ++si) {
                    const stop = this._stops[si];
                    if (stop <= blockIndex) stopBefore = stop; else break;
                }
                return stopBefore;
            }
            _appendPlaceholder(toBlockIndex) {
                const details = new ChangeDetails;
                if (this.lazy && toBlockIndex == null) return details;
                const startBlockIter = this._mapPosToBlock(this.displayValue.length);
                if (!startBlockIter) return details;
                const startBlockIndex = startBlockIter.index;
                const endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;
                this._blocks.slice(startBlockIndex, endBlockIndex).forEach((b => {
                    if (!b.lazy || toBlockIndex != null) {
                        var _blocks2;
                        const bDetails = b._appendPlaceholder((_blocks2 = b._blocks) == null ? void 0 : _blocks2.length);
                        this._value += bDetails.inserted;
                        details.aggregate(bDetails);
                    }
                }));
                return details;
            }
            _mapPosToBlock(pos) {
                let accVal = "";
                for (let bi = 0; bi < this._blocks.length; ++bi) {
                    const block = this._blocks[bi];
                    const blockStartPos = accVal.length;
                    accVal += block.displayValue;
                    if (pos <= accVal.length) return {
                        index: bi,
                        offset: pos - blockStartPos
                    };
                }
            }
            _blockStartPos(blockIndex) {
                return this._blocks.slice(0, blockIndex).reduce(((pos, b) => pos += b.displayValue.length), 0);
            }
            _forEachBlocksInRange(fromPos, toPos, fn) {
                if (toPos === void 0) toPos = this.displayValue.length;
                const fromBlockIter = this._mapPosToBlock(fromPos);
                if (fromBlockIter) {
                    const toBlockIter = this._mapPosToBlock(toPos);
                    const isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;
                    const fromBlockStartPos = fromBlockIter.offset;
                    const fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].displayValue.length;
                    fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);
                    if (toBlockIter && !isSameBlock) {
                        for (let bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) fn(this._blocks[bi], bi, 0, this._blocks[bi].displayValue.length);
                        fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);
                    }
                }
            }
            remove(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.displayValue.length;
                const removeDetails = super.remove(fromPos, toPos);
                this._forEachBlocksInRange(fromPos, toPos, ((b, _, bFromPos, bToPos) => {
                    removeDetails.aggregate(b.remove(bFromPos, bToPos));
                }));
                return removeDetails;
            }
            nearestInputPos(cursorPos, direction) {
                if (direction === void 0) direction = DIRECTION.NONE;
                if (!this._blocks.length) return 0;
                const cursor = new PatternCursor(this, cursorPos);
                if (direction === DIRECTION.NONE) {
                    if (cursor.pushRightBeforeInput()) return cursor.pos;
                    cursor.popState();
                    if (cursor.pushLeftBeforeInput()) return cursor.pos;
                    return this.displayValue.length;
                }
                if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {
                    if (direction === DIRECTION.LEFT) {
                        cursor.pushRightBeforeFilled();
                        if (cursor.ok && cursor.pos === cursorPos) return cursorPos;
                        cursor.popState();
                    }
                    cursor.pushLeftBeforeInput();
                    cursor.pushLeftBeforeRequired();
                    cursor.pushLeftBeforeFilled();
                    if (direction === DIRECTION.LEFT) {
                        cursor.pushRightBeforeInput();
                        cursor.pushRightBeforeRequired();
                        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;
                        cursor.popState();
                        if (cursor.ok && cursor.pos <= cursorPos) return cursor.pos;
                        cursor.popState();
                    }
                    if (cursor.ok) return cursor.pos;
                    if (direction === DIRECTION.FORCE_LEFT) return 0;
                    cursor.popState();
                    if (cursor.ok) return cursor.pos;
                    cursor.popState();
                    if (cursor.ok) return cursor.pos;
                    return 0;
                }
                if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {
                    cursor.pushRightBeforeInput();
                    cursor.pushRightBeforeRequired();
                    if (cursor.pushRightBeforeFilled()) return cursor.pos;
                    if (direction === DIRECTION.FORCE_RIGHT) return this.displayValue.length;
                    cursor.popState();
                    if (cursor.ok) return cursor.pos;
                    cursor.popState();
                    if (cursor.ok) return cursor.pos;
                    return this.nearestInputPos(cursorPos, DIRECTION.LEFT);
                }
                return cursorPos;
            }
            totalInputPositions(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.displayValue.length;
                let total = 0;
                this._forEachBlocksInRange(fromPos, toPos, ((b, _, bFromPos, bToPos) => {
                    total += b.totalInputPositions(bFromPos, bToPos);
                }));
                return total;
            }
            maskedBlock(name) {
                return this.maskedBlocks(name)[0];
            }
            maskedBlocks(name) {
                const indices = this._maskedBlocks[name];
                if (!indices) return [];
                return indices.map((gi => this._blocks[gi]));
            }
        }
        MaskedPattern.DEFAULTS = {
            lazy: true,
            placeholderChar: "_"
        };
        MaskedPattern.STOP_CHAR = "`";
        MaskedPattern.ESCAPE_CHAR = "\\";
        MaskedPattern.InputDefinition = PatternInputDefinition;
        MaskedPattern.FixedDefinition = PatternFixedDefinition;
        holder_IMask.MaskedPattern = MaskedPattern;
        class MaskedRange extends MaskedPattern {
            get _matchFrom() {
                return this.maxLength - String(this.from).length;
            }
            constructor(opts) {
                super(opts);
            }
            updateOptions(opts) {
                super.updateOptions(opts);
            }
            _update(opts) {
                const {to = this.to || 0, from = this.from || 0, maxLength = this.maxLength || 0, autofix = this.autofix, ...patternOpts} = opts;
                this.to = to;
                this.from = from;
                this.maxLength = Math.max(String(to).length, maxLength);
                this.autofix = autofix;
                const fromStr = String(this.from).padStart(this.maxLength, "0");
                const toStr = String(this.to).padStart(this.maxLength, "0");
                let sameCharsCount = 0;
                while (sameCharsCount < toStr.length && toStr[sameCharsCount] === fromStr[sameCharsCount]) ++sameCharsCount;
                patternOpts.mask = toStr.slice(0, sameCharsCount).replace(/0/g, "\\0") + "0".repeat(this.maxLength - sameCharsCount);
                super._update(patternOpts);
            }
            get isComplete() {
                return super.isComplete && Boolean(this.value);
            }
            boundaries(str) {
                let minstr = "";
                let maxstr = "";
                const [, placeholder, num] = str.match(/^(\D*)(\d*)(\D*)/) || [];
                if (num) {
                    minstr = "0".repeat(placeholder.length) + num;
                    maxstr = "9".repeat(placeholder.length) + num;
                }
                minstr = minstr.padEnd(this.maxLength, "0");
                maxstr = maxstr.padEnd(this.maxLength, "9");
                return [ minstr, maxstr ];
            }
            doPrepareChar(ch, flags) {
                if (flags === void 0) flags = {};
                let details;
                [ch, details] = super.doPrepareChar(ch.replace(/\D/g, ""), flags);
                if (!this.autofix || !ch) return [ ch, details ];
                const fromStr = String(this.from).padStart(this.maxLength, "0");
                const toStr = String(this.to).padStart(this.maxLength, "0");
                const nextVal = this.value + ch;
                if (nextVal.length > this.maxLength) return [ "", details ];
                const [minstr, maxstr] = this.boundaries(nextVal);
                if (Number(maxstr) < this.from) return [ fromStr[nextVal.length - 1], details ];
                if (Number(minstr) > this.to) {
                    if (this.autofix === "pad" && nextVal.length < this.maxLength) return [ "", details.aggregate(this.append(fromStr[nextVal.length - 1] + ch, flags)) ];
                    return [ toStr[nextVal.length - 1], details ];
                }
                return [ ch, details ];
            }
            doValidate(flags) {
                const str = this.value;
                const firstNonZero = str.search(/[^0]/);
                if (firstNonZero === -1 && str.length <= this._matchFrom) return true;
                const [minstr, maxstr] = this.boundaries(str);
                return this.from <= Number(maxstr) && Number(minstr) <= this.to && super.doValidate(flags);
            }
        }
        holder_IMask.MaskedRange = MaskedRange;
        class MaskedDate extends MaskedPattern {
            constructor(opts) {
                const {mask, pattern, ...patternOpts} = {
                    ...MaskedDate.DEFAULTS,
                    ...opts
                };
                super({
                    ...patternOpts,
                    mask: isString(mask) ? mask : pattern
                });
            }
            updateOptions(opts) {
                super.updateOptions(opts);
            }
            _update(opts) {
                const {mask, pattern, blocks, ...patternOpts} = {
                    ...MaskedDate.DEFAULTS,
                    ...opts
                };
                const patternBlocks = Object.assign({}, MaskedDate.GET_DEFAULT_BLOCKS());
                if (opts.min) patternBlocks.Y.from = opts.min.getFullYear();
                if (opts.max) patternBlocks.Y.to = opts.max.getFullYear();
                if (opts.min && opts.max && patternBlocks.Y.from === patternBlocks.Y.to) {
                    patternBlocks.m.from = opts.min.getMonth() + 1;
                    patternBlocks.m.to = opts.max.getMonth() + 1;
                    if (patternBlocks.m.from === patternBlocks.m.to) {
                        patternBlocks.d.from = opts.min.getDate();
                        patternBlocks.d.to = opts.max.getDate();
                    }
                }
                Object.assign(patternBlocks, this.blocks, blocks);
                Object.keys(patternBlocks).forEach((bk => {
                    const b = patternBlocks[bk];
                    if (!("autofix" in b) && "autofix" in opts) b.autofix = opts.autofix;
                }));
                super._update({
                    ...patternOpts,
                    mask: isString(mask) ? mask : pattern,
                    blocks: patternBlocks
                });
            }
            doValidate(flags) {
                const date = this.date;
                return super.doValidate(flags) && (!this.isComplete || this.isDateExist(this.value) && date != null && (this.min == null || this.min <= date) && (this.max == null || date <= this.max));
            }
            isDateExist(str) {
                return this.format(this.parse(str, this), this).indexOf(str) >= 0;
            }
            get date() {
                return this.typedValue;
            }
            set date(date) {
                this.typedValue = date;
            }
            get typedValue() {
                return this.isComplete ? super.typedValue : null;
            }
            set typedValue(value) {
                super.typedValue = value;
            }
            maskEquals(mask) {
                return mask === Date || super.maskEquals(mask);
            }
        }
        MaskedDate.GET_DEFAULT_BLOCKS = () => ({
            d: {
                mask: MaskedRange,
                from: 1,
                to: 31,
                maxLength: 2
            },
            m: {
                mask: MaskedRange,
                from: 1,
                to: 12,
                maxLength: 2
            },
            Y: {
                mask: MaskedRange,
                from: 1900,
                to: 9999
            }
        });
        MaskedDate.DEFAULTS = {
            mask: Date,
            pattern: "d{.}`m{.}`Y",
            format: (date, masked) => {
                if (!date) return "";
                const day = String(date.getDate()).padStart(2, "0");
                const month = String(date.getMonth() + 1).padStart(2, "0");
                const year = date.getFullYear();
                return [ day, month, year ].join(".");
            },
            parse: (str, masked) => {
                const [day, month, year] = str.split(".").map(Number);
                return new Date(year, month - 1, day);
            }
        };
        holder_IMask.MaskedDate = MaskedDate;
        class MaskedDynamic extends Masked {
            constructor(opts) {
                super({
                    ...MaskedDynamic.DEFAULTS,
                    ...opts
                });
                this.currentMask = void 0;
            }
            updateOptions(opts) {
                super.updateOptions(opts);
            }
            _update(opts) {
                super._update(opts);
                if ("mask" in opts) {
                    this.exposeMask = void 0;
                    this.compiledMasks = Array.isArray(opts.mask) ? opts.mask.map((m => {
                        const {expose, ...maskOpts} = normalizeOpts(m);
                        const masked = createMask({
                            overwrite: this._overwrite,
                            eager: this._eager,
                            skipInvalid: this._skipInvalid,
                            ...maskOpts
                        });
                        if (expose) this.exposeMask = masked;
                        return masked;
                    })) : [];
                }
            }
            _appendCharRaw(ch, flags) {
                if (flags === void 0) flags = {};
                const details = this._applyDispatch(ch, flags);
                if (this.currentMask) details.aggregate(this.currentMask._appendChar(ch, this.currentMaskFlags(flags)));
                return details;
            }
            _applyDispatch(appended, flags, tail) {
                if (appended === void 0) appended = "";
                if (flags === void 0) flags = {};
                if (tail === void 0) tail = "";
                const prevValueBeforeTail = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._value : this.value;
                const inputValue = this.rawInputValue;
                const insertValue = flags.tail && flags._beforeTailState != null ? flags._beforeTailState._rawInputValue : inputValue;
                const tailValue = inputValue.slice(insertValue.length);
                const prevMask = this.currentMask;
                const details = new ChangeDetails;
                const prevMaskState = prevMask == null ? void 0 : prevMask.state;
                this.currentMask = this.doDispatch(appended, {
                    ...flags
                }, tail);
                if (this.currentMask) if (this.currentMask !== prevMask) {
                    this.currentMask.reset();
                    if (insertValue) {
                        const d = this.currentMask.append(insertValue, {
                            raw: true
                        });
                        details.tailShift = d.inserted.length - prevValueBeforeTail.length;
                    }
                    if (tailValue) details.tailShift += this.currentMask.append(tailValue, {
                        raw: true,
                        tail: true
                    }).tailShift;
                } else if (prevMaskState) this.currentMask.state = prevMaskState;
                return details;
            }
            _appendPlaceholder() {
                const details = this._applyDispatch();
                if (this.currentMask) details.aggregate(this.currentMask._appendPlaceholder());
                return details;
            }
            _appendEager() {
                const details = this._applyDispatch();
                if (this.currentMask) details.aggregate(this.currentMask._appendEager());
                return details;
            }
            appendTail(tail) {
                const details = new ChangeDetails;
                if (tail) details.aggregate(this._applyDispatch("", {}, tail));
                return details.aggregate(this.currentMask ? this.currentMask.appendTail(tail) : super.appendTail(tail));
            }
            currentMaskFlags(flags) {
                var _flags$_beforeTailSta, _flags$_beforeTailSta2;
                return {
                    ...flags,
                    _beforeTailState: ((_flags$_beforeTailSta = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta.currentMaskRef) === this.currentMask && ((_flags$_beforeTailSta2 = flags._beforeTailState) == null ? void 0 : _flags$_beforeTailSta2.currentMask) || flags._beforeTailState
                };
            }
            doDispatch(appended, flags, tail) {
                if (flags === void 0) flags = {};
                if (tail === void 0) tail = "";
                return this.dispatch(appended, this, flags, tail);
            }
            doValidate(flags) {
                return super.doValidate(flags) && (!this.currentMask || this.currentMask.doValidate(this.currentMaskFlags(flags)));
            }
            doPrepare(str, flags) {
                if (flags === void 0) flags = {};
                let [s, details] = super.doPrepare(str, flags);
                if (this.currentMask) {
                    let currentDetails;
                    [s, currentDetails] = super.doPrepare(s, this.currentMaskFlags(flags));
                    details = details.aggregate(currentDetails);
                }
                return [ s, details ];
            }
            doPrepareChar(str, flags) {
                if (flags === void 0) flags = {};
                let [s, details] = super.doPrepareChar(str, flags);
                if (this.currentMask) {
                    let currentDetails;
                    [s, currentDetails] = super.doPrepareChar(s, this.currentMaskFlags(flags));
                    details = details.aggregate(currentDetails);
                }
                return [ s, details ];
            }
            reset() {
                var _this$currentMask;
                (_this$currentMask = this.currentMask) == null ? void 0 : _this$currentMask.reset();
                this.compiledMasks.forEach((m => m.reset()));
            }
            get value() {
                return this.exposeMask ? this.exposeMask.value : this.currentMask ? this.currentMask.value : "";
            }
            set value(value) {
                if (this.exposeMask) {
                    this.exposeMask.value = value;
                    this.currentMask = this.exposeMask;
                    this._applyDispatch();
                } else super.value = value;
            }
            get unmaskedValue() {
                return this.exposeMask ? this.exposeMask.unmaskedValue : this.currentMask ? this.currentMask.unmaskedValue : "";
            }
            set unmaskedValue(unmaskedValue) {
                if (this.exposeMask) {
                    this.exposeMask.unmaskedValue = unmaskedValue;
                    this.currentMask = this.exposeMask;
                    this._applyDispatch();
                } else super.unmaskedValue = unmaskedValue;
            }
            get typedValue() {
                return this.exposeMask ? this.exposeMask.typedValue : this.currentMask ? this.currentMask.typedValue : "";
            }
            set typedValue(typedValue) {
                if (this.exposeMask) {
                    this.exposeMask.typedValue = typedValue;
                    this.currentMask = this.exposeMask;
                    this._applyDispatch();
                    return;
                }
                let unmaskedValue = String(typedValue);
                if (this.currentMask) {
                    this.currentMask.typedValue = typedValue;
                    unmaskedValue = this.currentMask.unmaskedValue;
                }
                this.unmaskedValue = unmaskedValue;
            }
            get displayValue() {
                return this.currentMask ? this.currentMask.displayValue : "";
            }
            get isComplete() {
                var _this$currentMask2;
                return Boolean((_this$currentMask2 = this.currentMask) == null ? void 0 : _this$currentMask2.isComplete);
            }
            get isFilled() {
                var _this$currentMask3;
                return Boolean((_this$currentMask3 = this.currentMask) == null ? void 0 : _this$currentMask3.isFilled);
            }
            remove(fromPos, toPos) {
                const details = new ChangeDetails;
                if (this.currentMask) details.aggregate(this.currentMask.remove(fromPos, toPos)).aggregate(this._applyDispatch());
                return details;
            }
            get state() {
                var _this$currentMask4;
                return {
                    ...super.state,
                    _rawInputValue: this.rawInputValue,
                    compiledMasks: this.compiledMasks.map((m => m.state)),
                    currentMaskRef: this.currentMask,
                    currentMask: (_this$currentMask4 = this.currentMask) == null ? void 0 : _this$currentMask4.state
                };
            }
            set state(state) {
                const {compiledMasks, currentMaskRef, currentMask, ...maskedState} = state;
                if (compiledMasks) this.compiledMasks.forEach(((m, mi) => m.state = compiledMasks[mi]));
                if (currentMaskRef != null) {
                    this.currentMask = currentMaskRef;
                    this.currentMask.state = currentMask;
                }
                super.state = maskedState;
            }
            extractInput(fromPos, toPos, flags) {
                return this.currentMask ? this.currentMask.extractInput(fromPos, toPos, flags) : "";
            }
            extractTail(fromPos, toPos) {
                return this.currentMask ? this.currentMask.extractTail(fromPos, toPos) : super.extractTail(fromPos, toPos);
            }
            doCommit() {
                if (this.currentMask) this.currentMask.doCommit();
                super.doCommit();
            }
            nearestInputPos(cursorPos, direction) {
                return this.currentMask ? this.currentMask.nearestInputPos(cursorPos, direction) : super.nearestInputPos(cursorPos, direction);
            }
            get overwrite() {
                return this.currentMask ? this.currentMask.overwrite : this._overwrite;
            }
            set overwrite(overwrite) {
                this._overwrite = overwrite;
            }
            get eager() {
                return this.currentMask ? this.currentMask.eager : this._eager;
            }
            set eager(eager) {
                this._eager = eager;
            }
            get skipInvalid() {
                return this.currentMask ? this.currentMask.skipInvalid : this._skipInvalid;
            }
            set skipInvalid(skipInvalid) {
                this._skipInvalid = skipInvalid;
            }
            maskEquals(mask) {
                return Array.isArray(mask) ? this.compiledMasks.every(((m, mi) => {
                    if (!mask[mi]) return;
                    const {mask: oldMask, ...restOpts} = mask[mi];
                    return objectIncludes(m, restOpts) && m.maskEquals(oldMask);
                })) : super.maskEquals(mask);
            }
            typedValueEquals(value) {
                var _this$currentMask5;
                return Boolean((_this$currentMask5 = this.currentMask) == null ? void 0 : _this$currentMask5.typedValueEquals(value));
            }
        }
        MaskedDynamic.DEFAULTS = void 0;
        MaskedDynamic.DEFAULTS = {
            dispatch: (appended, masked, flags, tail) => {
                if (!masked.compiledMasks.length) return;
                const inputValue = masked.rawInputValue;
                const inputs = masked.compiledMasks.map(((m, index) => {
                    const isCurrent = masked.currentMask === m;
                    const startInputPos = isCurrent ? m.displayValue.length : m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT);
                    if (m.rawInputValue !== inputValue) {
                        m.reset();
                        m.append(inputValue, {
                            raw: true
                        });
                    } else if (!isCurrent) m.remove(startInputPos);
                    m.append(appended, masked.currentMaskFlags(flags));
                    m.appendTail(tail);
                    return {
                        index,
                        weight: m.rawInputValue.length,
                        totalInputPositions: m.totalInputPositions(0, Math.max(startInputPos, m.nearestInputPos(m.displayValue.length, DIRECTION.FORCE_LEFT)))
                    };
                }));
                inputs.sort(((i1, i2) => i2.weight - i1.weight || i2.totalInputPositions - i1.totalInputPositions));
                return masked.compiledMasks[inputs[0].index];
            }
        };
        holder_IMask.MaskedDynamic = MaskedDynamic;
        class MaskedEnum extends MaskedPattern {
            updateOptions(opts) {
                super.updateOptions(opts);
            }
            _update(opts) {
                const {enum: _enum, ...eopts} = opts;
                if (_enum) {
                    eopts.mask = "*".repeat(_enum[0].length);
                    this.enum = _enum;
                }
                super._update(eopts);
            }
            doValidate(flags) {
                return this.enum.some((e => e.indexOf(this.unmaskedValue) >= 0)) && super.doValidate(flags);
            }
        }
        holder_IMask.MaskedEnum = MaskedEnum;
        class MaskedFunction extends Masked {
            updateOptions(opts) {
                super.updateOptions(opts);
            }
            _update(opts) {
                super._update({
                    ...opts,
                    validate: opts.mask
                });
            }
        }
        holder_IMask.MaskedFunction = MaskedFunction;
        class MaskedNumber extends Masked {
            constructor(opts) {
                super({
                    ...MaskedNumber.DEFAULTS,
                    ...opts
                });
            }
            updateOptions(opts) {
                super.updateOptions(opts);
            }
            _update(opts) {
                super._update(opts);
                this._updateRegExps();
            }
            _updateRegExps() {
                const start = "^" + (this.allowNegative ? "[+|\\-]?" : "");
                const mid = "\\d*";
                const end = (this.scale ? "(" + escapeRegExp(this.radix) + "\\d{0," + this.scale + "})?" : "") + "$";
                this._numberRegExp = new RegExp(start + mid + end);
                this._mapToRadixRegExp = new RegExp("[" + this.mapToRadix.map(escapeRegExp).join("") + "]", "g");
                this._thousandsSeparatorRegExp = new RegExp(escapeRegExp(this.thousandsSeparator), "g");
            }
            _removeThousandsSeparators(value) {
                return value.replace(this._thousandsSeparatorRegExp, "");
            }
            _insertThousandsSeparators(value) {
                const parts = value.split(this.radix);
                parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, this.thousandsSeparator);
                return parts.join(this.radix);
            }
            doPrepareChar(ch, flags) {
                if (flags === void 0) flags = {};
                ch = this._removeThousandsSeparators(this.scale && this.mapToRadix.length && (flags.input && flags.raw || !flags.input && !flags.raw) ? ch.replace(this._mapToRadixRegExp, this.radix) : ch);
                const [prepCh, details] = super.doPrepareChar(ch, flags);
                if (ch && !prepCh) details.skip = true;
                if (prepCh && !this.allowPositive && !this.value && prepCh !== "-") details.aggregate(this._appendChar("-"));
                return [ prepCh, details ];
            }
            _separatorsCount(to, extendOnSeparators) {
                if (extendOnSeparators === void 0) extendOnSeparators = false;
                let count = 0;
                for (let pos = 0; pos < to; ++pos) if (this._value.indexOf(this.thousandsSeparator, pos) === pos) {
                    ++count;
                    if (extendOnSeparators) to += this.thousandsSeparator.length;
                }
                return count;
            }
            _separatorsCountFromSlice(slice) {
                if (slice === void 0) slice = this._value;
                return this._separatorsCount(this._removeThousandsSeparators(slice).length, true);
            }
            extractInput(fromPos, toPos, flags) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.displayValue.length;
                [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);
                return this._removeThousandsSeparators(super.extractInput(fromPos, toPos, flags));
            }
            _appendCharRaw(ch, flags) {
                if (flags === void 0) flags = {};
                if (!this.thousandsSeparator) return super._appendCharRaw(ch, flags);
                const prevBeforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;
                const prevBeforeTailSeparatorsCount = this._separatorsCountFromSlice(prevBeforeTailValue);
                this._value = this._removeThousandsSeparators(this.value);
                const appendDetails = super._appendCharRaw(ch, flags);
                this._value = this._insertThousandsSeparators(this._value);
                const beforeTailValue = flags.tail && flags._beforeTailState ? flags._beforeTailState._value : this._value;
                const beforeTailSeparatorsCount = this._separatorsCountFromSlice(beforeTailValue);
                appendDetails.tailShift += (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length;
                appendDetails.skip = !appendDetails.rawInserted && ch === this.thousandsSeparator;
                return appendDetails;
            }
            _findSeparatorAround(pos) {
                if (this.thousandsSeparator) {
                    const searchFrom = pos - this.thousandsSeparator.length + 1;
                    const separatorPos = this.value.indexOf(this.thousandsSeparator, searchFrom);
                    if (separatorPos <= pos) return separatorPos;
                }
                return -1;
            }
            _adjustRangeWithSeparators(from, to) {
                const separatorAroundFromPos = this._findSeparatorAround(from);
                if (separatorAroundFromPos >= 0) from = separatorAroundFromPos;
                const separatorAroundToPos = this._findSeparatorAround(to);
                if (separatorAroundToPos >= 0) to = separatorAroundToPos + this.thousandsSeparator.length;
                return [ from, to ];
            }
            remove(fromPos, toPos) {
                if (fromPos === void 0) fromPos = 0;
                if (toPos === void 0) toPos = this.displayValue.length;
                [fromPos, toPos] = this._adjustRangeWithSeparators(fromPos, toPos);
                const valueBeforePos = this.value.slice(0, fromPos);
                const valueAfterPos = this.value.slice(toPos);
                const prevBeforeTailSeparatorsCount = this._separatorsCount(valueBeforePos.length);
                this._value = this._insertThousandsSeparators(this._removeThousandsSeparators(valueBeforePos + valueAfterPos));
                const beforeTailSeparatorsCount = this._separatorsCountFromSlice(valueBeforePos);
                return new ChangeDetails({
                    tailShift: (beforeTailSeparatorsCount - prevBeforeTailSeparatorsCount) * this.thousandsSeparator.length
                });
            }
            nearestInputPos(cursorPos, direction) {
                if (!this.thousandsSeparator) return cursorPos;
                switch (direction) {
                  case DIRECTION.NONE:
                  case DIRECTION.LEFT:
                  case DIRECTION.FORCE_LEFT:
                    {
                        const separatorAtLeftPos = this._findSeparatorAround(cursorPos - 1);
                        if (separatorAtLeftPos >= 0) {
                            const separatorAtLeftEndPos = separatorAtLeftPos + this.thousandsSeparator.length;
                            if (cursorPos < separatorAtLeftEndPos || this.value.length <= separatorAtLeftEndPos || direction === DIRECTION.FORCE_LEFT) return separatorAtLeftPos;
                        }
                        break;
                    }

                  case DIRECTION.RIGHT:
                  case DIRECTION.FORCE_RIGHT:
                    {
                        const separatorAtRightPos = this._findSeparatorAround(cursorPos);
                        if (separatorAtRightPos >= 0) return separatorAtRightPos + this.thousandsSeparator.length;
                    }
                }
                return cursorPos;
            }
            doValidate(flags) {
                let valid = Boolean(this._removeThousandsSeparators(this.value).match(this._numberRegExp));
                if (valid) {
                    const number = this.number;
                    valid = valid && !isNaN(number) && (this.min == null || this.min >= 0 || this.min <= this.number) && (this.max == null || this.max <= 0 || this.number <= this.max);
                }
                return valid && super.doValidate(flags);
            }
            doCommit() {
                if (this.value) {
                    const number = this.number;
                    let validnum = number;
                    if (this.min != null) validnum = Math.max(validnum, this.min);
                    if (this.max != null) validnum = Math.min(validnum, this.max);
                    if (validnum !== number) this.unmaskedValue = this.format(validnum, this);
                    let formatted = this.value;
                    if (this.normalizeZeros) formatted = this._normalizeZeros(formatted);
                    if (this.padFractionalZeros && this.scale > 0) formatted = this._padFractionalZeros(formatted);
                    this._value = formatted;
                }
                super.doCommit();
            }
            _normalizeZeros(value) {
                const parts = this._removeThousandsSeparators(value).split(this.radix);
                parts[0] = parts[0].replace(/^(\D*)(0*)(\d*)/, ((match, sign, zeros, num) => sign + num));
                if (value.length && !/\d$/.test(parts[0])) parts[0] = parts[0] + "0";
                if (parts.length > 1) {
                    parts[1] = parts[1].replace(/0*$/, "");
                    if (!parts[1].length) parts.length = 1;
                }
                return this._insertThousandsSeparators(parts.join(this.radix));
            }
            _padFractionalZeros(value) {
                if (!value) return value;
                const parts = value.split(this.radix);
                if (parts.length < 2) parts.push("");
                parts[1] = parts[1].padEnd(this.scale, "0");
                return parts.join(this.radix);
            }
            doSkipInvalid(ch, flags, checkTail) {
                if (flags === void 0) flags = {};
                const dropFractional = this.scale === 0 && ch !== this.thousandsSeparator && (ch === this.radix || ch === MaskedNumber.UNMASKED_RADIX || this.mapToRadix.includes(ch));
                return super.doSkipInvalid(ch, flags, checkTail) && !dropFractional;
            }
            get unmaskedValue() {
                return this._removeThousandsSeparators(this._normalizeZeros(this.value)).replace(this.radix, MaskedNumber.UNMASKED_RADIX);
            }
            set unmaskedValue(unmaskedValue) {
                super.unmaskedValue = unmaskedValue;
            }
            get typedValue() {
                return this.parse(this.unmaskedValue, this);
            }
            set typedValue(n) {
                this.rawInputValue = this.format(n, this).replace(MaskedNumber.UNMASKED_RADIX, this.radix);
            }
            get number() {
                return this.typedValue;
            }
            set number(number) {
                this.typedValue = number;
            }
            get allowNegative() {
                return this.min != null && this.min < 0 || this.max != null && this.max < 0;
            }
            get allowPositive() {
                return this.min != null && this.min > 0 || this.max != null && this.max > 0;
            }
            typedValueEquals(value) {
                return (super.typedValueEquals(value) || MaskedNumber.EMPTY_VALUES.includes(value) && MaskedNumber.EMPTY_VALUES.includes(this.typedValue)) && !(value === 0 && this.value === "");
            }
        }
        MaskedNumber.UNMASKED_RADIX = ".";
        MaskedNumber.EMPTY_VALUES = [ ...Masked.EMPTY_VALUES, 0 ];
        MaskedNumber.DEFAULTS = {
            mask: Number,
            radix: ",",
            thousandsSeparator: "",
            mapToRadix: [ MaskedNumber.UNMASKED_RADIX ],
            min: Number.MIN_SAFE_INTEGER,
            max: Number.MAX_SAFE_INTEGER,
            scale: 2,
            normalizeZeros: true,
            padFractionalZeros: false,
            parse: Number,
            format: n => n.toLocaleString("en-US", {
                useGrouping: false,
                maximumFractionDigits: 20
            })
        };
        holder_IMask.MaskedNumber = MaskedNumber;
        const PIPE_TYPE = {
            MASKED: "value",
            UNMASKED: "unmaskedValue",
            TYPED: "typedValue"
        };
        function createPipe(arg, from, to) {
            if (from === void 0) from = PIPE_TYPE.MASKED;
            if (to === void 0) to = PIPE_TYPE.MASKED;
            const masked = createMask(arg);
            return value => masked.runIsolated((m => {
                m[from] = value;
                return m[to];
            }));
        }
        function pipe(value, mask, from, to) {
            return createPipe(mask, from, to)(value);
        }
        holder_IMask.PIPE_TYPE = PIPE_TYPE;
        holder_IMask.createPipe = createPipe;
        holder_IMask.pipe = pipe;
        try {
            globalThis.IMask = holder_IMask;
        } catch {}
        class Popup {
            constructor(options) {
                let config = {
                    logging: true,
                    init: true,
                    attributeOpenButton: "data-popup",
                    attributeCloseButton: "data-close",
                    fixElementSelector: "[data-lp]",
                    youtubeAttribute: "data-popup-youtube",
                    youtubePlaceAttribute: "data-popup-youtube-place",
                    setAutoplayYoutube: true,
                    classes: {
                        popup: "popup",
                        popupContent: "popup__content",
                        popupActive: "popup_show",
                        bodyActive: "popup-show"
                    },
                    focusCatch: true,
                    closeEsc: true,
                    bodyLock: true,
                    hashSettings: {
                        location: true,
                        goHash: true
                    },
                    on: {
                        beforeOpen: function() {},
                        afterOpen: function() {},
                        beforeClose: function() {},
                        afterClose: function() {}
                    }
                };
                this.youTubeCode;
                this.isOpen = false;
                this.targetOpen = {
                    selector: false,
                    element: false
                };
                this.previousOpen = {
                    selector: false,
                    element: false
                };
                this.lastClosed = {
                    selector: false,
                    element: false
                };
                this._dataValue = false;
                this.hash = false;
                this._reopen = false;
                this._selectorOpen = false;
                this.lastFocusEl = false;
                this._focusEl = [ "a[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "button:not([disabled]):not([aria-hidden])", "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "area[href]", "iframe", "object", "embed", "[contenteditable]", '[tabindex]:not([tabindex^="-"])' ];
                this.options = {
                    ...config,
                    ...options,
                    classes: {
                        ...config.classes,
                        ...options?.classes
                    },
                    hashSettings: {
                        ...config.hashSettings,
                        ...options?.hashSettings
                    },
                    on: {
                        ...config.on,
                        ...options?.on
                    }
                };
                this.bodyLock = false;
                this.options.init ? this.initPopups() : null;
            }
            initPopups() {
                this.popupLogging(`–ü—Ä–æ—Å–Ω—É–ª—Å—è`);
                this.eventsPopup();
            }
            eventsPopup() {
                document.addEventListener("click", function(e) {
                    const buttonOpen = e.target.closest(`[${this.options.attributeOpenButton}]`);
                    if (buttonOpen) {
                        e.preventDefault();
                        this._dataValue = buttonOpen.getAttribute(this.options.attributeOpenButton) ? buttonOpen.getAttribute(this.options.attributeOpenButton) : "error";
                        this.youTubeCode = buttonOpen.getAttribute(this.options.youtubeAttribute) ? buttonOpen.getAttribute(this.options.youtubeAttribute) : null;
                        if (this._dataValue !== "error") {
                            if (!this.isOpen) this.lastFocusEl = buttonOpen;
                            this.targetOpen.selector = `${this._dataValue}`;
                            this._selectorOpen = true;
                            this.open();
                            return;
                        } else this.popupLogging(`–ï–π, –Ω–µ –∑–∞–ø–æ–ª–Ω–µ–Ω –∞—Ç—Ä–∏–±—É—Ç —É ${buttonOpen.classList}`);
                        return;
                    }
                    const buttonClose = e.target.closest(`[${this.options.attributeCloseButton}]`);
                    if (buttonClose || !e.target.closest(`.${this.options.classes.popupContent}`) && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                }.bind(this));
                document.addEventListener("keydown", function(e) {
                    if (this.options.closeEsc && e.which == 27 && e.code === "Escape" && this.isOpen) {
                        e.preventDefault();
                        this.close();
                        return;
                    }
                    if (this.options.focusCatch && e.which == 9 && this.isOpen) {
                        this._focusCatch(e);
                        return;
                    }
                }.bind(this));
                if (this.options.hashSettings.goHash) {
                    window.addEventListener("hashchange", function() {
                        if (window.location.hash) this._openToHash(); else this.close(this.targetOpen.selector);
                    }.bind(this));
                    window.addEventListener("load", function() {
                        if (window.location.hash) this._openToHash();
                    }.bind(this));
                }
            }
            open(selectorValue) {
                if (bodyLockStatus) {
                    this.bodyLock = document.documentElement.classList.contains("lock") && !this.isOpen ? true : false;
                    if (selectorValue && typeof selectorValue === "string" && selectorValue.trim() !== "") {
                        this.targetOpen.selector = selectorValue;
                        this._selectorOpen = true;
                    }
                    if (this.isOpen) {
                        this._reopen = true;
                        this.close();
                    }
                    if (!this._selectorOpen) this.targetOpen.selector = this.lastClosed.selector;
                    if (!this._reopen) this.previousActiveElement = document.activeElement;
                    this.targetOpen.element = document.querySelector(this.targetOpen.selector);
                    if (this.targetOpen.element) {
                        if (this.youTubeCode) {
                            const codeVideo = this.youTubeCode;
                            const urlVideo = `https://www.youtube.com/embed/${codeVideo}?rel=0&showinfo=0&autoplay=1`;
                            const iframe = document.createElement("iframe");
                            iframe.setAttribute("allowfullscreen", "");
                            const autoplay = this.options.setAutoplayYoutube ? "autoplay;" : "";
                            iframe.setAttribute("allow", `${autoplay}; encrypted-media`);
                            iframe.setAttribute("src", urlVideo);
                            if (!this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) {
                                this.targetOpen.element.querySelector(".popup__text").setAttribute(`${this.options.youtubePlaceAttribute}`, "");
                            }
                            this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).appendChild(iframe);
                        }
                        if (this.options.hashSettings.location) {
                            this._getHash();
                            this._setHash();
                        }
                        this.options.on.beforeOpen(this);
                        document.dispatchEvent(new CustomEvent("beforePopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.targetOpen.element.classList.add(this.options.classes.popupActive);
                        document.documentElement.classList.add(this.options.classes.bodyActive);
                        if (!this._reopen) !this.bodyLock ? bodyLock() : null; else this._reopen = false;
                        this.targetOpen.element.setAttribute("aria-hidden", "false");
                        this.previousOpen.selector = this.targetOpen.selector;
                        this.previousOpen.element = this.targetOpen.element;
                        this._selectorOpen = false;
                        this.isOpen = true;
                        setTimeout((() => {
                            this._focusTrap();
                        }), 50);
                        this.options.on.afterOpen(this);
                        document.dispatchEvent(new CustomEvent("afterPopupOpen", {
                            detail: {
                                popup: this
                            }
                        }));
                        this.popupLogging(`–û—Ç–∫—Ä—ã–ª –ø–æ–ø–∞–ø`);
                    } else this.popupLogging(`–û–π, –Ω–µ—Ç —Ç–∞–∫–æ–≥–æ –ø–æ–ø–∞–ø–∞. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –≤–≤–æ–¥–∞`);
                }
            }
            close(selectorValue) {
                if (selectorValue && typeof selectorValue === "string" && selectorValue.trim() !== "") this.previousOpen.selector = selectorValue;
                if (!this.isOpen || !bodyLockStatus) return;
                this.options.on.beforeClose(this);
                document.dispatchEvent(new CustomEvent("beforePopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                if (this.youTubeCode) if (this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`)) this.targetOpen.element.querySelector(`[${this.options.youtubePlaceAttribute}]`).innerHTML = "";
                this.previousOpen.element.classList.remove(this.options.classes.popupActive);
                this.previousOpen.element.setAttribute("aria-hidden", "true");
                if (!this._reopen) {
                    document.documentElement.classList.remove(this.options.classes.bodyActive);
                    !this.bodyLock ? bodyUnlock() : null;
                    this.isOpen = false;
                }
                this._removeHash();
                if (this._selectorOpen) {
                    this.lastClosed.selector = this.previousOpen.selector;
                    this.lastClosed.element = this.previousOpen.element;
                }
                this.options.on.afterClose(this);
                document.dispatchEvent(new CustomEvent("afterPopupClose", {
                    detail: {
                        popup: this
                    }
                }));
                setTimeout((() => {
                    this._focusTrap();
                }), 50);
                this.popupLogging(`–ó–∞–∫—Ä—ã–ª –ø–æ–ø–∞–ø`);
            }
            _getHash() {
                if (this.options.hashSettings.location) this.hash = this.targetOpen.selector.includes("#") ? this.targetOpen.selector : this.targetOpen.selector.replace(".", "#");
            }
            _openToHash() {
                let classInHash = document.querySelector(`.${window.location.hash.replace("#", "")}`) ? `.${window.location.hash.replace("#", "")}` : document.querySelector(`${window.location.hash}`) ? `${window.location.hash}` : null;
                const buttons = document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) ? document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash}"]`) : document.querySelector(`[${this.options.attributeOpenButton} = "${classInHash.replace(".", "#")}"]`);
                this.youTubeCode = buttons.getAttribute(this.options.youtubeAttribute) ? buttons.getAttribute(this.options.youtubeAttribute) : null;
                if (buttons && classInHash) this.open(classInHash);
            }
            _setHash() {
                history.pushState("", "", this.hash);
            }
            _removeHash() {
                history.pushState("", "", window.location.href.split("#")[0]);
            }
            _focusCatch(e) {
                const focusable = this.targetOpen.element.querySelectorAll(this._focusEl);
                const focusArray = Array.prototype.slice.call(focusable);
                const focusedIndex = focusArray.indexOf(document.activeElement);
                if (e.shiftKey && focusedIndex === 0) {
                    focusArray[focusArray.length - 1].focus();
                    e.preventDefault();
                }
                if (!e.shiftKey && focusedIndex === focusArray.length - 1) {
                    focusArray[0].focus();
                    e.preventDefault();
                }
            }
            _focusTrap() {
                const focusable = this.previousOpen.element.querySelectorAll(this._focusEl);
                if (!this.isOpen && this.lastFocusEl) this.lastFocusEl.focus(); else focusable[0].focus();
            }
            popupLogging(message) {
                this.options.logging ? FLS(`[–ü–æ–ø–∞–ø–æ—Å]: ${message}`) : null;
            }
        }
        flsModules.popup = new Popup({});
        let gotoBlock = (targetBlock, noHeader = false, speed = 500, offsetTop = 0) => {
            const targetBlockElement = document.querySelector(targetBlock);
            if (targetBlockElement) {
                let headerItem = "";
                let headerItemHeight = 0;
                if (noHeader) {
                    headerItem = "header.header";
                    const headerElement = document.querySelector(headerItem);
                    if (!headerElement.classList.contains("_header-scroll")) {
                        headerElement.style.cssText = `transition-duration: 0s;`;
                        headerElement.classList.add("_header-scroll");
                        headerItemHeight = headerElement.offsetHeight;
                        headerElement.classList.remove("_header-scroll");
                        setTimeout((() => {
                            headerElement.style.cssText = ``;
                        }), 0);
                    } else headerItemHeight = headerElement.offsetHeight;
                }
                let options = {
                    speedAsDuration: true,
                    speed,
                    header: headerItem,
                    offset: offsetTop,
                    easing: "easeOutQuad"
                };
                document.documentElement.classList.contains("menu-open") ? menuClose() : null;
                if (typeof SmoothScroll !== "undefined") (new SmoothScroll).animateScroll(targetBlockElement, "", options); else {
                    let targetBlockElementPosition = targetBlockElement.getBoundingClientRect().top + scrollY;
                    targetBlockElementPosition = headerItemHeight ? targetBlockElementPosition - headerItemHeight : targetBlockElementPosition;
                    targetBlockElementPosition = offsetTop ? targetBlockElementPosition - offsetTop : targetBlockElementPosition;
                    window.scrollTo({
                        top: targetBlockElementPosition,
                        behavior: "smooth"
                    });
                }
                FLS(`[gotoBlock]: –Æ—Ö—É...–ï–¥–µ–º –¥–æ ${targetBlock}`);
            } else FLS(`[gotoBlock]: –û–π... –ù–µ—Ç —Ç–∞–∫–æ–≥–æ –±–ª–æ–∫–∞ –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ: ${targetBlock}`);
        };
        function formFieldsInit(options = {
            viewPass: false,
            autoHeight: false
        }) {
            document.body.addEventListener("focusin", (function(e) {
                const targetElement = e.target;
                if (targetElement.tagName === "INPUT" || targetElement.tagName === "TEXTAREA") {
                    if (!targetElement.hasAttribute("data-no-focus-classes")) {
                        targetElement.classList.add("_form-focus");
                        targetElement.parentElement.classList.add("_form-focus");
                    }
                    formValidate.removeError(targetElement);
                    targetElement.hasAttribute("data-validate") ? formValidate.removeError(targetElement) : null;
                }
            }));
            document.body.addEventListener("focusout", (function(e) {
                const targetElement = e.target;
                if (targetElement.tagName === "INPUT" || targetElement.tagName === "TEXTAREA") {
                    if (!targetElement.hasAttribute("data-no-focus-classes")) {
                        targetElement.classList.remove("_form-focus");
                        targetElement.parentElement.classList.remove("_form-focus");
                    }
                    targetElement.hasAttribute("data-validate") ? formValidate.validateInput(targetElement) : null;
                }
            }));
            if (options.viewPass) document.addEventListener("click", (function(e) {
                let targetElement = e.target;
                if (targetElement.closest('[class*="__viewpass"]')) {
                    let inputType = targetElement.classList.contains("_viewpass-active") ? "password" : "text";
                    targetElement.parentElement.querySelector("input").setAttribute("type", inputType);
                    targetElement.classList.toggle("_viewpass-active");
                }
            }));
            if (options.autoHeight) {
                const textareas = document.querySelectorAll("textarea[data-autoheight]");
                if (textareas.length) {
                    textareas.forEach((textarea => {
                        const startHeight = textarea.hasAttribute("data-autoheight-min") ? Number(textarea.dataset.autoheightMin) : Number(textarea.offsetHeight);
                        const maxHeight = textarea.hasAttribute("data-autoheight-max") ? Number(textarea.dataset.autoheightMax) : 1 / 0;
                        setHeight(textarea, Math.min(startHeight, maxHeight));
                        textarea.addEventListener("input", (() => {
                            if (textarea.scrollHeight > startHeight) {
                                textarea.style.height = `auto`;
                                setHeight(textarea, Math.min(Math.max(textarea.scrollHeight, startHeight), maxHeight));
                            }
                        }));
                    }));
                    function setHeight(textarea, height) {
                        textarea.style.height = `${height}px`;
                    }
                }
            }
        }
        let formValidate = {
            getErrors(form) {
                let error = 0;
                let formRequiredItems = form.querySelectorAll("*[data-required]");
                if (formRequiredItems.length) formRequiredItems.forEach((formRequiredItem => {
                    if ((formRequiredItem.offsetParent !== null || formRequiredItem.tagName === "SELECT") && !formRequiredItem.disabled) error += this.validateInput(formRequiredItem);
                }));
                return error;
            },
            validateInput(formRequiredItem) {
                let error = 0;
                if (formRequiredItem.dataset.required === "email") {
                    formRequiredItem.value = formRequiredItem.value.replace(" ", "");
                    if (this.emailTest(formRequiredItem)) {
                        this.addError(formRequiredItem);
                        error++;
                    } else this.removeError(formRequiredItem);
                } else if (formRequiredItem.type === "checkbox" && !formRequiredItem.checked) {
                    this.addError(formRequiredItem);
                    error++;
                } else if (!formRequiredItem.value.trim()) {
                    this.addError(formRequiredItem);
                    error++;
                } else if (formRequiredItem.value.includes("_")) {
                    this.addError(formRequiredItem);
                    error++;
                } else this.removeError(formRequiredItem);
                return error;
            },
            addError(formRequiredItem) {
                formRequiredItem.classList.add("_form-error");
                formRequiredItem.parentElement.classList.add("_form-error");
                let inputError = formRequiredItem.parentElement.querySelector(".form__error");
                if (inputError) formRequiredItem.parentElement.removeChild(inputError);
                if (formRequiredItem.dataset.error) formRequiredItem.parentElement.insertAdjacentHTML("beforeend", `<div class="form__error">${formRequiredItem.dataset.error}</div>`);
            },
            removeError(formRequiredItem) {
                formRequiredItem.classList.remove("_form-error");
                formRequiredItem.parentElement.classList.remove("_form-error");
                if (formRequiredItem.parentElement.querySelector(".form__error")) formRequiredItem.parentElement.removeChild(formRequiredItem.parentElement.querySelector(".form__error"));
            },
            formClean(form) {
                form.reset();
                setTimeout((() => {
                    let maskInput = form.querySelector("._input-phone-mask");
                    if (maskInput) {
                        let maskOptions = {
                            mask: "+7(000)000-00-00",
                            lazy: false
                        };
                        let mask = new IMask(maskInput, maskOptions);
                        mask.updateValue();
                    }
                }), 20);
                setTimeout((() => {
                    let inputs = form.querySelectorAll("input,textarea");
                    for (let index = 0; index < inputs.length; index++) {
                        const el = inputs[index];
                        el.parentElement.classList.remove("_form-focus");
                        el.classList.remove("_form-focus");
                        formValidate.removeError(el);
                    }
                    let checkboxes = form.querySelectorAll(".checkbox__input");
                    if (checkboxes.length > 0) for (let index = 0; index < checkboxes.length; index++) {
                        const checkbox = checkboxes[index];
                        checkbox.checked = false;
                    }
                    if (flsModules.select) {
                        let selects = form.querySelectorAll(".select");
                        if (selects.length) for (let index = 0; index < selects.length; index++) {
                            const select = selects[index].querySelector("select");
                            flsModules.select.selectBuild(select);
                        }
                    }
                }), 0);
            },
            emailTest(formRequiredItem) {
                return !/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,8})+$/.test(formRequiredItem.value);
            }
        };
        function formSubmit() {
            const forms = document.forms;
            if (forms.length) for (const form of forms) {
                form.addEventListener("submit", (function(e) {
                    const form = e.target;
                    formSubmitAction(form, e);
                }));
                form.addEventListener("reset", (function(e) {
                    const form = e.target;
                    formValidate.formClean(form);
                }));
            }
            async function formSubmitAction(form, e) {
                const error = !form.hasAttribute("data-no-validate") ? formValidate.getErrors(form) : 0;
                if (error === 0) {
                    const ajax = form.hasAttribute("data-ajax");
                    if (ajax) {
                        e.preventDefault();
                        const formAction = form.getAttribute("action") ? form.getAttribute("action").trim() : "#";
                        const formMethod = form.getAttribute("method") ? form.getAttribute("method").trim() : "POST";
                        const formData = new FormData(form);
                        if (form.dataset.ajax === "feedback") {
                            formData.append("url", window.location.href);
                            formData.append("theme", form.dataset.formTheme);
                        }
                        form.classList.add("_sending");
                        const response = await fetch(formAction, {
                            method: formMethod,
                            body: formData
                        });
                        if (response.ok) try {
                            let responseResult = await response.json();
                            form.classList.remove("_sending");
                            formSent(form, responseResult);
                            if (form.dataset.ajax === "feedback") flsModules.popup.open("#thanks-popup");
                        } catch (err) {
                            console.log("–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ json —Ñ–∞–π–ª–∞");
                            console.log(response);
                        } else {
                            alert("–û—à–∏–±–∫–∞");
                            form.classList.remove("_sending");
                        }
                    } else if (form.hasAttribute("data-dev")) {
                        e.preventDefault();
                        formSent(form);
                    }
                } else {
                    e.preventDefault();
                    if (form.querySelector("._form-error") && form.hasAttribute("data-goto-error")) {
                        const formGoToErrorClass = form.dataset.gotoError ? form.dataset.gotoError : "._form-error";
                        gotoBlock(formGoToErrorClass, true, 1e3);
                    }
                }
            }
            function formSent(form, responseResult = ``) {
                document.dispatchEvent(new CustomEvent("formSent", {
                    detail: {
                        form
                    }
                }));
                setTimeout((() => {
                    if (flsModules.popup) {
                        const popup = form.dataset.popupMessage;
                        popup ? flsModules.popup.open(popup) : null;
                    }
                }), 0);
                formValidate.formClean(form);
                formLogging(`–§–æ—Ä–º–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞!`);
            }
            function formLogging(message) {
                FLS(`[Forms]: ${message}`);
            }
        }
        function ssr_window_esm_isObject(obj) {
            return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
        }
        function extend(target = {}, src = {}) {
            Object.keys(src).forEach((key => {
                if (typeof target[key] === "undefined") target[key] = src[key]; else if (ssr_window_esm_isObject(src[key]) && ssr_window_esm_isObject(target[key]) && Object.keys(src[key]).length > 0) extend(target[key], src[key]);
            }));
        }
        const ssrDocument = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector() {
                return null;
            },
            querySelectorAll() {
                return [];
            },
            getElementById() {
                return null;
            },
            createEvent() {
                return {
                    initEvent() {}
                };
            },
            createElement() {
                return {
                    children: [],
                    childNodes: [],
                    style: {},
                    setAttribute() {},
                    getElementsByTagName() {
                        return [];
                    }
                };
            },
            createElementNS() {
                return {};
            },
            importNode() {
                return null;
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };
        function ssr_window_esm_getDocument() {
            const doc = typeof document !== "undefined" ? document : {};
            extend(doc, ssrDocument);
            return doc;
        }
        const ssrWindow = {
            document: ssrDocument,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function CustomEvent() {
                return this;
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle() {
                return {
                    getPropertyValue() {
                        return "";
                    }
                };
            },
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia() {
                return {};
            },
            requestAnimationFrame(callback) {
                if (typeof setTimeout === "undefined") {
                    callback();
                    return null;
                }
                return setTimeout(callback, 0);
            },
            cancelAnimationFrame(id) {
                if (typeof setTimeout === "undefined") return;
                clearTimeout(id);
            }
        };
        function ssr_window_esm_getWindow() {
            const win = typeof window !== "undefined" ? window : {};
            extend(win, ssrWindow);
            return win;
        }
        function deleteProps(obj) {
            const object = obj;
            Object.keys(object).forEach((key => {
                try {
                    object[key] = null;
                } catch (e) {}
                try {
                    delete object[key];
                } catch (e) {}
            }));
        }
        function utils_nextTick(callback, delay = 0) {
            return setTimeout(callback, delay);
        }
        function utils_now() {
            return Date.now();
        }
        function utils_getComputedStyle(el) {
            const window = ssr_window_esm_getWindow();
            let style;
            if (window.getComputedStyle) style = window.getComputedStyle(el, null);
            if (!style && el.currentStyle) style = el.currentStyle;
            if (!style) style = el.style;
            return style;
        }
        function utils_getTranslate(el, axis = "x") {
            const window = ssr_window_esm_getWindow();
            let matrix;
            let curTransform;
            let transformMatrix;
            const curStyle = utils_getComputedStyle(el, null);
            if (window.WebKitCSSMatrix) {
                curTransform = curStyle.transform || curStyle.webkitTransform;
                if (curTransform.split(",").length > 6) curTransform = curTransform.split(", ").map((a => a.replace(",", "."))).join(", ");
                transformMatrix = new window.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
            } else {
                transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
                matrix = transformMatrix.toString().split(",");
            }
            if (axis === "x") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); else curTransform = parseFloat(matrix[4]);
            if (axis === "y") if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); else curTransform = parseFloat(matrix[5]);
            return curTransform || 0;
        }
        function shared_utils_isObject(o) {
            return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
        }
        function isNode(node) {
            if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") return node instanceof HTMLElement;
            return node && (node.nodeType === 1 || node.nodeType === 11);
        }
        function utils_extend(...args) {
            const to = Object(args[0]);
            const noExtend = [ "__proto__", "constructor", "prototype" ];
            for (let i = 1; i < args.length; i += 1) {
                const nextSource = args[i];
                if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
                    const keysArray = Object.keys(Object(nextSource)).filter((key => noExtend.indexOf(key) < 0));
                    for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
                        const nextKey = keysArray[nextIndex];
                        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                        if (desc !== void 0 && desc.enumerable) if (shared_utils_isObject(to[nextKey]) && shared_utils_isObject(nextSource[nextKey])) if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]); else if (!shared_utils_isObject(to[nextKey]) && shared_utils_isObject(nextSource[nextKey])) {
                            to[nextKey] = {};
                            if (nextSource[nextKey].__swiper__) to[nextKey] = nextSource[nextKey]; else utils_extend(to[nextKey], nextSource[nextKey]);
                        } else to[nextKey] = nextSource[nextKey];
                    }
                }
            }
            return to;
        }
        function utils_setCSSProperty(el, varName, varValue) {
            el.style.setProperty(varName, varValue);
        }
        function animateCSSModeScroll({swiper, targetPosition, side}) {
            const window = ssr_window_esm_getWindow();
            const startPosition = -swiper.translate;
            let startTime = null;
            let time;
            const duration = swiper.params.speed;
            swiper.wrapperEl.style.scrollSnapType = "none";
            window.cancelAnimationFrame(swiper.cssModeFrameID);
            const dir = targetPosition > startPosition ? "next" : "prev";
            const isOutOfBound = (current, target) => dir === "next" && current >= target || dir === "prev" && current <= target;
            const animate = () => {
                time = (new Date).getTime();
                if (startTime === null) startTime = time;
                const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
                const easeProgress = .5 - Math.cos(progress * Math.PI) / 2;
                let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
                if (isOutOfBound(currentPosition, targetPosition)) currentPosition = targetPosition;
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
                if (isOutOfBound(currentPosition, targetPosition)) {
                    swiper.wrapperEl.style.overflow = "hidden";
                    swiper.wrapperEl.style.scrollSnapType = "";
                    setTimeout((() => {
                        swiper.wrapperEl.style.overflow = "";
                        swiper.wrapperEl.scrollTo({
                            [side]: currentPosition
                        });
                    }));
                    window.cancelAnimationFrame(swiper.cssModeFrameID);
                    return;
                }
                swiper.cssModeFrameID = window.requestAnimationFrame(animate);
            };
            animate();
        }
        function utils_elementChildren(element, selector = "") {
            return [ ...element.children ].filter((el => el.matches(selector)));
        }
        function utils_createElement(tag, classes = []) {
            const el = document.createElement(tag);
            el.classList.add(...Array.isArray(classes) ? classes : [ classes ]);
            return el;
        }
        function elementPrevAll(el, selector) {
            const prevEls = [];
            while (el.previousElementSibling) {
                const prev = el.previousElementSibling;
                if (selector) {
                    if (prev.matches(selector)) prevEls.push(prev);
                } else prevEls.push(prev);
                el = prev;
            }
            return prevEls;
        }
        function elementNextAll(el, selector) {
            const nextEls = [];
            while (el.nextElementSibling) {
                const next = el.nextElementSibling;
                if (selector) {
                    if (next.matches(selector)) nextEls.push(next);
                } else nextEls.push(next);
                el = next;
            }
            return nextEls;
        }
        function elementStyle(el, prop) {
            const window = ssr_window_esm_getWindow();
            return window.getComputedStyle(el, null).getPropertyValue(prop);
        }
        function utils_elementIndex(el) {
            let child = el;
            let i;
            if (child) {
                i = 0;
                while ((child = child.previousSibling) !== null) if (child.nodeType === 1) i += 1;
                return i;
            }
            return;
        }
        function utils_elementParents(el, selector) {
            const parents = [];
            let parent = el.parentElement;
            while (parent) {
                if (selector) {
                    if (parent.matches(selector)) parents.push(parent);
                } else parents.push(parent);
                parent = parent.parentElement;
            }
            return parents;
        }
        function utils_elementOuterSize(el, size, includeMargins) {
            const window = ssr_window_esm_getWindow();
            if (includeMargins) return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
            return el.offsetWidth;
        }
        let support;
        function calcSupport() {
            const window = ssr_window_esm_getWindow();
            const document = ssr_window_esm_getDocument();
            return {
                smoothScroll: document.documentElement && document.documentElement.style && "scrollBehavior" in document.documentElement.style,
                touch: !!("ontouchstart" in window || window.DocumentTouch && document instanceof window.DocumentTouch)
            };
        }
        function getSupport() {
            if (!support) support = calcSupport();
            return support;
        }
        let deviceCached;
        function calcDevice({userAgent} = {}) {
            const support = getSupport();
            const window = ssr_window_esm_getWindow();
            const platform = window.navigator.platform;
            const ua = userAgent || window.navigator.userAgent;
            const device = {
                ios: false,
                android: false
            };
            const screenWidth = window.screen.width;
            const screenHeight = window.screen.height;
            const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
            let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
            const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
            const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
            const windows = platform === "Win32";
            let macos = platform === "MacIntel";
            const iPadScreens = [ "1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810" ];
            if (!ipad && macos && support.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
                ipad = ua.match(/(Version)\/([\d.]+)/);
                if (!ipad) ipad = [ 0, 1, "13_0_0" ];
                macos = false;
            }
            if (android && !windows) {
                device.os = "android";
                device.android = true;
            }
            if (ipad || iphone || ipod) {
                device.os = "ios";
                device.ios = true;
            }
            return device;
        }
        function getDevice(overrides = {}) {
            if (!deviceCached) deviceCached = calcDevice(overrides);
            return deviceCached;
        }
        let browser;
        function calcBrowser() {
            const window = ssr_window_esm_getWindow();
            let needPerspectiveFix = false;
            function isSafari() {
                const ua = window.navigator.userAgent.toLowerCase();
                return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
            }
            if (isSafari()) {
                const ua = String(window.navigator.userAgent);
                if (ua.includes("Version/")) {
                    const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num => Number(num)));
                    needPerspectiveFix = major < 16 || major === 16 && minor < 2;
                }
            }
            return {
                isSafari: needPerspectiveFix || isSafari(),
                needPerspectiveFix,
                isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
            };
        }
        function getBrowser() {
            if (!browser) browser = calcBrowser();
            return browser;
        }
        function Resize({swiper, on, emit}) {
            const window = ssr_window_esm_getWindow();
            let observer = null;
            let animationFrame = null;
            const resizeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("beforeResize");
                emit("resize");
            };
            const createObserver = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                observer = new ResizeObserver((entries => {
                    animationFrame = window.requestAnimationFrame((() => {
                        const {width, height} = swiper;
                        let newWidth = width;
                        let newHeight = height;
                        entries.forEach((({contentBoxSize, contentRect, target}) => {
                            if (target && target !== swiper.el) return;
                            newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                            newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                        }));
                        if (newWidth !== width || newHeight !== height) resizeHandler();
                    }));
                }));
                observer.observe(swiper.el);
            };
            const removeObserver = () => {
                if (animationFrame) window.cancelAnimationFrame(animationFrame);
                if (observer && observer.unobserve && swiper.el) {
                    observer.unobserve(swiper.el);
                    observer = null;
                }
            };
            const orientationChangeHandler = () => {
                if (!swiper || swiper.destroyed || !swiper.initialized) return;
                emit("orientationchange");
            };
            on("init", (() => {
                if (swiper.params.resizeObserver && typeof window.ResizeObserver !== "undefined") {
                    createObserver();
                    return;
                }
                window.addEventListener("resize", resizeHandler);
                window.addEventListener("orientationchange", orientationChangeHandler);
            }));
            on("destroy", (() => {
                removeObserver();
                window.removeEventListener("resize", resizeHandler);
                window.removeEventListener("orientationchange", orientationChangeHandler);
            }));
        }
        function Observer({swiper, extendParams, on, emit}) {
            const observers = [];
            const window = ssr_window_esm_getWindow();
            const attach = (target, options = {}) => {
                const ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
                const observer = new ObserverFunc((mutations => {
                    if (swiper.__preventObserver__) return;
                    if (mutations.length === 1) {
                        emit("observerUpdate", mutations[0]);
                        return;
                    }
                    const observerUpdate = function observerUpdate() {
                        emit("observerUpdate", mutations[0]);
                    };
                    if (window.requestAnimationFrame) window.requestAnimationFrame(observerUpdate); else window.setTimeout(observerUpdate, 0);
                }));
                observer.observe(target, {
                    attributes: typeof options.attributes === "undefined" ? true : options.attributes,
                    childList: typeof options.childList === "undefined" ? true : options.childList,
                    characterData: typeof options.characterData === "undefined" ? true : options.characterData
                });
                observers.push(observer);
            };
            const init = () => {
                if (!swiper.params.observer) return;
                if (swiper.params.observeParents) {
                    const containerParents = utils_elementParents(swiper.el);
                    for (let i = 0; i < containerParents.length; i += 1) attach(containerParents[i]);
                }
                attach(swiper.el, {
                    childList: swiper.params.observeSlideChildren
                });
                attach(swiper.wrapperEl, {
                    attributes: false
                });
            };
            const destroy = () => {
                observers.forEach((observer => {
                    observer.disconnect();
                }));
                observers.splice(0, observers.length);
            };
            extendParams({
                observer: false,
                observeParents: false,
                observeSlideChildren: false
            });
            on("init", init);
            on("destroy", destroy);
        }
        const events_emitter = {
            on(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                events.split(" ").forEach((event => {
                    if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
                    self.eventsListeners[event][method](handler);
                }));
                return self;
            },
            once(events, handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                function onceHandler(...args) {
                    self.off(events, onceHandler);
                    if (onceHandler.__emitterProxy) delete onceHandler.__emitterProxy;
                    handler.apply(self, args);
                }
                onceHandler.__emitterProxy = handler;
                return self.on(events, onceHandler, priority);
            },
            onAny(handler, priority) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (typeof handler !== "function") return self;
                const method = priority ? "unshift" : "push";
                if (self.eventsAnyListeners.indexOf(handler) < 0) self.eventsAnyListeners[method](handler);
                return self;
            },
            offAny(handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsAnyListeners) return self;
                const index = self.eventsAnyListeners.indexOf(handler);
                if (index >= 0) self.eventsAnyListeners.splice(index, 1);
                return self;
            },
            off(events, handler) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                events.split(" ").forEach((event => {
                    if (typeof handler === "undefined") self.eventsListeners[event] = []; else if (self.eventsListeners[event]) self.eventsListeners[event].forEach(((eventHandler, index) => {
                        if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) self.eventsListeners[event].splice(index, 1);
                    }));
                }));
                return self;
            },
            emit(...args) {
                const self = this;
                if (!self.eventsListeners || self.destroyed) return self;
                if (!self.eventsListeners) return self;
                let events;
                let data;
                let context;
                if (typeof args[0] === "string" || Array.isArray(args[0])) {
                    events = args[0];
                    data = args.slice(1, args.length);
                    context = self;
                } else {
                    events = args[0].events;
                    data = args[0].data;
                    context = args[0].context || self;
                }
                data.unshift(context);
                const eventsArray = Array.isArray(events) ? events : events.split(" ");
                eventsArray.forEach((event => {
                    if (self.eventsAnyListeners && self.eventsAnyListeners.length) self.eventsAnyListeners.forEach((eventHandler => {
                        eventHandler.apply(context, [ event, ...data ]);
                    }));
                    if (self.eventsListeners && self.eventsListeners[event]) self.eventsListeners[event].forEach((eventHandler => {
                        eventHandler.apply(context, data);
                    }));
                }));
                return self;
            }
        };
        function updateSize() {
            const swiper = this;
            let width;
            let height;
            const el = swiper.el;
            if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) width = swiper.params.width; else width = el.clientWidth;
            if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) height = swiper.params.height; else height = el.clientHeight;
            if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) return;
            width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
            height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
            if (Number.isNaN(width)) width = 0;
            if (Number.isNaN(height)) height = 0;
            Object.assign(swiper, {
                width,
                height,
                size: swiper.isHorizontal() ? width : height
            });
        }
        function updateSlides() {
            const swiper = this;
            function getDirectionLabel(property) {
                if (swiper.isHorizontal()) return property;
                return {
                    width: "height",
                    "margin-top": "margin-left",
                    "margin-bottom ": "margin-right",
                    "margin-left": "margin-top",
                    "margin-right": "margin-bottom",
                    "padding-left": "padding-top",
                    "padding-right": "padding-bottom",
                    marginRight: "marginBottom"
                }[property];
            }
            function getDirectionPropertyValue(node, label) {
                return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
            }
            const params = swiper.params;
            const {wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
            const slides = utils_elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
            const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
            let snapGrid = [];
            const slidesGrid = [];
            const slidesSizesGrid = [];
            let offsetBefore = params.slidesOffsetBefore;
            if (typeof offsetBefore === "function") offsetBefore = params.slidesOffsetBefore.call(swiper);
            let offsetAfter = params.slidesOffsetAfter;
            if (typeof offsetAfter === "function") offsetAfter = params.slidesOffsetAfter.call(swiper);
            const previousSnapGridLength = swiper.snapGrid.length;
            const previousSlidesGridLength = swiper.slidesGrid.length;
            let spaceBetween = params.spaceBetween;
            let slidePosition = -offsetBefore;
            let prevSlideSize = 0;
            let index = 0;
            if (typeof swiperSize === "undefined") return;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            swiper.virtualSize = -spaceBetween;
            slides.forEach((slideEl => {
                if (rtl) slideEl.style.marginLeft = ""; else slideEl.style.marginRight = "";
                slideEl.style.marginBottom = "";
                slideEl.style.marginTop = "";
            }));
            if (params.centeredSlides && params.cssMode) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
            }
            const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
            if (gridEnabled) swiper.grid.initSlides(slidesLength);
            let slideSize;
            const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key => typeof params.breakpoints[key].slidesPerView !== "undefined")).length > 0;
            for (let i = 0; i < slidesLength; i += 1) {
                slideSize = 0;
                let slide;
                if (slides[i]) slide = slides[i];
                if (gridEnabled) swiper.grid.updateSlide(i, slide, slidesLength, getDirectionLabel);
                if (slides[i] && elementStyle(slide, "display") === "none") continue;
                if (params.slidesPerView === "auto") {
                    if (shouldResetSlideSize) slides[i].style[getDirectionLabel("width")] = ``;
                    const slideStyles = getComputedStyle(slide);
                    const currentTransform = slide.style.transform;
                    const currentWebKitTransform = slide.style.webkitTransform;
                    if (currentTransform) slide.style.transform = "none";
                    if (currentWebKitTransform) slide.style.webkitTransform = "none";
                    if (params.roundLengths) slideSize = swiper.isHorizontal() ? utils_elementOuterSize(slide, "width", true) : utils_elementOuterSize(slide, "height", true); else {
                        const width = getDirectionPropertyValue(slideStyles, "width");
                        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                        const boxSizing = slideStyles.getPropertyValue("box-sizing");
                        if (boxSizing && boxSizing === "border-box") slideSize = width + marginLeft + marginRight; else {
                            const {clientWidth, offsetWidth} = slide;
                            slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                        }
                    }
                    if (currentTransform) slide.style.transform = currentTransform;
                    if (currentWebKitTransform) slide.style.webkitTransform = currentWebKitTransform;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                } else {
                    slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
                    if (params.roundLengths) slideSize = Math.floor(slideSize);
                    if (slides[i]) slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
                }
                if (slides[i]) slides[i].swiperSlideSize = slideSize;
                slidesSizesGrid.push(slideSize);
                if (params.centeredSlides) {
                    slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
                    if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                    if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                } else {
                    if (params.roundLengths) slidePosition = Math.floor(slidePosition);
                    if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
                    slidesGrid.push(slidePosition);
                    slidePosition = slidePosition + slideSize + spaceBetween;
                }
                swiper.virtualSize += slideSize + spaceBetween;
                prevSlideSize = slideSize;
                index += 1;
            }
            swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
            if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
            if (params.setWrapperSize) wrapperEl.style[getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
            if (gridEnabled) swiper.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
            if (!params.centeredSlides) {
                const newSlidesGrid = [];
                for (let i = 0; i < snapGrid.length; i += 1) {
                    let slidesGridItem = snapGrid[i];
                    if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                    if (snapGrid[i] <= swiper.virtualSize - swiperSize) newSlidesGrid.push(slidesGridItem);
                }
                snapGrid = newSlidesGrid;
                if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) snapGrid.push(swiper.virtualSize - swiperSize);
            }
            if (isVirtual && params.loop) {
                const size = slidesSizesGrid[0] + spaceBetween;
                if (params.slidesPerGroup > 1) {
                    const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
                    const groupSize = size * params.slidesPerGroup;
                    for (let i = 0; i < groups; i += 1) snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
                }
                for (let i = 0; i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i += 1) {
                    if (params.slidesPerGroup === 1) snapGrid.push(snapGrid[snapGrid.length - 1] + size);
                    slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
                    swiper.virtualSize += size;
                }
            }
            if (snapGrid.length === 0) snapGrid = [ 0 ];
            if (spaceBetween !== 0) {
                const key = swiper.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
                slides.filter(((_, slideIndex) => {
                    if (!params.cssMode || params.loop) return true;
                    if (slideIndex === slides.length - 1) return false;
                    return true;
                })).forEach((slideEl => {
                    slideEl.style[key] = `${spaceBetween}px`;
                }));
            }
            if (params.centeredSlides && params.centeredSlidesBounds) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                const maxSnap = allSlidesSize - swiperSize;
                snapGrid = snapGrid.map((snap => {
                    if (snap < 0) return -offsetBefore;
                    if (snap > maxSnap) return maxSnap + offsetAfter;
                    return snap;
                }));
            }
            if (params.centerInsufficientSlides) {
                let allSlidesSize = 0;
                slidesSizesGrid.forEach((slideSizeValue => {
                    allSlidesSize += slideSizeValue + (spaceBetween || 0);
                }));
                allSlidesSize -= spaceBetween;
                if (allSlidesSize < swiperSize) {
                    const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                    snapGrid.forEach(((snap, snapIndex) => {
                        snapGrid[snapIndex] = snap - allSlidesOffset;
                    }));
                    slidesGrid.forEach(((snap, snapIndex) => {
                        slidesGrid[snapIndex] = snap + allSlidesOffset;
                    }));
                }
            }
            Object.assign(swiper, {
                slides,
                snapGrid,
                slidesGrid,
                slidesSizesGrid
            });
            if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
                utils_setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
                const addToSnapGrid = -swiper.snapGrid[0];
                const addToSlidesGrid = -swiper.slidesGrid[0];
                swiper.snapGrid = swiper.snapGrid.map((v => v + addToSnapGrid));
                swiper.slidesGrid = swiper.slidesGrid.map((v => v + addToSlidesGrid));
            }
            if (slidesLength !== previousSlidesLength) swiper.emit("slidesLengthChange");
            if (snapGrid.length !== previousSnapGridLength) {
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                swiper.emit("snapGridLengthChange");
            }
            if (slidesGrid.length !== previousSlidesGridLength) swiper.emit("slidesGridLengthChange");
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
                const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
                if (slidesLength <= params.maxBackfaceHiddenSlides) {
                    if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
                } else if (hasClassBackfaceClassAdded) swiper.el.classList.remove(backFaceHiddenClass);
            }
        }
        function updateAutoHeight(speed) {
            const swiper = this;
            const activeSlides = [];
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            let newHeight = 0;
            let i;
            if (typeof speed === "number") swiper.setTransition(speed); else if (speed === true) swiper.setTransition(swiper.params.speed);
            const getSlideByIndex = index => {
                if (isVirtual) return swiper.slides[swiper.getSlideIndexByData(index)];
                return swiper.slides[index];
            };
            if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) if (swiper.params.centeredSlides) (swiper.visibleSlides || []).forEach((slide => {
                activeSlides.push(slide);
            })); else for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                const index = swiper.activeIndex + i;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            } else activeSlides.push(getSlideByIndex(swiper.activeIndex));
            for (i = 0; i < activeSlides.length; i += 1) if (typeof activeSlides[i] !== "undefined") {
                const height = activeSlides[i].offsetHeight;
                newHeight = height > newHeight ? height : newHeight;
            }
            if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
        }
        function updateSlidesOffset() {
            const swiper = this;
            const slides = swiper.slides;
            const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
            for (let i = 0; i < slides.length; i += 1) slides[i].swiperSlideOffset = (swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
        }
        function updateSlidesProgress(translate = this && this.translate || 0) {
            const swiper = this;
            const params = swiper.params;
            const {slides, rtlTranslate: rtl, snapGrid} = swiper;
            if (slides.length === 0) return;
            if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
            let offsetCenter = -translate;
            if (rtl) offsetCenter = translate;
            slides.forEach((slideEl => {
                slideEl.classList.remove(params.slideVisibleClass);
            }));
            swiper.visibleSlidesIndexes = [];
            swiper.visibleSlides = [];
            let spaceBetween = params.spaceBetween;
            if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size; else if (typeof spaceBetween === "string") spaceBetween = parseFloat(spaceBetween);
            for (let i = 0; i < slides.length; i += 1) {
                const slide = slides[i];
                let slideOffset = slide.swiperSlideOffset;
                if (params.cssMode && params.centeredSlides) slideOffset -= slides[0].swiperSlideOffset;
                const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide.swiperSlideSize + spaceBetween);
                const slideBefore = -(offsetCenter - slideOffset);
                const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                const isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
                if (isVisible) {
                    swiper.visibleSlides.push(slide);
                    swiper.visibleSlidesIndexes.push(i);
                    slides[i].classList.add(params.slideVisibleClass);
                }
                slide.progress = rtl ? -slideProgress : slideProgress;
                slide.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
            }
        }
        function updateProgress(translate) {
            const swiper = this;
            if (typeof translate === "undefined") {
                const multiplier = swiper.rtlTranslate ? -1 : 1;
                translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
            }
            const params = swiper.params;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            let {progress, isBeginning, isEnd, progressLoop} = swiper;
            const wasBeginning = isBeginning;
            const wasEnd = isEnd;
            if (translatesDiff === 0) {
                progress = 0;
                isBeginning = true;
                isEnd = true;
            } else {
                progress = (translate - swiper.minTranslate()) / translatesDiff;
                const isBeginningRounded = Math.abs(translate - swiper.minTranslate()) < 1;
                const isEndRounded = Math.abs(translate - swiper.maxTranslate()) < 1;
                isBeginning = isBeginningRounded || progress <= 0;
                isEnd = isEndRounded || progress >= 1;
                if (isBeginningRounded) progress = 0;
                if (isEndRounded) progress = 1;
            }
            if (params.loop) {
                const firstSlideIndex = swiper.getSlideIndexByData(0);
                const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
                const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
                const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
                const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
                const translateAbs = Math.abs(translate);
                if (translateAbs >= firstSlideTranslate) progressLoop = (translateAbs - firstSlideTranslate) / translateMax; else progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
                if (progressLoop > 1) progressLoop -= 1;
            }
            Object.assign(swiper, {
                progress,
                progressLoop,
                isBeginning,
                isEnd
            });
            if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);
            if (isBeginning && !wasBeginning) swiper.emit("reachBeginning toEdge");
            if (isEnd && !wasEnd) swiper.emit("reachEnd toEdge");
            if (wasBeginning && !isBeginning || wasEnd && !isEnd) swiper.emit("fromEdge");
            swiper.emit("progress", progress);
        }
        function updateSlidesClasses() {
            const swiper = this;
            const {slides, params, slidesEl, activeIndex} = swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            const getFilteredSlide = selector => utils_elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
            slides.forEach((slideEl => {
                slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
            }));
            let activeSlide;
            if (isVirtual) if (params.loop) {
                let slideIndex = activeIndex - swiper.virtual.slidesBefore;
                if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
                if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
                activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
            } else activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`); else activeSlide = slides[activeIndex];
            if (activeSlide) {
                activeSlide.classList.add(params.slideActiveClass);
                let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !nextSlide) nextSlide = slides[0];
                if (nextSlide) nextSlide.classList.add(params.slideNextClass);
                let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
                if (params.loop && !prevSlide === 0) prevSlide = slides[slides.length - 1];
                if (prevSlide) prevSlide.classList.add(params.slidePrevClass);
            }
            swiper.emitSlidesClasses();
        }
        const processLazyPreloader = (swiper, imageEl) => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            const slideSelector = () => swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
            const slideEl = imageEl.closest(slideSelector());
            if (slideEl) {
                const lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                if (lazyEl) lazyEl.remove();
            }
        };
        const unlazy = (swiper, index) => {
            if (!swiper.slides[index]) return;
            const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
            if (imageEl) imageEl.removeAttribute("loading");
        };
        const preload = swiper => {
            if (!swiper || swiper.destroyed || !swiper.params) return;
            let amount = swiper.params.lazyPreloadPrevNext;
            const len = swiper.slides.length;
            if (!len || !amount || amount < 0) return;
            amount = Math.min(amount, len);
            const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
            const activeIndex = swiper.activeIndex;
            const slideIndexLastInView = activeIndex + slidesPerView - 1;
            if (swiper.params.rewind) for (let i = activeIndex - amount; i <= slideIndexLastInView + amount; i += 1) {
                const realIndex = (i % len + len) % len;
                if (realIndex !== activeIndex && realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
            } else for (let i = Math.max(slideIndexLastInView - amount, 0); i <= Math.min(slideIndexLastInView + amount, len - 1); i += 1) if (i !== activeIndex && i > slideIndexLastInView) unlazy(swiper, i);
        };
        function getActiveIndexByTranslate(swiper) {
            const {slidesGrid, params} = swiper;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            let activeIndex;
            for (let i = 0; i < slidesGrid.length; i += 1) if (typeof slidesGrid[i + 1] !== "undefined") {
                if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) activeIndex = i; else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) activeIndex = i + 1;
            } else if (translate >= slidesGrid[i]) activeIndex = i;
            if (params.normalizeSlideIndex) if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
            return activeIndex;
        }
        function updateActiveIndex(newActiveIndex) {
            const swiper = this;
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            const {snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex} = swiper;
            let activeIndex = newActiveIndex;
            let snapIndex;
            const getVirtualRealIndex = aIndex => {
                let realIndex = aIndex - swiper.virtual.slidesBefore;
                if (realIndex < 0) realIndex = swiper.virtual.slides.length + realIndex;
                if (realIndex >= swiper.virtual.slides.length) realIndex -= swiper.virtual.slides.length;
                return realIndex;
            };
            if (typeof activeIndex === "undefined") activeIndex = getActiveIndexByTranslate(swiper);
            if (snapGrid.indexOf(translate) >= 0) snapIndex = snapGrid.indexOf(translate); else {
                const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
            }
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            if (activeIndex === previousIndex) {
                if (snapIndex !== previousSnapIndex) {
                    swiper.snapIndex = snapIndex;
                    swiper.emit("snapIndexChange");
                }
                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.realIndex = getVirtualRealIndex(activeIndex);
                return;
            }
            let realIndex;
            if (swiper.virtual && params.virtual.enabled && params.loop) realIndex = getVirtualRealIndex(activeIndex); else if (swiper.slides[activeIndex]) realIndex = parseInt(swiper.slides[activeIndex].getAttribute("data-swiper-slide-index") || activeIndex, 10); else realIndex = activeIndex;
            Object.assign(swiper, {
                previousSnapIndex,
                snapIndex,
                previousRealIndex,
                realIndex,
                previousIndex,
                activeIndex
            });
            if (swiper.initialized) preload(swiper);
            swiper.emit("activeIndexChange");
            swiper.emit("snapIndexChange");
            if (previousRealIndex !== realIndex) swiper.emit("realIndexChange");
            if (swiper.initialized || swiper.params.runCallbacksOnInit) swiper.emit("slideChange");
        }
        function updateClickedSlide(e) {
            const swiper = this;
            const params = swiper.params;
            const slide = e.closest(`.${params.slideClass}, swiper-slide`);
            let slideFound = false;
            let slideIndex;
            if (slide) for (let i = 0; i < swiper.slides.length; i += 1) if (swiper.slides[i] === slide) {
                slideFound = true;
                slideIndex = i;
                break;
            }
            if (slide && slideFound) {
                swiper.clickedSlide = slide;
                if (swiper.virtual && swiper.params.virtual.enabled) swiper.clickedIndex = parseInt(slide.getAttribute("data-swiper-slide-index"), 10); else swiper.clickedIndex = slideIndex;
            } else {
                swiper.clickedSlide = void 0;
                swiper.clickedIndex = void 0;
                return;
            }
            if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) swiper.slideToClickedSlide();
        }
        const update = {
            updateSize,
            updateSlides,
            updateAutoHeight,
            updateSlidesOffset,
            updateSlidesProgress,
            updateProgress,
            updateSlidesClasses,
            updateActiveIndex,
            updateClickedSlide
        };
        function getSwiperTranslate(axis = (this.isHorizontal() ? "x" : "y")) {
            const swiper = this;
            const {params, rtlTranslate: rtl, translate, wrapperEl} = swiper;
            if (params.virtualTranslate) return rtl ? -translate : translate;
            if (params.cssMode) return translate;
            let currentTranslate = utils_getTranslate(wrapperEl, axis);
            currentTranslate += swiper.cssOverflowAdjustment();
            if (rtl) currentTranslate = -currentTranslate;
            return currentTranslate || 0;
        }
        function setTranslate(translate, byController) {
            const swiper = this;
            const {rtlTranslate: rtl, params, wrapperEl, progress} = swiper;
            let x = 0;
            let y = 0;
            const z = 0;
            if (swiper.isHorizontal()) x = rtl ? -translate : translate; else y = translate;
            if (params.roundLengths) {
                x = Math.floor(x);
                y = Math.floor(y);
            }
            swiper.previousTranslate = swiper.translate;
            swiper.translate = swiper.isHorizontal() ? x : y;
            if (params.cssMode) wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y; else if (!params.virtualTranslate) {
                if (swiper.isHorizontal()) x -= swiper.cssOverflowAdjustment(); else y -= swiper.cssOverflowAdjustment();
                wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
            }
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== progress) swiper.updateProgress(translate);
            swiper.emit("setTranslate", swiper.translate, byController);
        }
        function minTranslate() {
            return -this.snapGrid[0];
        }
        function maxTranslate() {
            return -this.snapGrid[this.snapGrid.length - 1];
        }
        function translateTo(translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
            const swiper = this;
            const {params, wrapperEl} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition) return false;
            const minTranslate = swiper.minTranslate();
            const maxTranslate = swiper.maxTranslate();
            let newTranslate;
            if (translateBounds && translate > minTranslate) newTranslate = minTranslate; else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate; else newTranslate = translate;
            swiper.updateProgress(newTranslate);
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                if (speed === 0) wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate; else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: -newTranslate,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: -newTranslate,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            if (speed === 0) {
                swiper.setTransition(0);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionEnd");
                }
            } else {
                swiper.setTransition(speed);
                swiper.setTranslate(newTranslate);
                if (runCallbacks) {
                    swiper.emit("beforeTransitionStart", speed, internal);
                    swiper.emit("transitionStart");
                }
                if (!swiper.animating) {
                    swiper.animating = true;
                    if (!swiper.onTranslateToWrapperTransitionEnd) swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
                        if (!swiper || swiper.destroyed) return;
                        if (e.target !== this) return;
                        swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                        swiper.onTranslateToWrapperTransitionEnd = null;
                        delete swiper.onTranslateToWrapperTransitionEnd;
                        if (runCallbacks) swiper.emit("transitionEnd");
                    };
                    swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                }
            }
            return true;
        }
        const translate = {
            getTranslate: getSwiperTranslate,
            setTranslate,
            minTranslate,
            maxTranslate,
            translateTo
        };
        function setTransition(duration, byController) {
            const swiper = this;
            if (!swiper.params.cssMode) swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
            swiper.emit("setTransition", duration, byController);
        }
        function transitionEmit({swiper, runCallbacks, direction, step}) {
            const {activeIndex, previousIndex} = swiper;
            let dir = direction;
            if (!dir) if (activeIndex > previousIndex) dir = "next"; else if (activeIndex < previousIndex) dir = "prev"; else dir = "reset";
            swiper.emit(`transition${step}`);
            if (runCallbacks && activeIndex !== previousIndex) {
                if (dir === "reset") {
                    swiper.emit(`slideResetTransition${step}`);
                    return;
                }
                swiper.emit(`slideChangeTransition${step}`);
                if (dir === "next") swiper.emit(`slideNextTransition${step}`); else swiper.emit(`slidePrevTransition${step}`);
            }
        }
        function transitionStart(runCallbacks = true, direction) {
            const swiper = this;
            const {params} = swiper;
            if (params.cssMode) return;
            if (params.autoHeight) swiper.updateAutoHeight();
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "Start"
            });
        }
        function transitionEnd(runCallbacks = true, direction) {
            const swiper = this;
            const {params} = swiper;
            swiper.animating = false;
            if (params.cssMode) return;
            swiper.setTransition(0);
            transitionEmit({
                swiper,
                runCallbacks,
                direction,
                step: "End"
            });
        }
        const transition = {
            setTransition,
            transitionStart,
            transitionEnd
        };
        function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {
            if (typeof index === "string") index = parseInt(index, 10);
            const swiper = this;
            let slideIndex = index;
            if (slideIndex < 0) slideIndex = 0;
            const {params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled} = swiper;
            if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) return false;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
            let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
            if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
            const translate = -snapGrid[snapIndex];
            if (params.normalizeSlideIndex) for (let i = 0; i < slidesGrid.length; i += 1) {
                const normalizedTranslate = -Math.floor(translate * 100);
                const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                if (typeof slidesGrid[i + 1] !== "undefined") {
                    if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) slideIndex = i; else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) slideIndex = i + 1;
                } else if (normalizedTranslate >= normalizedGrid) slideIndex = i;
            }
            if (swiper.initialized && slideIndex !== activeIndex) {
                if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) return false;
                if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) if ((activeIndex || 0) !== slideIndex) return false;
            }
            if (slideIndex !== (previousIndex || 0) && runCallbacks) swiper.emit("beforeSlideChangeStart");
            swiper.updateProgress(translate);
            let direction;
            if (slideIndex > activeIndex) direction = "next"; else if (slideIndex < activeIndex) direction = "prev"; else direction = "reset";
            if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
                swiper.updateActiveIndex(slideIndex);
                if (params.autoHeight) swiper.updateAutoHeight();
                swiper.updateSlidesClasses();
                if (params.effect !== "slide") swiper.setTranslate(translate);
                if (direction !== "reset") {
                    swiper.transitionStart(runCallbacks, direction);
                    swiper.transitionEnd(runCallbacks, direction);
                }
                return false;
            }
            if (params.cssMode) {
                const isH = swiper.isHorizontal();
                const t = rtl ? translate : -translate;
                if (speed === 0) {
                    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                    if (isVirtual) {
                        swiper.wrapperEl.style.scrollSnapType = "none";
                        swiper._immediateVirtual = true;
                    }
                    if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                        swiper._cssModeVirtualInitialSet = true;
                        requestAnimationFrame((() => {
                            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                        }));
                    } else wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                    if (isVirtual) requestAnimationFrame((() => {
                        swiper.wrapperEl.style.scrollSnapType = "";
                        swiper._immediateVirtual = false;
                    }));
                } else {
                    if (!swiper.support.smoothScroll) {
                        animateCSSModeScroll({
                            swiper,
                            targetPosition: t,
                            side: isH ? "left" : "top"
                        });
                        return true;
                    }
                    wrapperEl.scrollTo({
                        [isH ? "left" : "top"]: t,
                        behavior: "smooth"
                    });
                }
                return true;
            }
            swiper.setTransition(speed);
            swiper.setTranslate(translate);
            swiper.updateActiveIndex(slideIndex);
            swiper.updateSlidesClasses();
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.transitionStart(runCallbacks, direction);
            if (speed === 0) swiper.transitionEnd(runCallbacks, direction); else if (!swiper.animating) {
                swiper.animating = true;
                if (!swiper.onSlideToWrapperTransitionEnd) swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                    swiper.onSlideToWrapperTransitionEnd = null;
                    delete swiper.onSlideToWrapperTransitionEnd;
                    swiper.transitionEnd(runCallbacks, direction);
                };
                swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
            }
            return true;
        }
        function slideToLoop(index = 0, speed = this.params.speed, runCallbacks = true, internal) {
            if (typeof index === "string") {
                const indexAsNumber = parseInt(index, 10);
                index = indexAsNumber;
            }
            const swiper = this;
            let newIndex = index;
            if (swiper.params.loop) if (swiper.virtual && swiper.params.virtual.enabled) newIndex += swiper.virtual.slidesBefore; else newIndex = swiper.getSlideIndexByData(newIndex);
            return swiper.slideTo(newIndex, speed, runCallbacks, internal);
        }
        function slideNext(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            const {enabled, params, animating} = swiper;
            if (!enabled) return swiper;
            let perGroup = params.slidesPerGroup;
            if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
            const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "next"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
            }
            if (params.rewind && swiper.isEnd) return swiper.slideTo(0, speed, runCallbacks, internal);
            return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
        }
        function slidePrev(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            const {params, snapGrid, slidesGrid, rtlTranslate, enabled, animating} = swiper;
            if (!enabled) return swiper;
            const isVirtual = swiper.virtual && params.virtual.enabled;
            if (params.loop) {
                if (animating && !isVirtual && params.loopPreventsSliding) return false;
                swiper.loopFix({
                    direction: "prev"
                });
                swiper._clientLeft = swiper.wrapperEl.clientLeft;
            }
            const translate = rtlTranslate ? swiper.translate : -swiper.translate;
            function normalize(val) {
                if (val < 0) return -Math.floor(Math.abs(val));
                return Math.floor(val);
            }
            const normalizedTranslate = normalize(translate);
            const normalizedSnapGrid = snapGrid.map((val => normalize(val)));
            let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
            if (typeof prevSnap === "undefined" && params.cssMode) {
                let prevSnapIndex;
                snapGrid.forEach(((snap, snapIndex) => {
                    if (normalizedTranslate >= snap) prevSnapIndex = snapIndex;
                }));
                if (typeof prevSnapIndex !== "undefined") prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
            }
            let prevIndex = 0;
            if (typeof prevSnap !== "undefined") {
                prevIndex = slidesGrid.indexOf(prevSnap);
                if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
                    prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
                    prevIndex = Math.max(prevIndex, 0);
                }
            }
            if (params.rewind && swiper.isBeginning) {
                const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
                return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
            }
            return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        }
        function slideReset(speed = this.params.speed, runCallbacks = true, internal) {
            const swiper = this;
            return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
        }
        function slideToClosest(speed = this.params.speed, runCallbacks = true, internal, threshold = .5) {
            const swiper = this;
            let index = swiper.activeIndex;
            const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
            const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
            const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
            if (translate >= swiper.snapGrid[snapIndex]) {
                const currentSnap = swiper.snapGrid[snapIndex];
                const nextSnap = swiper.snapGrid[snapIndex + 1];
                if (translate - currentSnap > (nextSnap - currentSnap) * threshold) index += swiper.params.slidesPerGroup;
            } else {
                const prevSnap = swiper.snapGrid[snapIndex - 1];
                const currentSnap = swiper.snapGrid[snapIndex];
                if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) index -= swiper.params.slidesPerGroup;
            }
            index = Math.max(index, 0);
            index = Math.min(index, swiper.slidesGrid.length - 1);
            return swiper.slideTo(index, speed, runCallbacks, internal);
        }
        function slideToClickedSlide() {
            const swiper = this;
            const {params, slidesEl} = swiper;
            const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
            let slideToIndex = swiper.clickedIndex;
            let realIndex;
            const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
            if (params.loop) {
                if (swiper.animating) return;
                realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
                if (params.centeredSlides) if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex); else if (slideToIndex > swiper.slides.length - slidesPerView) {
                    swiper.loopFix();
                    slideToIndex = swiper.getSlideIndex(utils_elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                    utils_nextTick((() => {
                        swiper.slideTo(slideToIndex);
                    }));
                } else swiper.slideTo(slideToIndex);
            } else swiper.slideTo(slideToIndex);
        }
        const slide = {
            slideTo,
            slideToLoop,
            slideNext,
            slidePrev,
            slideReset,
            slideToClosest,
            slideToClickedSlide
        };
        function loopCreate(slideRealIndex) {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            slides.forEach(((el, index) => {
                el.setAttribute("data-swiper-slide-index", index);
            }));
            swiper.loopFix({
                slideRealIndex,
                direction: params.centeredSlides ? void 0 : "next"
            });
        }
        function loopFix({slideRealIndex, slideTo = true, direction, setTranslate, activeSlideIndex, byController, byMousewheel} = {}) {
            const swiper = this;
            if (!swiper.params.loop) return;
            swiper.emit("beforeLoopFix");
            const {slides, allowSlidePrev, allowSlideNext, slidesEl, params} = swiper;
            swiper.allowSlidePrev = true;
            swiper.allowSlideNext = true;
            if (swiper.virtual && params.virtual.enabled) {
                if (slideTo) if (!params.centeredSlides && swiper.snapIndex === 0) swiper.slideTo(swiper.virtual.slides.length, 0, false, true); else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true); else if (swiper.snapIndex === swiper.snapGrid.length - 1) swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
                swiper.allowSlidePrev = allowSlidePrev;
                swiper.allowSlideNext = allowSlideNext;
                swiper.emit("loopFix");
                return;
            }
            const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));
            let loopedSlides = params.loopedSlides || slidesPerView;
            if (loopedSlides % params.slidesPerGroup !== 0) loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;
            swiper.loopedSlides = loopedSlides;
            const prependSlidesIndexes = [];
            const appendSlidesIndexes = [];
            let activeIndex = swiper.activeIndex;
            if (typeof activeSlideIndex === "undefined") activeSlideIndex = swiper.getSlideIndex(swiper.slides.filter((el => el.classList.contains(params.slideActiveClass)))[0]); else activeIndex = activeSlideIndex;
            const isNext = direction === "next" || !direction;
            const isPrev = direction === "prev" || !direction;
            let slidesPrepended = 0;
            let slidesAppended = 0;
            if (activeSlideIndex < loopedSlides) {
                slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
                for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {
                    const index = i - Math.floor(i / slides.length) * slides.length;
                    prependSlidesIndexes.push(slides.length - index - 1);
                }
            } else if (activeSlideIndex > swiper.slides.length - loopedSlides * 2) {
                slidesAppended = Math.max(activeSlideIndex - (swiper.slides.length - loopedSlides * 2), params.slidesPerGroup);
                for (let i = 0; i < slidesAppended; i += 1) {
                    const index = i - Math.floor(i / slides.length) * slides.length;
                    appendSlidesIndexes.push(index);
                }
            }
            if (isPrev) prependSlidesIndexes.forEach((index => {
                swiper.slides[index].swiperLoopMoveDOM = true;
                slidesEl.prepend(swiper.slides[index]);
                swiper.slides[index].swiperLoopMoveDOM = false;
            }));
            if (isNext) appendSlidesIndexes.forEach((index => {
                swiper.slides[index].swiperLoopMoveDOM = true;
                slidesEl.append(swiper.slides[index]);
                swiper.slides[index].swiperLoopMoveDOM = false;
            }));
            swiper.recalcSlides();
            if (params.slidesPerView === "auto") swiper.updateSlides();
            if (params.watchSlidesProgress) swiper.updateSlidesOffset();
            if (slideTo) if (prependSlidesIndexes.length > 0 && isPrev) {
                if (typeof slideRealIndex === "undefined") {
                    const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                    const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                    const diff = newSlideTranslate - currentSlideTranslate;
                    if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                        swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
                        if (setTranslate) swiper.touches[swiper.isHorizontal() ? "startX" : "startY"] += diff;
                    }
                } else if (setTranslate) swiper.slideToLoop(slideRealIndex, 0, false, true);
            } else if (appendSlidesIndexes.length > 0 && isNext) if (typeof slideRealIndex === "undefined") {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) swiper.setTranslate(swiper.translate - diff); else {
                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                    if (setTranslate) swiper.touches[swiper.isHorizontal() ? "startX" : "startY"] += diff;
                }
            } else swiper.slideToLoop(slideRealIndex, 0, false, true);
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.controller && swiper.controller.control && !byController) {
                const loopParams = {
                    slideRealIndex,
                    slideTo: false,
                    direction,
                    setTranslate,
                    activeSlideIndex,
                    byController: true
                };
                if (Array.isArray(swiper.controller.control)) swiper.controller.control.forEach((c => {
                    if (!c.destroyed && c.params.loop) c.loopFix(loopParams);
                })); else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) swiper.controller.control.loopFix(loopParams);
            }
            swiper.emit("loopFix");
        }
        function loopDestroy() {
            const swiper = this;
            const {params, slidesEl} = swiper;
            if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
            swiper.recalcSlides();
            const newSlidesOrder = [];
            swiper.slides.forEach((slideEl => {
                const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
                newSlidesOrder[index] = slideEl;
            }));
            swiper.slides.forEach((slideEl => {
                slideEl.removeAttribute("data-swiper-slide-index");
            }));
            newSlidesOrder.forEach((slideEl => {
                slidesEl.append(slideEl);
            }));
            swiper.recalcSlides();
            swiper.slideTo(swiper.realIndex, 0);
        }
        const loop = {
            loopCreate,
            loopFix,
            loopDestroy
        };
        function setGrabCursor(moving) {
            const swiper = this;
            if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            el.style.cursor = "move";
            el.style.cursor = moving ? "grabbing" : "grab";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        function unsetGrabCursor() {
            const swiper = this;
            if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
            if (swiper.isElement) swiper.__preventObserver__ = true;
            swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
            if (swiper.isElement) requestAnimationFrame((() => {
                swiper.__preventObserver__ = false;
            }));
        }
        const grab_cursor = {
            setGrabCursor,
            unsetGrabCursor
        };
        function closestElement(selector, base = this) {
            function __closestFrom(el) {
                if (!el || el === ssr_window_esm_getDocument() || el === ssr_window_esm_getWindow()) return null;
                if (el.assignedSlot) el = el.assignedSlot;
                const found = el.closest(selector);
                if (!found && !el.getRootNode) return null;
                return found || __closestFrom(el.getRootNode().host);
            }
            return __closestFrom(base);
        }
        function onTouchStart(event) {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const window = ssr_window_esm_getWindow();
            const data = swiper.touchEventsData;
            data.evCache.push(event);
            const {params, touches, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            if (swiper.animating && params.preventInteractionOnTransition) return;
            if (!swiper.animating && params.cssMode && params.loop) swiper.loopFix();
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            let targetEl = e.target;
            if (params.touchEventsTarget === "wrapper") if (!swiper.wrapperEl.contains(targetEl)) return;
            if ("which" in e && e.which === 3) return;
            if ("button" in e && e.button > 0) return;
            if (data.isTouched && data.isMoved) return;
            const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
            const eventPath = event.composedPath ? event.composedPath() : event.path;
            if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) targetEl = eventPath[0];
            const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
            const isTargetShadow = !!(e.target && e.target.shadowRoot);
            if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
                swiper.allowClick = true;
                return;
            }
            if (params.swipeHandler) if (!targetEl.closest(params.swipeHandler)) return;
            touches.currentX = e.pageX;
            touches.currentY = e.pageY;
            const startX = touches.currentX;
            const startY = touches.currentY;
            const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
            const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
            if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) if (edgeSwipeDetection === "prevent") event.preventDefault(); else return;
            Object.assign(data, {
                isTouched: true,
                isMoved: false,
                allowTouchCallbacks: true,
                isScrolling: void 0,
                startMoving: void 0
            });
            touches.startX = startX;
            touches.startY = startY;
            data.touchStartTime = utils_now();
            swiper.allowClick = true;
            swiper.updateSize();
            swiper.swipeDirection = void 0;
            if (params.threshold > 0) data.allowThresholdMove = false;
            let preventDefault = true;
            if (targetEl.matches(data.focusableElements)) {
                preventDefault = false;
                if (targetEl.nodeName === "SELECT") data.isTouched = false;
            }
            if (document.activeElement && document.activeElement.matches(data.focusableElements) && document.activeElement !== targetEl) document.activeElement.blur();
            const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
            if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) e.preventDefault();
            if (swiper.params.freeMode && swiper.params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) swiper.freeMode.onTouchStart();
            swiper.emit("touchStart", e);
        }
        function onTouchMove(event) {
            const document = ssr_window_esm_getDocument();
            const swiper = this;
            const data = swiper.touchEventsData;
            const {params, touches, rtlTranslate: rtl, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (!data.isTouched) {
                if (data.startMoving && data.isScrolling) swiper.emit("touchMoveOpposite", e);
                return;
            }
            const pointerIndex = data.evCache.findIndex((cachedEv => cachedEv.pointerId === e.pointerId));
            if (pointerIndex >= 0) data.evCache[pointerIndex] = e;
            const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;
            const pageX = targetTouch.pageX;
            const pageY = targetTouch.pageY;
            if (e.preventedByNestedSwiper) {
                touches.startX = pageX;
                touches.startY = pageY;
                return;
            }
            if (!swiper.allowTouchMove) {
                if (!e.target.matches(data.focusableElements)) swiper.allowClick = false;
                if (data.isTouched) {
                    Object.assign(touches, {
                        startX: pageX,
                        startY: pageY,
                        prevX: swiper.touches.currentX,
                        prevY: swiper.touches.currentY,
                        currentX: pageX,
                        currentY: pageY
                    });
                    data.touchStartTime = utils_now();
                }
                return;
            }
            if (params.touchReleaseOnEdges && !params.loop) if (swiper.isVertical()) {
                if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                    data.isTouched = false;
                    data.isMoved = false;
                    return;
                }
            } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) return;
            if (document.activeElement) if (e.target === document.activeElement && e.target.matches(data.focusableElements)) {
                data.isMoved = true;
                swiper.allowClick = false;
                return;
            }
            if (data.allowTouchCallbacks) swiper.emit("touchMove", e);
            if (e.targetTouches && e.targetTouches.length > 1) return;
            touches.currentX = pageX;
            touches.currentY = pageY;
            const diffX = touches.currentX - touches.startX;
            const diffY = touches.currentY - touches.startY;
            if (swiper.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold) return;
            if (typeof data.isScrolling === "undefined") {
                let touchAngle;
                if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) data.isScrolling = false; else if (diffX * diffX + diffY * diffY >= 25) {
                    touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                    data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
                }
            }
            if (data.isScrolling) swiper.emit("touchMoveOpposite", e);
            if (typeof data.startMoving === "undefined") if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) data.startMoving = true;
            if (data.isScrolling || swiper.zoom && swiper.params.zoom && swiper.params.zoom.enabled && data.evCache.length > 1) {
                data.isTouched = false;
                return;
            }
            if (!data.startMoving) return;
            swiper.allowClick = false;
            if (!params.cssMode && e.cancelable) e.preventDefault();
            if (params.touchMoveStopPropagation && !params.nested) e.stopPropagation();
            let diff = swiper.isHorizontal() ? diffX : diffY;
            let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
            if (params.oneWayMovement) {
                diff = Math.abs(diff) * (rtl ? 1 : -1);
                touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
            }
            touches.diff = diff;
            diff *= params.touchRatio;
            if (rtl) {
                diff = -diff;
                touchesDiff = -touchesDiff;
            }
            const prevTouchesDirection = swiper.touchesDirection;
            swiper.swipeDirection = diff > 0 ? "prev" : "next";
            swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
            const isLoop = swiper.params.loop && !params.cssMode;
            if (!data.isMoved) {
                if (isLoop) swiper.loopFix({
                    direction: swiper.swipeDirection
                });
                data.startTranslate = swiper.getTranslate();
                swiper.setTransition(0);
                if (swiper.animating) {
                    const evt = new window.CustomEvent("transitionend", {
                        bubbles: true,
                        cancelable: true
                    });
                    swiper.wrapperEl.dispatchEvent(evt);
                }
                data.allowMomentumBounce = false;
                if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(true);
                swiper.emit("sliderFirstMove", e);
            }
            let loopFixed;
            if (data.isMoved && prevTouchesDirection !== swiper.touchesDirection && isLoop && Math.abs(diff) >= 1) {
                swiper.loopFix({
                    direction: swiper.swipeDirection,
                    setTranslate: true
                });
                loopFixed = true;
            }
            swiper.emit("sliderMove", e);
            data.isMoved = true;
            data.currentTranslate = diff + data.startTranslate;
            let disableParentSwiper = true;
            let resistanceRatio = params.resistanceRatio;
            if (params.touchReleaseOnEdges) resistanceRatio = 0;
            if (diff > 0) {
                if (isLoop && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.size / 2 : swiper.minTranslate())) swiper.loopFix({
                    direction: "prev",
                    setTranslate: true,
                    activeSlideIndex: 0
                });
                if (data.currentTranslate > swiper.minTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + (-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
                }
            } else if (diff < 0) {
                if (isLoop && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.size / 2 : swiper.maxTranslate())) swiper.loopFix({
                    direction: "next",
                    setTranslate: true,
                    activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
                });
                if (data.currentTranslate < swiper.maxTranslate()) {
                    disableParentSwiper = false;
                    if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - (swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
                }
            }
            if (disableParentSwiper) e.preventedByNestedSwiper = true;
            if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) data.currentTranslate = data.startTranslate;
            if (!swiper.allowSlidePrev && !swiper.allowSlideNext) data.currentTranslate = data.startTranslate;
            if (params.threshold > 0) if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                if (!data.allowThresholdMove) {
                    data.allowThresholdMove = true;
                    touches.startX = touches.currentX;
                    touches.startY = touches.currentY;
                    data.currentTranslate = data.startTranslate;
                    touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                    return;
                }
            } else {
                data.currentTranslate = data.startTranslate;
                return;
            }
            if (!params.followFinger || params.cssMode) return;
            if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            if (swiper.params.freeMode && params.freeMode.enabled && swiper.freeMode) swiper.freeMode.onTouchMove();
            swiper.updateProgress(data.currentTranslate);
            swiper.setTranslate(data.currentTranslate);
        }
        function onTouchEnd(event) {
            const swiper = this;
            const data = swiper.touchEventsData;
            const pointerIndex = data.evCache.findIndex((cachedEv => cachedEv.pointerId === event.pointerId));
            if (pointerIndex >= 0) data.evCache.splice(pointerIndex, 1);
            if ([ "pointercancel", "pointerout", "pointerleave" ].includes(event.type)) {
                const proceed = event.type === "pointercancel" && (swiper.browser.isSafari || swiper.browser.isWebView);
                if (!proceed) return;
            }
            const {params, touches, rtlTranslate: rtl, slidesGrid, enabled} = swiper;
            if (!enabled) return;
            if (!params.simulateTouch && event.pointerType === "mouse") return;
            let e = event;
            if (e.originalEvent) e = e.originalEvent;
            if (data.allowTouchCallbacks) swiper.emit("touchEnd", e);
            data.allowTouchCallbacks = false;
            if (!data.isTouched) {
                if (data.isMoved && params.grabCursor) swiper.setGrabCursor(false);
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) swiper.setGrabCursor(false);
            const touchEndTime = utils_now();
            const timeDiff = touchEndTime - data.touchStartTime;
            if (swiper.allowClick) {
                const pathTree = e.path || e.composedPath && e.composedPath();
                swiper.updateClickedSlide(pathTree && pathTree[0] || e.target);
                swiper.emit("tap click", e);
                if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) swiper.emit("doubleTap doubleClick", e);
            }
            data.lastClickTime = utils_now();
            utils_nextTick((() => {
                if (!swiper.destroyed) swiper.allowClick = true;
            }));
            if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                return;
            }
            data.isTouched = false;
            data.isMoved = false;
            data.startMoving = false;
            let currentPos;
            if (params.followFinger) currentPos = rtl ? swiper.translate : -swiper.translate; else currentPos = -data.currentTranslate;
            if (params.cssMode) return;
            if (swiper.params.freeMode && params.freeMode.enabled) {
                swiper.freeMode.onTouchEnd({
                    currentPos
                });
                return;
            }
            let stopIndex = 0;
            let groupSize = swiper.slidesSizesGrid[0];
            for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
                const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                if (typeof slidesGrid[i + increment] !== "undefined") {
                    if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
                        stopIndex = i;
                        groupSize = slidesGrid[i + increment] - slidesGrid[i];
                    }
                } else if (currentPos >= slidesGrid[i]) {
                    stopIndex = i;
                    groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
                }
            }
            let rewindFirstIndex = null;
            let rewindLastIndex = null;
            if (params.rewind) if (swiper.isBeginning) rewindLastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1; else if (swiper.isEnd) rewindFirstIndex = 0;
            const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
            const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
            if (timeDiff > params.longSwipesMs) {
                if (!params.longSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                if (swiper.swipeDirection === "next") if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment); else swiper.slideTo(stopIndex);
                if (swiper.swipeDirection === "prev") if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment); else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) swiper.slideTo(rewindLastIndex); else swiper.slideTo(stopIndex);
            } else {
                if (!params.shortSwipes) {
                    swiper.slideTo(swiper.activeIndex);
                    return;
                }
                const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
                if (!isNavButtonTarget) {
                    if (swiper.swipeDirection === "next") swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
                    if (swiper.swipeDirection === "prev") swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
                } else if (e.target === swiper.navigation.nextEl) swiper.slideTo(stopIndex + increment); else swiper.slideTo(stopIndex);
            }
        }
        function onResize() {
            const swiper = this;
            const {params, el} = swiper;
            if (el && el.offsetWidth === 0) return;
            if (params.breakpoints) swiper.setBreakpoint();
            const {allowSlideNext, allowSlidePrev, snapGrid} = swiper;
            const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
            swiper.allowSlideNext = true;
            swiper.allowSlidePrev = true;
            swiper.updateSize();
            swiper.updateSlides();
            swiper.updateSlidesClasses();
            const isVirtualLoop = isVirtual && params.loop;
            if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) swiper.slideTo(swiper.slides.length - 1, 0, false, true); else if (swiper.params.loop && !isVirtual) swiper.slideToLoop(swiper.realIndex, 0, false, true); else swiper.slideTo(swiper.activeIndex, 0, false, true);
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                clearTimeout(swiper.autoplay.resizeTimeout);
                swiper.autoplay.resizeTimeout = setTimeout((() => {
                    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) swiper.autoplay.resume();
                }), 500);
            }
            swiper.allowSlidePrev = allowSlidePrev;
            swiper.allowSlideNext = allowSlideNext;
            if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
        }
        function onClick(e) {
            const swiper = this;
            if (!swiper.enabled) return;
            if (!swiper.allowClick) {
                if (swiper.params.preventClicks) e.preventDefault();
                if (swiper.params.preventClicksPropagation && swiper.animating) {
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                }
            }
        }
        function onScroll() {
            const swiper = this;
            const {wrapperEl, rtlTranslate, enabled} = swiper;
            if (!enabled) return;
            swiper.previousTranslate = swiper.translate;
            if (swiper.isHorizontal()) swiper.translate = -wrapperEl.scrollLeft; else swiper.translate = -wrapperEl.scrollTop;
            if (swiper.translate === 0) swiper.translate = 0;
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
            let newProgress;
            const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
            if (translatesDiff === 0) newProgress = 0; else newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
            if (newProgress !== swiper.progress) swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
            swiper.emit("setTranslate", swiper.translate, false);
        }
        function onLoad(e) {
            const swiper = this;
            processLazyPreloader(swiper, e.target);
            if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) return;
            swiper.update();
        }
        let dummyEventAttached = false;
        function dummyEventListener() {}
        const events = (swiper, method) => {
            const document = ssr_window_esm_getDocument();
            const {params, el, wrapperEl, device} = swiper;
            const capture = !!params.nested;
            const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
            const swiperMethod = method;
            el[domMethod]("pointerdown", swiper.onTouchStart, {
                passive: false
            });
            document[domMethod]("pointermove", swiper.onTouchMove, {
                passive: false,
                capture
            });
            document[domMethod]("pointerup", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointercancel", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerout", swiper.onTouchEnd, {
                passive: true
            });
            document[domMethod]("pointerleave", swiper.onTouchEnd, {
                passive: true
            });
            if (params.preventClicks || params.preventClicksPropagation) el[domMethod]("click", swiper.onClick, true);
            if (params.cssMode) wrapperEl[domMethod]("scroll", swiper.onScroll);
            if (params.updateOnWindowResize) swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true); else swiper[swiperMethod]("observerUpdate", onResize, true);
            el[domMethod]("load", swiper.onLoad, {
                capture: true
            });
        };
        function attachEvents() {
            const swiper = this;
            const document = ssr_window_esm_getDocument();
            const {params} = swiper;
            swiper.onTouchStart = onTouchStart.bind(swiper);
            swiper.onTouchMove = onTouchMove.bind(swiper);
            swiper.onTouchEnd = onTouchEnd.bind(swiper);
            if (params.cssMode) swiper.onScroll = onScroll.bind(swiper);
            swiper.onClick = onClick.bind(swiper);
            swiper.onLoad = onLoad.bind(swiper);
            if (!dummyEventAttached) {
                document.addEventListener("touchstart", dummyEventListener);
                dummyEventAttached = true;
            }
            events(swiper, "on");
        }
        function detachEvents() {
            const swiper = this;
            events(swiper, "off");
        }
        const core_events = {
            attachEvents,
            detachEvents
        };
        const isGridEnabled = (swiper, params) => swiper.grid && params.grid && params.grid.rows > 1;
        function setBreakpoint() {
            const swiper = this;
            const {realIndex, initialized, params, el} = swiper;
            const breakpoints = params.breakpoints;
            if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return;
            const breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
            if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
            const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : void 0;
            const breakpointParams = breakpointOnlyParams || swiper.originalParams;
            const wasMultiRow = isGridEnabled(swiper, params);
            const isMultiRow = isGridEnabled(swiper, breakpointParams);
            const wasEnabled = params.enabled;
            if (wasMultiRow && !isMultiRow) {
                el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            } else if (!wasMultiRow && isMultiRow) {
                el.classList.add(`${params.containerModifierClass}grid`);
                if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") el.classList.add(`${params.containerModifierClass}grid-column`);
                swiper.emitContainerClasses();
            }
            [ "navigation", "pagination", "scrollbar" ].forEach((prop => {
                const wasModuleEnabled = params[prop] && params[prop].enabled;
                const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
                if (wasModuleEnabled && !isModuleEnabled) swiper[prop].disable();
                if (!wasModuleEnabled && isModuleEnabled) swiper[prop].enable();
            }));
            const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
            const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
            if (directionChanged && initialized) swiper.changeDirection();
            utils_extend(swiper.params, breakpointParams);
            const isEnabled = swiper.params.enabled;
            Object.assign(swiper, {
                allowTouchMove: swiper.params.allowTouchMove,
                allowSlideNext: swiper.params.allowSlideNext,
                allowSlidePrev: swiper.params.allowSlidePrev
            });
            if (wasEnabled && !isEnabled) swiper.disable(); else if (!wasEnabled && isEnabled) swiper.enable();
            swiper.currentBreakpoint = breakpoint;
            swiper.emit("_beforeBreakpoint", breakpointParams);
            if (needsReLoop && initialized) {
                swiper.loopDestroy();
                swiper.loopCreate(realIndex);
                swiper.updateSlides();
            }
            swiper.emit("breakpoint", breakpointParams);
        }
        function getBreakpoint(breakpoints, base = "window", containerEl) {
            if (!breakpoints || base === "container" && !containerEl) return;
            let breakpoint = false;
            const window = ssr_window_esm_getWindow();
            const currentHeight = base === "window" ? window.innerHeight : containerEl.clientHeight;
            const points = Object.keys(breakpoints).map((point => {
                if (typeof point === "string" && point.indexOf("@") === 0) {
                    const minRatio = parseFloat(point.substr(1));
                    const value = currentHeight * minRatio;
                    return {
                        value,
                        point
                    };
                }
                return {
                    value: point,
                    point
                };
            }));
            points.sort(((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10)));
            for (let i = 0; i < points.length; i += 1) {
                const {point, value} = points[i];
                if (base === "window") {
                    if (window.matchMedia(`(min-width: ${value}px)`).matches) breakpoint = point;
                } else if (value <= containerEl.clientWidth) breakpoint = point;
            }
            return breakpoint || "max";
        }
        const breakpoints = {
            setBreakpoint,
            getBreakpoint
        };
        function prepareClasses(entries, prefix) {
            const resultClasses = [];
            entries.forEach((item => {
                if (typeof item === "object") Object.keys(item).forEach((classNames => {
                    if (item[classNames]) resultClasses.push(prefix + classNames);
                })); else if (typeof item === "string") resultClasses.push(prefix + item);
            }));
            return resultClasses;
        }
        function addClasses() {
            const swiper = this;
            const {classNames, params, rtl, el, device} = swiper;
            const suffixes = prepareClasses([ "initialized", params.direction, {
                "free-mode": swiper.params.freeMode && params.freeMode.enabled
            }, {
                autoheight: params.autoHeight
            }, {
                rtl
            }, {
                grid: params.grid && params.grid.rows > 1
            }, {
                "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
            }, {
                android: device.android
            }, {
                ios: device.ios
            }, {
                "css-mode": params.cssMode
            }, {
                centered: params.cssMode && params.centeredSlides
            }, {
                "watch-progress": params.watchSlidesProgress
            } ], params.containerModifierClass);
            classNames.push(...suffixes);
            el.classList.add(...classNames);
            swiper.emitContainerClasses();
        }
        function removeClasses_removeClasses() {
            const swiper = this;
            const {el, classNames} = swiper;
            el.classList.remove(...classNames);
            swiper.emitContainerClasses();
        }
        const classes = {
            addClasses,
            removeClasses: removeClasses_removeClasses
        };
        function checkOverflow() {
            const swiper = this;
            const {isLocked: wasLocked, params} = swiper;
            const {slidesOffsetBefore} = params;
            if (slidesOffsetBefore) {
                const lastSlideIndex = swiper.slides.length - 1;
                const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
                swiper.isLocked = swiper.size > lastSlideRightEdge;
            } else swiper.isLocked = swiper.snapGrid.length === 1;
            if (params.allowSlideNext === true) swiper.allowSlideNext = !swiper.isLocked;
            if (params.allowSlidePrev === true) swiper.allowSlidePrev = !swiper.isLocked;
            if (wasLocked && wasLocked !== swiper.isLocked) swiper.isEnd = false;
            if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? "lock" : "unlock");
        }
        const check_overflow = {
            checkOverflow
        };
        const defaults = {
            init: true,
            direction: "horizontal",
            oneWayMovement: false,
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: false,
            updateOnWindowResize: true,
            resizeObserver: true,
            nested: false,
            createElements: false,
            enabled: true,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: false,
            userAgent: null,
            url: null,
            edgeSwipeDetection: false,
            edgeSwipeThreshold: 20,
            autoHeight: false,
            setWrapperSize: false,
            virtualTranslate: false,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: false,
            centeredSlides: false,
            centeredSlidesBounds: false,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: true,
            centerInsufficientSlides: false,
            watchOverflow: true,
            roundLengths: false,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: true,
            shortSwipes: true,
            longSwipes: true,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: true,
            allowTouchMove: true,
            threshold: 5,
            touchMoveStopPropagation: false,
            touchStartPreventDefault: true,
            touchStartForcePreventDefault: false,
            touchReleaseOnEdges: false,
            uniqueNavElements: true,
            resistance: true,
            resistanceRatio: .85,
            watchSlidesProgress: false,
            grabCursor: false,
            preventClicks: true,
            preventClicksPropagation: true,
            slideToClickedSlide: false,
            loop: false,
            loopedSlides: null,
            loopPreventsSliding: true,
            rewind: false,
            allowSlidePrev: true,
            allowSlideNext: true,
            swipeHandler: null,
            noSwiping: true,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: true,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideActiveClass: "swiper-slide-active",
            slideVisibleClass: "swiper-slide-visible",
            slideNextClass: "swiper-slide-next",
            slidePrevClass: "swiper-slide-prev",
            wrapperClass: "swiper-wrapper",
            lazyPreloaderClass: "swiper-lazy-preloader",
            lazyPreloadPrevNext: 0,
            runCallbacksOnInit: true,
            _emitClasses: false
        };
        function moduleExtendParams(params, allModulesParams) {
            return function extendParams(obj = {}) {
                const moduleParamName = Object.keys(obj)[0];
                const moduleParams = obj[moduleParamName];
                if (typeof moduleParams !== "object" || moduleParams === null) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if ([ "navigation", "pagination", "scrollbar" ].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) params[moduleParamName] = {
                    auto: true
                };
                if (!(moduleParamName in params && "enabled" in moduleParams)) {
                    utils_extend(allModulesParams, obj);
                    return;
                }
                if (params[moduleParamName] === true) params[moduleParamName] = {
                    enabled: true
                };
                if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) params[moduleParamName].enabled = true;
                if (!params[moduleParamName]) params[moduleParamName] = {
                    enabled: false
                };
                utils_extend(allModulesParams, obj);
            };
        }
        const prototypes = {
            eventsEmitter: events_emitter,
            update,
            translate,
            transition,
            slide,
            loop,
            grabCursor: grab_cursor,
            events: core_events,
            breakpoints,
            checkOverflow: check_overflow,
            classes
        };
        const extendedDefaults = {};
        class core_Swiper {
            constructor(...args) {
                let el;
                let params;
                if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") params = args[0]; else [el, params] = args;
                if (!params) params = {};
                params = utils_extend({}, params);
                if (el && !params.el) params.el = el;
                const document = ssr_window_esm_getDocument();
                if (params.el && typeof params.el === "string" && document.querySelectorAll(params.el).length > 1) {
                    const swipers = [];
                    document.querySelectorAll(params.el).forEach((containerEl => {
                        const newParams = utils_extend({}, params, {
                            el: containerEl
                        });
                        swipers.push(new core_Swiper(newParams));
                    }));
                    return swipers;
                }
                const swiper = this;
                swiper.__swiper__ = true;
                swiper.support = getSupport();
                swiper.device = getDevice({
                    userAgent: params.userAgent
                });
                swiper.browser = getBrowser();
                swiper.eventsListeners = {};
                swiper.eventsAnyListeners = [];
                swiper.modules = [ ...swiper.__modules__ ];
                if (params.modules && Array.isArray(params.modules)) swiper.modules.push(...params.modules);
                const allModulesParams = {};
                swiper.modules.forEach((mod => {
                    mod({
                        params,
                        swiper,
                        extendParams: moduleExtendParams(params, allModulesParams),
                        on: swiper.on.bind(swiper),
                        once: swiper.once.bind(swiper),
                        off: swiper.off.bind(swiper),
                        emit: swiper.emit.bind(swiper)
                    });
                }));
                const swiperParams = utils_extend({}, defaults, allModulesParams);
                swiper.params = utils_extend({}, swiperParams, extendedDefaults, params);
                swiper.originalParams = utils_extend({}, swiper.params);
                swiper.passedParams = utils_extend({}, params);
                if (swiper.params && swiper.params.on) Object.keys(swiper.params.on).forEach((eventName => {
                    swiper.on(eventName, swiper.params.on[eventName]);
                }));
                if (swiper.params && swiper.params.onAny) swiper.onAny(swiper.params.onAny);
                Object.assign(swiper, {
                    enabled: swiper.params.enabled,
                    el,
                    classNames: [],
                    slides: [],
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal() {
                        return swiper.params.direction === "horizontal";
                    },
                    isVertical() {
                        return swiper.params.direction === "vertical";
                    },
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: true,
                    isEnd: false,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: false,
                    cssOverflowAdjustment() {
                        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
                    },
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev,
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: swiper.params.focusableElements,
                        lastClickTime: 0,
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        startMoving: void 0,
                        evCache: []
                    },
                    allowClick: true,
                    allowTouchMove: swiper.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                });
                swiper.emit("_swiper");
                if (swiper.params.init) swiper.init();
                return swiper;
            }
            getSlideIndex(slideEl) {
                const {slidesEl, params} = this;
                const slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
                const firstSlideIndex = utils_elementIndex(slides[0]);
                return utils_elementIndex(slideEl) - firstSlideIndex;
            }
            getSlideIndexByData(index) {
                return this.getSlideIndex(this.slides.filter((slideEl => slideEl.getAttribute("data-swiper-slide-index") * 1 === index))[0]);
            }
            recalcSlides() {
                const swiper = this;
                const {slidesEl, params} = swiper;
                swiper.slides = utils_elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
            }
            enable() {
                const swiper = this;
                if (swiper.enabled) return;
                swiper.enabled = true;
                if (swiper.params.grabCursor) swiper.setGrabCursor();
                swiper.emit("enable");
            }
            disable() {
                const swiper = this;
                if (!swiper.enabled) return;
                swiper.enabled = false;
                if (swiper.params.grabCursor) swiper.unsetGrabCursor();
                swiper.emit("disable");
            }
            setProgress(progress, speed) {
                const swiper = this;
                progress = Math.min(Math.max(progress, 0), 1);
                const min = swiper.minTranslate();
                const max = swiper.maxTranslate();
                const current = (max - min) * progress + min;
                swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
            }
            emitContainerClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const cls = swiper.el.className.split(" ").filter((className => className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0));
                swiper.emit("_containerClasses", cls.join(" "));
            }
            getSlideClasses(slideEl) {
                const swiper = this;
                if (swiper.destroyed) return "";
                return slideEl.className.split(" ").filter((className => className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0)).join(" ");
            }
            emitSlidesClasses() {
                const swiper = this;
                if (!swiper.params._emitClasses || !swiper.el) return;
                const updates = [];
                swiper.slides.forEach((slideEl => {
                    const classNames = swiper.getSlideClasses(slideEl);
                    updates.push({
                        slideEl,
                        classNames
                    });
                    swiper.emit("_slideClass", slideEl, classNames);
                }));
                swiper.emit("_slideClasses", updates);
            }
            slidesPerViewDynamic(view = "current", exact = false) {
                const swiper = this;
                const {params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex} = swiper;
                let spv = 1;
                if (params.centeredSlides) {
                    let slideSize = slides[activeIndex].swiperSlideSize;
                    let breakLoop;
                    for (let i = activeIndex + 1; i < slides.length; i += 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                    for (let i = activeIndex - 1; i >= 0; i -= 1) if (slides[i] && !breakLoop) {
                        slideSize += slides[i].swiperSlideSize;
                        spv += 1;
                        if (slideSize > swiperSize) breakLoop = true;
                    }
                } else if (view === "current") for (let i = activeIndex + 1; i < slides.length; i += 1) {
                    const slideInView = exact ? slidesGrid[i] + slidesSizesGrid[i] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) spv += 1;
                } else for (let i = activeIndex - 1; i >= 0; i -= 1) {
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                    if (slideInView) spv += 1;
                }
                return spv;
            }
            update() {
                const swiper = this;
                if (!swiper || swiper.destroyed) return;
                const {snapGrid, params} = swiper;
                if (params.breakpoints) swiper.setBreakpoint();
                [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach((imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl);
                }));
                swiper.updateSize();
                swiper.updateSlides();
                swiper.updateProgress();
                swiper.updateSlidesClasses();
                function setTranslate() {
                    const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
                    const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
                    swiper.setTranslate(newTranslate);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                let translated;
                if (swiper.params.freeMode && swiper.params.freeMode.enabled) {
                    setTranslate();
                    if (swiper.params.autoHeight) swiper.updateAutoHeight();
                } else {
                    if ((swiper.params.slidesPerView === "auto" || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
                        const slides = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                        translated = swiper.slideTo(slides.length - 1, 0, false, true);
                    } else translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                    if (!translated) setTranslate();
                }
                if (params.watchOverflow && snapGrid !== swiper.snapGrid) swiper.checkOverflow();
                swiper.emit("update");
            }
            changeDirection(newDirection, needUpdate = true) {
                const swiper = this;
                const currentDirection = swiper.params.direction;
                if (!newDirection) newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
                if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") return swiper;
                swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
                swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
                swiper.emitContainerClasses();
                swiper.params.direction = newDirection;
                swiper.slides.forEach((slideEl => {
                    if (newDirection === "vertical") slideEl.style.width = ""; else slideEl.style.height = "";
                }));
                swiper.emit("changeDirection");
                if (needUpdate) swiper.update();
                return swiper;
            }
            changeLanguageDirection(direction) {
                const swiper = this;
                if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
                swiper.rtl = direction === "rtl";
                swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
                if (swiper.rtl) {
                    swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "rtl";
                } else {
                    swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
                    swiper.el.dir = "ltr";
                }
                swiper.update();
            }
            mount(element) {
                const swiper = this;
                if (swiper.mounted) return true;
                let el = element || swiper.params.el;
                if (typeof el === "string") el = document.querySelector(el);
                if (!el) return false;
                el.swiper = swiper;
                if (el.shadowEl) swiper.isElement = true;
                const getWrapperSelector = () => `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
                const getWrapper = () => {
                    if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                        const res = el.shadowRoot.querySelector(getWrapperSelector());
                        return res;
                    }
                    return utils_elementChildren(el, getWrapperSelector())[0];
                };
                let wrapperEl = getWrapper();
                if (!wrapperEl && swiper.params.createElements) {
                    wrapperEl = utils_createElement("div", swiper.params.wrapperClass);
                    el.append(wrapperEl);
                    utils_elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl => {
                        wrapperEl.append(slideEl);
                    }));
                }
                Object.assign(swiper, {
                    el,
                    wrapperEl,
                    slidesEl: swiper.isElement ? el : wrapperEl,
                    mounted: true,
                    rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
                    rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
                    wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
                });
                return true;
            }
            init(el) {
                const swiper = this;
                if (swiper.initialized) return swiper;
                const mounted = swiper.mount(el);
                if (mounted === false) return swiper;
                swiper.emit("beforeInit");
                if (swiper.params.breakpoints) swiper.setBreakpoint();
                swiper.addClasses();
                swiper.updateSize();
                swiper.updateSlides();
                if (swiper.params.watchOverflow) swiper.checkOverflow();
                if (swiper.params.grabCursor && swiper.enabled) swiper.setGrabCursor();
                if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true); else swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
                if (swiper.params.loop) swiper.loopCreate();
                swiper.attachEvents();
                [ ...swiper.el.querySelectorAll('[loading="lazy"]') ].forEach((imageEl => {
                    if (imageEl.complete) processLazyPreloader(swiper, imageEl); else imageEl.addEventListener("load", (e => {
                        processLazyPreloader(swiper, e.target);
                    }));
                }));
                preload(swiper);
                swiper.initialized = true;
                preload(swiper);
                swiper.emit("init");
                swiper.emit("afterInit");
                return swiper;
            }
            destroy(deleteInstance = true, cleanStyles = true) {
                const swiper = this;
                const {params, el, wrapperEl, slides} = swiper;
                if (typeof swiper.params === "undefined" || swiper.destroyed) return null;
                swiper.emit("beforeDestroy");
                swiper.initialized = false;
                swiper.detachEvents();
                if (params.loop) swiper.loopDestroy();
                if (cleanStyles) {
                    swiper.removeClasses();
                    el.removeAttribute("style");
                    wrapperEl.removeAttribute("style");
                    if (slides && slides.length) slides.forEach((slideEl => {
                        slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                        slideEl.removeAttribute("style");
                        slideEl.removeAttribute("data-swiper-slide-index");
                    }));
                }
                swiper.emit("destroy");
                Object.keys(swiper.eventsListeners).forEach((eventName => {
                    swiper.off(eventName);
                }));
                if (deleteInstance !== false) {
                    swiper.el.swiper = null;
                    deleteProps(swiper);
                }
                swiper.destroyed = true;
                return null;
            }
            static extendDefaults(newDefaults) {
                utils_extend(extendedDefaults, newDefaults);
            }
            static get extendedDefaults() {
                return extendedDefaults;
            }
            static get defaults() {
                return defaults;
            }
            static installModule(mod) {
                if (!core_Swiper.prototype.__modules__) core_Swiper.prototype.__modules__ = [];
                const modules = core_Swiper.prototype.__modules__;
                if (typeof mod === "function" && modules.indexOf(mod) < 0) modules.push(mod);
            }
            static use(module) {
                if (Array.isArray(module)) {
                    module.forEach((m => core_Swiper.installModule(m)));
                    return core_Swiper;
                }
                core_Swiper.installModule(module);
                return core_Swiper;
            }
        }
        Object.keys(prototypes).forEach((prototypeGroup => {
            Object.keys(prototypes[prototypeGroup]).forEach((protoMethod => {
                core_Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
            }));
        }));
        core_Swiper.use([ Resize, Observer ]);
        const core = core_Swiper;
        function create_element_if_not_defined_createElementIfNotDefined(swiper, originalParams, params, checkProps) {
            if (swiper.params.createElements) Object.keys(checkProps).forEach((key => {
                if (!params[key] && params.auto === true) {
                    let element = utils_elementChildren(swiper.el, `.${checkProps[key]}`)[0];
                    if (!element) {
                        element = utils_createElement("div", checkProps[key]);
                        element.className = checkProps[key];
                        swiper.el.append(element);
                    }
                    params[key] = element;
                    originalParams[key] = element;
                }
            }));
            return params;
        }
        function Navigation({swiper, extendParams, on, emit}) {
            extendParams({
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: false,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock",
                    navigationDisabledClass: "swiper-navigation-disabled"
                }
            });
            swiper.navigation = {
                nextEl: null,
                prevEl: null
            };
            const makeElementsArray = el => {
                if (!Array.isArray(el)) el = [ el ].filter((e => !!e));
                return el;
            };
            function getEl(el) {
                let res;
                if (el && typeof el === "string" && swiper.isElement) {
                    res = swiper.el.shadowRoot.querySelector(el);
                    if (res) return res;
                }
                if (el) {
                    if (typeof el === "string") res = [ ...document.querySelectorAll(el) ];
                    if (swiper.params.uniqueNavElements && typeof el === "string" && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) res = swiper.el.querySelector(el);
                }
                if (el && !res) return el;
                return res;
            }
            function toggleEl(el, disabled) {
                const params = swiper.params.navigation;
                el = makeElementsArray(el);
                el.forEach((subEl => {
                    if (subEl) {
                        subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
                        if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
                        if (swiper.params.watchOverflow && swiper.enabled) subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
                    }
                }));
            }
            function update() {
                const {nextEl, prevEl} = swiper.navigation;
                if (swiper.params.loop) {
                    toggleEl(prevEl, false);
                    toggleEl(nextEl, false);
                    return;
                }
                toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
                toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
            }
            function onPrevClick(e) {
                e.preventDefault();
                if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slidePrev();
                emit("navigationPrev");
            }
            function onNextClick(e) {
                e.preventDefault();
                if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
                swiper.slideNext();
                emit("navigationNext");
            }
            function init() {
                const params = swiper.params.navigation;
                swiper.params.navigation = create_element_if_not_defined_createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
                    nextEl: "swiper-button-next",
                    prevEl: "swiper-button-prev"
                });
                if (!(params.nextEl || params.prevEl)) return;
                let nextEl = getEl(params.nextEl);
                let prevEl = getEl(params.prevEl);
                Object.assign(swiper.navigation, {
                    nextEl,
                    prevEl
                });
                nextEl = makeElementsArray(nextEl);
                prevEl = makeElementsArray(prevEl);
                const initButton = (el, dir) => {
                    if (el) el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
                    if (!swiper.enabled && el) el.classList.add(...params.lockClass.split(" "));
                };
                nextEl.forEach((el => initButton(el, "next")));
                prevEl.forEach((el => initButton(el, "prev")));
            }
            function destroy() {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = makeElementsArray(nextEl);
                prevEl = makeElementsArray(prevEl);
                const destroyButton = (el, dir) => {
                    el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
                    el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
                };
                nextEl.forEach((el => destroyButton(el, "next")));
                prevEl.forEach((el => destroyButton(el, "prev")));
            }
            on("init", (() => {
                if (swiper.params.navigation.enabled === false) disable(); else {
                    init();
                    update();
                }
            }));
            on("toEdge fromEdge lock unlock", (() => {
                update();
            }));
            on("destroy", (() => {
                destroy();
            }));
            on("enable disable", (() => {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = makeElementsArray(nextEl);
                prevEl = makeElementsArray(prevEl);
                [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList[swiper.enabled ? "remove" : "add"](swiper.params.navigation.lockClass)));
            }));
            on("click", ((_s, e) => {
                let {nextEl, prevEl} = swiper.navigation;
                nextEl = makeElementsArray(nextEl);
                prevEl = makeElementsArray(prevEl);
                const targetEl = e.target;
                if (swiper.params.navigation.hideOnClick && !prevEl.includes(targetEl) && !nextEl.includes(targetEl)) {
                    if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
                    let isHidden;
                    if (nextEl.length) isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass); else if (prevEl.length) isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
                    if (isHidden === true) emit("navigationShow"); else emit("navigationHide");
                    [ ...nextEl, ...prevEl ].filter((el => !!el)).forEach((el => el.classList.toggle(swiper.params.navigation.hiddenClass)));
                }
            }));
            const enable = () => {
                swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
                init();
                update();
            };
            const disable = () => {
                swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
                destroy();
            };
            Object.assign(swiper.navigation, {
                enable,
                disable,
                update,
                init,
                destroy
            });
        }
        function buildSliders() {
            let sliders = document.querySelectorAll('[class*="__swiper"]:not(.swiper-wrapper)');
            if (sliders) sliders.forEach((slider => {
                slider.parentElement.classList.add("swiper");
                slider.classList.add("swiper-wrapper");
                for (const slide of slider.children) slide.classList.add("swiper-slide");
            }));
        }
        function initSliders() {
            if (document.querySelector(".slider-proccesses")) new core(".slider-proccesses", {
                modules: [ Navigation ],
                observer: true,
                observeParents: true,
                spaceBetween: 16,
                speed: 800,
                navigation: {
                    prevEl: ".slider-proccesses .arrow-prev",
                    nextEl: ".slider-proccesses .arrow-next"
                },
                breakpoints: {
                    640: {
                        slidesPerView: 1
                    },
                    768: {
                        slidesPerView: 2
                    },
                    1024: {
                        slidesPerView: 3
                    }
                },
                on: {}
            });
            if (document.querySelector(".slider-in-touch")) new core(".slider-in-touch", {
                modules: [ Navigation ],
                observer: true,
                observeParents: true,
                spaceBetween: 16,
                speed: 800,
                navigation: {
                    prevEl: ".slider-in-touch .arrow-prev",
                    nextEl: ".slider-in-touch .arrow-next"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 2
                    },
                    768: {
                        slidesPerView: 4
                    },
                    1024: {
                        slidesPerView: 6
                    }
                },
                on: {}
            });
            if (document.querySelector(".slider-ourselves")) new core(".slider-ourselves", {
                modules: [ Navigation ],
                observer: true,
                observeParents: true,
                spaceBetween: 16,
                speed: 800,
                navigation: {
                    prevEl: ".slider-ourselves .arrow-prev",
                    nextEl: ".slider-ourselves .arrow-next"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 2
                    },
                    768.98: {
                        slidesPerView: 4
                    }
                },
                on: {}
            });
            if (document.querySelector(".slider-outview")) new core(".slider-outview", {
                modules: [ Navigation ],
                observer: true,
                observeParents: true,
                spaceBetween: 16,
                speed: 800,
                navigation: {
                    prevEl: ".slider-outview .arrow-prev",
                    nextEl: ".slider-outview .arrow-next"
                },
                breakpoints: {
                    320: {
                        slidesPerView: 1
                    },
                    768: {
                        slidesPerView: 2
                    },
                    1300: {
                        slidesPerView: 3
                    }
                },
                on: {}
            });
            if (document.querySelector(".experience__slider")) new core(".experience__slider", {
                modules: [ Navigation ],
                observer: true,
                observeParents: true,
                slidesPerView: 1,
                spaceBetween: 28,
                speed: 800,
                navigation: {
                    prevEl: ".experience__slider .arrow-prev",
                    nextEl: ".experience__slider .arrow-next"
                },
                on: {}
            });
        }
        window.addEventListener("load", (function(e) {
            buildSliders();
            initSliders();
        }));
        var lazyload_min = __webpack_require__(732);
        new lazyload_min({
            elements_selector: "[data-src],[data-srcset]",
            class_loaded: "_lazy-loaded",
            use_native: true
        });
        let addWindowScrollEvent = false;
        function pageNavigation() {
            document.addEventListener("click", pageNavigationAction);
            document.addEventListener("watcherCallback", pageNavigationAction);
            function pageNavigationAction(e) {
                if (e.type === "click") {
                    const targetElement = e.target;
                    if (targetElement.closest("[data-goto]")) {
                        const gotoLink = targetElement.closest("[data-goto]");
                        const gotoLinkSelector = gotoLink.dataset.goto ? gotoLink.dataset.goto : "";
                        const noHeader = gotoLink.hasAttribute("data-goto-header") ? true : false;
                        const gotoSpeed = gotoLink.dataset.gotoSpeed ? gotoLink.dataset.gotoSpeed : 500;
                        const offsetTop = gotoLink.dataset.gotoTop ? parseInt(gotoLink.dataset.gotoTop) : 0;
                        if (flsModules.fullpage) {
                            const fullpageSection = document.querySelector(`${gotoLinkSelector}`).closest("[data-fp-section]");
                            const fullpageSectionId = fullpageSection ? +fullpageSection.dataset.fpId : null;
                            if (fullpageSectionId !== null) {
                                flsModules.fullpage.switchingSection(fullpageSectionId);
                                document.documentElement.classList.contains("menu-open") ? menuClose() : null;
                            }
                        } else gotoBlock(gotoLinkSelector, noHeader, gotoSpeed, offsetTop);
                        e.preventDefault();
                    }
                } else if (e.type === "watcherCallback" && e.detail) {
                    const entry = e.detail.entry;
                    const targetElement = entry.target;
                    if (targetElement.dataset.watch === "navigator") {
                        document.querySelector(`[data-goto]._navigator-active`);
                        let navigatorCurrentItem;
                        if (targetElement.id && document.querySelector(`[data-goto="#${targetElement.id}"]`)) navigatorCurrentItem = document.querySelector(`[data-goto="#${targetElement.id}"]`); else if (targetElement.classList.length) for (let index = 0; index < targetElement.classList.length; index++) {
                            const element = targetElement.classList[index];
                            if (document.querySelector(`[data-goto=".${element}"]`)) {
                                navigatorCurrentItem = document.querySelector(`[data-goto=".${element}"]`);
                                break;
                            }
                        }
                        if (entry.isIntersecting) navigatorCurrentItem ? navigatorCurrentItem.classList.add("_navigator-active") : null; else navigatorCurrentItem ? navigatorCurrentItem.classList.remove("_navigator-active") : null;
                    }
                }
            }
            if (getHash()) {
                let goToHash;
                if (document.querySelector(`#${getHash()}`)) goToHash = `#${getHash()}`; else if (document.querySelector(`.${getHash()}`)) goToHash = `.${getHash()}`;
                goToHash ? gotoBlock(goToHash, true, 500, 20) : null;
            }
        }
        setTimeout((() => {
            if (addWindowScrollEvent) {
                let windowScroll = new Event("windowScroll");
                window.addEventListener("scroll", (function(e) {
                    document.dispatchEvent(windowScroll);
                }));
            }
        }), 0);
        const t = (t, e = 1e4) => (t = parseFloat(t + "") || 0, Math.round((t + Number.EPSILON) * e) / e), e = function(t) {
            if (!(t && t instanceof Element && t.offsetParent)) return !1;
            const e = t.scrollHeight > t.clientHeight, i = window.getComputedStyle(t).overflowY, n = -1 !== i.indexOf("hidden"), s = -1 !== i.indexOf("visible");
            return e && !n && !s;
        }, i = function(t, n = void 0) {
            return !(!t || t === document.body || n && t === n) && (e(t) ? t : i(t.parentElement, n));
        }, n = function(t) {
            var e = (new DOMParser).parseFromString(t, "text/html").body;
            if (e.childElementCount > 1) {
                for (var i = document.createElement("div"); e.firstChild; ) i.appendChild(e.firstChild);
                return i;
            }
            return e.firstChild;
        }, s = t => `${t || ""}`.split(" ").filter((t => !!t)), o = (t, e, i) => {
            s(e).forEach((e => {
                t && t.classList.toggle(e, i || !1);
            }));
        };
        class a {
            constructor(t) {
                Object.defineProperty(this, "pageX", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "pageY", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "clientX", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "clientY", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "id", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "time", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "nativePointer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), this.nativePointer = t, this.pageX = t.pageX, this.pageY = t.pageY, this.clientX = t.clientX, 
                this.clientY = t.clientY, this.id = self.Touch && t instanceof Touch ? t.identifier : -1, 
                this.time = Date.now();
            }
        }
        const r = {
            passive: !1
        };
        class l {
            constructor(t, {start: e = (() => !0), move: i = (() => {}), end: n = (() => {})}) {
                Object.defineProperty(this, "element", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "startCallback", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "moveCallback", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "endCallback", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "currentPointers", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), Object.defineProperty(this, "startPointers", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), this.element = t, this.startCallback = e, this.moveCallback = i, this.endCallback = n;
                for (const t of [ "onPointerStart", "onTouchStart", "onMove", "onTouchEnd", "onPointerEnd", "onWindowBlur" ]) this[t] = this[t].bind(this);
                this.element.addEventListener("mousedown", this.onPointerStart, r), this.element.addEventListener("touchstart", this.onTouchStart, r), 
                this.element.addEventListener("touchmove", this.onMove, r), this.element.addEventListener("touchend", this.onTouchEnd), 
                this.element.addEventListener("touchcancel", this.onTouchEnd);
            }
            onPointerStart(t) {
                if (!t.buttons || 0 !== t.button) return;
                const e = new a(t);
                this.currentPointers.some((t => t.id === e.id)) || this.triggerPointerStart(e, t) && (window.addEventListener("mousemove", this.onMove), 
                window.addEventListener("mouseup", this.onPointerEnd), window.addEventListener("blur", this.onWindowBlur));
            }
            onTouchStart(t) {
                for (const e of Array.from(t.changedTouches || [])) this.triggerPointerStart(new a(e), t);
                window.addEventListener("blur", this.onWindowBlur);
            }
            onMove(t) {
                const e = this.currentPointers.slice(), i = "changedTouches" in t ? Array.from(t.changedTouches || []).map((t => new a(t))) : [ new a(t) ], n = [];
                for (const t of i) {
                    const e = this.currentPointers.findIndex((e => e.id === t.id));
                    e < 0 || (n.push(t), this.currentPointers[e] = t);
                }
                n.length && this.moveCallback(t, this.currentPointers.slice(), e);
            }
            onPointerEnd(t) {
                t.buttons > 0 && 0 !== t.button || (this.triggerPointerEnd(t, new a(t)), window.removeEventListener("mousemove", this.onMove), 
                window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur));
            }
            onTouchEnd(t) {
                for (const e of Array.from(t.changedTouches || [])) this.triggerPointerEnd(t, new a(e));
            }
            triggerPointerStart(t, e) {
                return !!this.startCallback(e, t, this.currentPointers.slice()) && (this.currentPointers.push(t), 
                this.startPointers.push(t), !0);
            }
            triggerPointerEnd(t, e) {
                const i = this.currentPointers.findIndex((t => t.id === e.id));
                i < 0 || (this.currentPointers.splice(i, 1), this.startPointers.splice(i, 1), this.endCallback(t, e, this.currentPointers.slice()));
            }
            onWindowBlur() {
                this.clear();
            }
            clear() {
                for (;this.currentPointers.length; ) {
                    const t = this.currentPointers[this.currentPointers.length - 1];
                    this.currentPointers.splice(this.currentPointers.length - 1, 1), this.startPointers.splice(this.currentPointers.length - 1, 1), 
                    this.endCallback(new Event("touchend", {
                        bubbles: !0,
                        cancelable: !0,
                        clientX: t.clientX,
                        clientY: t.clientY
                    }), t, this.currentPointers.slice());
                }
            }
            stop() {
                this.element.removeEventListener("mousedown", this.onPointerStart, r), this.element.removeEventListener("touchstart", this.onTouchStart, r), 
                this.element.removeEventListener("touchmove", this.onMove, r), this.element.removeEventListener("touchend", this.onTouchEnd), 
                this.element.removeEventListener("touchcancel", this.onTouchEnd), window.removeEventListener("mousemove", this.onMove), 
                window.removeEventListener("mouseup", this.onPointerEnd), window.removeEventListener("blur", this.onWindowBlur);
            }
        }
        function c(t, e) {
            return e ? Math.sqrt(Math.pow(e.clientX - t.clientX, 2) + Math.pow(e.clientY - t.clientY, 2)) : 0;
        }
        function h(t, e) {
            return e ? {
                clientX: (t.clientX + e.clientX) / 2,
                clientY: (t.clientY + e.clientY) / 2
            } : t;
        }
        const d = t => "object" == typeof t && null !== t && t.constructor === Object && "[object Object]" === Object.prototype.toString.call(t), u = (t, ...e) => {
            const i = e.length;
            for (let n = 0; n < i; n++) {
                const i = e[n] || {};
                Object.entries(i).forEach((([e, i]) => {
                    const n = Array.isArray(i) ? [] : {};
                    t[e] || Object.assign(t, {
                        [e]: n
                    }), d(i) ? Object.assign(t[e], u(n, i)) : Array.isArray(i) ? Object.assign(t, {
                        [e]: [ ...i ]
                    }) : Object.assign(t, {
                        [e]: i
                    });
                }));
            }
            return t;
        }, p = function(t, e) {
            return t.split(".").reduce(((t, e) => "object" == typeof t ? t[e] : void 0), e);
        };
        class f {
            constructor(t = {}) {
                Object.defineProperty(this, "options", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                }), Object.defineProperty(this, "events", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: new Map
                }), this.setOptions(t);
                for (const t of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) t.startsWith("on") && "function" == typeof this[t] && (this[t] = this[t].bind(this));
            }
            setOptions(t) {
                this.options = t ? u({}, this.constructor.defaults, t) : {};
                for (const [t, e] of Object.entries(this.option("on") || {})) this.on(t, e);
            }
            option(t, ...e) {
                let i = p(t, this.options);
                return i && "function" == typeof i && (i = i.call(this, this, ...e)), i;
            }
            optionFor(t, e, i, ...n) {
                let s = p(e, t);
                var o;
                "string" != typeof (o = s) || isNaN(o) || isNaN(parseFloat(o)) || (s = parseFloat(s)), 
                "true" === s && (s = !0), "false" === s && (s = !1), s && "function" == typeof s && (s = s.call(this, this, t, ...n));
                let a = p(e, this.options);
                return a && "function" == typeof a ? s = a.call(this, this, t, ...n, s) : void 0 === s && (s = a), 
                void 0 === s ? i : s;
            }
            cn(t) {
                const e = this.options.classes;
                return e && e[t] || "";
            }
            localize(t, e = []) {
                t = String(t).replace(/\{\{(\w+).?(\w+)?\}\}/g, ((t, e, i) => {
                    let n = "";
                    return i ? n = this.option(`${e[0] + e.toLowerCase().substring(1)}.l10n.${i}`) : e && (n = this.option(`l10n.${e}`)), 
                    n || (n = t), n;
                }));
                for (let i = 0; i < e.length; i++) t = t.split(e[i][0]).join(e[i][1]);
                return t = t.replace(/\{\{(.*?)\}\}/g, ((t, e) => e));
            }
            on(t, e) {
                let i = [];
                "string" == typeof t ? i = t.split(" ") : Array.isArray(t) && (i = t), this.events || (this.events = new Map), 
                i.forEach((t => {
                    let i = this.events.get(t);
                    i || (this.events.set(t, []), i = []), i.includes(e) || i.push(e), this.events.set(t, i);
                }));
            }
            off(t, e) {
                let i = [];
                "string" == typeof t ? i = t.split(" ") : Array.isArray(t) && (i = t), i.forEach((t => {
                    const i = this.events.get(t);
                    if (Array.isArray(i)) {
                        const t = i.indexOf(e);
                        t > -1 && i.splice(t, 1);
                    }
                }));
            }
            emit(t, ...e) {
                [ ...this.events.get(t) || [] ].forEach((t => t(this, ...e))), "*" !== t && this.emit("*", t, ...e);
            }
        }
        Object.defineProperty(f, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "5.0.20"
        }), Object.defineProperty(f, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {}
        });
        class m extends f {
            constructor(t = {}) {
                super(t), Object.defineProperty(this, "plugins", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {}
                });
            }
            attachPlugins(t = {}) {
                const e = new Map;
                for (const [i, n] of Object.entries(t)) {
                    const t = this.option(i), s = this.plugins[i];
                    s || !1 === t ? s && !1 === t && (s.detach(), delete this.plugins[i]) : e.set(i, new n(this, t || {}));
                }
                for (const [t, i] of e) this.plugins[t] = i, i.attach();
                this.emit("attachPlugins");
            }
            detachPlugins(t) {
                t = t || Object.keys(this.plugins);
                for (const e of t) {
                    const t = this.plugins[e];
                    t && t.detach(), delete this.plugins[e];
                }
                return this.emit("detachPlugins"), this;
            }
        }
        var g;
        !function(t) {
            t[t.Init = 0] = "Init", t[t.Error = 1] = "Error", t[t.Ready = 2] = "Ready", t[t.Panning = 3] = "Panning", 
            t[t.Mousemove = 4] = "Mousemove", t[t.Destroy = 5] = "Destroy";
        }(g || (g = {}));
        const b = [ "a", "b", "c", "d", "e", "f" ], v = {
            PANUP: "Move up",
            PANDOWN: "Move down",
            PANLEFT: "Move left",
            PANRIGHT: "Move right",
            ZOOMIN: "Zoom in",
            ZOOMOUT: "Zoom out",
            TOGGLEZOOM: "Toggle zoom level",
            TOGGLE1TO1: "Toggle zoom level",
            ITERATEZOOM: "Toggle zoom level",
            ROTATECCW: "Rotate counterclockwise",
            ROTATECW: "Rotate clockwise",
            FLIPX: "Flip horizontally",
            FLIPY: "Flip vertically",
            FITX: "Fit horizontally",
            FITY: "Fit vertically",
            RESET: "Reset",
            TOGGLEFS: "Toggle fullscreen"
        }, y = {
            content: null,
            width: "auto",
            height: "auto",
            panMode: "drag",
            touch: !0,
            dragMinThreshold: 3,
            lockAxis: !1,
            mouseMoveFactor: 1,
            mouseMoveFriction: .12,
            zoom: !0,
            pinchToZoom: !0,
            panOnlyZoomed: "auto",
            minScale: 1,
            maxScale: 2,
            friction: .25,
            dragFriction: .35,
            decelFriction: .05,
            click: "toggleZoom",
            dblClick: !1,
            wheel: "zoom",
            wheelLimit: 7,
            spinner: !0,
            bounds: "auto",
            infinite: !1,
            rubberband: !0,
            bounce: !0,
            maxVelocity: 75,
            transformParent: !1,
            classes: {
                content: "f-panzoom__content",
                isLoading: "is-loading",
                canZoomIn: "can-zoom_in",
                canZoomOut: "can-zoom_out",
                isDraggable: "is-draggable",
                isDragging: "is-dragging",
                inFullscreen: "in-fullscreen",
                htmlHasFullscreen: "with-panzoom-in-fullscreen"
            },
            l10n: v
        }, w = '<div class="f-spinner"><svg viewBox="0 0 50 50"><circle cx="25" cy="25" r="20"></circle><circle cx="25" cy="25" r="20"></circle></svg></div>', x = t => t && null !== t && t instanceof Element && "nodeType" in t, E = (t, e) => {
            t && s(e).forEach((e => {
                t.classList.remove(e);
            }));
        }, S = (t, e) => {
            t && s(e).forEach((e => {
                t.classList.add(e);
            }));
        }, P = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: 0,
            f: 0
        }, C = 1e5, M = 1e3, T = "mousemove", O = "drag", A = "content";
        let z = null, L = null;
        class R extends m {
            get isTouchDevice() {
                return null === L && (L = window.matchMedia("(hover: none)").matches), L;
            }
            get isMobile() {
                return null === z && (z = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)), 
                z;
            }
            get panMode() {
                return this.options.panMode !== T || this.isTouchDevice ? O : T;
            }
            get panOnlyZoomed() {
                const t = this.options.panOnlyZoomed;
                return "auto" === t ? this.isTouchDevice : t;
            }
            get isInfinite() {
                return this.option("infinite");
            }
            get angle() {
                return 180 * Math.atan2(this.current.b, this.current.a) / Math.PI || 0;
            }
            get targetAngle() {
                return 180 * Math.atan2(this.target.b, this.target.a) / Math.PI || 0;
            }
            get scale() {
                const {a: t, b: e} = this.current;
                return Math.sqrt(t * t + e * e) || 1;
            }
            get targetScale() {
                const {a: t, b: e} = this.target;
                return Math.sqrt(t * t + e * e) || 1;
            }
            get minScale() {
                return this.option("minScale") || 1;
            }
            get fullScale() {
                const {contentRect: t} = this;
                return t.fullWidth / t.fitWidth || 1;
            }
            get maxScale() {
                return this.fullScale * (this.option("maxScale") || 1) || 1;
            }
            get coverScale() {
                const {containerRect: t, contentRect: e} = this, i = Math.max(t.height / e.fitHeight, t.width / e.fitWidth) || 1;
                return Math.min(this.fullScale, i);
            }
            get isScaling() {
                return Math.abs(this.targetScale - this.scale) > 1e-5 && !this.isResting;
            }
            get isContentLoading() {
                const t = this.content;
                return !!(t && t instanceof HTMLImageElement) && !t.complete;
            }
            get isResting() {
                if (this.isBouncingX || this.isBouncingY) return !1;
                for (const t of b) {
                    const e = "e" == t || "f" === t ? .001 : 1e-5;
                    if (Math.abs(this.target[t] - this.current[t]) > e) return !1;
                }
                return !(!this.ignoreBounds && !this.checkBounds().inBounds);
            }
            constructor(t, e = {}, i = {}) {
                var s;
                if (super(e), Object.defineProperty(this, "pointerTracker", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "resizeObserver", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "updateTimer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "clickTimer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "rAF", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "isTicking", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "friction", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "ignoreBounds", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "isBouncingX", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "isBouncingY", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "clicks", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "trackingPoints", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), Object.defineProperty(this, "pwt", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "cwd", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "pmme", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: g.Init
                }), Object.defineProperty(this, "isDragging", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "content", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "spinner", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "containerRect", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {
                        width: 0,
                        height: 0,
                        innerWidth: 0,
                        innerHeight: 0
                    }
                }), Object.defineProperty(this, "contentRect", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0,
                        fullWidth: 0,
                        fullHeight: 0,
                        fitWidth: 0,
                        fitHeight: 0,
                        width: 0,
                        height: 0
                    }
                }), Object.defineProperty(this, "dragStart", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {
                        x: 0,
                        y: 0,
                        top: 0,
                        left: 0,
                        time: 0
                    }
                }), Object.defineProperty(this, "dragOffset", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {
                        x: 0,
                        y: 0,
                        time: 0
                    }
                }), Object.defineProperty(this, "current", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: Object.assign({}, P)
                }), Object.defineProperty(this, "target", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: Object.assign({}, P)
                }), Object.defineProperty(this, "velocity", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {
                        a: 0,
                        b: 0,
                        c: 0,
                        d: 0,
                        e: 0,
                        f: 0
                    }
                }), Object.defineProperty(this, "lockedAxis", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), !t) throw new Error("Container Element Not Found");
                this.container = t, this.initContent(), this.attachPlugins(Object.assign(Object.assign({}, R.Plugins), i)), 
                this.emit("init");
                const o = this.content;
                if (o.addEventListener("load", this.onLoad), o.addEventListener("error", this.onError), 
                this.isContentLoading) {
                    if (this.option("spinner")) {
                        t.classList.add(this.cn("isLoading"));
                        const e = n(w);
                        !t.contains(o) || o.parentElement instanceof HTMLPictureElement ? this.spinner = t.appendChild(e) : this.spinner = (null === (s = o.parentElement) || void 0 === s ? void 0 : s.insertBefore(e, o)) || null;
                    }
                    this.emit("beforeLoad");
                } else queueMicrotask((() => {
                    this.enable();
                }));
            }
            initContent() {
                const {container: t} = this, e = this.cn(A);
                let i = this.option(A) || t.querySelector(`.${e}`);
                if (i || (i = t.querySelector("img,picture") || t.firstElementChild, i && S(i, e)), 
                i instanceof HTMLPictureElement && (i = i.querySelector("img")), !i) throw new Error("No content found");
                this.content = i;
            }
            onLoad() {
                this.spinner && (this.spinner.remove(), this.spinner = null), this.option("spinner") && this.container.classList.remove(this.cn("isLoading")), 
                this.emit("afterLoad"), this.state === g.Init ? this.enable() : this.updateMetrics();
            }
            onError() {
                this.state !== g.Destroy && (this.spinner && (this.spinner.remove(), this.spinner = null), 
                this.stop(), this.detachEvents(), this.state = g.Error, this.emit("error"));
            }
            attachObserver() {
                var t;
                const e = () => Math.abs(this.containerRect.width - this.container.getBoundingClientRect().width) > .1 || Math.abs(this.containerRect.height - this.container.getBoundingClientRect().height) > .1;
                this.resizeObserver || void 0 === window.ResizeObserver || (this.resizeObserver = new ResizeObserver((() => {
                    this.updateTimer || (e() ? (this.onResize(), this.isMobile && (this.updateTimer = setTimeout((() => {
                        e() && this.onResize(), this.updateTimer = null;
                    }), 500))) : this.updateTimer && (clearTimeout(this.updateTimer), this.updateTimer = null));
                }))), null === (t = this.resizeObserver) || void 0 === t || t.observe(this.container);
            }
            detachObserver() {
                var t;
                null === (t = this.resizeObserver) || void 0 === t || t.disconnect();
            }
            attachEvents() {
                const {container: t} = this;
                t.addEventListener("click", this.onClick, {
                    passive: !1,
                    capture: !1
                }), t.addEventListener("wheel", this.onWheel, {
                    passive: !1
                }), this.pointerTracker = new l(t, {
                    start: this.onPointerDown,
                    move: this.onPointerMove,
                    end: this.onPointerUp
                }), document.addEventListener(T, this.onMouseMove);
            }
            detachEvents() {
                var t;
                const {container: e} = this;
                e.removeEventListener("click", this.onClick, {
                    passive: !1,
                    capture: !1
                }), e.removeEventListener("wheel", this.onWheel, {
                    passive: !1
                }), null === (t = this.pointerTracker) || void 0 === t || t.stop(), this.pointerTracker = null, 
                document.removeEventListener(T, this.onMouseMove), document.removeEventListener("keydown", this.onKeydown, !0), 
                this.clickTimer && (clearTimeout(this.clickTimer), this.clickTimer = null), this.updateTimer && (clearTimeout(this.updateTimer), 
                this.updateTimer = null);
            }
            animate() {
                const t = this.friction;
                this.setTargetForce();
                const e = this.option("maxVelocity");
                for (const i of b) t ? (this.velocity[i] *= 1 - t, e && !this.isScaling && (this.velocity[i] = Math.max(Math.min(this.velocity[i], e), -1 * e)), 
                this.current[i] += this.velocity[i]) : this.current[i] = this.target[i];
                this.setTransform(), this.setEdgeForce(), !this.isResting || this.isDragging ? this.rAF = requestAnimationFrame((() => this.animate())) : this.stop("current");
            }
            setTargetForce() {
                for (const t of b) "e" === t && this.isBouncingX || "f" === t && this.isBouncingY || (this.velocity[t] = (1 / (1 - this.friction) - 1) * (this.target[t] - this.current[t]));
            }
            checkBounds(t = 0, e = 0) {
                const {current: i} = this, n = i.e + t, s = i.f + e, o = this.getBounds(), {x: a, y: r} = o, l = a.min, c = a.max, h = r.min, d = r.max;
                let u = 0, p = 0;
                return l !== 1 / 0 && n < l ? u = l - n : c !== 1 / 0 && n > c && (u = c - n), h !== 1 / 0 && s < h ? p = h - s : d !== 1 / 0 && s > d && (p = d - s), 
                Math.abs(u) < .001 && (u = 0), Math.abs(p) < .001 && (p = 0), Object.assign(Object.assign({}, o), {
                    xDiff: u,
                    yDiff: p,
                    inBounds: !u && !p
                });
            }
            clampTargetBounds() {
                const {target: t} = this, {x: e, y: i} = this.getBounds();
                e.min !== 1 / 0 && (t.e = Math.max(t.e, e.min)), e.max !== 1 / 0 && (t.e = Math.min(t.e, e.max)), 
                i.min !== 1 / 0 && (t.f = Math.max(t.f, i.min)), i.max !== 1 / 0 && (t.f = Math.min(t.f, i.max));
            }
            calculateContentDim(t = this.current) {
                const {content: e, contentRect: i} = this, {fitWidth: n, fitHeight: s, fullWidth: o, fullHeight: a} = i;
                let r = o, l = a;
                if (this.option("zoom") || 0 !== this.angle) {
                    const i = !(e instanceof HTMLImageElement) && ("none" === window.getComputedStyle(e).maxWidth || "none" === window.getComputedStyle(e).maxHeight), c = i ? o : n, h = i ? a : s, d = this.getMatrix(t), u = new DOMPoint(0, 0).matrixTransform(d), p = new DOMPoint(0 + c, 0).matrixTransform(d), f = new DOMPoint(0 + c, 0 + h).matrixTransform(d), m = new DOMPoint(0, 0 + h).matrixTransform(d), g = Math.abs(f.x - u.x), b = Math.abs(f.y - u.y), v = Math.abs(m.x - p.x), y = Math.abs(m.y - p.y);
                    r = Math.max(g, v), l = Math.max(b, y);
                }
                return {
                    contentWidth: r,
                    contentHeight: l
                };
            }
            setEdgeForce() {
                if (this.ignoreBounds || this.isDragging || this.panMode === T || this.targetScale < this.scale) return this.isBouncingX = !1, 
                void (this.isBouncingY = !1);
                const {target: t} = this, {x: e, y: i, xDiff: n, yDiff: s} = this.checkBounds();
                const o = this.option("maxVelocity");
                let a = this.velocity.e, r = this.velocity.f;
                0 !== n ? (this.isBouncingX = !0, n * a <= 0 ? a += .14 * n : (a = .14 * n, e.min !== 1 / 0 && (this.target.e = Math.max(t.e, e.min)), 
                e.max !== 1 / 0 && (this.target.e = Math.min(t.e, e.max))), o && (a = Math.max(Math.min(a, o), -1 * o))) : this.isBouncingX = !1, 
                0 !== s ? (this.isBouncingY = !0, s * r <= 0 ? r += .14 * s : (r = .14 * s, i.min !== 1 / 0 && (this.target.f = Math.max(t.f, i.min)), 
                i.max !== 1 / 0 && (this.target.f = Math.min(t.f, i.max))), o && (r = Math.max(Math.min(r, o), -1 * o))) : this.isBouncingY = !1, 
                this.isBouncingX && (this.velocity.e = a), this.isBouncingY && (this.velocity.f = r);
            }
            enable() {
                const {content: t} = this, e = new DOMMatrixReadOnly(window.getComputedStyle(t).transform);
                for (const t of b) this.current[t] = this.target[t] = e[t];
                this.updateMetrics(), this.attachObserver(), this.attachEvents(), this.state = g.Ready, 
                this.emit("ready");
            }
            onClick(t) {
                var e;
                this.isDragging && (null === (e = this.pointerTracker) || void 0 === e || e.clear(), 
                this.trackingPoints = [], this.startDecelAnim());
                const i = t.target;
                if (!i || t.defaultPrevented) return;
                if (i && i.hasAttribute("disabled")) return t.preventDefault(), void t.stopPropagation();
                if ((() => {
                    const t = window.getSelection();
                    return t && "Range" === t.type;
                })() && !i.closest("button")) return;
                const n = i.closest("[data-panzoom-action]"), s = i.closest("[data-panzoom-change]"), o = n || s, a = o && x(o) ? o.dataset : null;
                if (a) {
                    const e = a.panzoomChange, i = a.panzoomAction;
                    if ((e || i) && t.preventDefault(), e) {
                        let t = {};
                        try {
                            t = JSON.parse(e);
                        } catch (t) {
                            console && console.warn("The given data was not valid JSON");
                        }
                        return void this.applyChange(t);
                    }
                    if (i) return void (this[i] && this[i]());
                }
                if (Math.abs(this.dragOffset.x) > 3 || Math.abs(this.dragOffset.y) > 3) return t.preventDefault(), 
                void t.stopPropagation();
                const r = this.content.getBoundingClientRect();
                if (this.dragStart.time && !this.canZoomOut() && (Math.abs(r.x - this.dragStart.x) > 2 || Math.abs(r.y - this.dragStart.y) > 2)) return;
                this.dragStart.time = 0;
                const l = e => {
                    this.option("zoom") && e && "string" == typeof e && /(iterateZoom)|(toggle(Zoom|Full|Cover|Max)|(zoomTo(Fit|Cover|Max)))/.test(e) && "function" == typeof this[e] && (t.preventDefault(), 
                    this[e]({
                        event: t
                    }));
                }, c = this.option("click", t), h = this.option("dblClick", t);
                h ? (this.clicks++, 1 == this.clicks && (this.clickTimer = setTimeout((() => {
                    1 === this.clicks ? (this.emit("click", t), !t.defaultPrevented && c && l(c)) : (this.emit("dblClick", t), 
                    t.defaultPrevented || l(h)), this.clicks = 0, this.clickTimer = null;
                }), 350))) : (this.emit("click", t), !t.defaultPrevented && c && l(c));
            }
            addTrackingPoint(t) {
                const e = this.trackingPoints.filter((t => t.time > Date.now() - 100));
                e.push(t), this.trackingPoints = e;
            }
            onPointerDown(t, e, i) {
                var n;
                this.pwt = 0, this.dragOffset = {
                    x: 0,
                    y: 0,
                    time: 0
                }, this.trackingPoints = [];
                const s = this.content.getBoundingClientRect();
                if (this.dragStart = {
                    x: s.x,
                    y: s.y,
                    top: s.top,
                    left: s.left,
                    time: Date.now()
                }, this.clickTimer) return !1;
                if (this.panMode === T && this.targetScale > 1) return t.preventDefault(), t.stopPropagation(), 
                !1;
                if (!i.length) {
                    const e = t.composedPath()[0];
                    if ([ "A", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO" ].includes(e.nodeName) || e.closest("[contenteditable]") || e.closest("[data-selectable]") || e.closest("[data-draggable]") || e.closest("[data-clickable]") || e.closest("[data-panzoom-change]") || e.closest("[data-panzoom-action]")) return !1;
                    null === (n = window.getSelection()) || void 0 === n || n.removeAllRanges();
                }
                if ("mousedown" === t.type) t.preventDefault(); else if (Math.abs(this.velocity.a) > .3) return !1;
                return this.target.e = this.current.e, this.target.f = this.current.f, this.stop(), 
                this.isDragging || (this.isDragging = !0, this.addTrackingPoint(e), this.emit("touchStart", t)), 
                !0;
            }
            onPointerMove(e, n, s) {
                if (!1 === this.option("touch", e)) return;
                if (!this.isDragging) return;
                if (n.length < 2 && this.panOnlyZoomed && t(this.targetScale) <= t(this.minScale)) return;
                if (this.emit("touchMove", e), e.defaultPrevented) return;
                this.addTrackingPoint(n[0]);
                const {content: o} = this, a = h(s[0], s[1]), r = h(n[0], n[1]);
                let l = 0, d = 0;
                if (n.length > 1) {
                    const t = o.getBoundingClientRect();
                    l = a.clientX - t.left - .5 * t.width, d = a.clientY - t.top - .5 * t.height;
                }
                const u = c(s[0], s[1]), p = c(n[0], n[1]);
                let f = u ? p / u : 1, m = r.clientX - a.clientX, g = r.clientY - a.clientY;
                this.dragOffset.x += m, this.dragOffset.y += g, this.dragOffset.time = Date.now() - this.dragStart.time;
                let b = t(this.targetScale) === t(this.minScale) && this.option("lockAxis");
                if (b && !this.lockedAxis) if ("xy" === b || "y" === b || "touchmove" === e.type) {
                    if (Math.abs(this.dragOffset.x) < 6 && Math.abs(this.dragOffset.y) < 6) return void e.preventDefault();
                    const t = Math.abs(180 * Math.atan2(this.dragOffset.y, this.dragOffset.x) / Math.PI);
                    this.lockedAxis = t > 45 && t < 135 ? "y" : "x", this.dragOffset.x = 0, this.dragOffset.y = 0, 
                    m = 0, g = 0;
                } else this.lockedAxis = b;
                if (i(e.target, this.content) && (b = "x", this.dragOffset.y = 0), b && "xy" !== b && this.lockedAxis !== b && t(this.targetScale) === t(this.minScale)) return;
                e.cancelable && e.preventDefault(), this.container.classList.add(this.cn("isDragging"));
                const v = this.checkBounds(m, g);
                this.option("rubberband") ? ("x" !== this.isInfinite && (v.xDiff > 0 && m < 0 || v.xDiff < 0 && m > 0) && (m *= Math.max(0, .5 - Math.abs(.75 / this.contentRect.fitWidth * v.xDiff))), 
                "y" !== this.isInfinite && (v.yDiff > 0 && g < 0 || v.yDiff < 0 && g > 0) && (g *= Math.max(0, .5 - Math.abs(.75 / this.contentRect.fitHeight * v.yDiff)))) : (v.xDiff && (m = 0), 
                v.yDiff && (g = 0));
                const y = this.targetScale, w = this.minScale, x = this.maxScale;
                y < .5 * w && (f = Math.max(f, w)), y > 1.5 * x && (f = Math.min(f, x)), "y" === this.lockedAxis && t(y) === t(w) && (m = 0), 
                "x" === this.lockedAxis && t(y) === t(w) && (g = 0), this.applyChange({
                    originX: l,
                    originY: d,
                    panX: m,
                    panY: g,
                    scale: f,
                    friction: this.option("dragFriction"),
                    ignoreBounds: !0
                });
            }
            onPointerUp(t, e, n) {
                if (n.length) return this.dragOffset.x = 0, this.dragOffset.y = 0, void (this.trackingPoints = []);
                this.container.classList.remove(this.cn("isDragging")), this.isDragging && (this.addTrackingPoint(e), 
                this.panOnlyZoomed && this.contentRect.width - this.contentRect.fitWidth < 1 && this.contentRect.height - this.contentRect.fitHeight < 1 && (this.trackingPoints = []), 
                i(t.target, this.content) && "y" === this.lockedAxis && (this.trackingPoints = []), 
                this.emit("touchEnd", t), this.isDragging = !1, this.lockedAxis = !1, this.state !== g.Destroy && (t.defaultPrevented || this.startDecelAnim()));
            }
            startDecelAnim() {
                var e;
                const i = this.isScaling;
                this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = !1, 
                this.isBouncingY = !1;
                for (const t of b) this.velocity[t] = 0;
                this.target.e = this.current.e, this.target.f = this.current.f, E(this.container, "is-scaling"), 
                E(this.container, "is-animating"), this.isTicking = !1;
                const {trackingPoints: n} = this, s = n[0], o = n[n.length - 1];
                let a = 0, r = 0, l = 0;
                o && s && (a = o.clientX - s.clientX, r = o.clientY - s.clientY, l = o.time - s.time);
                const c = (null === (e = window.visualViewport) || void 0 === e ? void 0 : e.scale) || 1;
                1 !== c && (a *= c, r *= c);
                let h = 0, d = 0, u = 0, p = 0, f = this.option("decelFriction");
                const m = this.targetScale;
                if (l > 0) {
                    u = Math.abs(a) > 3 ? a / (l / 30) : 0, p = Math.abs(r) > 3 ? r / (l / 30) : 0;
                    const t = this.option("maxVelocity");
                    t && (u = Math.max(Math.min(u, t), -1 * t), p = Math.max(Math.min(p, t), -1 * t));
                }
                u && (h = u / (1 / (1 - f) - 1)), p && (d = p / (1 / (1 - f) - 1)), ("y" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "y" === this.lockedAxis && t(m) === this.minScale) && (h = u = 0), 
                ("x" === this.option("lockAxis") || "xy" === this.option("lockAxis") && "x" === this.lockedAxis && t(m) === this.minScale) && (d = p = 0);
                const g = this.dragOffset.x, v = this.dragOffset.y, y = this.option("dragMinThreshold") || 0;
                Math.abs(g) < y && Math.abs(v) < y && (h = d = 0, u = p = 0), (m < this.minScale - 1e-5 || m > this.maxScale + 1e-5 || i && !h && !d) && (f = .35), 
                this.applyChange({
                    panX: h,
                    panY: d,
                    friction: f
                }), this.emit("decel", u, p, g, v);
            }
            onWheel(t) {
                var e = [ -t.deltaX || 0, -t.deltaY || 0, -t.detail || 0 ].reduce((function(t, e) {
                    return Math.abs(e) > Math.abs(t) ? e : t;
                }));
                const i = Math.max(-1, Math.min(1, e));
                if (this.emit("wheel", t, i), this.panMode === T) return;
                if (t.defaultPrevented) return;
                const n = this.option("wheel");
                "pan" === n ? (t.preventDefault(), this.panOnlyZoomed && !this.canZoomOut() || this.applyChange({
                    panX: 2 * -t.deltaX,
                    panY: 2 * -t.deltaY,
                    bounce: !1
                })) : "zoom" === n && !1 !== this.option("zoom") && this.zoomWithWheel(t);
            }
            onMouseMove(t) {
                this.panWithMouse(t);
            }
            onKeydown(t) {
                "Escape" === t.key && this.toggleFS();
            }
            onResize() {
                this.updateMetrics(), this.checkBounds().inBounds || this.requestTick();
            }
            setTransform() {
                this.emit("beforeTransform");
                const {current: e, target: i, content: n, contentRect: s} = this, o = Object.assign({}, P);
                for (const n of b) {
                    const s = "e" == n || "f" === n ? M : C;
                    o[n] = t(e[n], s), Math.abs(i[n] - e[n]) < ("e" == n || "f" === n ? .51 : .001) && (e[n] = i[n]);
                }
                let {a, b: r, c: l, d: c, e: h, f: d} = o, u = `matrix(${a}, ${r}, ${l}, ${c}, ${h}, ${d})`, p = n.parentElement instanceof HTMLPictureElement ? n.parentElement : n;
                if (this.option("transformParent") && (p = p.parentElement || p), p.style.transform === u) return;
                p.style.transform = u;
                const {contentWidth: f, contentHeight: m} = this.calculateContentDim();
                s.width = f, s.height = m, this.emit("afterTransform");
            }
            updateMetrics(e = !1) {
                var i;
                if (!this || this.state === g.Destroy) return;
                if (this.isContentLoading) return;
                const n = Math.max(1, (null === (i = window.visualViewport) || void 0 === i ? void 0 : i.scale) || 1), {container: s, content: o} = this, a = o instanceof HTMLImageElement, r = s.getBoundingClientRect(), l = getComputedStyle(this.container);
                let c = r.width * n, h = r.height * n;
                const d = parseFloat(l.paddingTop) + parseFloat(l.paddingBottom), u = c - (parseFloat(l.paddingLeft) + parseFloat(l.paddingRight)), p = h - d;
                this.containerRect = {
                    width: c,
                    height: h,
                    innerWidth: u,
                    innerHeight: p
                };
                let f = this.option("width") || "auto", m = this.option("height") || "auto";
                "auto" === f && (f = parseFloat(o.dataset.width || "") || (t => {
                    let e = 0;
                    return e = t instanceof HTMLImageElement ? t.naturalWidth : t instanceof SVGElement ? t.width.baseVal.value : Math.max(t.offsetWidth, t.scrollWidth), 
                    e || 0;
                })(o)), "auto" === m && (m = parseFloat(o.dataset.height || "") || (t => {
                    let e = 0;
                    return e = t instanceof HTMLImageElement ? t.naturalHeight : t instanceof SVGElement ? t.height.baseVal.value : Math.max(t.offsetHeight, t.scrollHeight), 
                    e || 0;
                })(o));
                let b = o.parentElement instanceof HTMLPictureElement ? o.parentElement : o;
                this.option("transformParent") && (b = b.parentElement || b);
                const v = b.getAttribute("style") || "";
                b.style.setProperty("transform", "none", "important"), a && (b.style.width = "", 
                b.style.height = ""), b.offsetHeight;
                const y = o.getBoundingClientRect();
                let w = y.width * n, x = y.height * n, E = 0, S = 0;
                a && (Math.abs(f - w) > 1 || Math.abs(m - x) > 1) && ({width: w, height: x, top: E, left: S} = ((t, e, i, n) => {
                    const s = i / n;
                    return s > t / e ? (i = t, n = t / s) : (i = e * s, n = e), {
                        width: i,
                        height: n,
                        top: .5 * (e - n),
                        left: .5 * (t - i)
                    };
                })(w, x, f, m)), this.contentRect = Object.assign(Object.assign({}, this.contentRect), {
                    top: y.top - r.top + E,
                    bottom: r.bottom - y.bottom + E,
                    left: y.left - r.left + S,
                    right: r.right - y.right + S,
                    fitWidth: w,
                    fitHeight: x,
                    width: w,
                    height: x,
                    fullWidth: f,
                    fullHeight: m
                }), b.style.cssText = v, a && (b.style.width = `${w}px`, b.style.height = `${x}px`), 
                this.setTransform(), !0 !== e && this.emit("refresh"), this.ignoreBounds || (t(this.targetScale) < t(this.minScale) ? this.zoomTo(this.minScale, {
                    friction: 0
                }) : this.targetScale > this.maxScale ? this.zoomTo(this.maxScale, {
                    friction: 0
                }) : this.state === g.Init || this.checkBounds().inBounds || this.requestTick()), 
                this.updateControls();
            }
            getBounds() {
                const e = this.option("bounds");
                if ("auto" !== e) return e;
                const {contentWidth: i, contentHeight: n} = this.calculateContentDim(this.target);
                let s = 0, o = 0, a = 0, r = 0;
                const l = this.option("infinite");
                if (!0 === l || this.lockedAxis && l === this.lockedAxis) s = -1 / 0, a = 1 / 0, 
                o = -1 / 0, r = 1 / 0; else {
                    let {containerRect: e, contentRect: l} = this, c = t(this.contentRect.fitWidth * this.targetScale, M), h = t(this.contentRect.fitHeight * this.targetScale, M), {innerWidth: d, innerHeight: u} = e;
                    if (this.containerRect.width === c && (d = e.width), this.containerRect.width === h && (u = e.height), 
                    i > d) {
                        a = .5 * (i - d), s = -1 * a;
                        let t = .5 * (l.right - l.left);
                        s += t, a += t;
                    }
                    if (this.contentRect.fitWidth > d && i < d && (s -= .5 * (this.contentRect.fitWidth - d), 
                    a -= .5 * (this.contentRect.fitWidth - d)), n > u) {
                        r = .5 * (n - u), o = -1 * r;
                        let t = .5 * (l.bottom - l.top);
                        o += t, r += t;
                    }
                    this.contentRect.fitHeight > u && n < u && (s -= .5 * (this.contentRect.fitHeight - u), 
                    a -= .5 * (this.contentRect.fitHeight - u));
                }
                return {
                    x: {
                        min: s,
                        max: a
                    },
                    y: {
                        min: o,
                        max: r
                    }
                };
            }
            updateControls() {
                const e = this, i = e.container, {panMode: n, contentRect: s, fullScale: a, targetScale: r, coverScale: l, maxScale: c, minScale: h} = e;
                let d = {
                    toggleMax: r - h < .5 * (c - h) ? c : h,
                    toggleCover: r - h < .5 * (l - h) ? l : h,
                    toggleZoom: r - h < .5 * (a - h) ? a : h
                }[e.option("click") || ""] || h, u = e.canZoomIn(), p = e.canZoomOut(), f = p && n === O;
                t(r) < t(h) && !this.panOnlyZoomed && (f = !0), (t(s.width, 1) > t(s.fitWidth, 1) || t(s.height, 1) > t(s.fitHeight, 1)) && (f = !0), 
                t(s.width * r, 1) < t(s.fitWidth, 1) && (f = !1), n === T && (f = !1);
                let m = u && t(d) > t(r), g = !m && !f && p && t(d) < t(r);
                o(i, this.cn("canZoomIn"), m), o(i, this.cn("canZoomOut"), g), o(i, this.cn("isDraggable"), f);
                for (const t of i.querySelectorAll('[data-panzoom-action="zoomIn"]')) u ? (t.removeAttribute("disabled"), 
                t.removeAttribute("tabindex")) : (t.setAttribute("disabled", ""), t.setAttribute("tabindex", "-1"));
                for (const t of i.querySelectorAll('[data-panzoom-action="zoomOut"]')) p ? (t.removeAttribute("disabled"), 
                t.removeAttribute("tabindex")) : (t.setAttribute("disabled", ""), t.setAttribute("tabindex", "-1"));
                for (const t of i.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) {
                    u || p ? (t.removeAttribute("disabled"), t.removeAttribute("tabindex")) : (t.setAttribute("disabled", ""), 
                    t.setAttribute("tabindex", "-1"));
                    const e = t.querySelector("g");
                    e && (e.style.display = u ? "" : "none");
                }
            }
            panTo({x: t = this.target.e, y: e = this.target.f, scale: i = this.targetScale, friction: n = this.option("friction"), angle: s = 0, originX: o = 0, originY: a = 0, flipX: r = !1, flipY: l = !1, ignoreBounds: c = !1}) {
                this.state !== g.Destroy && this.applyChange({
                    panX: t - this.target.e,
                    panY: e - this.target.f,
                    scale: i / this.targetScale,
                    angle: s,
                    originX: o,
                    originY: a,
                    friction: n,
                    flipX: r,
                    flipY: l,
                    ignoreBounds: c
                });
            }
            applyChange({panX: e = 0, panY: i = 0, scale: n = 1, angle: s = 0, originX: o = -this.current.e, originY: a = -this.current.f, friction: r = this.option("friction"), flipX: l = !1, flipY: c = !1, ignoreBounds: h = !1, bounce: d = this.option("bounce")}) {
                if (this.state === g.Destroy) return;
                this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.friction = r || 0, 
                this.ignoreBounds = h;
                const {current: u} = this, p = u.e, f = u.f, m = this.getMatrix(this.target);
                let v = (new DOMMatrix).translate(p, f).translate(o, a).translate(e, i);
                if (this.option("zoom")) {
                    if (!h) {
                        const t = this.targetScale, e = this.minScale, i = this.maxScale;
                        t * n < e && (n = e / t), t * n > i && (n = i / t);
                    }
                    v = v.scale(n);
                }
                v = v.translate(-o, -a).translate(-p, -f).multiply(m), s && (v = v.rotate(s)), l && (v = v.scale(-1, 1)), 
                c && (v = v.scale(1, -1));
                for (const e of b) "e" !== e && "f" !== e && (v[e] > this.minScale + 1e-5 || v[e] < this.minScale - 1e-5) ? this.target[e] = v[e] : this.target[e] = t(v[e], M);
                (this.targetScale < this.scale || Math.abs(n - 1) > .1 || this.panMode === T || !1 === d) && !h && this.clampTargetBounds(), 
                this.isResting || (this.state = g.Panning, this.requestTick());
            }
            stop(t = !1) {
                if (this.state === g.Init || this.state === g.Destroy) return;
                const e = this.isTicking;
                this.rAF && (cancelAnimationFrame(this.rAF), this.rAF = null), this.isBouncingX = !1, 
                this.isBouncingY = !1;
                for (const e of b) this.velocity[e] = 0, "current" === t ? this.current[e] = this.target[e] : "target" === t && (this.target[e] = this.current[e]);
                this.setTransform(), E(this.container, "is-scaling"), E(this.container, "is-animating"), 
                this.isTicking = !1, this.state = g.Ready, e && (this.emit("endAnimation"), this.updateControls());
            }
            requestTick() {
                this.isTicking || (this.emit("startAnimation"), this.updateControls(), S(this.container, "is-animating"), 
                this.isScaling && S(this.container, "is-scaling")), this.isTicking = !0, this.rAF || (this.rAF = requestAnimationFrame((() => this.animate())));
            }
            panWithMouse(e, i = this.option("mouseMoveFriction")) {
                if (this.pmme = e, this.panMode !== T || !e) return;
                if (t(this.targetScale) <= t(this.minScale)) return;
                this.emit("mouseMove", e);
                const {container: n, containerRect: s, contentRect: o} = this, a = s.width, r = s.height, l = n.getBoundingClientRect(), c = (e.clientX || 0) - l.left, h = (e.clientY || 0) - l.top;
                let {contentWidth: d, contentHeight: u} = this.calculateContentDim(this.target);
                const p = this.option("mouseMoveFactor");
                p > 1 && (d !== a && (d *= p), u !== r && (u *= p));
                let f = .5 * (d - a) - c / a * 100 / 100 * (d - a);
                f += .5 * (o.right - o.left);
                let m = .5 * (u - r) - h / r * 100 / 100 * (u - r);
                m += .5 * (o.bottom - o.top), this.applyChange({
                    panX: f - this.target.e,
                    panY: m - this.target.f,
                    friction: i
                });
            }
            zoomWithWheel(e) {
                if (this.state === g.Destroy || this.state === g.Init) return;
                const i = Date.now();
                if (i - this.pwt < 45) return void e.preventDefault();
                this.pwt = i;
                var n = [ -e.deltaX || 0, -e.deltaY || 0, -e.detail || 0 ].reduce((function(t, e) {
                    return Math.abs(e) > Math.abs(t) ? e : t;
                }));
                const s = Math.max(-1, Math.min(1, n)), {targetScale: o, maxScale: a, minScale: r} = this;
                let l = o * (100 + 45 * s) / 100;
                t(l) < t(r) && t(o) <= t(r) ? (this.cwd += Math.abs(s), l = r) : t(l) > t(a) && t(o) >= t(a) ? (this.cwd += Math.abs(s), 
                l = a) : (this.cwd = 0, l = Math.max(Math.min(l, a), r)), this.cwd > this.option("wheelLimit") || (e.preventDefault(), 
                t(l) !== t(o) && this.zoomTo(l, {
                    event: e
                }));
            }
            canZoomIn() {
                return this.option("zoom") && (t(this.contentRect.width, 1) < t(this.contentRect.fitWidth, 1) || t(this.targetScale) < t(this.maxScale));
            }
            canZoomOut() {
                return this.option("zoom") && t(this.targetScale) > t(this.minScale);
            }
            zoomIn(t = 1.25, e) {
                this.zoomTo(this.targetScale * t, e);
            }
            zoomOut(t = .8, e) {
                this.zoomTo(this.targetScale * t, e);
            }
            zoomToFit(t) {
                this.zoomTo("fit", t);
            }
            zoomToCover(t) {
                this.zoomTo("cover", t);
            }
            zoomToFull(t) {
                this.zoomTo("full", t);
            }
            zoomToMax(t) {
                this.zoomTo("max", t);
            }
            toggleZoom(t) {
                this.zoomTo(this.targetScale - this.minScale < .5 * (this.fullScale - this.minScale) ? "full" : "fit", t);
            }
            toggleMax(t) {
                this.zoomTo(this.targetScale - this.minScale < .5 * (this.maxScale - this.minScale) ? "max" : "fit", t);
            }
            toggleCover(t) {
                this.zoomTo(this.targetScale - this.minScale < .5 * (this.coverScale - this.minScale) ? "cover" : "fit", t);
            }
            iterateZoom(t) {
                this.zoomTo("next", t);
            }
            zoomTo(t = 1, {friction: e = "auto", originX: i = 0, originY: n = 0, event: s} = {}) {
                if (this.isContentLoading || this.state === g.Destroy) return;
                const {targetScale: o} = this;
                this.stop();
                let a = 1;
                if (this.panMode === T && (s = this.pmme || s), s) {
                    const t = this.content.getBoundingClientRect(), e = s.clientX || 0, o = s.clientY || 0;
                    i = e - t.left - .5 * t.width, n = o - t.top - .5 * t.height;
                }
                const r = this.fullScale, l = this.maxScale;
                let c = this.coverScale;
                "number" == typeof t ? a = t / o : ("next" === t && (r - c < .2 && (c = r), t = o < r - 1e-5 ? "full" : o < l - 1e-5 ? "max" : "fit"), 
                a = "full" === t ? r / o || 1 : "cover" === t ? c / o || 1 : "max" === t ? l / o || 1 : 1 / o || 1), 
                e = "auto" === e ? a > 1 ? .15 : .25 : e, this.applyChange({
                    scale: a,
                    originX: i,
                    originY: n,
                    friction: e
                }), s && this.panMode === T && this.panWithMouse(s, e);
            }
            rotateCCW() {
                this.applyChange({
                    angle: -90
                });
            }
            rotateCW() {
                this.applyChange({
                    angle: 90
                });
            }
            flipX() {
                this.applyChange({
                    flipX: !0
                });
            }
            flipY() {
                this.applyChange({
                    flipY: !0
                });
            }
            fitX() {
                this.stop("target");
                const {containerRect: t, contentRect: e, target: i} = this;
                this.applyChange({
                    panX: .5 * t.width - (e.left + .5 * e.fitWidth) - i.e,
                    panY: .5 * t.height - (e.top + .5 * e.fitHeight) - i.f,
                    scale: t.width / e.fitWidth / this.targetScale,
                    originX: 0,
                    originY: 0,
                    ignoreBounds: !0
                });
            }
            fitY() {
                this.stop("target");
                const {containerRect: t, contentRect: e, target: i} = this;
                this.applyChange({
                    panX: .5 * t.width - (e.left + .5 * e.fitWidth) - i.e,
                    panY: .5 * t.innerHeight - (e.top + .5 * e.fitHeight) - i.f,
                    scale: t.height / e.fitHeight / this.targetScale,
                    originX: 0,
                    originY: 0,
                    ignoreBounds: !0
                });
            }
            toggleFS() {
                const {container: t} = this, e = this.cn("inFullscreen"), i = this.cn("htmlHasFullscreen");
                t.classList.toggle(e);
                const n = t.classList.contains(e);
                n ? (document.documentElement.classList.add(i), document.addEventListener("keydown", this.onKeydown, !0)) : (document.documentElement.classList.remove(i), 
                document.removeEventListener("keydown", this.onKeydown, !0)), this.updateMetrics(), 
                this.emit(n ? "enterFS" : "exitFS");
            }
            getMatrix(t = this.current) {
                const {a: e, b: i, c: n, d: s, e: o, f: a} = t;
                return new DOMMatrix([ e, i, n, s, o, a ]);
            }
            reset(t) {
                if (this.state !== g.Init && this.state !== g.Destroy) {
                    this.stop("current");
                    for (const t of b) this.target[t] = P[t];
                    this.target.a = this.minScale, this.target.d = this.minScale, this.clampTargetBounds(), 
                    this.isResting || (this.friction = void 0 === t ? this.option("friction") : t, this.state = g.Panning, 
                    this.requestTick());
                }
            }
            destroy() {
                this.stop(), this.state = g.Destroy, this.detachEvents(), this.detachObserver();
                const {container: t, content: e} = this, i = this.option("classes") || {};
                for (const e of Object.values(i)) t.classList.remove(e + "");
                e && (e.removeEventListener("load", this.onLoad), e.removeEventListener("error", this.onError)), 
                this.detachPlugins();
            }
        }
        Object.defineProperty(R, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: y
        }), Object.defineProperty(R, "Plugins", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {}
        });
        const k = function(t, e) {
            let i = !0;
            return (...n) => {
                i && (i = !1, t(...n), setTimeout((() => {
                    i = !0;
                }), e));
            };
        }, I = (t, e) => {
            let i = [];
            return t.childNodes.forEach((t => {
                t.nodeType !== Node.ELEMENT_NODE || e && !t.matches(e) || i.push(t);
            })), i;
        }, D = {
            viewport: null,
            track: null,
            enabled: !0,
            slides: [],
            axis: "x",
            transition: "fade",
            preload: 1,
            slidesPerPage: "auto",
            initialPage: 0,
            friction: .12,
            Panzoom: {
                decelFriction: .12
            },
            center: !0,
            infinite: !0,
            fill: !0,
            dragFree: !1,
            adaptiveHeight: !1,
            direction: "ltr",
            classes: {
                container: "f-carousel",
                viewport: "f-carousel__viewport",
                track: "f-carousel__track",
                slide: "f-carousel__slide",
                isLTR: "is-ltr",
                isRTL: "is-rtl",
                isHorizontal: "is-horizontal",
                isVertical: "is-vertical",
                inTransition: "in-transition",
                isSelected: "is-selected"
            },
            l10n: {
                NEXT: "Next slide",
                PREV: "Previous slide",
                GOTO: "Go to slide #%d"
            }
        };
        var F;
        !function(t) {
            t[t.Init = 0] = "Init", t[t.Ready = 1] = "Ready", t[t.Destroy = 2] = "Destroy";
        }(F || (F = {}));
        const j = t => {
            if ("string" == typeof t && (t = {
                html: t
            }), !(t instanceof String || t instanceof HTMLElement)) {
                const e = t.thumb;
                void 0 !== e && ("string" == typeof e && (t.thumbSrc = e), e instanceof HTMLImageElement && (t.thumbEl = e, 
                t.thumbElSrc = e.src, t.thumbSrc = e.src), delete t.thumb);
            }
            return Object.assign({
                html: "",
                el: null,
                isDom: !1,
                class: "",
                index: -1,
                dim: 0,
                gap: 0,
                pos: 0,
                transition: !1
            }, t);
        }, H = (t = {}) => Object.assign({
            index: -1,
            slides: [],
            dim: 0,
            pos: -1
        }, t);
        class B extends f {
            constructor(t, e) {
                super(e), Object.defineProperty(this, "instance", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: t
                });
            }
            attach() {}
            detach() {}
        }
        const N = {
            classes: {
                list: "f-carousel__dots",
                isDynamic: "is-dynamic",
                hasDots: "has-dots",
                dot: "f-carousel__dot",
                isBeforePrev: "is-before-prev",
                isPrev: "is-prev",
                isCurrent: "is-current",
                isNext: "is-next",
                isAfterNext: "is-after-next"
            },
            dotTpl: '<button type="button" data-carousel-page="%i" aria-label="{{GOTO}}"><span class="f-carousel__dot" aria-hidden="true"></span></button>',
            dynamicFrom: 11,
            maxCount: 1 / 0,
            minCount: 2
        };
        class _ extends B {
            constructor() {
                super(...arguments), Object.defineProperty(this, "isDynamic", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "list", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            onRefresh() {
                this.refresh();
            }
            build() {
                let t = this.list;
                return t || (t = document.createElement("ul"), S(t, this.cn("list")), t.setAttribute("role", "tablist"), 
                this.instance.container.appendChild(t), S(this.instance.container, this.cn("hasDots")), 
                this.list = t), t;
            }
            refresh() {
                var t;
                const e = this.instance.pages.length, i = Math.min(2, this.option("minCount")), n = Math.max(2e3, this.option("maxCount")), s = this.option("dynamicFrom");
                if (e < i || e > n) return void this.cleanup();
                const a = "number" == typeof s && e > 5 && e >= s, r = !this.list || this.isDynamic !== a || this.list.children.length !== e;
                r && this.cleanup();
                const l = this.build();
                if (o(l, this.cn("isDynamic"), !!a), r) for (let t = 0; t < e; t++) l.append(this.createItem(t));
                let c, h = 0;
                for (const e of [ ...l.children ]) {
                    const i = h === this.instance.page;
                    i && (c = e), o(e, this.cn("isCurrent"), i), null === (t = e.children[0]) || void 0 === t || t.setAttribute("aria-selected", i ? "true" : "false");
                    for (const t of [ "isBeforePrev", "isPrev", "isNext", "isAfterNext" ]) E(e, this.cn(t));
                    h++;
                }
                if (c = c || l.firstChild, a && c) {
                    const t = c.previousElementSibling, e = t && t.previousElementSibling;
                    S(t, this.cn("isPrev")), S(e, this.cn("isBeforePrev"));
                    const i = c.nextElementSibling, n = i && i.nextElementSibling;
                    S(i, this.cn("isNext")), S(n, this.cn("isAfterNext"));
                }
                this.isDynamic = a;
            }
            createItem(t = 0) {
                var e;
                const i = document.createElement("li");
                i.setAttribute("role", "presentation");
                const s = n(this.instance.localize(this.option("dotTpl"), [ [ "%d", t + 1 ] ]).replace(/\%i/g, t + ""));
                return i.appendChild(s), null === (e = i.children[0]) || void 0 === e || e.setAttribute("role", "tab"), 
                i;
            }
            cleanup() {
                this.list && (this.list.remove(), this.list = null), this.isDynamic = !1, E(this.instance.container, this.cn("hasDots"));
            }
            attach() {
                this.instance.on([ "refresh", "change" ], this.onRefresh);
            }
            detach() {
                this.instance.off([ "refresh", "change" ], this.onRefresh), this.cleanup();
            }
        }
        Object.defineProperty(_, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: N
        });
        const W = "disabled", $ = "next", X = "prev";
        class Y extends B {
            constructor() {
                super(...arguments), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "prev", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "next", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            onRefresh() {
                const t = this.instance, e = t.pages.length, i = t.page;
                if (e < 2) return void this.cleanup();
                this.build();
                let n = this.prev, s = this.next;
                n && s && (n.removeAttribute(W), s.removeAttribute(W), t.isInfinite || (i <= 0 && n.setAttribute(W, ""), 
                i >= e - 1 && s.setAttribute(W, "")));
            }
            createButton(t) {
                const e = this.instance, i = document.createElement("button");
                i.setAttribute("tabindex", "0"), i.setAttribute("title", e.localize(`{{${t.toUpperCase()}}}`)), 
                S(i, this.cn("button") + " " + this.cn(t === $ ? "isNext" : "isPrev"));
                const n = e.isRTL ? t === $ ? X : $ : t;
                var s;
                return i.innerHTML = e.localize(this.option(`${n}Tpl`)), i.dataset[`carousel${s = t, 
                s ? s.match("^[a-z]") ? s.charAt(0).toUpperCase() + s.substring(1) : s : ""}`] = "true", 
                i;
            }
            build() {
                let t = this.container;
                t || (this.container = t = document.createElement("div"), S(t, this.cn("container")), 
                this.instance.container.appendChild(t)), this.next || (this.next = t.appendChild(this.createButton($))), 
                this.prev || (this.prev = t.appendChild(this.createButton(X)));
            }
            cleanup() {
                this.prev && this.prev.remove(), this.next && this.next.remove(), this.container && this.container.remove(), 
                this.prev = null, this.next = null, this.container = null;
            }
            attach() {
                this.instance.on([ "refresh", "change" ], this.onRefresh);
            }
            detach() {
                this.instance.off([ "refresh", "change" ], this.onRefresh), this.cleanup();
            }
        }
        Object.defineProperty(Y, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {
                classes: {
                    container: "f-carousel__nav",
                    button: "f-button",
                    isNext: "is-next",
                    isPrev: "is-prev"
                },
                nextTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M9 3l9 9-9 9"/></svg>',
                prevTpl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M15 3l-9 9 9 9"/></svg>'
            }
        });
        class q extends B {
            constructor() {
                super(...arguments), Object.defineProperty(this, "selectedIndex", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "target", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "nav", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            addAsTargetFor(t) {
                this.target = this.instance, this.nav = t, this.attachEvents();
            }
            addAsNavFor(t) {
                this.nav = this.instance, this.target = t, this.attachEvents();
            }
            attachEvents() {
                this.nav && this.target && (this.nav.options.initialSlide = this.target.options.initialPage, 
                this.nav.on("ready", this.onNavReady), this.nav.state === F.Ready && this.onNavReady(this.nav), 
                this.target.on("ready", this.onTargetReady), this.target.state === F.Ready && this.onTargetReady(this.target));
            }
            onNavReady(t) {
                t.on("createSlide", this.onNavCreateSlide), t.on("Panzoom.click", this.onNavClick), 
                t.on("Panzoom.touchEnd", this.onNavTouch), this.onTargetChange();
            }
            onTargetReady(t) {
                t.on("change", this.onTargetChange), t.on("Panzoom.refresh", this.onTargetChange), 
                this.onTargetChange();
            }
            onNavClick(t, e, i) {
                i.pointerType || this.onNavTouch(t, t.panzoom, i);
            }
            onNavTouch(t, e, i) {
                var n, s;
                if (Math.abs(e.dragOffset.x) > 3 || Math.abs(e.dragOffset.y) > 3) return;
                const o = i.target, {nav: a, target: r} = this;
                if (!a || !r || !o) return;
                const l = o.closest("[data-index]");
                if (i.stopPropagation(), i.preventDefault(), !l) return;
                const c = parseInt(l.dataset.index || "", 10) || 0, h = r.getPageForSlide(c), d = a.getPageForSlide(c);
                a.slideTo(d), r.slideTo(h, {
                    friction: (null === (s = null === (n = this.nav) || void 0 === n ? void 0 : n.plugins) || void 0 === s ? void 0 : s.Sync.option("friction")) || 0
                }), this.markSelectedSlide(c);
            }
            onNavCreateSlide(t, e) {
                e.index === this.selectedIndex && this.markSelectedSlide(e.index);
            }
            onTargetChange() {
                const {target: t, nav: e} = this;
                if (!t || !e) return;
                if (e.state !== F.Ready || t.state !== F.Ready) return;
                const i = t.pages[t.page].slides[0].index, n = e.getPageForSlide(i);
                this.markSelectedSlide(i), e.slideTo(n);
            }
            markSelectedSlide(t) {
                const e = this.nav;
                e && e.state === F.Ready && (this.selectedIndex = t, [ ...e.slides ].map((e => {
                    e.el && e.el.classList[e.index === t ? "add" : "remove"]("is-nav-selected");
                })));
            }
            attach() {
                const t = this;
                let e = t.options.target, i = t.options.nav;
                e ? t.addAsNavFor(e) : i && t.addAsTargetFor(i);
            }
            detach() {
                const t = this, e = t.nav, i = t.target;
                e && (e.off("ready", t.onNavReady), e.off("createSlide", t.onNavCreateSlide), e.off("Panzoom.click", t.onNavClick), 
                e.off("Panzoom.touchEnd", t.onNavTouch)), t.nav = null, i && (i.off("ready", t.onTargetReady), 
                i.off("refresh", t.onTargetChange), i.off("change", t.onTargetChange)), t.target = null;
            }
        }
        Object.defineProperty(q, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {
                friction: .35
            }
        });
        const V = {
            Navigation: Y,
            Dots: _,
            Sync: q
        };
        class Z extends m {
            get axis() {
                return this.isHorizontal ? "e" : "f";
            }
            get isEnabled() {
                return this.state === F.Ready;
            }
            get isInfinite() {
                let t = !1;
                const {contentDim: e, viewportDim: i, pages: n, slides: s} = this;
                return n.length >= 2 && e + s[0].dim >= i && (t = this.option("infinite")), t;
            }
            get isRTL() {
                return "rtl" === this.option("direction");
            }
            get isHorizontal() {
                return "x" === this.option("axis");
            }
            constructor(t, e = {}, i = {}) {
                if (super(), Object.defineProperty(this, "userOptions", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {}
                }), Object.defineProperty(this, "userPlugins", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {}
                }), Object.defineProperty(this, "bp", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: ""
                }), Object.defineProperty(this, "lp", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: F.Init
                }), Object.defineProperty(this, "page", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "prevPage", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "viewport", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "track", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "slides", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), Object.defineProperty(this, "pages", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), Object.defineProperty(this, "panzoom", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "inTransition", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: new Set
                }), Object.defineProperty(this, "contentDim", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "viewportDim", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), "string" == typeof t && (t = document.querySelector(t)), !t || !x(t)) throw new Error("No Element found");
                this.container = t, this.slideNext = k(this.slideNext.bind(this), 150), this.slidePrev = k(this.slidePrev.bind(this), 150), 
                this.userOptions = e, this.userPlugins = i, queueMicrotask((() => {
                    this.processOptions();
                }));
            }
            processOptions() {
                const t = u({}, Z.defaults, this.userOptions);
                let e = "";
                const i = t.breakpoints;
                if (i && d(i)) for (const [n, s] of Object.entries(i)) window.matchMedia(n).matches && d(s) && (e += n, 
                u(t, s));
                e === this.bp && this.state !== F.Init || (this.bp = e, this.state === F.Ready && (t.initialSlide = this.pages[this.page].slides[0].index), 
                this.state !== F.Init && this.destroy(), super.setOptions(t), !1 === this.option("enabled") ? this.attachEvents() : setTimeout((() => {
                    this.init();
                }), 0));
            }
            init() {
                this.state = F.Init, this.emit("init"), this.attachPlugins(Object.assign(Object.assign({}, Z.Plugins), this.userPlugins)), 
                this.initLayout(), this.initSlides(), this.updateMetrics(), this.setInitialPosition(), 
                this.initPanzoom(), this.attachEvents(), this.state = F.Ready, this.emit("ready");
            }
            initLayout() {
                const {container: t} = this, e = this.option("classes");
                S(t, this.cn("container")), o(t, e.isLTR, !this.isRTL), o(t, e.isRTL, this.isRTL), 
                o(t, e.isVertical, !this.isHorizontal), o(t, e.isHorizontal, this.isHorizontal);
                let i = this.option("viewport") || t.querySelector(`.${e.viewport}`);
                i || (i = document.createElement("div"), S(i, e.viewport), i.append(...I(t, `.${e.slide}`)), 
                t.prepend(i));
                let n = this.option("track") || t.querySelector(`.${e.track}`);
                n || (n = document.createElement("div"), S(n, e.track), n.append(...Array.from(i.childNodes))), 
                n.setAttribute("aria-live", "polite"), i.contains(n) || i.prepend(n), this.viewport = i, 
                this.track = n, this.emit("initLayout");
            }
            initSlides() {
                const {track: t} = this;
                if (t) {
                    this.slides = [], [ ...I(t, `.${this.cn("slide")}`) ].forEach((t => {
                        if (x(t)) {
                            const e = j({
                                el: t,
                                isDom: !0,
                                index: this.slides.length
                            });
                            this.slides.push(e), this.emit("initSlide", e, this.slides.length);
                        }
                    }));
                    for (let t of this.option("slides", [])) {
                        const e = j(t);
                        e.index = this.slides.length, this.slides.push(e), this.emit("initSlide", e, this.slides.length);
                    }
                    this.emit("initSlides");
                }
            }
            setInitialPage() {
                let t = 0;
                const e = this.option("initialSlide");
                t = "number" == typeof e ? this.getPageForSlide(e) : parseInt(this.option("initialPage", 0) + "", 10) || 0, 
                this.page = t;
            }
            setInitialPosition() {
                if (!this.track || !this.pages.length) return;
                const t = this.isHorizontal;
                let e = this.page;
                this.pages[e] || (this.page = e = 0);
                const i = this.pages[e].pos * (this.isRTL && t ? 1 : -1), n = t ? `${i}px` : "0", s = t ? "0" : `${i}px`;
                this.track.style.transform = `translate3d(${n}, ${s}, 0) scale(1)`, this.option("adaptiveHeight") && this.setViewportHeight();
            }
            initPanzoom() {
                this.panzoom && (this.panzoom.destroy(), this.panzoom = null);
                const t = this.option("Panzoom") || {};
                this.panzoom = new R(this.viewport, u({}, {
                    content: this.track,
                    zoom: !1,
                    panOnlyZoomed: !1,
                    lockAxis: this.isHorizontal ? "x" : "y",
                    infinite: this.isInfinite,
                    click: !1,
                    dblClick: !1,
                    touch: t => !(this.pages.length < 2 && !t.options.infinite),
                    bounds: () => this.getBounds(),
                    maxVelocity: t => Math.abs(t.target[this.axis] - t.current[this.axis]) < 2 * this.viewportDim ? 100 : 0
                }, t)), this.panzoom.on("*", ((t, e, ...i) => {
                    this.emit(`Panzoom.${e}`, t, ...i);
                })), this.panzoom.on("decel", this.onDecel), this.panzoom.on("refresh", this.onRefresh), 
                this.panzoom.on("beforeTransform", this.onBeforeTransform), this.panzoom.on("endAnimation", this.onEndAnimation);
            }
            attachEvents() {
                const t = this.container;
                t && (t.addEventListener("click", this.onClick, {
                    passive: !1,
                    capture: !1
                }), t.addEventListener("slideTo", this.onSlideTo)), window.addEventListener("resize", this.onResize);
            }
            createPages() {
                let t = [];
                const {contentDim: e, viewportDim: i} = this;
                let n = this.option("slidesPerPage");
                ("number" != typeof n || e <= i) && (n = 1 / 0);
                let s = 0, o = 0, a = 0;
                for (const e of this.slides) (!t.length || o + e.dim > i || a === n) && (t.push(H()), 
                s = t.length - 1, o = 0, a = 0), t[s].slides.push(e), o += e.dim + e.gap, a++;
                return t;
            }
            processPages() {
                const e = this.pages, {contentDim: i, viewportDim: n} = this, s = this.option("center"), o = this.option("fill"), a = o && s && i > n && !this.isInfinite;
                if (e.forEach(((t, e) => {
                    t.index = e, t.pos = t.slides[0].pos, t.dim = 0;
                    for (const [e, i] of t.slides.entries()) t.dim += i.dim, e < t.slides.length - 1 && (t.dim += i.gap);
                    a && t.pos + .5 * t.dim < .5 * n ? t.pos = 0 : a && t.pos + .5 * t.dim >= i - .5 * n ? t.pos = i - n : s && (t.pos += -.5 * (n - t.dim));
                })), e.forEach(((e, s) => {
                    o && !this.isInfinite && i > n && (e.pos = Math.max(e.pos, 0), e.pos = Math.min(e.pos, i - n)), 
                    e.pos = t(e.pos, 1e3), e.dim = t(e.dim, 1e3), e.pos < .1 && e.pos > -.1 && (e.pos = 0);
                })), this.isInfinite) return e;
                const r = [];
                let l;
                return e.forEach((t => {
                    const e = Object.assign({}, t);
                    l && e.pos === l.pos ? (l.dim += e.dim, l.slides = [ ...l.slides, ...e.slides ]) : (e.index = r.length, 
                    l = e, r.push(e));
                })), r;
            }
            getPageFromIndex(t = 0) {
                const e = this.pages.length;
                let i;
                return t = parseInt((t || 0).toString()) || 0, i = this.isInfinite ? (t % e + e) % e : Math.max(Math.min(t, e - 1), 0), 
                i;
            }
            getSlideMetrics(e) {
                var i;
                const n = this.isHorizontal ? "width" : "height";
                let s = 0, o = 0, a = e.el;
                if (a ? s = parseFloat(a.dataset[n] || "") || 0 : (a = document.createElement("div"), 
                a.style.visibility = "hidden", S(a, this.cn("slide") + " " + e.class), (this.track || document.body).prepend(a)), 
                s) a.style[n] = `${s}px`, a.style["width" === n ? "height" : "width"] = ""; else {
                    const t = Math.max(1, (null === (i = window.visualViewport) || void 0 === i ? void 0 : i.scale) || 1);
                    s = a.getBoundingClientRect()[n] * t;
                }
                const r = getComputedStyle(a);
                return "content-box" === r.boxSizing && (this.isHorizontal ? (s += parseFloat(r.paddingLeft) || 0, 
                s += parseFloat(r.paddingRight) || 0) : (s += parseFloat(r.paddingTop) || 0, s += parseFloat(r.paddingBottom) || 0)), 
                o = parseFloat(r[this.isHorizontal ? "marginRight" : "marginBottom"]) || 0, e.el || a.remove(), 
                {
                    dim: t(s, 1e3),
                    gap: t(o, 1e3)
                };
            }
            getBounds() {
                const {isInfinite: t, isRTL: e, isHorizontal: i, pages: n} = this;
                let s = {
                    min: 0,
                    max: 0
                };
                if (t) s = {
                    min: -1 / 0,
                    max: 1 / 0
                }; else if (n.length) {
                    const t = n[0].pos, o = n[n.length - 1].pos;
                    s = e && i ? {
                        min: t,
                        max: o
                    } : {
                        min: -1 * o,
                        max: -1 * t
                    };
                }
                return {
                    x: i ? s : {
                        min: 0,
                        max: 0
                    },
                    y: i ? {
                        min: 0,
                        max: 0
                    } : s
                };
            }
            repositionSlides() {
                let e, {isHorizontal: i, isRTL: n, isInfinite: s, viewport: o, viewportDim: a, contentDim: r, page: l, pages: c, slides: h, panzoom: d} = this, u = 0, p = 0, f = 0, m = 0;
                d ? m = -1 * d.current[this.axis] : c[l] && (m = c[l].pos || 0), e = i ? n ? "right" : "left" : "top", 
                n && i && (m *= -1);
                for (const i of h) i.el ? ("top" === e ? (i.el.style.right = "", i.el.style.left = "") : i.el.style.top = "", 
                i.index !== u ? i.el.style[e] = 0 === p ? "" : `${t(p, 1e3)}px` : i.el.style[e] = "", 
                f += i.dim + i.gap, u++) : p += i.dim + i.gap;
                if (s && f && o) {
                    let n = getComputedStyle(o), s = "padding", l = i ? "Right" : "Bottom", c = parseFloat(n[s + (i ? "Left" : "Top")]);
                    m -= c, a += c, a += parseFloat(n[s + l]);
                    for (const i of h) i.el && (t(i.pos) < t(a) && t(i.pos + i.dim + i.gap) < t(m) && t(m) > t(r - a) && (i.el.style[e] = `${t(p + f, 1e3)}px`), 
                    t(i.pos + i.gap) >= t(r - a) && t(i.pos) > t(m + a) && t(m) < t(a) && (i.el.style[e] = `-${t(f, 1e3)}px`));
                }
                let g, b, v = [ ...this.inTransition ];
                if (v.length > 1 && (g = c[v[0]], b = c[v[1]]), g && b) {
                    let i = 0;
                    for (const n of h) n.el ? this.inTransition.has(n.index) && g.slides.indexOf(n) < 0 && (n.el.style[e] = `${t(i + (g.pos - b.pos), 1e3)}px`) : i += n.dim + n.gap;
                }
            }
            createSlideEl(t) {
                const {track: e, slides: i} = this;
                if (!e || !t) return;
                if (t.el) return;
                const n = document.createElement("div");
                S(n, this.cn("slide")), S(n, t.class), S(n, t.customClass), t.html && (n.innerHTML = t.html);
                const s = [];
                i.forEach(((t, e) => {
                    t.el && s.push(e);
                }));
                const o = t.index;
                let a = null;
                if (s.length) a = i[s.reduce(((t, e) => Math.abs(e - o) < Math.abs(t - o) ? e : t))];
                const r = a && a.el ? a.index < t.index ? a.el.nextSibling : a.el : null;
                e.insertBefore(n, e.contains(r) ? r : null), t.el = n, this.emit("createSlide", t);
            }
            removeSlideEl(t, e = !1) {
                const i = t.el;
                if (!i) return;
                if (E(i, this.cn("isSelected")), t.isDom && !e) return i.removeAttribute("aria-hidden"), 
                i.removeAttribute("data-index"), E(i, this.cn("isSelected")), void (i.style.left = "");
                this.emit("removeSlide", t);
                const n = new CustomEvent("animationend");
                i.dispatchEvent(n), t.el && t.el.remove(), t.el = null;
            }
            transitionTo(e = 0, i = this.option("transition")) {
                if (!i) return !1;
                const {pages: n, panzoom: s} = this;
                e = parseInt((e || 0).toString()) || 0;
                const o = this.getPageFromIndex(e);
                if (!s || !n[o] || n.length < 2 || Math.abs(n[this.page].slides[0].dim - this.viewportDim) > 1) return !1;
                const a = e > this.page ? 1 : -1, r = this.pages[o].pos * (this.isRTL ? 1 : -1);
                if (this.page === o && t(r, 1e3) === t(s.target[this.axis], 1e3)) return !1;
                this.clearTransitions();
                const l = s.isResting;
                S(this.container, this.cn("inTransition"));
                const c = this.pages[this.page].slides[0], h = this.pages[o].slides[0];
                this.inTransition.add(h.index), this.createSlideEl(h);
                let d = c.el, u = h.el;
                l || "slide" === i || (i = "fadeFast", d = null);
                const p = this.isRTL ? "next" : "prev", f = this.isRTL ? "prev" : "next";
                return d && (this.inTransition.add(c.index), c.transition = i, d.addEventListener("animationend", this.onAnimationEnd), 
                d.classList.add(`f-${i}Out`, `to-${a > 0 ? f : p}`)), u && (h.transition = i, u.addEventListener("animationend", this.onAnimationEnd), 
                u.classList.add(`f-${i}In`, `from-${a > 0 ? p : f}`)), s.panTo({
                    x: this.isHorizontal ? r : 0,
                    y: this.isHorizontal ? 0 : r,
                    friction: 0
                }), this.onChange(o), !0;
            }
            manageSlideVisiblity() {
                const t = new Set, e = new Set, i = this.getVisibleSlides(parseFloat(this.option("preload", 0) + "") || 0);
                for (const n of this.slides) i.has(n) ? t.add(n) : e.add(n);
                for (const e of this.inTransition) t.add(this.slides[e]);
                for (const e of t) this.createSlideEl(e), this.lazyLoadSlide(e);
                for (const i of e) t.has(i) || this.removeSlideEl(i);
                this.markSelectedSlides(), this.repositionSlides();
            }
            markSelectedSlides() {
                if (!this.pages[this.page] || !this.pages[this.page].slides) return;
                const t = "aria-hidden";
                let e = this.cn("isSelected");
                if (e) for (const i of this.slides) i.el && (i.el.dataset.index = `${i.index}`, 
                this.pages[this.page].slides.includes(i) ? (i.el.classList.contains(e) || (S(i.el, e), 
                this.emit("selectSlide", i)), i.el.removeAttribute(t)) : (i.el.classList.contains(e) && (E(i.el, e), 
                this.emit("unselectSlide", i)), i.el.setAttribute(t, "true")));
            }
            flipInfiniteTrack() {
                const t = this.panzoom;
                if (!t || !this.isInfinite) return;
                const e = "x" === this.option("axis") ? "e" : "f", {viewportDim: i, contentDim: n} = this;
                let s = t.current[e], o = t.target[e] - s, a = 0, r = .5 * i, l = n;
                this.isRTL && this.isHorizontal ? (s < -r && (a = -1, s += l), s > l - r && (a = 1, 
                s -= l)) : (s > r && (a = 1, s -= l), s < -l + r && (a = -1, s += l)), a && (t.current[e] = s, 
                t.target[e] = s + o);
            }
            lazyLoadSlide(t) {
                const e = this, i = t && t.el;
                if (!i) return;
                const s = new Set, o = "f-fadeIn";
                i.querySelectorAll("[data-lazy-srcset]").forEach((t => {
                    t instanceof HTMLImageElement && s.add(t);
                }));
                let a = Array.from(i.querySelectorAll("[data-lazy-src]"));
                i.dataset.lazySrc && a.push(i), a.map((t => {
                    t instanceof HTMLImageElement ? s.add(t) : x(t) && (t.style.backgroundImage = `url('${t.dataset.lazySrc || ""}')`, 
                    delete t.dataset.lazySrc);
                }));
                const r = (t, i, n) => {
                    n && (n.remove(), n = null), i.complete && (i.classList.add(o), setTimeout((() => {
                        i.classList.remove(o);
                    }), 350), i.style.display = ""), this.option("adaptiveHeight") && t.el && this.pages[this.page].slides.indexOf(t) > -1 && (e.updateMetrics(), 
                    e.setViewportHeight()), this.emit("load", t);
                };
                for (const e of s) {
                    let i = null;
                    e.src = e.dataset.lazySrcset || e.dataset.lazySrc || "", delete e.dataset.lazySrc, 
                    delete e.dataset.lazySrcset, e.style.display = "none", e.addEventListener("error", (() => {
                        r(t, e, i);
                    })), e.addEventListener("load", (() => {
                        r(t, e, i);
                    })), setTimeout((() => {
                        e.parentNode && t.el && (e.complete ? r(t, e, i) : (i = n(w), e.parentNode.insertBefore(i, e)));
                    }), 300);
                }
            }
            onAnimationEnd(t) {
                var e;
                const i = t.target, n = i ? parseInt(i.dataset.index || "", 10) || 0 : -1, s = this.slides[n], o = t.animationName;
                if (!i || !s || !o) return;
                const a = !!this.inTransition.has(n) && s.transition;
                a && o.substring(0, a.length + 2) === `f-${a}` && this.inTransition.delete(n), this.inTransition.size || this.clearTransitions(), 
                n === this.page && (null === (e = this.panzoom) || void 0 === e ? void 0 : e.isResting) && this.emit("settle");
            }
            onDecel(t, e = 0, i = 0, n = 0, s = 0) {
                const {isRTL: o, isHorizontal: a, axis: r, pages: l} = this, c = l.length, h = Math.abs(Math.atan2(i, e) / (Math.PI / 180));
                let d = 0;
                if (d = h > 45 && h < 135 ? a ? 0 : i : a ? e : 0, !c) return;
                const u = this.option("dragFree");
                let p = this.page, f = o && a ? 1 : -1;
                const m = t.target[r] * f, g = t.current[r] * f;
                let {pageIndex: b} = this.getPageFromPosition(m), {pageIndex: v} = this.getPageFromPosition(g);
                u ? this.onChange(b) : (Math.abs(d) > 5 ? (l[p].dim < document.documentElement["client" + (this.isHorizontal ? "Width" : "Height")] - 1 && (p = v), 
                p = o && a ? d < 0 ? p - 1 : p + 1 : d < 0 ? p + 1 : p - 1) : p = 0 === n && 0 === s ? p : v, 
                this.slideTo(p, {
                    transition: !1,
                    friction: t.option("decelFriction")
                }));
            }
            onClick(t) {
                const e = t.target, i = e && x(e) ? e.dataset : null;
                let n, s;
                i && (void 0 !== i.carouselPage ? (s = "slideTo", n = i.carouselPage) : void 0 !== i.carouselNext ? s = "slideNext" : void 0 !== i.carouselPrev && (s = "slidePrev")), 
                s ? (t.preventDefault(), t.stopPropagation(), e && !e.hasAttribute("disabled") && this[s](n)) : this.emit("click", t);
            }
            onSlideTo(t) {
                const e = t.detail || 0;
                this.slideTo(this.getPageForSlide(e), {
                    friction: 0
                });
            }
            onChange(t, e = 0) {
                const i = this.page;
                this.prevPage = i, this.page = t, this.option("adaptiveHeight") && this.setViewportHeight(), 
                t !== i && (this.markSelectedSlides(), this.emit("change", t, i, e));
            }
            onRefresh() {
                let t = this.contentDim, e = this.viewportDim;
                this.updateMetrics(), this.contentDim === t && this.viewportDim === e || this.slideTo(this.page, {
                    friction: 0,
                    transition: !1
                });
            }
            onResize() {
                this.option("breakpoints") && this.processOptions();
            }
            onBeforeTransform(t) {
                this.lp !== t.current[this.axis] && (this.flipInfiniteTrack(), this.manageSlideVisiblity()), 
                this.lp = t.current.e;
            }
            onEndAnimation() {
                this.inTransition.size || this.emit("settle");
            }
            reInit(t = null, e = null) {
                this.destroy(), this.state = F.Init, this.userOptions = t || this.userOptions, this.userPlugins = e || this.userPlugins, 
                this.processOptions();
            }
            slideTo(t = 0, {friction: e = this.option("friction"), transition: i = this.option("transition")} = {}) {
                if (this.state === F.Destroy) return;
                const {axis: n, isHorizontal: s, isRTL: o, pages: a, panzoom: r} = this, l = a.length, c = o && s ? 1 : -1;
                if (!r || !l) return;
                if (this.transitionTo(t, i)) return;
                const h = this.getPageFromIndex(t);
                let d = a[h].pos;
                if (this.isInfinite) {
                    const e = this.contentDim, i = r.target[n] * c;
                    if (2 === l) d += e * Math.floor(parseFloat(t + "") / 2); else {
                        const t = i;
                        d = [ d, d - e, d + e ].reduce((function(e, i) {
                            return Math.abs(i - t) < Math.abs(e - t) ? i : e;
                        }));
                    }
                }
                d *= c, Math.abs(r.target[n] - d) < .1 || (r.panTo({
                    x: s ? d : 0,
                    y: s ? 0 : d,
                    friction: e
                }), this.onChange(h));
            }
            slideToClosest(t) {
                if (this.panzoom) {
                    const {pageIndex: e} = this.getPageFromPosition(this.panzoom.current[this.isHorizontal ? "e" : "f"]);
                    this.slideTo(e, t);
                }
            }
            slideNext() {
                this.slideTo(this.page + 1);
            }
            slidePrev() {
                this.slideTo(this.page - 1);
            }
            clearTransitions() {
                this.inTransition.clear(), E(this.container, this.cn("inTransition"));
                const t = [ "to-prev", "to-next", "from-prev", "from-next" ];
                for (const e of this.slides) {
                    const i = e.el;
                    if (i) {
                        i.removeEventListener("animationend", this.onAnimationEnd), i.classList.remove(...t);
                        const n = e.transition;
                        n && i.classList.remove(`f-${n}Out`, `f-${n}In`);
                    }
                }
                this.manageSlideVisiblity();
            }
            prependSlide(t) {
                var e, i;
                let n = Array.isArray(t) ? t : [ t ];
                for (const t of n.reverse()) this.slides.unshift(j(t));
                for (let t = 0; t < this.slides.length; t++) this.slides[t].index = t;
                const s = (null === (e = this.pages[this.page]) || void 0 === e ? void 0 : e.pos) || 0;
                this.page += n.length, this.updateMetrics();
                const o = (null === (i = this.pages[this.page]) || void 0 === i ? void 0 : i.pos) || 0;
                if (this.panzoom) {
                    const t = this.isRTL ? s - o : o - s;
                    this.panzoom.target.e -= t, this.panzoom.current.e -= t, this.panzoom.requestTick();
                }
            }
            appendSlide(t) {
                let e = Array.isArray(t) ? t : [ t ];
                for (const t of e) {
                    const e = j(t);
                    e.index = this.slides.length, this.slides.push(e), this.emit("initSlide", e, this.slides.length);
                }
                this.updateMetrics();
            }
            removeSlide(t) {
                const e = this.slides.length;
                t = (t % e + e) % e, this.removeSlideEl(this.slides[t], !0), this.slides.splice(t, 1);
                for (let t = 0; t < this.slides.length; t++) this.slides[t].index = t;
                this.updateMetrics(), this.slideTo(this.page, {
                    friction: 0,
                    transition: !1
                });
            }
            updateMetrics() {
                const {panzoom: e, viewport: i, track: n, isHorizontal: s} = this;
                if (!n) return;
                const o = s ? "width" : "height", a = s ? "offsetWidth" : "offsetHeight";
                if (i) {
                    let e = Math.max(i[a], t(i.getBoundingClientRect()[o], 1e3)), n = getComputedStyle(i), r = "padding", l = s ? "Right" : "Bottom";
                    e -= parseFloat(n[r + (s ? "Left" : "Top")]) + parseFloat(n[r + l]), this.viewportDim = e;
                }
                let r, l = this.pages.length, c = 0;
                for (const [e, i] of this.slides.entries()) {
                    let n = 0, s = 0;
                    !i.el && r ? (n = r.dim, s = r.gap) : (({dim: n, gap: s} = this.getSlideMetrics(i)), 
                    r = i), n = t(n, 1e3), s = t(s, 1e3), i.dim = n, i.gap = s, i.pos = c, c += n, (this.isInfinite || e < this.slides.length - 1) && (c += s);
                }
                const h = this.contentDim;
                c = t(c, 1e3), this.contentDim = c, e && (e.contentRect[o] = c, e.contentRect["e" === this.axis ? "fullWidth" : "fullHeight"] = c), 
                this.pages = this.createPages(), this.pages = this.processPages(), this.state === F.Init && this.setInitialPage(), 
                this.page = Math.max(0, Math.min(this.page, this.pages.length - 1)), e && l === this.pages.length && Math.abs(c - h) > .5 && (e.target[this.axis] = -1 * this.pages[this.page].pos, 
                e.current[this.axis] = -1 * this.pages[this.page].pos, e.stop()), this.manageSlideVisiblity(), 
                this.emit("refresh");
            }
            getProgress(e, i = !1) {
                void 0 === e && (e = this.page);
                const n = this, s = n.panzoom, o = n.pages[e] || 0;
                if (!o || !s) return 0;
                let a = -1 * s.current.e, r = n.contentDim;
                var l = [ t((a - o.pos) / (1 * o.dim), 1e3), t((a + r - o.pos) / (1 * o.dim), 1e3), t((a - r - o.pos) / (1 * o.dim), 1e3) ].reduce((function(t, e) {
                    return Math.abs(e) < Math.abs(t) ? e : t;
                }));
                return i ? l : Math.max(-1, Math.min(1, l));
            }
            setViewportHeight() {
                const {page: t, pages: e, viewport: i, isHorizontal: n} = this;
                if (!i || !e[t]) return;
                let s = 0;
                n && this.track && (this.track.style.height = "auto", e[t].slides.forEach((t => {
                    t.el && (s = Math.max(s, t.el.offsetHeight));
                }))), i.style.height = s ? `${s}px` : "";
            }
            getPageForSlide(t) {
                for (const e of this.pages) for (const i of e.slides) if (i.index === t) return e.index;
                return -1;
            }
            getVisibleSlides(t = 0) {
                var e;
                const i = new Set;
                let {contentDim: n, viewportDim: s, pages: o, page: a} = this;
                n = n + (null === (e = this.slides[this.slides.length - 1]) || void 0 === e ? void 0 : e.gap) || 0;
                let r = 0;
                r = this.panzoom ? -1 * this.panzoom.current[this.axis] : o[a] && o[a].pos || 0, 
                this.isInfinite && (r -= Math.floor(r / n) * n), this.isRTL && this.isHorizontal && (r *= -1);
                const l = r - s * t, c = r + s * (t + 1), h = this.isInfinite ? [ -1, 0, 1 ] : [ 0 ];
                for (const t of this.slides) for (const e of h) {
                    const s = t.pos + e * n, o = t.pos + t.dim + t.gap + e * n;
                    s < c && o > l && i.add(t);
                }
                return i;
            }
            getPageFromPosition(t) {
                const {viewportDim: e, contentDim: i} = this, n = this.pages.length, s = this.slides.length, o = this.slides[s - 1];
                let a = 0, r = 0, l = 0;
                const c = this.option("center");
                c && (t += .5 * e), this.isInfinite || (t = Math.max(this.slides[0].pos, Math.min(t, o.pos)));
                const h = i + o.gap;
                l = Math.floor(t / h) || 0, t -= l * h;
                let d = o, u = this.slides.find((e => {
                    const i = t + (d && !c ? .5 * d.dim : 0);
                    return d = e, e.pos <= i && e.pos + e.dim + e.gap > i;
                }));
                return u || (u = o), r = this.getPageForSlide(u.index), a = r + l * n, {
                    page: a,
                    pageIndex: r
                };
            }
            destroy() {
                if ([ F.Destroy ].includes(this.state)) return;
                this.state = F.Destroy;
                const {container: t, viewport: e, track: i, slides: n, panzoom: s} = this, o = this.option("classes");
                t.removeEventListener("click", this.onClick, {
                    passive: !1,
                    capture: !1
                }), t.removeEventListener("slideTo", this.onSlideTo), window.removeEventListener("resize", this.onResize), 
                s && (s.destroy(), this.panzoom = null), n && n.forEach((t => {
                    this.removeSlideEl(t);
                })), this.detachPlugins(), e && e.offsetParent && i && i.offsetParent && e.replaceWith(...i.childNodes);
                for (const [e, i] of Object.entries(o)) "container" !== e && i && t.classList.remove(i);
                this.track = null, this.viewport = null, this.page = 0, this.slides = [];
                const a = this.events.get("ready");
                this.events = new Map, a && this.events.set("ready", a);
            }
        }
        Object.defineProperty(Z, "Panzoom", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: R
        }), Object.defineProperty(Z, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: D
        }), Object.defineProperty(Z, "Plugins", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: V
        });
        const U = function(t) {
            const e = window.pageYOffset, i = window.pageYOffset + window.innerHeight;
            if (!x(t)) return 0;
            const n = t.getBoundingClientRect(), s = n.y + window.pageYOffset, o = n.y + n.height + window.pageYOffset;
            if (e > o || i < s) return 0;
            if (e < s && i > o) return 100;
            if (s < e && o > i) return 100;
            let a = n.height;
            s < e && (a -= window.pageYOffset - s), o > i && (a -= o - i);
            const r = a / window.innerHeight * 100;
            return Math.round(r);
        }, G = !("undefined" == typeof window || !window.document || !window.document.createElement);
        let K;
        const J = [ "a[href]", "area[href]", 'input:not([disabled]):not([type="hidden"]):not([aria-hidden])', "select:not([disabled]):not([aria-hidden])", "textarea:not([disabled]):not([aria-hidden])", "button:not([disabled]):not([aria-hidden]):not(.fancybox-focus-guard)", "iframe", "object", "embed", "video", "audio", "[contenteditable]", '[tabindex]:not([tabindex^="-"]):not([disabled]):not([aria-hidden])' ].join(","), Q = t => {
            if (t && G) {
                void 0 === K && document.createElement("div").focus({
                    get preventScroll() {
                        return K = !0, !1;
                    }
                });
                try {
                    if (K) t.focus({
                        preventScroll: !0
                    }); else {
                        const e = window.pageXOffset || document.body.scrollTop, i = window.pageYOffset || document.body.scrollLeft;
                        t.focus(), document.body.scrollTo({
                            top: e,
                            left: i,
                            behavior: "auto"
                        });
                    }
                } catch (t) {}
            }
        }, tt = {
            dragToClose: !0,
            hideScrollbar: !0,
            Carousel: {
                classes: {
                    container: "fancybox__carousel",
                    viewport: "fancybox__viewport",
                    track: "fancybox__track",
                    slide: "fancybox__slide"
                }
            },
            contentClick: "toggleZoom",
            contentDblClick: !1,
            backdropClick: "close",
            animated: !0,
            idle: 3500,
            showClass: "f-zoomInUp",
            hideClass: "f-fadeOut",
            commonCaption: !1,
            parentEl: null,
            startIndex: 0,
            l10n: Object.assign(Object.assign({}, v), {
                CLOSE: "Close",
                NEXT: "Next",
                PREV: "Previous",
                MODAL: "You can close this modal content with the ESC key",
                ERROR: "Something Went Wrong, Please Try Again Later",
                IMAGE_ERROR: "Image Not Found",
                ELEMENT_NOT_FOUND: "HTML Element Not Found",
                AJAX_NOT_FOUND: "Error Loading AJAX : Not Found",
                AJAX_FORBIDDEN: "Error Loading AJAX : Forbidden",
                IFRAME_ERROR: "Error Loading Page",
                TOGGLE_ZOOM: "Toggle zoom level",
                TOGGLE_THUMBS: "Toggle thumbnails",
                TOGGLE_SLIDESHOW: "Toggle slideshow",
                TOGGLE_FULLSCREEN: "Toggle full-screen mode",
                DOWNLOAD: "Download"
            }),
            tpl: {
                closeButton: '<button data-fancybox-close class="f-button is-close-btn" title="{{CLOSE}}"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" tabindex="-1"><path d="M20 20L4 4m16 0L4 20"/></svg></button>',
                main: '<div class="fancybox__container" role="dialog" aria-modal="true" aria-label="{{MODAL}}" tabindex="-1">\n    <div class="fancybox__backdrop"></div>\n    <div class="fancybox__carousel"></div>\n    <div class="fancybox__footer"></div>\n  </div>'
            },
            groupAll: !1,
            groupAttr: "data-fancybox",
            defaultType: "image",
            defaultDisplay: "block",
            autoFocus: !0,
            trapFocus: !0,
            placeFocusBack: !0,
            closeButton: "auto",
            keyboard: {
                Escape: "close",
                Delete: "close",
                Backspace: "close",
                PageUp: "next",
                PageDown: "prev",
                ArrowUp: "prev",
                ArrowDown: "next",
                ArrowRight: "next",
                ArrowLeft: "prev"
            },
            Fullscreen: {
                autoStart: !1
            },
            compact: () => window.matchMedia("(max-width: 578px), (max-height: 578px)").matches,
            wheel: "zoom"
        };
        var et, it;
        !function(t) {
            t[t.Init = 0] = "Init", t[t.Ready = 1] = "Ready", t[t.Closing = 2] = "Closing", 
            t[t.CustomClosing = 3] = "CustomClosing", t[t.Destroy = 4] = "Destroy";
        }(et || (et = {})), function(t) {
            t[t.Loading = 0] = "Loading", t[t.Opening = 1] = "Opening", t[t.Ready = 2] = "Ready", 
            t[t.Closing = 3] = "Closing";
        }(it || (it = {}));
        const nt = () => {
            queueMicrotask((() => {
                (() => {
                    const {slug: t, index: e} = st.parseURL(), i = _t.getInstance();
                    if (i && !1 !== i.option("Hash")) {
                        const n = i.carousel;
                        if (t && n) {
                            for (let e of n.slides) if (e.slug && e.slug === t) return n.slideTo(e.index);
                            if (t === i.option("slug")) return n.slideTo(e - 1);
                            const s = i.getSlide(), o = s && s.triggerEl && s.triggerEl.dataset;
                            if (o && o.fancybox === t) return n.slideTo(e - 1);
                        }
                        st.hasSilentClose = !0, i.close();
                    }
                    st.startFromUrl();
                })();
            }));
        };
        class st extends B {
            constructor() {
                super(...arguments), Object.defineProperty(this, "origHash", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: ""
                }), Object.defineProperty(this, "timer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            onChange() {
                const t = this.instance, e = t.carousel;
                this.timer && clearTimeout(this.timer);
                const i = t.getSlide();
                if (!e || !i) return;
                const n = t.isOpeningSlide(i), s = new URL(document.URL).hash;
                let o, a = i.slug || void 0, r = i.triggerEl || void 0;
                o = a || this.instance.option("slug"), !o && r && r.dataset && (o = r.dataset.fancybox);
                let l = "";
                o && "true" !== o && (l = "#" + o + (!a && e.slides.length > 1 ? "-" + (i.index + 1) : "")), 
                n && (this.origHash = s !== l ? s : ""), l && s !== l && (this.timer = setTimeout((() => {
                    try {
                        t.state === et.Ready && window.history[n ? "pushState" : "replaceState"]({}, document.title, window.location.pathname + window.location.search + l);
                    } catch (t) {}
                }), 300));
            }
            onClose() {
                if (this.timer && clearTimeout(this.timer), !0 !== st.hasSilentClose) try {
                    window.history.replaceState({}, document.title, window.location.pathname + window.location.search + (this.origHash || ""));
                } catch (t) {}
            }
            attach() {
                const t = this.instance;
                t.on("Carousel.ready", this.onChange), t.on("Carousel.change", this.onChange), t.on("close", this.onClose);
            }
            detach() {
                const t = this.instance;
                t.off("Carousel.ready", this.onChange), t.off("Carousel.change", this.onChange), 
                t.off("close", this.onClose);
            }
            static parseURL() {
                const t = window.location.hash.slice(1), e = t.split("-"), i = e[e.length - 1], n = i && /^\+?\d+$/.test(i) && parseInt(e.pop() || "1", 10) || 1;
                return {
                    hash: t,
                    slug: e.join("-"),
                    index: n
                };
            }
            static startFromUrl() {
                if (st.hasSilentClose = !1, _t.getInstance() || !1 === _t.defaults.Hash) return;
                const {hash: t, slug: e, index: i} = st.parseURL();
                if (!e) return;
                let n = document.querySelector(`[data-slug="${t}"]`);
                if (n && n.dispatchEvent(new CustomEvent("click", {
                    bubbles: !0,
                    cancelable: !0
                })), _t.getInstance()) return;
                const s = document.querySelectorAll(`[data-fancybox="${e}"]`);
                s.length && (n = s[i - 1], n && n.dispatchEvent(new CustomEvent("click", {
                    bubbles: !0,
                    cancelable: !0
                })));
            }
            static destroy() {
                window.removeEventListener("hashchange", nt, !1);
            }
        }
        function ot() {
            window.addEventListener("hashchange", nt, !1), setTimeout((() => {
                st.startFromUrl();
            }), 500);
        }
        Object.defineProperty(st, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {}
        }), Object.defineProperty(st, "hasSilentClose", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: !1
        }), G && (/complete|interactive|loaded/.test(document.readyState) ? ot() : document.addEventListener("DOMContentLoaded", ot));
        class at extends B {
            onCreateSlide(t, e, i) {
                const n = this.instance.optionFor(i, "src") || "";
                i.el && "image" === i.type && "string" == typeof n && this.setImage(i, n);
            }
            onRemoveSlide(t, e, i) {
                i.panzoom && i.panzoom.destroy(), i.panzoom = void 0, i.imageEl = void 0;
            }
            onChange(t, e, i, n) {
                for (const t of e.slides) {
                    const e = t.panzoom;
                    e && t.index !== i && e.reset(.35);
                }
            }
            onClose() {
                var t;
                const e = this.instance, i = e.container, n = e.getSlide();
                if (!i || !i.parentElement || !n) return;
                const {el: s, contentEl: o, panzoom: a} = n, r = n.thumbElSrc;
                if (!s || !r || !o || !a || a.isContentLoading || a.state === g.Init || a.state === g.Destroy) return;
                a.updateMetrics();
                let l = this.getZoomInfo(n);
                if (!l) return;
                this.instance.state = et.CustomClosing, i.classList.remove("is-zooming-in"), i.classList.add("is-zooming-out"), 
                o.style.backgroundImage = `url('${r}')`;
                const c = i.getBoundingClientRect();
                1 === ((null === (t = window.visualViewport) || void 0 === t ? void 0 : t.scale) || 1) && Object.assign(i.style, {
                    position: "absolute",
                    top: `${window.pageYOffset}px`,
                    left: `${window.pageXOffset}px`,
                    bottom: "auto",
                    right: "auto",
                    width: `${c.width}px`,
                    height: `${c.height}px`,
                    overflow: "hidden"
                });
                const {x: h, y: d, scale: u, opacity: p} = l;
                if (p) {
                    const t = ((t, e, i, n) => {
                        const s = e - t, o = n - i;
                        return e => i + ((e - t) / s * o || 0);
                    })(a.scale, u, 1, 0);
                    a.on("afterTransform", (() => {
                        o.style.opacity = t(a.scale) + "";
                    }));
                }
                a.on("endAnimation", (() => {
                    e.destroy();
                })), a.target.a = u, a.target.b = 0, a.target.c = 0, a.target.d = u, a.panTo({
                    x: h,
                    y: d,
                    scale: u,
                    friction: p ? .2 : .33,
                    ignoreBounds: !0
                }), a.isResting && e.destroy();
            }
            setImage(t, e) {
                const i = this.instance;
                t.src = e, this.process(t, e).then((e => {
                    var n;
                    const s = t.contentEl, o = t.imageEl, a = t.thumbElSrc;
                    if (i.isClosing() || !s || !o) return;
                    s.offsetHeight;
                    const r = !!i.isOpeningSlide(t) && this.getZoomInfo(t);
                    if (this.option("protected")) {
                        null === (n = t.el) || void 0 === n || n.addEventListener("contextmenu", (t => {
                            t.preventDefault();
                        }));
                        const e = document.createElement("div");
                        S(e, "fancybox-protected"), s.appendChild(e);
                    }
                    if (a && r) {
                        const n = e.contentRect, o = Math.max(n.fullWidth, n.fullHeight);
                        let c = null;
                        !r.opacity && o > 1200 && (c = document.createElement("img"), S(c, "fancybox-ghost"), 
                        c.src = a, s.appendChild(c));
                        const h = () => {
                            c && (S(c, "f-fadeFastOut"), setTimeout((() => {
                                c && (c.remove(), c = null);
                            }), 200));
                        };
                        (l = a, new Promise(((t, e) => {
                            const i = new Image;
                            i.onload = t, i.onerror = e, i.src = l;
                        }))).then((() => {
                            t.state = it.Opening, this.instance.emit("reveal", t), this.zoomIn(t).then((() => {
                                h(), this.instance.done(t);
                            }), (() => {
                                i.hideLoading(t);
                            })), c && setTimeout((() => {
                                h();
                            }), o > 2500 ? 800 : 200);
                        }), (() => {
                            i.hideLoading(t), i.revealContent(t);
                        }));
                    } else {
                        const n = this.optionFor(t, "initialSize"), s = this.optionFor(t, "zoom"), o = {
                            event: i.prevMouseMoveEvent || i.options.event,
                            friction: s ? .12 : 0
                        };
                        let a = i.optionFor(t, "showClass") || void 0, r = !0;
                        i.isOpeningSlide(t) && ("full" === n ? e.zoomToFull(o) : "cover" === n ? e.zoomToCover(o) : "max" === n ? e.zoomToMax(o) : r = !1, 
                        e.stop("current")), r && a && (a = e.isDragging ? "f-fadeIn" : ""), i.revealContent(t, a);
                    }
                    var l;
                }), (() => {
                    i.setError(t, "{{IMAGE_ERROR}}");
                }));
            }
            process(t, e) {
                return new Promise(((i, s) => {
                    var o, a;
                    const r = this.instance, l = t.el;
                    r.clearContent(t), r.showLoading(t);
                    let c = this.optionFor(t, "content");
                    "string" == typeof c && (c = n(c)), c && x(c) || (c = document.createElement("img"), 
                    c instanceof HTMLImageElement && (c.src = e || "", c.alt = (null === (o = t.caption) || void 0 === o ? void 0 : o.replace(/<[^>]+>/gi, "").substring(0, 1e3)) || `Image ${t.index + 1} of ${null === (a = r.carousel) || void 0 === a ? void 0 : a.pages.length}`, 
                    c.draggable = !1, t.srcset && c.setAttribute("srcset", t.srcset)), t.sizes && c.setAttribute("sizes", t.sizes)), 
                    c.classList.add("fancybox-image"), t.imageEl = c, r.setContent(t, c, !1);
                    t.panzoom = new R(l, u({
                        transformParent: !0
                    }, this.option("Panzoom") || {}, {
                        content: c,
                        width: r.optionFor(t, "width", "auto"),
                        height: r.optionFor(t, "height", "auto"),
                        wheel: () => {
                            const t = r.option("wheel");
                            return ("zoom" === t || "pan" == t) && t;
                        },
                        click: (e, i) => {
                            var n, s;
                            if (r.isCompact || r.isClosing()) return !1;
                            if (t.index !== (null === (n = r.getSlide()) || void 0 === n ? void 0 : n.index)) return !1;
                            if (i) {
                                const t = i.composedPath()[0];
                                if ([ "A", "BUTTON", "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO" ].includes(t.nodeName)) return !1;
                            }
                            let o = !i || i.target && (null === (s = t.contentEl) || void 0 === s ? void 0 : s.contains(i.target));
                            return r.option(o ? "contentClick" : "backdropClick") || !1;
                        },
                        dblClick: () => r.isCompact ? "toggleZoom" : r.option("contentDblClick") || !1,
                        spinner: !1,
                        panOnlyZoomed: !0,
                        wheelLimit: 1 / 0,
                        on: {
                            ready: t => {
                                i(t);
                            },
                            error: () => {
                                s();
                            },
                            destroy: () => {
                                s();
                            }
                        }
                    }));
                }));
            }
            zoomIn(t) {
                return new Promise(((e, i) => {
                    const n = this.instance, s = n.container, {panzoom: o, contentEl: a, el: r} = t;
                    o && o.updateMetrics();
                    const l = this.getZoomInfo(t);
                    if (!(l && r && a && o && s)) return void i();
                    const {x: c, y: h, scale: d, opacity: u} = l, p = () => {
                        t.state !== it.Closing && (u && (a.style.opacity = Math.max(Math.min(1, 1 - (1 - o.scale) / (1 - d)), 0) + ""), 
                        o.scale >= 1 && o.scale > o.targetScale - .1 && e(o));
                    }, f = t => {
                        E(s, "is-zooming-in"), t.scale < .99 || t.scale > 1.01 || (a.style.opacity = "", 
                        t.off("endAnimation", f), t.off("touchStart", f), t.off("afterTransform", p), e(t));
                    };
                    o.on("endAnimation", f), o.on("touchStart", f), o.on("afterTransform", p), o.on([ "error", "destroy" ], (() => {
                        i();
                    })), o.panTo({
                        x: c,
                        y: h,
                        scale: d,
                        friction: 0,
                        ignoreBounds: !0
                    }), o.stop("current");
                    const m = {
                        event: "mousemove" === o.panMode ? n.prevMouseMoveEvent || n.options.event : void 0
                    }, g = this.optionFor(t, "initialSize");
                    S(s, "is-zooming-in"), n.hideLoading(t), "full" === g ? o.zoomToFull(m) : "cover" === g ? o.zoomToCover(m) : "max" === g ? o.zoomToMax(m) : o.reset(.172);
                }));
            }
            getZoomInfo(t) {
                var e;
                const {el: i, imageEl: n, thumbEl: s, panzoom: o} = t;
                if (!i || !n || !s || !o || U(s) < 3 || !this.optionFor(t, "zoom") || this.instance.state === et.Destroy) return !1;
                if (1 !== ((null === (e = window.visualViewport) || void 0 === e ? void 0 : e.scale) || 1)) return !1;
                let {top: a, left: r, width: l, height: c} = s.getBoundingClientRect(), {top: h, left: d, fitWidth: u, fitHeight: p} = o.contentRect;
                if (!(l && c && u && p)) return !1;
                const f = o.container.getBoundingClientRect();
                d += f.left, h += f.top;
                const m = -1 * (d + .5 * u - (r + .5 * l)), g = -1 * (h + .5 * p - (a + .5 * c)), b = l / u;
                let v = this.option("zoomOpacity") || !1;
                return "auto" === v && (v = Math.abs(l / c - u / p) > .1), {
                    x: m,
                    y: g,
                    scale: b,
                    opacity: v
                };
            }
            attach() {
                const t = this, e = t.instance;
                e.on("Carousel.change", t.onChange), e.on("Carousel.createSlide", t.onCreateSlide), 
                e.on("Carousel.removeSlide", t.onRemoveSlide), e.on("close", t.onClose);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("Carousel.change", t.onChange), e.off("Carousel.createSlide", t.onCreateSlide), 
                e.off("Carousel.removeSlide", t.onRemoveSlide), e.off("close", t.onClose);
            }
        }
        Object.defineProperty(at, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {
                initialSize: "fit",
                Panzoom: {
                    maxScale: 1
                },
                protected: !1,
                zoom: !0,
                zoomOpacity: "auto"
            }
        }), "function" == typeof SuppressedError && SuppressedError;
        const rt = (t, e = {}) => {
            const i = new URL(t), n = new URLSearchParams(i.search), s = new URLSearchParams;
            for (const [t, i] of [ ...n, ...Object.entries(e) ]) {
                let e = i.toString();
                "t" === t ? s.set("start", parseInt(e).toString()) : s.set(t, e);
            }
            let o = s.toString(), a = t.match(/#t=((.*)?\d+s)/);
            return a && (o += `#t=${a[1]}`), o;
        }, lt = {
            ajax: null,
            autoSize: !0,
            iframeAttr: {
                allow: "autoplay; fullscreen",
                scrolling: "auto"
            },
            preload: !0,
            videoAutoplay: !0,
            videoRatio: 16 / 9,
            videoTpl: '<video class="fancybox__html5video" playsinline controls controlsList="nodownload" poster="{{poster}}">\n  <source src="{{src}}" type="{{format}}" />Sorry, your browser doesn\'t support embedded videos.</video>',
            videoFormat: "",
            vimeo: {
                byline: 1,
                color: "00adef",
                controls: 1,
                dnt: 1,
                muted: 0
            },
            youtube: {
                controls: 1,
                enablejsapi: 1,
                nocookie: 1,
                rel: 0,
                fs: 1
            }
        }, ct = [ "image", "html", "ajax", "inline", "clone", "iframe", "map", "pdf", "html5video", "youtube", "vimeo", "video" ];
        class ht extends B {
            onInitSlide(t, e, i) {
                this.processType(i);
            }
            onCreateSlide(t, e, i) {
                this.setContent(i);
            }
            onRemoveSlide(t, e, i) {
                i.xhr && (i.xhr.abort(), i.xhr = null);
                const n = i.iframeEl;
                n && (n.onload = n.onerror = null, n.src = "//about:blank", i.iframeEl = null);
                const s = i.contentEl, o = i.placeholderEl;
                if ("inline" === i.type && s && o) s.classList.remove("fancybox__content"), "none" !== s.style.display && (s.style.display = "none"), 
                o.parentNode && o.parentNode.insertBefore(s, o), o.remove(), i.contentEl = void 0, 
                i.placeholderEl = void 0; else for (;i.el && i.el.firstChild; ) i.el.removeChild(i.el.firstChild);
            }
            onSelectSlide(t, e, i) {
                i.state === it.Ready && this.playVideo();
            }
            onUnselectSlide(t, e, i) {
                var n, s;
                if ("html5video" === i.type) {
                    try {
                        null === (s = null === (n = i.el) || void 0 === n ? void 0 : n.querySelector("video")) || void 0 === s || s.pause();
                    } catch (t) {}
                    return;
                }
                let o;
                "vimeo" === i.type ? o = {
                    method: "pause",
                    value: "true"
                } : "youtube" === i.type && (o = {
                    event: "command",
                    func: "pauseVideo"
                }), o && i.iframeEl && i.iframeEl.contentWindow && i.iframeEl.contentWindow.postMessage(JSON.stringify(o), "*"), 
                i.poller && clearTimeout(i.poller);
            }
            onDone(t, e) {
                t.isCurrentSlide(e) && !t.isClosing() && this.playVideo();
            }
            onRefresh(t, e) {
                e.slides.forEach((t => {
                    t.el && (this.setAspectRatio(t), this.resizeIframe(t));
                }));
            }
            onMessage(t) {
                try {
                    let e = JSON.parse(t.data);
                    if ("https://player.vimeo.com" === t.origin) {
                        if ("ready" === e.event) for (let e of Array.from(document.getElementsByClassName("fancybox__iframe"))) e instanceof HTMLIFrameElement && e.contentWindow === t.source && (e.dataset.ready = "true");
                    } else if (t.origin.match(/^https:\/\/(www.)?youtube(-nocookie)?.com$/) && "onReady" === e.event) {
                        const t = document.getElementById(e.id);
                        t && (t.dataset.ready = "true");
                    }
                } catch (t) {}
            }
            loadAjaxContent(t) {
                const e = this.instance.optionFor(t, "src") || "";
                this.instance.showLoading(t);
                const i = this.instance, n = new XMLHttpRequest;
                i.showLoading(t), n.onreadystatechange = function() {
                    n.readyState === XMLHttpRequest.DONE && i.state === et.Ready && (i.hideLoading(t), 
                    200 === n.status ? i.setContent(t, n.responseText) : i.setError(t, 404 === n.status ? "{{AJAX_NOT_FOUND}}" : "{{AJAX_FORBIDDEN}}"));
                };
                const s = t.ajax || null;
                n.open(s ? "POST" : "GET", e + ""), n.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"), 
                n.setRequestHeader("X-Requested-With", "XMLHttpRequest"), n.send(s), t.xhr = n;
            }
            setInlineContent(t) {
                let e = null;
                if (x(t.src)) e = t.src; else if ("string" == typeof t.src) {
                    const i = t.src.split("#", 2).pop();
                    e = i ? document.getElementById(i) : null;
                }
                if (e) {
                    if ("clone" === t.type || e.closest(".fancybox__slide")) {
                        e = e.cloneNode(!0);
                        const i = e.dataset.animationName;
                        i && (e.classList.remove(i), delete e.dataset.animationName);
                        let n = e.getAttribute("id");
                        n = n ? `${n}--clone` : `clone-${this.instance.id}-${t.index}`, e.setAttribute("id", n);
                    } else if (e.parentNode) {
                        const i = document.createElement("div");
                        i.classList.add("fancybox-placeholder"), e.parentNode.insertBefore(i, e), t.placeholderEl = i;
                    }
                    this.instance.setContent(t, e);
                } else this.instance.setError(t, "{{ELEMENT_NOT_FOUND}}");
            }
            setIframeContent(t) {
                const {src: e, el: i} = t;
                if (!e || "string" != typeof e || !i) return;
                const n = this.instance, s = document.createElement("iframe");
                s.className = "fancybox__iframe", s.setAttribute("id", `fancybox__iframe_${n.id}_${t.index}`);
                for (const [e, i] of Object.entries(this.optionFor(t, "iframeAttr") || {})) s.setAttribute(e, i);
                s.onerror = () => {
                    n.setError(t, "{{IFRAME_ERROR}}");
                }, t.iframeEl = s;
                const o = this.optionFor(t, "preload");
                if (i.classList.add("is-loading"), "iframe" !== t.type || !1 === o) return s.setAttribute("src", t.src + ""), 
                this.resizeIframe(t), void n.setContent(t, s);
                n.showLoading(t), s.onload = () => {
                    if (!s.src.length) return;
                    const e = "true" !== s.dataset.ready;
                    s.dataset.ready = "true", this.resizeIframe(t), e ? n.revealContent(t) : n.hideLoading(t);
                }, s.setAttribute("src", e), n.setContent(t, s, !1);
            }
            resizeIframe(t) {
                const e = t.iframeEl, i = null == e ? void 0 : e.parentElement;
                if (!e || !i) return;
                let n = t.autoSize, s = t.width || 0, o = t.height || 0;
                s && o && (n = !1);
                const a = i && i.style;
                if (!1 !== t.preload && !1 !== n && a) try {
                    const t = window.getComputedStyle(i), n = parseFloat(t.paddingLeft) + parseFloat(t.paddingRight), r = parseFloat(t.paddingTop) + parseFloat(t.paddingBottom), l = e.contentWindow;
                    if (l) {
                        const t = l.document, e = t.getElementsByTagName("html")[0], i = t.body;
                        a.width = "", i.style.overflow = "hidden", s = s || e.scrollWidth + n, a.width = `${s}px`, 
                        i.style.overflow = "", a.flex = "0 0 auto", a.height = `${i.scrollHeight}px`, o = e.scrollHeight + r;
                    }
                } catch (t) {}
                if (s || o) {
                    const t = {
                        flex: "0 1 auto",
                        width: "",
                        height: ""
                    };
                    s && (t.width = `${s}px`), o && (t.height = `${o}px`), Object.assign(a, t);
                }
            }
            playVideo() {
                const t = this.instance.getSlide();
                if (!t) return;
                const {el: e} = t;
                if (!e || !e.offsetParent) return;
                if (!this.optionFor(t, "videoAutoplay")) return;
                if ("html5video" === t.type) try {
                    const t = e.querySelector("video");
                    if (t) {
                        const e = t.play();
                        void 0 !== e && e.then((() => {})).catch((e => {
                            t.muted = !0, t.play();
                        }));
                    }
                } catch (t) {}
                if ("youtube" !== t.type && "vimeo" !== t.type) return;
                const i = () => {
                    if (t.iframeEl && t.iframeEl.contentWindow) {
                        let e;
                        if ("true" === t.iframeEl.dataset.ready) return e = "youtube" === t.type ? {
                            event: "command",
                            func: "playVideo"
                        } : {
                            method: "play",
                            value: "true"
                        }, e && t.iframeEl.contentWindow.postMessage(JSON.stringify(e), "*"), void (t.poller = void 0);
                        "youtube" === t.type && (e = {
                            event: "listening",
                            id: t.iframeEl.getAttribute("id")
                        }, t.iframeEl.contentWindow.postMessage(JSON.stringify(e), "*"));
                    }
                    t.poller = setTimeout(i, 250);
                };
                i();
            }
            processType(t) {
                if (t.html) return t.type = "html", t.src = t.html, void (t.html = "");
                const e = this.instance.optionFor(t, "src", "");
                if (!e || "string" != typeof e) return;
                let i = t.type, n = null;
                if (n = e.match(/(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(?:watch\?(?:.*&)?v=|v\/|u\/|shorts\/|embed\/?)?(videoseries\?list=(?:.*)|[\w-]{11}|\?listType=(?:.*)&list=(?:.*))(?:.*)/i)) {
                    const s = this.optionFor(t, "youtube"), {nocookie: o} = s, a = function(t, e) {
                        var i = {};
                        for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (i[n] = t[n]);
                        if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
                            var s = 0;
                            for (n = Object.getOwnPropertySymbols(t); s < n.length; s++) e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (i[n[s]] = t[n[s]]);
                        }
                        return i;
                    }(s, [ "nocookie" ]), r = `www.youtube${o ? "-nocookie" : ""}.com`, l = rt(e, a), c = encodeURIComponent(n[2]);
                    t.videoId = c, t.src = `https://${r}/embed/${c}?${l}`, t.thumbSrc = t.thumbSrc || `https://i.ytimg.com/vi/${c}/mqdefault.jpg`, 
                    i = "youtube";
                } else if (n = e.match(/^.+vimeo.com\/(?:\/)?([\d]+)((\/|\?h=)([a-z0-9]+))?(.*)?/)) {
                    const s = rt(e, this.optionFor(t, "vimeo")), o = encodeURIComponent(n[1]), a = n[4] || "";
                    t.videoId = o, t.src = `https://player.vimeo.com/video/${o}?${a ? `h=${a}${s ? "&" : ""}` : ""}${s}`, 
                    i = "vimeo";
                }
                if (!i && t.triggerEl) {
                    const e = t.triggerEl.dataset.type;
                    ct.includes(e) && (i = e);
                }
                i || "string" == typeof e && ("#" === e.charAt(0) ? i = "inline" : (n = e.match(/\.(mp4|mov|ogv|webm)((\?|#).*)?$/i)) ? (i = "html5video", 
                t.videoFormat = t.videoFormat || "video/" + ("ogv" === n[1] ? "ogg" : n[1])) : e.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i) ? i = "image" : e.match(/\.(pdf)((\?|#).*)?$/i) ? i = "pdf" : (n = e.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:(?:(?:maps\/(?:place\/(?:.*)\/)?\@(.*),(\d+.?\d+?)z))|(?:\?ll=))(.*)?/i)) ? (t.src = `https://maps.google.${n[1]}/?ll=${(n[2] ? n[2] + "&z=" + Math.floor(parseFloat(n[3])) + (n[4] ? n[4].replace(/^\//, "&") : "") : n[4] + "").replace(/\?/, "&")}&output=${n[4] && n[4].indexOf("layer=c") > 0 ? "svembed" : "embed"}`, 
                i = "map") : (n = e.match(/(?:maps\.)?google\.([a-z]{2,3}(?:\.[a-z]{2})?)\/(?:maps\/search\/)(.*)/i)) && (t.src = `https://maps.google.${n[1]}/maps?q=${n[2].replace("query=", "q=").replace("api=1", "")}&output=embed`, 
                i = "map")), i = i || this.instance.option("defaultType"), t.type = i, "image" === i && (t.thumbSrc = t.thumbSrc || t.src);
            }
            setContent(t) {
                const e = this.instance.optionFor(t, "src") || "";
                if (t && t.type && e) {
                    switch (t.type) {
                      case "html":
                        this.instance.setContent(t, e);
                        break;

                      case "html5video":
                        const i = this.option("videoTpl");
                        i && this.instance.setContent(t, i.replace(/\{\{src\}\}/gi, e + "").replace(/\{\{format\}\}/gi, this.optionFor(t, "videoFormat") || "").replace(/\{\{poster\}\}/gi, t.poster || t.thumbSrc || ""));
                        break;

                      case "inline":
                      case "clone":
                        this.setInlineContent(t);
                        break;

                      case "ajax":
                        this.loadAjaxContent(t);
                        break;

                      case "pdf":
                      case "map":
                      case "youtube":
                      case "vimeo":
                        t.preload = !1;

                      case "iframe":
                        this.setIframeContent(t);
                    }
                    this.setAspectRatio(t);
                }
            }
            setAspectRatio(t) {
                var e;
                const i = t.contentEl, n = this.optionFor(t, "videoRatio"), s = null === (e = t.el) || void 0 === e ? void 0 : e.getBoundingClientRect();
                if (!(i && s && n && 1 !== n && t.type && [ "video", "youtube", "vimeo", "html5video" ].includes(t.type))) return;
                const o = s.width, a = s.height;
                i.style.aspectRatio = n + "", i.style.width = o / a > n ? "auto" : "", i.style.height = o / a > n ? "" : "auto";
            }
            attach() {
                const t = this, e = t.instance;
                e.on("Carousel.initSlide", t.onInitSlide), e.on("Carousel.createSlide", t.onCreateSlide), 
                e.on("Carousel.removeSlide", t.onRemoveSlide), e.on("Carousel.selectSlide", t.onSelectSlide), 
                e.on("Carousel.unselectSlide", t.onUnselectSlide), e.on("Carousel.Panzoom.refresh", t.onRefresh), 
                e.on("done", t.onDone), window.addEventListener("message", t.onMessage);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("Carousel.initSlide", t.onInitSlide), e.off("Carousel.createSlide", t.onCreateSlide), 
                e.off("Carousel.removeSlide", t.onRemoveSlide), e.off("Carousel.selectSlide", t.onSelectSlide), 
                e.off("Carousel.unselectSlide", t.onUnselectSlide), e.off("Carousel.Panzoom.refresh", t.onRefresh), 
                e.off("done", t.onDone), window.removeEventListener("message", t.onMessage);
            }
        }
        Object.defineProperty(ht, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: lt
        });
        const dt = "play", ut = "pause", pt = "ready";
        class ft extends B {
            constructor() {
                super(...arguments), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: pt
                }), Object.defineProperty(this, "inHover", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "timer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "progressBar", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            get isActive() {
                return this.state !== pt;
            }
            onReady(t) {
                this.option("autoStart") && (t.isInfinite || t.page < t.pages.length - 1) && this.start();
            }
            onChange() {
                var t;
                (null === (t = this.instance.panzoom) || void 0 === t ? void 0 : t.isResting) || (this.removeProgressBar(), 
                this.pause());
            }
            onSettle() {
                this.resume();
            }
            onVisibilityChange() {
                "visible" === document.visibilityState ? this.resume() : this.pause();
            }
            onMouseEnter() {
                this.inHover = !0, this.pause();
            }
            onMouseLeave() {
                var t;
                this.inHover = !1, (null === (t = this.instance.panzoom) || void 0 === t ? void 0 : t.isResting) && this.resume();
            }
            onTimerEnd() {
                const t = this.instance;
                "play" === this.state && (t.isInfinite || t.page !== t.pages.length - 1 ? t.slideNext() : t.slideTo(0));
            }
            removeProgressBar() {
                this.progressBar && (this.progressBar.remove(), this.progressBar = null);
            }
            createProgressBar() {
                var t;
                if (!this.option("showProgress")) return null;
                this.removeProgressBar();
                const e = this.instance, i = (null === (t = e.pages[e.page]) || void 0 === t ? void 0 : t.slides) || [];
                let n = this.option("progressParentEl");
                if (n || (n = (1 === i.length ? i[0].el : null) || e.viewport), !n) return null;
                const s = document.createElement("div");
                return S(s, "f-progress"), n.prepend(s), this.progressBar = s, s.offsetHeight, s;
            }
            set() {
                const t = this, e = t.instance;
                if (e.pages.length < 2) return;
                if (t.timer) return;
                const i = t.option("timeout");
                t.state = dt, S(e.container, "has-autoplay");
                let n = t.createProgressBar();
                n && (n.style.transitionDuration = `${i}ms`, n.style.transform = "scaleX(1)"), t.timer = setTimeout((() => {
                    t.timer = null, t.inHover || t.onTimerEnd();
                }), i), t.emit("set");
            }
            clear() {
                const t = this;
                t.timer && (clearTimeout(t.timer), t.timer = null), t.removeProgressBar();
            }
            start() {
                const t = this;
                if (t.set(), t.state !== pt) {
                    if (t.option("pauseOnHover")) {
                        const e = t.instance.container;
                        e.addEventListener("mouseenter", t.onMouseEnter, !1), e.addEventListener("mouseleave", t.onMouseLeave, !1);
                    }
                    document.addEventListener("visibilitychange", t.onVisibilityChange, !1), t.emit("start");
                }
            }
            stop() {
                const t = this, e = t.state, i = t.instance.container;
                t.clear(), t.state = pt, i.removeEventListener("mouseenter", t.onMouseEnter, !1), 
                i.removeEventListener("mouseleave", t.onMouseLeave, !1), document.removeEventListener("visibilitychange", t.onVisibilityChange, !1), 
                E(i, "has-autoplay"), e !== pt && t.emit("stop");
            }
            pause() {
                const t = this;
                t.state === dt && (t.state = ut, t.clear(), t.emit(ut));
            }
            resume() {
                const t = this, e = t.instance;
                if (e.isInfinite || e.page !== e.pages.length - 1) if (t.state !== dt) {
                    if (t.state === ut && !t.inHover) {
                        const e = new Event("resume", {
                            bubbles: !0,
                            cancelable: !0
                        });
                        t.emit("resume", e), e.defaultPrevented || t.set();
                    }
                } else t.set(); else t.stop();
            }
            toggle() {
                this.state === dt || this.state === ut ? this.stop() : this.start();
            }
            attach() {
                const t = this, e = t.instance;
                e.on("ready", t.onReady), e.on("Panzoom.startAnimation", t.onChange), e.on("Panzoom.endAnimation", t.onSettle), 
                e.on("Panzoom.touchMove", t.onChange);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("ready", t.onReady), e.off("Panzoom.startAnimation", t.onChange), e.off("Panzoom.endAnimation", t.onSettle), 
                e.off("Panzoom.touchMove", t.onChange), t.stop();
            }
        }
        Object.defineProperty(ft, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {
                autoStart: !0,
                pauseOnHover: !0,
                progressParentEl: null,
                showProgress: !0,
                timeout: 3e3
            }
        });
        class mt extends B {
            constructor() {
                super(...arguments), Object.defineProperty(this, "ref", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            onPrepare(t) {
                const e = t.carousel;
                if (!e) return;
                const i = t.container;
                i && (e.options.Autoplay = u({
                    autoStart: !1
                }, this.option("Autoplay") || {}, {
                    pauseOnHover: !1,
                    timeout: this.option("timeout"),
                    progressParentEl: () => this.option("progressParentEl") || null,
                    on: {
                        start: () => {
                            t.emit("startSlideshow");
                        },
                        set: e => {
                            var n;
                            i.classList.add("has-slideshow"), (null === (n = t.getSlide()) || void 0 === n ? void 0 : n.state) !== it.Ready && e.pause();
                        },
                        stop: () => {
                            i.classList.remove("has-slideshow"), t.isCompact || t.endIdle(), t.emit("endSlideshow");
                        },
                        resume: (e, i) => {
                            var n, s, o;
                            !i || !i.cancelable || (null === (n = t.getSlide()) || void 0 === n ? void 0 : n.state) === it.Ready && (null === (o = null === (s = t.carousel) || void 0 === s ? void 0 : s.panzoom) || void 0 === o ? void 0 : o.isResting) || i.preventDefault();
                        }
                    }
                }), e.attachPlugins({
                    Autoplay: ft
                }), this.ref = e.plugins.Autoplay);
            }
            onReady(t) {
                const e = t.carousel, i = this.ref;
                e && i && this.option("playOnStart") && (e.isInfinite || e.page < e.pages.length - 1) && i.start();
            }
            onDone(t, e) {
                const i = this.ref;
                if (!i) return;
                const n = e.panzoom;
                n && n.on("startAnimation", (() => {
                    t.isCurrentSlide(e) && i.stop();
                })), t.isCurrentSlide(e) && i.resume();
            }
            onKeydown(t, e) {
                var i;
                const n = this.ref;
                n && e === this.option("key") && "BUTTON" !== (null === (i = document.activeElement) || void 0 === i ? void 0 : i.nodeName) && n.toggle();
            }
            attach() {
                const t = this, e = t.instance;
                e.on("Carousel.init", t.onPrepare), e.on("Carousel.ready", t.onReady), e.on("done", t.onDone), 
                e.on("keydown", t.onKeydown);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("Carousel.init", t.onPrepare), e.off("Carousel.ready", t.onReady), e.off("done", t.onDone), 
                e.off("keydown", t.onKeydown);
            }
        }
        Object.defineProperty(mt, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: {
                key: " ",
                playOnStart: !1,
                progressParentEl: t => {
                    var e;
                    return (null === (e = t.instance.container) || void 0 === e ? void 0 : e.querySelector(".fancybox__toolbar [data-fancybox-toggle-slideshow]")) || t.instance.container;
                },
                timeout: 3e3
            }
        });
        const gt = {
            classes: {
                container: "f-thumbs f-carousel__thumbs",
                viewport: "f-thumbs__viewport",
                track: "f-thumbs__track",
                slide: "f-thumbs__slide",
                isResting: "is-resting",
                isSelected: "is-selected",
                isLoading: "is-loading",
                hasThumbs: "has-thumbs"
            },
            minCount: 2,
            parentEl: null,
            thumbTpl: '<button class="f-thumbs__slide__button" tabindex="0" type="button" aria-label="{{GOTO}}" data-carousel-index="%i"><img class="f-thumbs__slide__img" data-lazy-src="{{%s}}" alt="" /></button>',
            type: "modern"
        };
        var bt;
        !function(t) {
            t[t.Init = 0] = "Init", t[t.Ready = 1] = "Ready", t[t.Hidden = 2] = "Hidden", t[t.Disabled = 3] = "Disabled";
        }(bt || (bt = {}));
        let vt = class extends B {
            constructor() {
                super(...arguments), Object.defineProperty(this, "type", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: "modern"
                }), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "track", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "carousel", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "panzoom", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "thumbWidth", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "thumbClipWidth", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "thumbHeight", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "thumbGap", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "thumbExtraGap", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "shouldCenter", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !0
                }), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: bt.Init
                });
            }
            formatThumb(t, e) {
                return this.instance.localize(e, [ [ "%i", t.index ], [ "%d", t.index + 1 ], [ "%s", t.thumbSrc || "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" ] ]);
            }
            getSlides() {
                const t = [], e = this.option("thumbTpl") || "";
                if (e) for (const i of this.instance.slides || []) {
                    let n = "";
                    i.type && (n = `for-${i.type}`, i.type && [ "video", "youtube", "vimeo", "html5video" ].includes(i.type) && (n += " for-video")), 
                    t.push({
                        html: this.formatThumb(i, e),
                        customClass: n
                    });
                }
                return t;
            }
            onInitSlide(t, e) {
                const i = e.el;
                i && (e.thumbSrc = i.dataset.thumbSrc || e.thumbSrc || "", e.thumbClipWidth = parseFloat(i.dataset.thumbClipWidth || "") || e.thumbClipWidth || 0, 
                e.thumbHeight = parseFloat(i.dataset.thumbHeight || "") || e.thumbHeight || 0);
            }
            onInitSlides() {
                this.state === bt.Init && this.build();
            }
            onRefreshM() {
                this.refreshModern();
            }
            onChangeM() {
                "modern" === this.type && (this.shouldCenter = !0, this.centerModern());
            }
            onClickModern(t) {
                t.preventDefault(), t.stopPropagation();
                const e = this.instance, i = e.page, n = t => {
                    if (t) {
                        const e = t.closest("[data-carousel-index]");
                        if (e) return parseInt(e.dataset.carouselIndex || "", 10) || 0;
                    }
                    return -1;
                }, s = (t, e) => {
                    const i = document.elementFromPoint(t, e);
                    return i ? n(i) : -1;
                };
                let o = n(t.target);
                o < 0 && (o = s(t.clientX + this.thumbGap, t.clientY), o === i && (o = i - 1)), 
                o < 0 && (o = s(t.clientX - this.thumbGap, t.clientY), o === i && (o = i + 1)), 
                o < 0 && (o = (e => {
                    let n = s(t.clientX - e, t.clientY), a = s(t.clientX + e, t.clientY);
                    return o < 0 && n === i && (o = i + 1), o < 0 && a === i && (o = i - 1), o;
                })(this.thumbExtraGap)), o === i ? this.centerModern() : o > -1 && o < e.pages.length && e.slideTo(o);
            }
            onTransformM() {
                if ("modern" !== this.type) return;
                const {instance: t, container: e, track: i} = this, n = t.panzoom;
                if (!(e && i && n && this.panzoom)) return;
                o(e, this.cn("isResting"), n.state !== g.Init && n.isResting);
                const s = this.thumbGap, a = this.thumbExtraGap, r = this.thumbClipWidth;
                let l = 0, c = 0, h = 0;
                for (const e of t.slides) {
                    let i = e.index, n = e.thumbSlideEl;
                    if (!n) continue;
                    o(n, this.cn("isSelected"), i === t.page), c = 1 - Math.abs(t.getProgress(i)), n.style.setProperty("--progress", c ? c + "" : "");
                    const d = .5 * ((e.thumbWidth || 0) - r);
                    l += s, l += d, c && (l -= c * (d + a)), n.style.setProperty("--shift", l - s + ""), 
                    l += d, c && (l -= c * (d + a)), l -= s, 0 === i && (h = a * c);
                }
                i && (i.style.setProperty("--left", h + ""), i.style.setProperty("--width", l + h + s + a * c + "")), 
                this.shouldCenter && this.centerModern();
            }
            buildClassic() {
                const {container: t, track: e} = this, i = this.getSlides();
                if (!t || !e || !i) return;
                const n = new this.instance.constructor(t, u({
                    track: e,
                    infinite: !1,
                    center: !0,
                    fill: !0,
                    dragFree: !0,
                    slidesPerPage: 1,
                    transition: !1,
                    Dots: !1,
                    Navigation: !1,
                    classes: {
                        container: "f-thumbs",
                        viewport: "f-thumbs__viewport",
                        track: "f-thumbs__track",
                        slide: "f-thumbs__slide"
                    }
                }, this.option("Carousel") || {}, {
                    Sync: {
                        target: this.instance
                    },
                    slides: i
                }));
                this.carousel = n, this.track = e, n.on("ready", (() => {
                    this.emit("ready");
                })), n.on("createSlide", ((t, e) => {
                    this.emit("createSlide", e, e.el);
                }));
            }
            buildModern() {
                if ("modern" !== this.type) return;
                const {container: t, track: e, instance: i} = this, s = this.option("thumbTpl") || "";
                if (!t || !e || !s) return;
                S(t, "is-horizontal"), this.updateModern();
                for (const t of i.slides || []) {
                    const i = document.createElement("div");
                    if (S(i, this.cn("slide")), t.type) {
                        let e = `for-${t.type}`;
                        [ "video", "youtube", "vimeo", "html5video" ].includes(t.type) && (e += " for-video"), 
                        S(i, e);
                    }
                    i.appendChild(n(this.formatThumb(t, s))), this.emit("createSlide", t, i), t.thumbSlideEl = i, 
                    e.appendChild(i), this.resizeModernSlide(t);
                }
                const o = new i.constructor.Panzoom(t, {
                    content: e,
                    lockAxis: "x",
                    zoom: !1,
                    panOnlyZoomed: !1,
                    bounds: () => {
                        let t = 0, e = 0, n = i.slides[0], s = i.slides[i.slides.length - 1], o = i.slides[i.page];
                        return n && s && o && (e = -1 * this.getModernThumbPos(0), 0 !== i.page && (e += .5 * (n.thumbWidth || 0)), 
                        t = -1 * this.getModernThumbPos(i.slides.length - 1), i.page !== i.slides.length - 1 && (t += (s.thumbWidth || 0) - (o.thumbWidth || 0) - .5 * (s.thumbWidth || 0))), 
                        {
                            x: {
                                min: t,
                                max: e
                            },
                            y: {
                                min: 0,
                                max: 0
                            }
                        };
                    }
                });
                o.on("touchStart", ((t, e) => {
                    this.shouldCenter = !1;
                })), o.on("click", ((t, e) => this.onClickModern(e))), o.on("ready", (() => {
                    this.centerModern(), this.emit("ready");
                })), o.on([ "afterTransform", "refresh" ], (t => {
                    this.lazyLoadModern();
                })), this.panzoom = o, this.refreshModern();
            }
            updateModern() {
                if ("modern" !== this.type) return;
                const {container: t} = this;
                t && (this.thumbGap = parseFloat(getComputedStyle(t).getPropertyValue("--f-thumb-gap")) || 0, 
                this.thumbExtraGap = parseFloat(getComputedStyle(t).getPropertyValue("--f-thumb-extra-gap")) || 0, 
                this.thumbWidth = parseFloat(getComputedStyle(t).getPropertyValue("--f-thumb-width")) || 40, 
                this.thumbClipWidth = parseFloat(getComputedStyle(t).getPropertyValue("--f-thumb-clip-width")) || 40, 
                this.thumbHeight = parseFloat(getComputedStyle(t).getPropertyValue("--f-thumb-height")) || 40);
            }
            refreshModern() {
                var t;
                if ("modern" === this.type) {
                    this.updateModern();
                    for (const t of this.instance.slides || []) this.resizeModernSlide(t);
                    this.onTransformM(), null === (t = this.panzoom) || void 0 === t || t.updateMetrics(!0), 
                    this.centerModern(0);
                }
            }
            centerModern(e) {
                const i = this.instance, {container: n, panzoom: s} = this;
                if (!n || !s || s.state === g.Init) return;
                const o = i.page;
                let a = this.getModernThumbPos(o), r = a;
                for (let t = i.page - 3; t < i.page + 3; t++) {
                    if (t < 0 || t > i.pages.length - 1 || t === i.page) continue;
                    const e = 1 - Math.abs(i.getProgress(t));
                    e > 0 && e < 1 && (r += e * (this.getModernThumbPos(t) - a));
                }
                let l = 100;
                void 0 === e && (e = .2, i.inTransition.size > 0 && (e = .12), Math.abs(-1 * s.current.e - r) > s.containerRect.width && (e = .5, 
                l = 0)), s.options.maxVelocity = l, s.applyChange({
                    panX: t(-1 * r - s.target.e, 1e3),
                    friction: null === i.prevPage ? 0 : e
                });
            }
            lazyLoadModern() {
                const {instance: t, panzoom: e} = this;
                if (!e) return;
                const i = -1 * e.current.e || 0;
                let s = this.getModernThumbPos(t.page);
                if (e.state !== g.Init || 0 === s) for (const s of t.slides || []) {
                    const t = s.thumbSlideEl;
                    if (!t) continue;
                    const o = t.querySelector("img[data-lazy-src]"), a = s.index, r = this.getModernThumbPos(a), l = i - .5 * e.containerRect.innerWidth, c = l + e.containerRect.innerWidth;
                    if (!o || r < l || r > c) continue;
                    let h = o.dataset.lazySrc;
                    if (!h || !h.length) continue;
                    if (delete o.dataset.lazySrc, o.src = h, o.complete) continue;
                    S(t, this.cn("isLoading"));
                    const d = n(w);
                    t.appendChild(d), o.addEventListener("load", (() => {
                        t.offsetParent && (t.classList.remove(this.cn("isLoading")), d.remove());
                    }), !1);
                }
            }
            resizeModernSlide(t) {
                if ("modern" !== this.type) return;
                if (!t.thumbSlideEl) return;
                const e = t.thumbClipWidth && t.thumbHeight ? Math.round(this.thumbHeight * (t.thumbClipWidth / t.thumbHeight)) : this.thumbWidth;
                t.thumbWidth = e;
            }
            getModernThumbPos(e) {
                const i = this.instance.slides[e], n = this.panzoom;
                if (!n || !n.contentRect.fitWidth) return 0;
                let s = n.containerRect.innerWidth, o = n.contentRect.width;
                2 === this.instance.slides.length && (e -= 1, o = 2 * this.thumbClipWidth);
                let a = e * (this.thumbClipWidth + this.thumbGap) + this.thumbExtraGap + .5 * (i.thumbWidth || 0);
                return a -= o > s ? .5 * s : .5 * o, t(a || 0, 1);
            }
            build() {
                const t = this.instance, e = t.container, i = this.option("minCount") || 0;
                if (i) {
                    let e = 0;
                    for (const i of t.slides || []) i.thumbSrc && e++;
                    if (e < i) return this.cleanup(), void (this.state = bt.Disabled);
                }
                const n = this.option("type");
                if ([ "modern", "classic" ].indexOf(n) < 0) return void (this.state = bt.Disabled);
                this.type = n;
                const s = document.createElement("div");
                S(s, this.cn("container")), S(s, `is-${n}`);
                const o = this.option("parentEl");
                o ? o.appendChild(s) : e.after(s), this.container = s, S(e, this.cn("hasThumbs"));
                const a = document.createElement("div");
                S(a, this.cn("track")), s.appendChild(a), this.track = a, "classic" === n ? this.buildClassic() : this.buildModern(), 
                this.state = bt.Ready, s.addEventListener("click", (e => {
                    setTimeout((() => {
                        var e;
                        null === (e = null == s ? void 0 : s.querySelector(`[data-carousel-index="${t.page}"]`)) || void 0 === e || e.focus();
                    }), 100);
                }));
            }
            cleanup() {
                this.carousel && this.carousel.destroy(), this.carousel = null, this.panzoom && this.panzoom.destroy(), 
                this.panzoom = null, this.container && this.container.remove(), this.container = null, 
                this.track = null, this.state = bt.Init, E(this.instance.container, this.cn("hasThumbs"));
            }
            attach() {
                const t = this, e = t.instance;
                e.on("initSlide", t.onInitSlide), e.state === F.Init ? e.on("initSlides", t.onInitSlides) : t.onInitSlides(), 
                e.on("Panzoom.afterTransform", t.onTransformM), e.on("Panzoom.refresh", t.onRefreshM), 
                e.on("change", t.onChangeM);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("initSlide", t.onInitSlide), e.off("initSlides", t.onInitSlides), e.off("Panzoom.afterTransform", t.onTransformM), 
                e.off("Panzoom.refresh", t.onRefreshM), e.off("change", t.onChangeM), t.cleanup();
            }
        };
        Object.defineProperty(vt, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: gt
        });
        const yt = Object.assign(Object.assign({}, gt), {
            key: "t",
            showOnStart: !0,
            parentEl: null
        }), wt = "is-masked", xt = "aria-hidden";
        class Et extends B {
            constructor() {
                super(...arguments), Object.defineProperty(this, "ref", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "hidden", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                });
            }
            get isEnabled() {
                const t = this.ref;
                return t && t.state !== bt.Disabled;
            }
            get isHidden() {
                return this.hidden;
            }
            onInit() {
                var t;
                const e = this, i = e.instance, n = i.carousel;
                if (e.ref || !n) return;
                const s = e.option("parentEl") || i.footer || i.container;
                if (!s) return;
                const o = u({}, e.options, {
                    parentEl: s,
                    classes: {
                        container: "f-thumbs fancybox__thumbs"
                    },
                    Carousel: {
                        Sync: {
                            friction: i.option("Carousel.friction") || 0
                        }
                    },
                    on: {
                        ready: t => {
                            const i = t.container;
                            i && this.hidden && (e.refresh(), i.style.transition = "none", e.hide(), i.offsetHeight, 
                            queueMicrotask((() => {
                                i.style.transition = "", e.show();
                            })));
                        }
                    }
                });
                o.Carousel = o.Carousel || {}, o.Carousel.on = u((null === (t = e.options.Carousel) || void 0 === t ? void 0 : t.on) || {}, {
                    click: (t, e) => {
                        e.stopPropagation();
                    }
                }), n.options.Thumbs = o, n.attachPlugins({
                    Thumbs: vt
                }), e.ref = n.plugins.Thumbs, e.option("showOnStart") || (e.ref.state = bt.Hidden, 
                e.hidden = !0);
            }
            onResize() {
                var t;
                const e = null === (t = this.ref) || void 0 === t ? void 0 : t.container;
                e && (e.style.maxHeight = "");
            }
            onKeydown(t, e) {
                const i = this.option("key");
                i && i === e && this.toggle();
            }
            toggle() {
                const t = this.ref;
                t && t.state !== bt.Disabled && (t.state !== bt.Hidden ? this.hidden ? this.show() : this.hide() : t.build());
            }
            show() {
                const t = this.ref, e = t && t.state !== bt.Disabled && t.container;
                e && (this.refresh(), e.offsetHeight, e.removeAttribute(xt), e.classList.remove(wt), 
                this.hidden = !1);
            }
            hide() {
                const t = this.ref, e = t && t.container;
                e && (this.refresh(), e.offsetHeight, e.classList.add(wt), e.setAttribute(xt, "true")), 
                this.hidden = !0;
            }
            refresh() {
                const t = this.ref;
                if (!t || t.state === bt.Disabled) return;
                const e = t.container, i = (null == e ? void 0 : e.firstChild) || null;
                e && i && i.childNodes.length && (e.style.maxHeight = `${i.getBoundingClientRect().height}px`);
            }
            attach() {
                const t = this, e = t.instance;
                e.state === et.Init ? e.on("Carousel.init", t.onInit) : t.onInit(), e.on("resize", t.onResize), 
                e.on("keydown", t.onKeydown);
            }
            detach() {
                var t;
                const e = this, i = e.instance;
                i.off("Carousel.init", e.onInit), i.off("resize", e.onResize), i.off("keydown", e.onKeydown), 
                null === (t = i.carousel) || void 0 === t || t.detachPlugins([ "Thumbs" ]), e.ref = null;
            }
        }
        Object.defineProperty(Et, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: yt
        });
        const St = {
            panLeft: {
                icon: '<svg><path d="M5 12h14M5 12l6 6M5 12l6-6"/></svg>',
                change: {
                    panX: -100
                }
            },
            panRight: {
                icon: '<svg><path d="M5 12h14M13 18l6-6M13 6l6 6"/></svg>',
                change: {
                    panX: 100
                }
            },
            panUp: {
                icon: '<svg><path d="M12 5v14M18 11l-6-6M6 11l6-6"/></svg>',
                change: {
                    panY: -100
                }
            },
            panDown: {
                icon: '<svg><path d="M12 5v14M18 13l-6 6M6 13l6 6"/></svg>',
                change: {
                    panY: 100
                }
            },
            zoomIn: {
                icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M11 8v6M8 11h6"/></svg>',
                action: "zoomIn"
            },
            zoomOut: {
                icon: '<svg><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>',
                action: "zoomOut"
            },
            toggle1to1: {
                icon: '<svg><path d="M3.51 3.07c5.74.02 11.48-.02 17.22.02 1.37.1 2.34 1.64 2.18 3.13 0 4.08.02 8.16 0 12.23-.1 1.54-1.47 2.64-2.79 2.46-5.61-.01-11.24.02-16.86-.01-1.36-.12-2.33-1.65-2.17-3.14 0-4.07-.02-8.16 0-12.23.1-1.36 1.22-2.48 2.42-2.46Z"/><path d="M5.65 8.54h1.49v6.92m8.94-6.92h1.49v6.92M11.5 9.4v.02m0 5.18v0"/></svg>',
                action: "toggleZoom"
            },
            toggleZoom: {
                icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>',
                action: "toggleZoom"
            },
            iterateZoom: {
                icon: '<svg><g><line x1="11" y1="8" x2="11" y2="14"></line></g><circle cx="11" cy="11" r="7.5"/><path d="m21 21-4.35-4.35M8 11h6"/></svg>',
                action: "iterateZoom"
            },
            rotateCCW: {
                icon: '<svg><path d="M15 4.55a8 8 0 0 0-6 14.9M9 15v5H4M18.37 7.16v.01M13 19.94v.01M16.84 18.37v.01M19.37 15.1v.01M19.94 11v.01"/></svg>',
                action: "rotateCCW"
            },
            rotateCW: {
                icon: '<svg><path d="M9 4.55a8 8 0 0 1 6 14.9M15 15v5h5M5.63 7.16v.01M4.06 11v.01M4.63 15.1v.01M7.16 18.37v.01M11 19.94v.01"/></svg>',
                action: "rotateCW"
            },
            flipX: {
                icon: '<svg style="stroke-width: 1.3"><path d="M12 3v18M16 7v10h5L16 7M8 7v10H3L8 7"/></svg>',
                action: "flipX"
            },
            flipY: {
                icon: '<svg style="stroke-width: 1.3"><path d="M3 12h18M7 16h10L7 21v-5M7 8h10L7 3v5"/></svg>',
                action: "flipY"
            },
            fitX: {
                icon: '<svg><path d="M4 12V6a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v6M10 18H3M21 18h-7M6 15l-3 3 3 3M18 15l3 3-3 3"/></svg>',
                action: "fitX"
            },
            fitY: {
                icon: '<svg><path d="M12 20H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6M18 14v7M18 3v7M15 18l3 3 3-3M15 6l3-3 3 3"/></svg>',
                action: "fitY"
            },
            reset: {
                icon: '<svg><path d="M20 11A8.1 8.1 0 0 0 4.5 9M4 5v4h4M4 13a8.1 8.1 0 0 0 15.5 2m.5 4v-4h-4"/></svg>',
                action: "reset"
            },
            toggleFS: {
                icon: '<svg><g><path d="M14.5 9.5 21 3m0 0h-6m6 0v6M3 21l6.5-6.5M3 21v-6m0 6h6"/></g><g><path d="m14 10 7-7m-7 7h6m-6 0V4M3 21l7-7m0 0v6m0-6H4"/></g></svg>',
                action: "toggleFS"
            }
        };
        var Pt;
        !function(t) {
            t[t.Init = 0] = "Init", t[t.Ready = 1] = "Ready", t[t.Disabled = 2] = "Disabled";
        }(Pt || (Pt = {}));
        const Ct = {
            absolute: "auto",
            display: {
                left: [ "infobar" ],
                middle: [],
                right: [ "iterateZoom", "slideshow", "fullscreen", "thumbs", "close" ]
            },
            enabled: "auto",
            items: {
                infobar: {
                    tpl: '<div class="fancybox__infobar" tabindex="-1"><span data-fancybox-current-index></span>/<span data-fancybox-count></span></div>'
                },
                download: {
                    tpl: '<a class="f-button" title="{{DOWNLOAD}}" data-fancybox-download href="javasript:;"><svg><path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M7 11l5 5 5-5M12 4v12"/></svg></a>'
                },
                prev: {
                    tpl: '<button class="f-button" title="{{PREV}}" data-fancybox-prev><svg><path d="m15 6-6 6 6 6"/></svg></button>'
                },
                next: {
                    tpl: '<button class="f-button" title="{{NEXT}}" data-fancybox-next><svg><path d="m9 6 6 6-6 6"/></svg></button>'
                },
                slideshow: {
                    tpl: '<button class="f-button" title="{{TOGGLE_SLIDESHOW}}" data-fancybox-toggle-slideshow><svg><g><path d="M8 4v16l13 -8z"></path></g><g><path d="M8 4v15M17 4v15"/></g></svg></button>'
                },
                fullscreen: {
                    tpl: '<button class="f-button" title="{{TOGGLE_FULLSCREEN}}" data-fancybox-toggle-fullscreen><svg><g><path d="M4 8V6a2 2 0 0 1 2-2h2M4 16v2a2 2 0 0 0 2 2h2M16 4h2a2 2 0 0 1 2 2v2M16 20h2a2 2 0 0 0 2-2v-2"/></g><g><path d="M15 19v-2a2 2 0 0 1 2-2h2M15 5v2a2 2 0 0 0 2 2h2M5 15h2a2 2 0 0 1 2 2v2M5 9h2a2 2 0 0 0 2-2V5"/></g></svg></button>'
                },
                thumbs: {
                    tpl: '<button class="f-button" title="{{TOGGLE_THUMBS}}" data-fancybox-toggle-thumbs><svg><circle cx="5.5" cy="5.5" r="1"/><circle cx="12" cy="5.5" r="1"/><circle cx="18.5" cy="5.5" r="1"/><circle cx="5.5" cy="12" r="1"/><circle cx="12" cy="12" r="1"/><circle cx="18.5" cy="12" r="1"/><circle cx="5.5" cy="18.5" r="1"/><circle cx="12" cy="18.5" r="1"/><circle cx="18.5" cy="18.5" r="1"/></svg></button>'
                },
                close: {
                    tpl: '<button class="f-button" title="{{CLOSE}}" data-fancybox-close><svg><path d="m19.5 4.5-15 15M4.5 4.5l15 15"/></svg></button>'
                }
            },
            parentEl: null
        }, Mt = {
            tabindex: "-1",
            width: "24",
            height: "24",
            viewBox: "0 0 24 24",
            xmlns: "http://www.w3.org/2000/svg"
        };
        class Tt extends B {
            constructor() {
                super(...arguments), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: Pt.Init
                }), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                });
            }
            onReady(t) {
                var e;
                if (!t.carousel) return;
                let i = this.option("display"), n = this.option("absolute"), s = this.option("enabled");
                if ("auto" === s) {
                    const t = this.instance.carousel;
                    let e = 0;
                    if (t) for (const i of t.slides) (i.panzoom || "image" === i.type) && e++;
                    e || (s = !1);
                }
                s || (i = void 0);
                let o = 0;
                const a = {
                    left: [],
                    middle: [],
                    right: []
                };
                if (i) for (const t of [ "left", "middle", "right" ]) for (const n of i[t]) {
                    const i = this.createEl(n);
                    i && (null === (e = a[t]) || void 0 === e || e.push(i), o++);
                }
                let r = null;
                if (o && (r = this.createContainer()), r) {
                    for (const [t, e] of Object.entries(a)) {
                        const i = document.createElement("div");
                        S(i, "fancybox__toolbar__column is-" + t);
                        for (const t of e) i.appendChild(t);
                        "auto" !== n || "middle" !== t || e.length || (n = !0), r.appendChild(i);
                    }
                    !0 === n && S(r, "is-absolute"), this.state = Pt.Ready, this.onRefresh();
                } else this.state = Pt.Disabled;
            }
            onClick(t) {
                var e, i;
                const n = this.instance, s = n.getSlide(), o = null == s ? void 0 : s.panzoom, a = t.target, r = a && x(a) ? a.dataset : null;
                if (!r) return;
                if (void 0 !== r.fancyboxToggleThumbs) return t.preventDefault(), t.stopPropagation(), 
                void (null === (e = n.plugins.Thumbs) || void 0 === e || e.toggle());
                if (void 0 !== r.fancyboxToggleFullscreen) return t.preventDefault(), t.stopPropagation(), 
                void this.instance.toggleFullscreen();
                if (void 0 !== r.fancyboxToggleSlideshow) {
                    t.preventDefault(), t.stopPropagation();
                    const e = null === (i = n.carousel) || void 0 === i ? void 0 : i.plugins.Autoplay;
                    let s = e.isActive;
                    return o && "mousemove" === o.panMode && !s && o.reset(), void (s ? e.stop() : e.start());
                }
                const l = r.panzoomAction, c = r.panzoomChange;
                if ((c || l) && (t.preventDefault(), t.stopPropagation()), c) {
                    let t = {};
                    try {
                        t = JSON.parse(c);
                    } catch (t) {}
                    o && o.applyChange(t);
                } else l && o && o[l] && o[l]();
            }
            onChange() {
                this.onRefresh();
            }
            onRefresh() {
                if (this.instance.isClosing()) return;
                const t = this.container;
                if (!t) return;
                const e = this.instance.getSlide();
                if (!e || e.state !== it.Ready) return;
                const i = e && !e.error && e.panzoom;
                for (const e of t.querySelectorAll("[data-panzoom-action]")) i ? (e.removeAttribute("disabled"), 
                e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), e.setAttribute("tabindex", "-1"));
                let n = i && i.canZoomIn(), s = i && i.canZoomOut();
                for (const e of t.querySelectorAll('[data-panzoom-action="zoomIn"]')) n ? (e.removeAttribute("disabled"), 
                e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), e.setAttribute("tabindex", "-1"));
                for (const e of t.querySelectorAll('[data-panzoom-action="zoomOut"]')) s ? (e.removeAttribute("disabled"), 
                e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), e.setAttribute("tabindex", "-1"));
                for (const e of t.querySelectorAll('[data-panzoom-action="toggleZoom"],[data-panzoom-action="iterateZoom"]')) {
                    s || n ? (e.removeAttribute("disabled"), e.removeAttribute("tabindex")) : (e.setAttribute("disabled", ""), 
                    e.setAttribute("tabindex", "-1"));
                    const t = e.querySelector("g");
                    t && (t.style.display = n ? "" : "none");
                }
            }
            onDone(t, e) {
                var i;
                null === (i = e.panzoom) || void 0 === i || i.on("afterTransform", (() => {
                    this.instance.isCurrentSlide(e) && this.onRefresh();
                })), this.instance.isCurrentSlide(e) && this.onRefresh();
            }
            createContainer() {
                const t = this.instance.container;
                if (!t) return null;
                const e = this.option("parentEl") || t, i = document.createElement("div");
                return S(i, "fancybox__toolbar"), e.prepend(i), i.addEventListener("click", this.onClick, {
                    passive: !1,
                    capture: !0
                }), t && S(t, "has-toolbar"), this.container = i, i;
            }
            createEl(t) {
                const e = this.instance, i = e.carousel;
                if (!i) return null;
                if ("toggleFS" === t) return null;
                if ("fullscreen" === t && !e.fsAPI) return null;
                let s = null;
                const o = i.slides.length || 0;
                let a = 0, r = 0;
                for (const t of i.slides) (t.panzoom || "image" === t.type) && a++, ("image" === t.type || t.downloadSrc) && r++;
                if (o < 2 && [ "infobar", "prev", "next" ].includes(t)) return s;
                if (void 0 !== St[t] && !a) return null;
                if ("download" === t && !r) return null;
                if ("thumbs" === t) {
                    const t = e.plugins.Thumbs;
                    if (!t || !t.isEnabled) return null;
                }
                if ("slideshow" === t) if (!i.plugins.Autoplay || o < 2) return null;
                if (void 0 !== St[t]) {
                    const e = St[t];
                    s = document.createElement("button"), s.setAttribute("title", this.instance.localize(`{{${t.toUpperCase()}}}`)), 
                    S(s, "f-button"), e.action && (s.dataset.panzoomAction = e.action), e.change && (s.dataset.panzoomChange = JSON.stringify(e.change)), 
                    s.appendChild(n(this.instance.localize(e.icon)));
                } else {
                    const e = (this.option("items") || [])[t];
                    e && (s = n(this.instance.localize(e.tpl)), "function" == typeof e.click && s.addEventListener("click", (t => {
                        t.preventDefault(), t.stopPropagation(), "function" == typeof e.click && e.click.call(this, this, t);
                    })));
                }
                const l = null == s ? void 0 : s.querySelector("svg");
                if (l) for (const [t, e] of Object.entries(Mt)) l.getAttribute(t) || l.setAttribute(t, String(e));
                return s;
            }
            removeContainer() {
                const t = this.container;
                t && t.remove(), this.container = null, this.state = Pt.Disabled;
                const e = this.instance.container;
                e && E(e, "has-toolbar");
            }
            attach() {
                const t = this, e = t.instance;
                e.on("Carousel.initSlides", t.onReady), e.on("done", t.onDone), e.on("reveal", t.onChange), 
                e.on("Carousel.change", t.onChange), t.onReady(t.instance);
            }
            detach() {
                const t = this, e = t.instance;
                e.off("Carousel.initSlides", t.onReady), e.off("done", t.onDone), e.off("reveal", t.onChange), 
                e.off("Carousel.change", t.onChange), t.removeContainer();
            }
        }
        Object.defineProperty(Tt, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: Ct
        });
        const Ot = {
            Hash: st,
            Html: ht,
            Images: at,
            Slideshow: mt,
            Thumbs: Et,
            Toolbar: Tt
        }, At = "with-fancybox", zt = "hide-scrollbar", Lt = "--fancybox-scrollbar-compensate", Rt = "--fancybox-body-margin", kt = "is-animated", It = "is-compact", Dt = "is-loading", Ft = function() {
            var t = window.getSelection();
            return t && "Range" === t.type;
        };
        let jt = null, Ht = null;
        const Bt = new Map;
        let Nt = 0;
        class _t extends m {
            get isIdle() {
                return this.idle;
            }
            get isCompact() {
                return this.option("compact");
            }
            constructor(t = [], e = {}, i = {}) {
                super(e), Object.defineProperty(this, "userSlides", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: []
                }), Object.defineProperty(this, "userPlugins", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: {}
                }), Object.defineProperty(this, "idle", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "idleTimer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "clickTimer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "pwt", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "ignoreFocusChange", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: !1
                }), Object.defineProperty(this, "state", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: et.Init
                }), Object.defineProperty(this, "id", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: 0
                }), Object.defineProperty(this, "container", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "footer", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "caption", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "carousel", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "lastFocus", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: null
                }), Object.defineProperty(this, "prevMouseMoveEvent", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), Object.defineProperty(this, "fsAPI", {
                    enumerable: !0,
                    configurable: !0,
                    writable: !0,
                    value: void 0
                }), this.fsAPI = (() => {
                    let t, e = "", i = "", n = "";
                    return document.fullscreenEnabled ? (e = "requestFullscreen", i = "exitFullscreen", 
                    n = "fullscreenElement") : document.webkitFullscreenEnabled && (e = "webkitRequestFullscreen", 
                    i = "webkitExitFullscreen", n = "webkitFullscreenElement"), e && (t = {
                        request: function(t) {
                            return "webkitRequestFullscreen" === e ? t[e](Element.ALLOW_KEYBOARD_INPUT) : t[e]();
                        },
                        exit: function() {
                            return document[n] && document[i]();
                        },
                        isFullscreen: function() {
                            return document[n];
                        }
                    }), t;
                })(), this.id = e.id || ++Nt, Bt.set(this.id, this), this.userSlides = t, this.userPlugins = i, 
                queueMicrotask((() => {
                    this.init();
                }));
            }
            init() {
                if (this.state === et.Destroy) return;
                this.state = et.Init, this.attachPlugins(Object.assign(Object.assign({}, _t.Plugins), this.userPlugins)), 
                this.emit("init"), !0 === this.option("hideScrollbar") && (() => {
                    if (!G) return;
                    const t = document.body;
                    if (t.classList.contains(zt)) return;
                    let e = window.innerWidth - document.documentElement.getBoundingClientRect().width;
                    e < 0 && (e = 0);
                    const i = t.currentStyle || window.getComputedStyle(t), n = parseFloat(i.marginRight);
                    document.documentElement.style.setProperty(Lt, `${e}px`), n && t.style.setProperty(Rt, `${n}px`), 
                    t.classList.add(zt);
                })(), this.initLayout(), this.scale();
                const t = () => {
                    this.initCarousel(this.userSlides), this.state = et.Ready, this.attachEvents(), 
                    this.emit("ready"), setTimeout((() => {
                        this.container && this.container.setAttribute("aria-hidden", "false");
                    }), 16);
                }, e = this.fsAPI;
                this.option("Fullscreen.autoStart") && e && !e.isFullscreen() ? e.request(this.container).then((() => t())).catch((() => t())) : t();
            }
            initLayout() {
                var t, e;
                const i = this.option("parentEl") || document.body, s = n(this.localize(this.option("tpl.main") || ""));
                s && (s.setAttribute("id", `fancybox-${this.id}`), s.setAttribute("aria-label", this.localize("{{MODAL}}")), 
                s.classList.toggle(It, this.isCompact), S(s, this.option("mainClass") || ""), this.container = s, 
                this.footer = s.querySelector(".fancybox__footer"), i.appendChild(s), S(document.documentElement, At), 
                jt && Ht || (jt = document.createElement("span"), S(jt, "fancybox-focus-guard"), 
                jt.setAttribute("tabindex", "0"), jt.setAttribute("aria-hidden", "true"), jt.setAttribute("aria-label", "Focus guard"), 
                Ht = jt.cloneNode(), null === (t = s.parentElement) || void 0 === t || t.insertBefore(jt, s), 
                null === (e = s.parentElement) || void 0 === e || e.append(Ht)), this.option("animated") && (S(s, kt), 
                setTimeout((() => {
                    this.isClosing() || E(s, kt);
                }), 350)), this.emit("initLayout"));
            }
            initCarousel(t) {
                const i = this.container;
                if (!i) return;
                const n = i.querySelector(".fancybox__carousel");
                if (!n) return;
                const s = this.carousel = new Z(n, u({}, {
                    slides: t,
                    transition: "fade",
                    Panzoom: {
                        lockAxis: this.option("dragToClose") ? "xy" : "x",
                        infinite: !!this.option("dragToClose") && "y"
                    },
                    Dots: !1,
                    Navigation: {
                        classes: {
                            container: "fancybox__nav",
                            button: "f-button",
                            isNext: "is-next",
                            isPrev: "is-prev"
                        }
                    },
                    initialPage: this.option("startIndex"),
                    l10n: this.option("l10n")
                }, this.option("Carousel") || {}));
                s.on("*", ((t, e, ...i) => {
                    this.emit(`Carousel.${e}`, t, ...i);
                })), s.on([ "ready", "change" ], (() => {
                    var t;
                    const e = this.getSlide();
                    e && (null === (t = e.panzoom) || void 0 === t || t.updateControls()), this.manageCaption(e);
                })), this.on("Carousel.removeSlide", ((t, e, i) => {
                    i.contentEl && (i.contentEl.remove(), i.contentEl = void 0);
                    const n = i.el;
                    n && (E(n, "has-error"), E(n, "has-unknown"), E(n, `has-${i.type || "unknown"}`)), 
                    i.closeBtnEl && i.closeBtnEl.remove(), i.closeBtnEl = void 0, i.captionEl && i.captionEl.remove(), 
                    i.captionEl = void 0, i.spinnerEl && i.spinnerEl.remove(), i.spinnerEl = void 0, 
                    i.state = void 0;
                })), s.on("Panzoom.touchStart", (() => {
                    this.isCompact || this.endIdle();
                })), s.on("settle", (() => {
                    this.idleTimer || this.isCompact || !this.option("idle") || this.setIdle(), this.option("autoFocus") && this.checkFocus();
                })), this.option("dragToClose") && (s.on("Panzoom.afterTransform", ((t, i) => {
                    const n = this.getSlide();
                    if (n && e(n.el)) return;
                    const s = this.container;
                    if (s) {
                        const t = Math.abs(i.current.f), e = t < 1 ? "" : Math.max(.5, Math.min(1, 1 - t / i.contentRect.fitHeight * 1.5));
                        s.style.setProperty("--fancybox-ts", e ? "0s" : ""), s.style.setProperty("--fancybox-opacity", e + "");
                    }
                })), s.on("Panzoom.touchEnd", ((t, i, n) => {
                    var s;
                    const o = this.getSlide();
                    if (o && e(o.el)) return;
                    if (i.isMobile && document.activeElement && -1 !== [ "TEXTAREA", "INPUT" ].indexOf(null === (s = document.activeElement) || void 0 === s ? void 0 : s.nodeName)) return;
                    const a = Math.abs(i.dragOffset.y);
                    "y" === i.lockedAxis && (a >= 200 || a >= 50 && i.dragOffset.time < 300) && (n && n.cancelable && n.preventDefault(), 
                    this.close(n, "f-throwOut" + (i.current.f < 0 ? "Up" : "Down")));
                }))), s.on("change", (t => {
                    var e;
                    let i = null === (e = this.getSlide()) || void 0 === e ? void 0 : e.triggerEl;
                    if (i) {
                        const e = new CustomEvent("slideTo", {
                            bubbles: !0,
                            cancelable: !0,
                            detail: t.page
                        });
                        i.dispatchEvent(e);
                    }
                })), s.on([ "refresh", "change" ], (t => {
                    const e = this.container;
                    if (!e) return;
                    for (const i of e.querySelectorAll("[data-fancybox-current-index]")) i.innerHTML = t.page + 1;
                    for (const i of e.querySelectorAll("[data-fancybox-count]")) i.innerHTML = t.pages.length;
                    if (!t.isInfinite) {
                        for (const i of e.querySelectorAll("[data-fancybox-next]")) t.page < t.pages.length - 1 ? (i.removeAttribute("disabled"), 
                        i.removeAttribute("tabindex")) : (i.setAttribute("disabled", ""), i.setAttribute("tabindex", "-1"));
                        for (const i of e.querySelectorAll("[data-fancybox-prev]")) t.page > 0 ? (i.removeAttribute("disabled"), 
                        i.removeAttribute("tabindex")) : (i.setAttribute("disabled", ""), i.setAttribute("tabindex", "-1"));
                    }
                    const i = this.getSlide();
                    if (!i) return;
                    let n = i.downloadSrc || "";
                    n || "image" !== i.type || i.error || "string" != typeof i.src || (n = i.src);
                    const s = "disabled", o = "tabindex", a = "download", r = "href";
                    for (const t of e.querySelectorAll("[data-fancybox-download]")) {
                        const e = i.downloadFilename;
                        n ? (t.removeAttribute(s), t.removeAttribute(o), t.setAttribute(r, n), t.setAttribute(a, e || n), 
                        t.setAttribute("target", "_blank")) : (t.setAttribute(s, ""), t.setAttribute(o, "-1"), 
                        t.removeAttribute(r), t.removeAttribute(a));
                    }
                })), this.emit("initCarousel");
            }
            attachEvents() {
                const t = this, e = t.container;
                if (!e) return;
                e.addEventListener("click", t.onClick, {
                    passive: !1,
                    capture: !1
                }), e.addEventListener("wheel", t.onWheel, {
                    passive: !1,
                    capture: !1
                }), document.addEventListener("keydown", t.onKeydown, {
                    passive: !1,
                    capture: !0
                }), document.addEventListener("visibilitychange", t.onVisibilityChange, !1), document.addEventListener("mousemove", t.onMousemove), 
                t.option("trapFocus") && document.addEventListener("focus", t.onFocus, !0), window.addEventListener("resize", t.onResize);
                const i = window.visualViewport;
                i && (i.addEventListener("scroll", t.onResize), i.addEventListener("resize", t.onResize));
            }
            detachEvents() {
                const t = this, e = t.container;
                if (!e) return;
                document.removeEventListener("keydown", t.onKeydown, {
                    passive: !1,
                    capture: !0
                }), e.removeEventListener("wheel", t.onWheel, {
                    passive: !1,
                    capture: !1
                }), e.removeEventListener("click", t.onClick, {
                    passive: !1,
                    capture: !1
                }), document.removeEventListener("mousemove", t.onMousemove), window.removeEventListener("resize", t.onResize);
                const i = window.visualViewport;
                i && (i.removeEventListener("resize", t.onResize), i.removeEventListener("scroll", t.onResize)), 
                document.removeEventListener("visibilitychange", t.onVisibilityChange, !1), document.removeEventListener("focus", t.onFocus, !0);
            }
            scale() {
                const t = this.container;
                if (!t) return;
                const e = window.visualViewport, i = Math.max(1, (null == e ? void 0 : e.scale) || 1);
                let n = "", s = "", o = "";
                if (e && i > 1) {
                    let t = `${e.offsetLeft}px`, a = `${e.offsetTop}px`;
                    n = e.width * i + "px", s = e.height * i + "px", o = `translate3d(${t}, ${a}, 0) scale(${1 / i})`;
                }
                t.style.transform = o, t.style.width = n, t.style.height = s;
            }
            onClick(t) {
                var e, i;
                const {container: n, isCompact: s} = this;
                if (!n || this.isClosing()) return;
                !s && this.option("idle") && this.resetIdle();
                const o = document.activeElement;
                if (Ft() && o && n.contains(o)) return;
                const a = t.composedPath()[0];
                if (a === (null === (e = this.carousel) || void 0 === e ? void 0 : e.container)) return;
                if (a.closest(".f-spinner") || a.closest("[data-fancybox-close]")) return t.preventDefault(), 
                void this.close(t);
                if (a.closest("[data-fancybox-prev]")) return t.preventDefault(), void this.prev();
                if (a.closest("[data-fancybox-next]")) return t.preventDefault(), void this.next();
                if (s && "image" === (null === (i = this.getSlide()) || void 0 === i ? void 0 : i.type)) return void (this.clickTimer ? (clearTimeout(this.clickTimer), 
                this.clickTimer = null) : this.clickTimer = setTimeout((() => {
                    this.toggleIdle(), this.clickTimer = null;
                }), 350));
                if (this.emit("click", t), t.defaultPrevented) return;
                let r = !1;
                if (a.closest(".fancybox__content")) {
                    if (o) {
                        if (o.closest("[contenteditable]")) return;
                        a.matches(J) || o.blur();
                    }
                    if (Ft()) return;
                    r = this.option("contentClick");
                } else a.closest(".fancybox__carousel") && !a.matches(J) && (r = this.option("backdropClick"));
                "close" === r ? (t.preventDefault(), this.close(t)) : "next" === r ? (t.preventDefault(), 
                this.next()) : "prev" === r && (t.preventDefault(), this.prev());
            }
            onWheel(t) {
                var e;
                let i = this.option("wheel", t);
                (null === (e = t.target) || void 0 === e ? void 0 : e.closest(".fancybox__thumbs")) && (i = "slide");
                const n = "slide" === i, s = [ -t.deltaX || 0, -t.deltaY || 0, -t.detail || 0 ].reduce((function(t, e) {
                    return Math.abs(e) > Math.abs(t) ? e : t;
                })), o = Math.max(-1, Math.min(1, s)), a = Date.now();
                this.pwt && a - this.pwt < 300 ? n && t.preventDefault() : (this.pwt = a, this.emit("wheel", t), 
                t.defaultPrevented || ("close" === i ? (t.preventDefault(), this.close(t)) : "slide" === i && (t.preventDefault(), 
                this[o > 0 ? "prev" : "next"]())));
            }
            onKeydown(t) {
                if (!this.isTopmost()) return;
                this.isCompact || !this.option("idle") || this.isClosing() || this.resetIdle();
                const e = t.key, i = this.option("keyboard");
                if (!i || t.ctrlKey || t.altKey || t.shiftKey) return;
                const n = t.composedPath()[0], s = document.activeElement && document.activeElement.classList, o = s && s.contains("f-button") || n.dataset.carouselPage || n.dataset.carouselIndex;
                if ("Escape" !== e && !o && x(n)) if (n.isContentEditable || -1 !== [ "TEXTAREA", "OPTION", "INPUT", "SELECT", "VIDEO" ].indexOf(n.nodeName)) return;
                this.emit("keydown", e, t);
                const a = i[e];
                "function" == typeof this[a] && (t.preventDefault(), this[a]());
            }
            onResize() {
                const t = It, e = this.container;
                if (!e) return;
                const i = this.isCompact;
                e.classList.toggle(t, i), this.manageCaption(this.getSlide()), this.isCompact ? this.clearIdle() : this.endIdle(), 
                this.scale(), this.emit("resize");
            }
            onFocus(t) {
                this.isTopmost() && this.checkFocus(t);
            }
            onMousemove(t) {
                this.prevMouseMoveEvent = t, !this.isCompact && this.option("idle") && this.resetIdle();
            }
            onVisibilityChange() {
                "visible" === document.visibilityState ? this.checkFocus() : this.endIdle();
            }
            manageCloseBtn(t) {
                const e = this.optionFor(t, "closeButton") || !1;
                if ("auto" === e) {
                    const t = this.plugins.Toolbar;
                    if (t && t.state === Pt.Ready) return;
                }
                if (!e) return;
                if (!t.contentEl || t.closeBtnEl) return;
                const i = this.option("tpl.closeButton");
                if (i) {
                    const e = n(this.localize(i));
                    t.closeBtnEl = t.contentEl.appendChild(e), t.el && S(t.el, "has-close-btn");
                }
            }
            manageCaption(t = void 0) {
                var e, i;
                const n = "fancybox__caption", s = "has-caption", o = this.container;
                if (!o) return;
                const a = this.isCompact || this.option("commonCaption"), r = !a;
                if (this.caption && this.stop(this.caption), r && this.caption && (this.caption.remove(), 
                this.caption = null), a && !this.caption) for (const t of (null === (e = this.carousel) || void 0 === e ? void 0 : e.slides) || []) t.captionEl && (t.captionEl.remove(), 
                t.captionEl = void 0, E(t.el, s), null === (i = t.el) || void 0 === i || i.removeAttribute("aria-labelledby"));
                if (t || (t = this.getSlide()), !t || a && !this.isCurrentSlide(t)) return;
                const l = t.el;
                let c = this.optionFor(t, "caption", "");
                if ("string" != typeof c || !c.length) return void (a && this.caption && this.animate(this.caption, "f-fadeOut", (() => {
                    this.caption && (this.caption.innerHTML = "");
                })));
                let h = null;
                if (r) {
                    if (h = t.captionEl || null, l && !h) {
                        const e = n + `_${this.id}_${t.index}`;
                        h = document.createElement("div"), S(h, n), h.setAttribute("id", e), t.captionEl = l.appendChild(h), 
                        S(l, s), l.setAttribute("aria-labelledby", e);
                    }
                } else {
                    if (h = this.caption, h || (h = o.querySelector("." + n)), !h) {
                        h = document.createElement("div"), h.dataset.fancyboxCaption = "", S(h, n), h.innerHTML = c;
                        (this.footer || o).prepend(h);
                    }
                    S(o, s), this.caption = h;
                }
                h && (h.innerHTML = c);
            }
            checkFocus(t) {
                var e;
                const i = document.activeElement || null;
                i && (null === (e = this.container) || void 0 === e ? void 0 : e.contains(i)) || this.focus(t);
            }
            focus(t) {
                var e;
                if (this.ignoreFocusChange) return;
                const i = document.activeElement || null, n = (null == t ? void 0 : t.target) || null, s = this.container, o = this.getSlide();
                if (!s || !(null === (e = this.carousel) || void 0 === e ? void 0 : e.viewport)) return;
                if (!t && i && s.contains(i)) return;
                const a = o && o.state === it.Ready ? o.el : null;
                if (!a || a.contains(i) || s === i) return;
                t && t.cancelable && t.preventDefault(), this.ignoreFocusChange = !0;
                const r = Array.from(s.querySelectorAll(J));
                let l = [], c = null;
                for (let t of r) {
                    const e = !t.offsetParent || t.closest('[aria-hidden="true"]'), i = a && a.contains(t), n = !this.carousel.viewport.contains(t);
                    if (t === s || (i || n) && !e) {
                        l.push(t);
                        const e = t.dataset.origTabindex;
                        void 0 !== e && e && (t.tabIndex = parseFloat(e)), t.removeAttribute("data-orig-tabindex"), 
                        !t.hasAttribute("autoFocus") && c || (c = t);
                    } else {
                        const e = void 0 === t.dataset.origTabindex ? t.getAttribute("tabindex") || "" : t.dataset.origTabindex;
                        e && (t.dataset.origTabindex = e), t.tabIndex = -1;
                    }
                }
                let h = null;
                t ? (!n || l.indexOf(n) < 0) && (h = c || s, l.length && (i === Ht ? h = l[0] : this.lastFocus !== s && i !== jt || (h = l[l.length - 1]))) : h = o && "image" === o.type ? s : c || s, 
                h && Q(h), this.lastFocus = document.activeElement, this.ignoreFocusChange = !1;
            }
            next() {
                const t = this.carousel;
                t && t.pages.length > 1 && t.slideNext();
            }
            prev() {
                const t = this.carousel;
                t && t.pages.length > 1 && t.slidePrev();
            }
            jumpTo(...t) {
                this.carousel && this.carousel.slideTo(...t);
            }
            isTopmost() {
                var t;
                return (null === (t = _t.getInstance()) || void 0 === t ? void 0 : t.id) == this.id;
            }
            animate(t = null, e = "", i) {
                if (!t || !e) return void (i && i());
                this.stop(t);
                const n = s => {
                    s.target === t && t.dataset.animationName && (t.removeEventListener("animationend", n), 
                    delete t.dataset.animationName, i && i(), E(t, e));
                };
                t.dataset.animationName = e, t.addEventListener("animationend", n), S(t, e);
            }
            stop(t) {
                t && t.dispatchEvent(new CustomEvent("animationend", {
                    bubbles: !1,
                    cancelable: !0,
                    currentTarget: t
                }));
            }
            setContent(t, e = "", i = !0) {
                if (this.isClosing()) return;
                const s = t.el;
                if (!s) return;
                let o = null;
                if (x(e) ? o = e : (o = n(e + ""), x(o) || (o = document.createElement("div"), o.innerHTML = e + "")), 
                [ "img", "picture", "iframe", "video", "audio" ].includes(o.nodeName.toLowerCase())) {
                    const t = document.createElement("div");
                    t.appendChild(o), o = t;
                }
                x(o) && t.filter && !t.error && (o = o.querySelector(t.filter)), o && x(o) ? (S(o, "fancybox__content"), 
                t.id && o.setAttribute("id", t.id), "none" !== o.style.display && "none" !== getComputedStyle(o).getPropertyValue("display") || (o.style.display = t.display || this.option("defaultDisplay") || "flex"), 
                s.classList.add(`has-${t.error ? "error" : t.type || "unknown"}`), s.prepend(o), 
                t.contentEl = o, i && this.revealContent(t), this.manageCloseBtn(t), this.manageCaption(t)) : this.setError(t, "{{ELEMENT_NOT_FOUND}}");
            }
            revealContent(t, e) {
                const i = t.el, n = t.contentEl;
                i && n && (this.emit("reveal", t), this.hideLoading(t), t.state = it.Opening, (e = this.isOpeningSlide(t) ? void 0 === e ? this.optionFor(t, "showClass") : e : "f-fadeIn") ? this.animate(n, e, (() => {
                    this.done(t);
                })) : this.done(t));
            }
            done(t) {
                this.isClosing() || (t.state = it.Ready, this.emit("done", t), S(t.el, "is-done"), 
                this.isCurrentSlide(t) && this.option("autoFocus") && queueMicrotask((() => {
                    this.option("autoFocus") && (this.option("autoFocus") ? this.focus() : this.checkFocus());
                })), this.isOpeningSlide(t) && !this.isCompact && this.option("idle") && this.setIdle());
            }
            isCurrentSlide(t) {
                const e = this.getSlide();
                return !(!t || !e) && e.index === t.index;
            }
            isOpeningSlide(t) {
                var e, i;
                return null === (null === (e = this.carousel) || void 0 === e ? void 0 : e.prevPage) && t.index === (null === (i = this.getSlide()) || void 0 === i ? void 0 : i.index);
            }
            showLoading(t) {
                t.state = it.Loading;
                const e = t.el;
                if (!e) return;
                S(e, Dt), this.emit("loading", t), t.spinnerEl || setTimeout((() => {
                    if (!this.isClosing() && !t.spinnerEl && t.state === it.Loading) {
                        let i = n(w);
                        t.spinnerEl = i, e.prepend(i), this.animate(i, "f-fadeIn");
                    }
                }), 250);
            }
            hideLoading(t) {
                const e = t.el;
                if (!e) return;
                const i = t.spinnerEl;
                this.isClosing() ? null == i || i.remove() : (E(e, Dt), i && this.animate(i, "f-fadeOut", (() => {
                    i.remove();
                })), t.state === it.Loading && (this.emit("loaded", t), t.state = it.Ready));
            }
            setError(t, e) {
                if (this.isClosing()) return;
                const i = new Event("error", {
                    bubbles: !0,
                    cancelable: !0
                });
                if (this.emit("error", i, t), i.defaultPrevented) return;
                t.error = e, this.hideLoading(t), this.clearContent(t);
                const n = document.createElement("div");
                n.classList.add("fancybox-error"), n.innerHTML = this.localize(e || "<p>{{ERROR}}</p>"), 
                this.setContent(t, n);
            }
            clearContent(t) {
                var e;
                null === (e = this.carousel) || void 0 === e || e.emit("removeSlide", t);
            }
            getSlide() {
                var t;
                const e = this.carousel;
                return (null === (t = null == e ? void 0 : e.pages[null == e ? void 0 : e.page]) || void 0 === t ? void 0 : t.slides[0]) || void 0;
            }
            close(t, e) {
                if (this.isClosing()) return;
                const i = new Event("shouldClose", {
                    bubbles: !0,
                    cancelable: !0
                });
                if (this.emit("shouldClose", i, t), i.defaultPrevented) return;
                t && t.cancelable && (t.preventDefault(), t.stopPropagation());
                const n = this.fsAPI, s = () => {
                    this.proceedClose(t, e);
                };
                n && n.isFullscreen() ? Promise.resolve(n.exit()).then((() => s())) : s();
            }
            clearIdle() {
                this.idleTimer && clearTimeout(this.idleTimer), this.idleTimer = null;
            }
            setIdle(t = !1) {
                const e = () => {
                    this.clearIdle(), this.idle = !0, S(this.container, "is-idle"), this.emit("setIdle");
                };
                if (this.clearIdle(), !this.isClosing()) if (t) e(); else {
                    const t = this.option("idle");
                    t && (this.idleTimer = setTimeout(e, t));
                }
            }
            endIdle() {
                this.clearIdle(), this.idle && !this.isClosing() && (this.idle = !1, E(this.container, "is-idle"), 
                this.emit("endIdle"));
            }
            resetIdle() {
                this.endIdle(), this.setIdle();
            }
            toggleIdle() {
                this.idle ? this.endIdle() : this.setIdle(!0);
            }
            toggleFullscreen() {
                const t = this.fsAPI;
                t && (t.isFullscreen() ? t.exit() : this.container && t.request(this.container));
            }
            isClosing() {
                return [ et.Closing, et.CustomClosing, et.Destroy ].includes(this.state);
            }
            proceedClose(t, e) {
                var i, n;
                this.state = et.Closing, this.clearIdle(), this.detachEvents();
                const s = this.container, o = this.carousel, a = this.getSlide(), r = a && this.option("placeFocusBack") ? a.triggerEl || this.option("triggerEl") : null;
                if (r && (U(r) ? Q(r) : r.focus()), s && (S(s, "is-closing"), s.setAttribute("aria-hidden", "true"), 
                this.option("animated") && S(s, kt), s.style.pointerEvents = "none"), o) {
                    o.clearTransitions(), null === (i = o.panzoom) || void 0 === i || i.destroy(), null === (n = o.plugins.Navigation) || void 0 === n || n.detach();
                    for (const t of o.slides) {
                        t.state = it.Closing, this.hideLoading(t);
                        const e = t.contentEl;
                        e && this.stop(e);
                        const i = null == t ? void 0 : t.panzoom;
                        i && (i.stop(), i.detachEvents(), i.detachObserver()), this.isCurrentSlide(t) || o.emit("removeSlide", t);
                    }
                }
                this.emit("close", t), this.state !== et.CustomClosing ? (void 0 === e && a && (e = this.optionFor(a, "hideClass")), 
                e && a ? (this.animate(a.contentEl, e, (() => {
                    o && o.emit("removeSlide", a);
                })), setTimeout((() => {
                    this.destroy();
                }), 500)) : this.destroy()) : setTimeout((() => {
                    this.destroy();
                }), 500);
            }
            destroy() {
                var t;
                if (this.state === et.Destroy) return;
                this.state = et.Destroy, null === (t = this.carousel) || void 0 === t || t.destroy();
                const e = this.container;
                e && e.remove(), Bt.delete(this.id);
                const i = _t.getInstance();
                i ? i.focus() : (jt && (jt.remove(), jt = null), Ht && (Ht.remove(), Ht = null), 
                E(document.documentElement, At), (() => {
                    if (!G) return;
                    const t = document, e = t.body;
                    e.classList.remove(zt), e.style.setProperty(Rt, ""), t.documentElement.style.setProperty(Lt, "");
                })(), this.emit("destroy"));
            }
            static bind(t, e, i) {
                if (!G) return;
                let n, s = "", o = {};
                if (void 0 === t ? n = document.body : "string" == typeof t ? (n = document.body, 
                s = t, "object" == typeof e && (o = e || {})) : (n = t, "string" == typeof e && (s = e), 
                "object" == typeof i && (o = i || {})), !n || !x(n)) return;
                s = s || "[data-fancybox]";
                const a = _t.openers.get(n) || new Map;
                a.set(s, o), _t.openers.set(n, a), 1 === a.size && n.addEventListener("click", _t.fromEvent);
            }
            static unbind(t, e) {
                let i, n = "";
                if ("string" == typeof t ? (i = document.body, n = t) : (i = t, "string" == typeof e && (n = e)), 
                !i) return;
                const s = _t.openers.get(i);
                s && n && s.delete(n), n && s || (_t.openers.delete(i), i.removeEventListener("click", _t.fromEvent));
            }
            static destroy() {
                let t;
                for (;t = _t.getInstance(); ) t.destroy();
                for (const t of _t.openers.keys()) t.removeEventListener("click", _t.fromEvent);
                _t.openers = new Map;
            }
            static fromEvent(t) {
                if (t.defaultPrevented) return;
                if (t.button && 0 !== t.button) return;
                if (t.ctrlKey || t.metaKey || t.shiftKey) return;
                let e = t.composedPath()[0];
                const i = e.closest("[data-fancybox-trigger]");
                if (i) {
                    const t = i.dataset.fancyboxTrigger || "", n = document.querySelectorAll(`[data-fancybox="${t}"]`), s = parseInt(i.dataset.fancyboxIndex || "", 10) || 0;
                    e = n[s] || e;
                }
                if (!(e && e instanceof Element)) return;
                let n, s, o, a;
                if ([ ..._t.openers ].reverse().find((([t, i]) => !(!t.contains(e) || ![ ...i ].reverse().find((([i, r]) => {
                    let l = e.closest(i);
                    return !!l && (n = t, s = i, o = l, a = r, !0);
                }))))), !n || !s || !o) return;
                a = a || {}, t.preventDefault(), e = o;
                let r = [], l = u({}, tt, a);
                l.event = t, l.triggerEl = e, l.delegate = i;
                const c = l.groupAll, h = l.groupAttr, d = h && e ? e.getAttribute(`${h}`) : "";
                if ((!e || d || c) && (r = [].slice.call(n.querySelectorAll(s))), e && !c && (r = d ? r.filter((t => t.getAttribute(`${h}`) === d)) : [ e ]), 
                !r.length) return;
                const p = _t.getInstance();
                return p && p.options.triggerEl && r.indexOf(p.options.triggerEl) > -1 ? void 0 : (e && (l.startIndex = r.indexOf(e)), 
                _t.fromNodes(r, l));
            }
            static fromSelector(t, e) {
                let i = null, n = "";
                if ("string" == typeof t ? (i = document.body, n = t) : t instanceof HTMLElement && "string" == typeof e && (i = t, 
                n = e), !i || !n) return !1;
                const s = _t.openers.get(i);
                if (!s) return !1;
                const o = s.get(n);
                return !!o && _t.fromNodes(Array.from(i.querySelectorAll(n)), o);
            }
            static fromNodes(t, e) {
                e = u({}, tt, e || {});
                const i = [];
                for (const n of t) {
                    const t = n.dataset || {}, s = t.src || n.getAttribute("href") || n.getAttribute("currentSrc") || n.getAttribute("src") || void 0;
                    let o;
                    const a = e.delegate;
                    let r;
                    a && i.length === e.startIndex && (o = a instanceof HTMLImageElement ? a : a.querySelector("img:not([aria-hidden])")), 
                    o || (o = n instanceof HTMLImageElement ? n : n.querySelector("img:not([aria-hidden])")), 
                    o && (r = o.currentSrc || o.src || void 0, !r && o.dataset && (r = o.dataset.lazySrc || o.dataset.src || void 0));
                    const l = {
                        src: s,
                        triggerEl: n,
                        thumbEl: o,
                        thumbElSrc: r,
                        thumbSrc: r
                    };
                    for (const e in t) l[e] = t[e] + "";
                    i.push(l);
                }
                return new _t(i, e);
            }
            static getInstance(t) {
                if (t) return Bt.get(t);
                return Array.from(Bt.values()).reverse().find((t => !t.isClosing() && t)) || null;
            }
            static getSlide() {
                var t;
                return (null === (t = _t.getInstance()) || void 0 === t ? void 0 : t.getSlide()) || null;
            }
            static show(t = [], e = {}) {
                return new _t(t, e);
            }
            static next() {
                const t = _t.getInstance();
                t && t.next();
            }
            static prev() {
                const t = _t.getInstance();
                t && t.prev();
            }
            static close(t = !0, ...e) {
                if (t) for (const t of Bt.values()) t.close(...e); else {
                    const t = _t.getInstance();
                    t && t.close(...e);
                }
            }
        }
        Object.defineProperty(_t, "version", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: "5.0.20"
        }), Object.defineProperty(_t, "defaults", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: tt
        }), Object.defineProperty(_t, "Plugins", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: Ot
        }), Object.defineProperty(_t, "openers", {
            enumerable: !0,
            configurable: !0,
            writable: !0,
            value: new Map
        });
        _t.bind("[data-fancybox]", {});
        let headerBody = document.querySelector(".body-header__body");
        let container = document.querySelector('[class*="__container"]');
        let maxWidth = Number.parseInt(window.getComputedStyle(container).maxWidth) - 30;
        let menuItems = headerBody.querySelectorAll(".menu__item");
        let menuItemsRevers = Array.from(menuItems).reverse();
        let menuItemsWidthReverse = Array.from(menuItems).map((item => item.offsetWidth)).reverse();
        let accumulator = 30;
        let offset = 160;
        menuItemsRevers.forEach(((elem, index) => {
            elem.dataset.da = `.more-menu__list, ${maxWidth - accumulator + offset}, first`;
            accumulator += menuItemsWidthReverse[index] + 20;
        }));
        let dataJson = {
            config: {
                user_sklad_price: [ {
                    bol: 0,
                    men: 3,
                    sum: 500
                }, {
                    bol: 4,
                    men: 10,
                    sum: 350
                }, {
                    bol: 11,
                    men: 20,
                    sum: 250
                }, {
                    bol: 21,
                    men: 50,
                    sum: 150
                }, {
                    bol: 51,
                    men: 100,
                    sum: 100
                }, {
                    bol: 101,
                    men: 300,
                    sum: 66
                }, {
                    bol: 301,
                    men: 600,
                    sum: 50
                }, {
                    bol: 601,
                    men: 1e3,
                    sum: 45
                } ],
                market_price: [ {
                    bol: 0,
                    men: 0,
                    sum: 0
                }, {
                    bol: 1,
                    men: 100,
                    sum: 50
                }, {
                    bol: 101,
                    men: 500,
                    sum: 25
                }, {
                    bol: 501,
                    men: 1e3,
                    sum: 20
                }, {
                    bol: 1001,
                    men: 3e3,
                    sum: 14
                }, {
                    bol: 3001,
                    men: 5e3,
                    sum: 10
                }, {
                    bol: 5001,
                    men: 1e4,
                    sum: 7
                }, {
                    bol: 10001,
                    men: 2e4,
                    sum: 6
                }, {
                    bol: 20001,
                    men: 1e5,
                    sum: 2
                } ]
            }
        };
        renderJson(dataJson);
        ratesDynamicAdaptive();
        window.addEventListener("resize", (e => {
            setTimeout(moreMenyHeaderCheck, 10);
            if (document.querySelector("html").classList.contains("menu-open") && e.target.outerWidth > 767.98) document.querySelector(".menu__icon").click();
        }));
        sessionCookiesStart();
        async function sessionCookiesStart() {
            let response = await fetch("session.php");
            if (response.ok) {
                let responseJson = await response.json();
                if (responseJson.cookies === true) document.querySelector(".cookie-agreement").classList.add("_accepted");
            } else throw new Error("connection denied");
        }
        window.addEventListener("load", (e => {
            let phoneInputs = document.querySelectorAll("._input-phone-mask");
            if (phoneInputs.length) {
                let maskOptions = {
                    mask: "+7(000)000-00-00",
                    lazy: false
                };
                phoneInputs.forEach((input => {
                    let mask = new IMask(input, maskOptions);
                    input.closest("form").addEventListener("reset", (e => {
                        mask.destroy();
                    }));
                }));
            }
            moreMenyHeaderCheck();
            let passEyeButtons = document.querySelectorAll('[class*="-viewpass"]');
            if (passEyeButtons) passEyeButtons.forEach((button => {
                button.closest("form").classList.add("_pass-hidden");
            }));
            document.addEventListener("click", (el => {
                const targetElement = el.target;
                if (targetElement.closest(".cookie-agreement__button")) {
                    e.preventDefault();
                    document.querySelector(".cookie-agreement").classList.add("_accepted");
                }
                if (targetElement.closest(".cookie-agreement__button")) {
                    el.preventDefault();
                    try {
                        sessionCookiesAccept();
                    } catch (e) {
                        console.log(e.message);
                    }
                }
                if (targetElement.closest('[class*="-viewpass"]')) {
                    let buttonEye = targetElement.closest('[class*="-viewpass"]');
                    if (targetElement.closest("form").classList.contains("_pass-hidden")) {
                        buttonEye.classList.remove("_icon-eye");
                        buttonEye.classList.add("_icon-eye-2");
                    } else {
                        buttonEye.classList.remove("_icon-eye-2");
                        buttonEye.classList.add("_icon-eye");
                    }
                    targetElement.closest("form").classList.toggle("_pass-hidden");
                }
                async function sessionCookiesAccept() {
                    let response = await fetch("session_accept.php");
                    if (response.ok) return await response.json(); else throw new Error("connection denied");
                }
            }));
        }));
        function moreMenyHeaderCheck() {
            let moreMenuItem = document.querySelector(".body-header__more-menu");
            let moreMenuItems = moreMenuItem.querySelector(".more-menu__list").children;
            if (moreMenuItems.length) moreMenuItem.classList.add("_show"); else moreMenuItem.classList.remove("_show");
        }
        function ratesDynamicAdaptive() {
            let columns = document.querySelectorAll(".rates__column");
            if (columns.length === 0) return null;
            columns.forEach(((columnItem, colIindex) => {
                columnItem.dataset.rateColumn = colIindex;
                let rowItems = columnItem.querySelectorAll(".rate-item__spollers");
                rowItems.forEach(((rowItem, rowIndex) => {
                    rowItem.querySelector(".rate-item__spollers-body").dataset.rateRow = rowIndex;
                    rowItem.querySelector(".rate-item__button").dataset.da = `[data-rate-column="${colIindex}"] [data-rate-row="${rowIndex}"], 659.98`;
                }));
            }));
        }
        function renderJson(json) {
            let jsonConfig = json.config;
            renderElem(jsonConfig.user_sklad_price, "–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–∏—Å—Ç–µ–º–µ", "–ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–π—Ç–µ —Å–∏—Å—Ç–µ–º—É —É—á–µ—Ç–∞, —á—Ç–æ–±—ã —É–ø—Ä–æ—Å—Ç–∏—Ç—å —Ä–∞–±–æ—Ç—É —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –∏¬†—Å—Ä–∞–∑—É –≤—ã–π—Ç–∏ –Ω–∞ –≤—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–¥–∞–∂–Ω–∞ –Ω–æ–≤–æ–π –ø–ª–æ—â–∞–¥–∫–µ.");
            renderElem(jsonConfig.market_price, "–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Marketplace", "–ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–π—Ç–µ —Å–∏—Å—Ç–µ–º—É —É—á–µ—Ç–∞, —á—Ç–æ–±—ã —É–ø—Ä–æ—Å—Ç–∏—Ç—å —Ä–∞–±–æ—Ç—É —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–æ–≤ –∏¬†—Å—Ä–∞–∑—É –≤—ã–π—Ç–∏ –Ω–∞ –≤—ã—Å–æ–∫–∏–π —É—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–¥–∞–∂–Ω–∞ –Ω–æ–≤–æ–π –ø–ª–æ—â–∞–¥–∫–µ.");
        }
        function renderElem(data, title, text) {
            let elementBody = document.querySelector("[data-fetch]");
            if (!elementBody) return null;
            let buildedTemplateHTML = buildTemplateElem(data, title, text);
            elementBody.insertAdjacentHTML("beforeend", buildedTemplateHTML);
        }
        function buildTemplateElem(data, title, text) {
            let rowsHTML = [];
            data.forEach((item => {
                let fixedPrice = fixPrice(item.sum * item.men);
                rowsHTML.push(`\n\t\t<div data-spollers="659.98" class="rate-item__spollers spollers">\n\t\t\t<details class="rate-item__details spollers__item">\n\t\t\t\t<summary class="rate-item__spollers-summary spollers__title">\n\t\t\t\t\t<div class="rate-item__content-line rate-item__line">\n\t\t\t\t\t\t<div class="rate-item__content-text text-font">\n\t\t\t\t\t\t\t–û—Ç ${item.bol} –¥–æ ${item.men}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div class="rate-item__content-text text-font">\n\t\t\t\t\t\t\t${item.sum} ‚ÇΩ\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclass="rate-item__content-text rate-item__content-text_bold text-font">\n\t\t\t\t\t\t\t${fixedPrice} ‚ÇΩ\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\tclass="rate-item__content-text text-font rate-item__button">\n\t\t\t\t\t\t\t<a\n\t\t\t\t\t\t\t\tclass="rate-item__button-inner rate-item__content-text_bold rate-item__content-text_red"\n\t\t\t\t\t\t\t\thref="#"\n\t\t\t\t\t\t\t\t>–ü–æ–¥–∫–ª—é—á–∏—Ç—å</a\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</summary>\n\t\t\t\t<div class="rate-item__spollers-body spollers__body"></div>\n\t\t\t</details>\n\t\t</div>\n\t\t`);
            }));
            let dataHTML = `<div class="rates__column">\n\t\t\t\t\t\t\t<div class="rate-item">\n\t\t\t\t\t\t\t\t<div class="rate-item__top">\n\t\t\t\t\t\t\t\t\t<div class="rate-item__top-title">${title}</div>\n\t\t\t\t\t\t\t\t\t<div class="rate-item__top-text text-font">\n\t\t\t\t\t\t\t\t\t\t${text}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t<div class="rate-item__body">\n\t\t\t\t\t\t\t\t\t<div class="rate-item__body-header rate-item__line">\n\t\t\t\t\t\t\t\t\t\t<div class="rate-item__header-title">–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏:</div>\n\t\t\t\t\t\t\t\t\t\t<div class="rate-item__header-title">–¶–µ–Ω–∞ –∑–∞ –∞–∫–∫–∞—É–Ω—Ç:</div>\n\t\t\t\t\t\t\t\t\t\t<div class="rate-item__header-title">–ü–æ–ª–Ω–∞—è —Ü–µ–Ω–∞:</div>\n\t\t\t\t\t\t\t\t\t\t<div class="rate-item__header-title"></div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<div class="rate-item__content">\n\t\t\t\t\t\t\t\t\t\t${rowsHTML.join("")}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t`;
            return dataHTML;
        }
        function fixPrice(price) {
            let result = "";
            let priceStr = reverseString(String(price));
            for (let i = 0; i < priceStr.length; i++) if (i % 3 === 0) result += ` ${priceStr[i]}`; else result += `${priceStr[i]}`;
            result = reverseString(result);
            return result;
        }
        function reverseString(str) {
            return str.split("").reverse().join("");
        }
        class DynamicAdapt {
            constructor(type) {
                this.type = type;
            }
            init() {
                this.–æbjects = [];
                this.daClassname = "_dynamic_adapt_";
                this.nodes = [ ...document.querySelectorAll("[data-da]") ];
                this.nodes.forEach((node => {
                    const data = node.dataset.da.trim();
                    const dataArray = data.split(",");
                    const –æbject = {};
                    –æbject.element = node;
                    –æbject.parent = node.parentNode;
                    –æbject.destination = document.querySelector(`${dataArray[0].trim()}`);
                    –æbject.breakpoint = dataArray[1] ? dataArray[1].trim() : "767";
                    –æbject.place = dataArray[2] ? dataArray[2].trim() : "last";
                    –æbject.index = this.indexInParent(–æbject.parent, –æbject.element);
                    this.–æbjects.push(–æbject);
                }));
                this.arraySort(this.–æbjects);
                this.mediaQueries = this.–æbjects.map((({breakpoint}) => `(${this.type}-width: ${breakpoint}px),${breakpoint}`)).filter(((item, index, self) => self.indexOf(item) === index));
                this.mediaQueries.forEach((media => {
                    const mediaSplit = media.split(",");
                    const matchMedia = window.matchMedia(mediaSplit[0]);
                    const mediaBreakpoint = mediaSplit[1];
                    const –æbjectsFilter = this.–æbjects.filter((({breakpoint}) => breakpoint === mediaBreakpoint));
                    matchMedia.addEventListener("change", (() => {
                        this.mediaHandler(matchMedia, –æbjectsFilter);
                    }));
                    this.mediaHandler(matchMedia, –æbjectsFilter);
                }));
            }
            mediaHandler(matchMedia, –æbjects) {
                if (matchMedia.matches) –æbjects.forEach((–æbject => {
                    this.moveTo(–æbject.place, –æbject.element, –æbject.destination);
                })); else –æbjects.forEach((({parent, element, index}) => {
                    if (element.classList.contains(this.daClassname)) this.moveBack(parent, element, index);
                }));
            }
            moveTo(place, element, destination) {
                element.classList.add(this.daClassname);
                if (place === "last" || place >= destination.children.length) {
                    destination.append(element);
                    return;
                }
                if (place === "first") {
                    destination.prepend(element);
                    return;
                }
                destination.children[place].before(element);
            }
            moveBack(parent, element, index) {
                element.classList.remove(this.daClassname);
                if (parent.children[index] !== void 0) parent.children[index].before(element); else parent.append(element);
            }
            indexInParent(parent, element) {
                return [ ...parent.children ].indexOf(element);
            }
            arraySort(arr) {
                if (this.type === "min") arr.sort(((a, b) => {
                    if (a.breakpoint === b.breakpoint) {
                        if (a.place === b.place) return 0;
                        if (a.place === "first" || b.place === "last") return -1;
                        if (a.place === "last" || b.place === "first") return 1;
                        return 0;
                    }
                    return a.breakpoint - b.breakpoint;
                })); else {
                    arr.sort(((a, b) => {
                        if (a.breakpoint === b.breakpoint) {
                            if (a.place === b.place) return 0;
                            if (a.place === "first" || b.place === "last") return 1;
                            if (a.place === "last" || b.place === "first") return -1;
                            return 0;
                        }
                        return b.breakpoint - a.breakpoint;
                    }));
                    return;
                }
            }
        }
        const da = new DynamicAdapt("max");
        da.init();
        var global_window = __webpack_require__(908);
        var window_default = __webpack_require__.n(global_window);
        var global_document = __webpack_require__(144);
        var document_default = __webpack_require__.n(global_document);
        var keycode = __webpack_require__(537);
        var keycode_default = __webpack_require__.n(keycode);
        var tuple = __webpack_require__(974);
        var tuple_default = __webpack_require__.n(tuple);
        var lib = __webpack_require__(603);
        var lib_default = __webpack_require__.n(lib);
        var browser_index = __webpack_require__(407);
        var browser_index_default = __webpack_require__.n(browser_index);
        var url_toolkit = __webpack_require__(945);
        var url_toolkit_default = __webpack_require__.n(url_toolkit);
        var DEFAULT_LOCATION = "http://example.com";
        var resolveUrl = function resolveUrl(baseUrl, relativeUrl) {
            if (/^[a-z]+:/i.test(relativeUrl)) return relativeUrl;
            if (/^data:/.test(baseUrl)) baseUrl = window_default().location && window_default().location.href || "";
            var nativeURL = typeof window_default().URL === "function";
            var protocolLess = /^\/\//.test(baseUrl);
            var removeLocation = !window_default().location && !/\/\//i.test(baseUrl);
            if (nativeURL) baseUrl = new (window_default().URL)(baseUrl, window_default().location || DEFAULT_LOCATION); else if (!/\/\//i.test(baseUrl)) baseUrl = url_toolkit_default().buildAbsoluteURL(window_default().location && window_default().location.href || "", baseUrl);
            if (nativeURL) {
                var newUrl = new URL(relativeUrl, baseUrl);
                if (removeLocation) return newUrl.href.slice(DEFAULT_LOCATION.length); else if (protocolLess) return newUrl.href.slice(newUrl.protocol.length);
                return newUrl.href;
            }
            return url_toolkit_default().buildAbsoluteURL(baseUrl, relativeUrl);
        };
        const resolve_url = resolveUrl;
        function _extends() {
            _extends = Object.assign ? Object.assign.bind() : function(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];
                }
                return target;
            };
            return _extends.apply(this, arguments);
        }
        var Stream = function() {
            function Stream() {
                this.listeners = {};
            }
            var _proto = Stream.prototype;
            _proto.on = function on(type, listener) {
                if (!this.listeners[type]) this.listeners[type] = [];
                this.listeners[type].push(listener);
            };
            _proto.off = function off(type, listener) {
                if (!this.listeners[type]) return false;
                var index = this.listeners[type].indexOf(listener);
                this.listeners[type] = this.listeners[type].slice(0);
                this.listeners[type].splice(index, 1);
                return index > -1;
            };
            _proto.trigger = function trigger(type) {
                var callbacks = this.listeners[type];
                if (!callbacks) return;
                if (arguments.length === 2) {
                    var length = callbacks.length;
                    for (var i = 0; i < length; ++i) callbacks[i].call(this, arguments[1]);
                } else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var _length = callbacks.length;
                    for (var _i = 0; _i < _length; ++_i) callbacks[_i].apply(this, args);
                }
            };
            _proto.dispose = function dispose() {
                this.listeners = {};
            };
            _proto.pipe = function pipe(destination) {
                this.on("data", (function(data) {
                    destination.push(data);
                }));
            };
            return Stream;
        }();
        var atob = function atob(s) {
            return window_default().atob ? window_default().atob(s) : Buffer.from(s, "base64").toString("binary");
        };
        function decodeB64ToUint8Array(b64Text) {
            var decodedString = atob(b64Text);
            var array = new Uint8Array(decodedString.length);
            for (var i = 0; i < decodedString.length; i++) array[i] = decodedString.charCodeAt(i);
            return array;
        }
        /*! @name m3u8-parser @version 6.2.0 @license Apache-2.0 */
        class LineStream extends Stream {
            constructor() {
                super();
                this.buffer = "";
            }
            push(data) {
                let nextNewline;
                this.buffer += data;
                nextNewline = this.buffer.indexOf("\n");
                for (;nextNewline > -1; nextNewline = this.buffer.indexOf("\n")) {
                    this.trigger("data", this.buffer.substring(0, nextNewline));
                    this.buffer = this.buffer.substring(nextNewline + 1);
                }
            }
        }
        const TAB = String.fromCharCode(9);
        const parseByterange = function(byterangeString) {
            const match = /([0-9.]*)?@?([0-9.]*)?/.exec(byterangeString || "");
            const result = {};
            if (match[1]) result.length = parseInt(match[1], 10);
            if (match[2]) result.offset = parseInt(match[2], 10);
            return result;
        };
        const attributeSeparator = function() {
            const key = "[^=]*";
            const value = '"[^"]*"|[^,]*';
            const keyvalue = "(?:" + key + ")=(?:" + value + ")";
            return new RegExp("(?:^|,)(" + keyvalue + ")");
        };
        const parseAttributes = function(attributes) {
            const result = {};
            if (!attributes) return result;
            const attrs = attributes.split(attributeSeparator());
            let i = attrs.length;
            let attr;
            while (i--) {
                if (attrs[i] === "") continue;
                attr = /([^=]*)=(.*)/.exec(attrs[i]).slice(1);
                attr[0] = attr[0].replace(/^\s+|\s+$/g, "");
                attr[1] = attr[1].replace(/^\s+|\s+$/g, "");
                attr[1] = attr[1].replace(/^['"](.*)['"]$/g, "$1");
                result[attr[0]] = attr[1];
            }
            return result;
        };
        class ParseStream extends Stream {
            constructor() {
                super();
                this.customParsers = [];
                this.tagMappers = [];
            }
            push(line) {
                let match;
                let event;
                line = line.trim();
                if (line.length === 0) return;
                if (line[0] !== "#") {
                    this.trigger("data", {
                        type: "uri",
                        uri: line
                    });
                    return;
                }
                const newLines = this.tagMappers.reduce(((acc, mapper) => {
                    const mappedLine = mapper(line);
                    if (mappedLine === line) return acc;
                    return acc.concat([ mappedLine ]);
                }), [ line ]);
                newLines.forEach((newLine => {
                    for (let i = 0; i < this.customParsers.length; i++) if (this.customParsers[i].call(this, newLine)) return;
                    if (newLine.indexOf("#EXT") !== 0) {
                        this.trigger("data", {
                            type: "comment",
                            text: newLine.slice(1)
                        });
                        return;
                    }
                    newLine = newLine.replace("\r", "");
                    match = /^#EXTM3U/.exec(newLine);
                    if (match) {
                        this.trigger("data", {
                            type: "tag",
                            tagType: "m3u"
                        });
                        return;
                    }
                    match = /^#EXTINF:([0-9\.]*)?,?(.*)?$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "inf"
                        };
                        if (match[1]) event.duration = parseFloat(match[1]);
                        if (match[2]) event.title = match[2];
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-TARGETDURATION:([0-9.]*)?/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "targetduration"
                        };
                        if (match[1]) event.duration = parseInt(match[1], 10);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-VERSION:([0-9.]*)?/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "version"
                        };
                        if (match[1]) event.version = parseInt(match[1], 10);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-MEDIA-SEQUENCE:(\-?[0-9.]*)?/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "media-sequence"
                        };
                        if (match[1]) event.number = parseInt(match[1], 10);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-DISCONTINUITY-SEQUENCE:(\-?[0-9.]*)?/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "discontinuity-sequence"
                        };
                        if (match[1]) event.number = parseInt(match[1], 10);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-PLAYLIST-TYPE:(.*)?$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "playlist-type"
                        };
                        if (match[1]) event.playlistType = match[1];
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-BYTERANGE:(.*)?$/.exec(newLine);
                    if (match) {
                        event = _extends(parseByterange(match[1]), {
                            type: "tag",
                            tagType: "byterange"
                        });
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-ALLOW-CACHE:(YES|NO)?/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "allow-cache"
                        };
                        if (match[1]) event.allowed = !/NO/.test(match[1]);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-MAP:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "map"
                        };
                        if (match[1]) {
                            const attributes = parseAttributes(match[1]);
                            if (attributes.URI) event.uri = attributes.URI;
                            if (attributes.BYTERANGE) event.byterange = parseByterange(attributes.BYTERANGE);
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-STREAM-INF:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "stream-inf"
                        };
                        if (match[1]) {
                            event.attributes = parseAttributes(match[1]);
                            if (event.attributes.RESOLUTION) {
                                const split = event.attributes.RESOLUTION.split("x");
                                const resolution = {};
                                if (split[0]) resolution.width = parseInt(split[0], 10);
                                if (split[1]) resolution.height = parseInt(split[1], 10);
                                event.attributes.RESOLUTION = resolution;
                            }
                            if (event.attributes.BANDWIDTH) event.attributes.BANDWIDTH = parseInt(event.attributes.BANDWIDTH, 10);
                            if (event.attributes["FRAME-RATE"]) event.attributes["FRAME-RATE"] = parseFloat(event.attributes["FRAME-RATE"]);
                            if (event.attributes["PROGRAM-ID"]) event.attributes["PROGRAM-ID"] = parseInt(event.attributes["PROGRAM-ID"], 10);
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-MEDIA:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "media"
                        };
                        if (match[1]) event.attributes = parseAttributes(match[1]);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-ENDLIST/.exec(newLine);
                    if (match) {
                        this.trigger("data", {
                            type: "tag",
                            tagType: "endlist"
                        });
                        return;
                    }
                    match = /^#EXT-X-DISCONTINUITY/.exec(newLine);
                    if (match) {
                        this.trigger("data", {
                            type: "tag",
                            tagType: "discontinuity"
                        });
                        return;
                    }
                    match = /^#EXT-X-PROGRAM-DATE-TIME:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "program-date-time"
                        };
                        if (match[1]) {
                            event.dateTimeString = match[1];
                            event.dateTimeObject = new Date(match[1]);
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-KEY:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "key"
                        };
                        if (match[1]) {
                            event.attributes = parseAttributes(match[1]);
                            if (event.attributes.IV) {
                                if (event.attributes.IV.substring(0, 2).toLowerCase() === "0x") event.attributes.IV = event.attributes.IV.substring(2);
                                event.attributes.IV = event.attributes.IV.match(/.{8}/g);
                                event.attributes.IV[0] = parseInt(event.attributes.IV[0], 16);
                                event.attributes.IV[1] = parseInt(event.attributes.IV[1], 16);
                                event.attributes.IV[2] = parseInt(event.attributes.IV[2], 16);
                                event.attributes.IV[3] = parseInt(event.attributes.IV[3], 16);
                                event.attributes.IV = new Uint32Array(event.attributes.IV);
                            }
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-START:(.*)$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "start"
                        };
                        if (match[1]) {
                            event.attributes = parseAttributes(match[1]);
                            event.attributes["TIME-OFFSET"] = parseFloat(event.attributes["TIME-OFFSET"]);
                            event.attributes.PRECISE = /YES/.test(event.attributes.PRECISE);
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-CUE-OUT-CONT:(.*)?$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "cue-out-cont"
                        };
                        if (match[1]) event.data = match[1]; else event.data = "";
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-CUE-OUT:(.*)?$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "cue-out"
                        };
                        if (match[1]) event.data = match[1]; else event.data = "";
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-CUE-IN:(.*)?$/.exec(newLine);
                    if (match) {
                        event = {
                            type: "tag",
                            tagType: "cue-in"
                        };
                        if (match[1]) event.data = match[1]; else event.data = "";
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-SKIP:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "skip"
                        };
                        event.attributes = parseAttributes(match[1]);
                        if (event.attributes.hasOwnProperty("SKIPPED-SEGMENTS")) event.attributes["SKIPPED-SEGMENTS"] = parseInt(event.attributes["SKIPPED-SEGMENTS"], 10);
                        if (event.attributes.hasOwnProperty("RECENTLY-REMOVED-DATERANGES")) event.attributes["RECENTLY-REMOVED-DATERANGES"] = event.attributes["RECENTLY-REMOVED-DATERANGES"].split(TAB);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-PART:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "part"
                        };
                        event.attributes = parseAttributes(match[1]);
                        [ "DURATION" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);
                        }));
                        [ "INDEPENDENT", "GAP" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = /YES/.test(event.attributes[key]);
                        }));
                        if (event.attributes.hasOwnProperty("BYTERANGE")) event.attributes.byterange = parseByterange(event.attributes.BYTERANGE);
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-SERVER-CONTROL:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "server-control"
                        };
                        event.attributes = parseAttributes(match[1]);
                        [ "CAN-SKIP-UNTIL", "PART-HOLD-BACK", "HOLD-BACK" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);
                        }));
                        [ "CAN-SKIP-DATERANGES", "CAN-BLOCK-RELOAD" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = /YES/.test(event.attributes[key]);
                        }));
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-PART-INF:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "part-inf"
                        };
                        event.attributes = parseAttributes(match[1]);
                        [ "PART-TARGET" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);
                        }));
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-PRELOAD-HINT:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "preload-hint"
                        };
                        event.attributes = parseAttributes(match[1]);
                        [ "BYTERANGE-START", "BYTERANGE-LENGTH" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) {
                                event.attributes[key] = parseInt(event.attributes[key], 10);
                                const subkey = key === "BYTERANGE-LENGTH" ? "length" : "offset";
                                event.attributes.byterange = event.attributes.byterange || {};
                                event.attributes.byterange[subkey] = event.attributes[key];
                                delete event.attributes[key];
                            }
                        }));
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-RENDITION-REPORT:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "rendition-report"
                        };
                        event.attributes = parseAttributes(match[1]);
                        [ "LAST-MSN", "LAST-PART" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseInt(event.attributes[key], 10);
                        }));
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-DATERANGE:(.*)$/.exec(newLine);
                    if (match && match[1]) {
                        event = {
                            type: "tag",
                            tagType: "daterange"
                        };
                        event.attributes = parseAttributes(match[1]);
                        [ "ID", "CLASS" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = String(event.attributes[key]);
                        }));
                        [ "START-DATE", "END-DATE" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = new Date(event.attributes[key]);
                        }));
                        [ "DURATION", "PLANNED-DURATION" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = parseFloat(event.attributes[key]);
                        }));
                        [ "END-ON-NEXT" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = /YES/i.test(event.attributes[key]);
                        }));
                        [ "SCTE35-CMD", " SCTE35-OUT", "SCTE35-IN" ].forEach((function(key) {
                            if (event.attributes.hasOwnProperty(key)) event.attributes[key] = event.attributes[key].toString(16);
                        }));
                        const clientAttributePattern = /^X-([A-Z]+-)+[A-Z]+$/;
                        for (const key in event.attributes) {
                            if (!clientAttributePattern.test(key)) continue;
                            const isHexaDecimal = /[0-9A-Fa-f]{6}/g.test(event.attributes[key]);
                            const isDecimalFloating = /^\d+(\.\d+)?$/.test(event.attributes[key]);
                            event.attributes[key] = isHexaDecimal ? event.attributes[key].toString(16) : isDecimalFloating ? parseFloat(event.attributes[key]) : String(event.attributes[key]);
                        }
                        this.trigger("data", event);
                        return;
                    }
                    match = /^#EXT-X-INDEPENDENT-SEGMENTS/.exec(newLine);
                    if (match) {
                        this.trigger("data", {
                            type: "tag",
                            tagType: "independent-segments"
                        });
                        return;
                    }
                    this.trigger("data", {
                        type: "tag",
                        data: newLine.slice(4)
                    });
                }));
            }
            addParser({expression, customType, dataParser, segment}) {
                if (typeof dataParser !== "function") dataParser = line => line;
                this.customParsers.push((line => {
                    const match = expression.exec(line);
                    if (match) {
                        this.trigger("data", {
                            type: "custom",
                            data: dataParser(line),
                            customType,
                            segment
                        });
                        return true;
                    }
                }));
            }
            addTagMapper({expression, map}) {
                const mapFn = line => {
                    if (expression.test(line)) return map(line);
                    return line;
                };
                this.tagMappers.push(mapFn);
            }
        }
        const camelCase = str => str.toLowerCase().replace(/-(\w)/g, (a => a[1].toUpperCase()));
        const camelCaseKeys = function(attributes) {
            const result = {};
            Object.keys(attributes).forEach((function(key) {
                result[camelCase(key)] = attributes[key];
            }));
            return result;
        };
        const setHoldBack = function(manifest) {
            const {serverControl, targetDuration, partTargetDuration} = manifest;
            if (!serverControl) return;
            const tag = "#EXT-X-SERVER-CONTROL";
            const hb = "holdBack";
            const phb = "partHoldBack";
            const minTargetDuration = targetDuration && targetDuration * 3;
            const minPartDuration = partTargetDuration && partTargetDuration * 2;
            if (targetDuration && !serverControl.hasOwnProperty(hb)) {
                serverControl[hb] = minTargetDuration;
                this.trigger("info", {
                    message: `${tag} defaulting HOLD-BACK to targetDuration * 3 (${minTargetDuration}).`
                });
            }
            if (minTargetDuration && serverControl[hb] < minTargetDuration) {
                this.trigger("warn", {
                    message: `${tag} clamping HOLD-BACK (${serverControl[hb]}) to targetDuration * 3 (${minTargetDuration})`
                });
                serverControl[hb] = minTargetDuration;
            }
            if (partTargetDuration && !serverControl.hasOwnProperty(phb)) {
                serverControl[phb] = partTargetDuration * 3;
                this.trigger("info", {
                    message: `${tag} defaulting PART-HOLD-BACK to partTargetDuration * 3 (${serverControl[phb]}).`
                });
            }
            if (partTargetDuration && serverControl[phb] < minPartDuration) {
                this.trigger("warn", {
                    message: `${tag} clamping PART-HOLD-BACK (${serverControl[phb]}) to partTargetDuration * 2 (${minPartDuration}).`
                });
                serverControl[phb] = minPartDuration;
            }
        };
        class Parser extends Stream {
            constructor() {
                super();
                this.lineStream = new LineStream;
                this.parseStream = new ParseStream;
                this.lineStream.pipe(this.parseStream);
                const self = this;
                const uris = [];
                let currentUri = {};
                let currentMap;
                let key;
                let hasParts = false;
                const noop = function() {};
                const defaultMediaGroups = {
                    AUDIO: {},
                    VIDEO: {},
                    "CLOSED-CAPTIONS": {},
                    SUBTITLES: {}
                };
                const widevineUuid = "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed";
                let currentTimeline = 0;
                this.manifest = {
                    allowCache: true,
                    discontinuityStarts: [],
                    segments: []
                };
                let lastByterangeEnd = 0;
                let lastPartByterangeEnd = 0;
                const daterangeTags = {};
                this.on("end", (() => {
                    if (currentUri.uri || !currentUri.parts && !currentUri.preloadHints) return;
                    if (!currentUri.map && currentMap) currentUri.map = currentMap;
                    if (!currentUri.key && key) currentUri.key = key;
                    if (!currentUri.timeline && typeof currentTimeline === "number") currentUri.timeline = currentTimeline;
                    this.manifest.preloadSegment = currentUri;
                }));
                this.parseStream.on("data", (function(entry) {
                    let mediaGroup;
                    let rendition;
                    ({
                        tag() {
                            ({
                                version() {
                                    if (entry.version) this.manifest.version = entry.version;
                                },
                                "allow-cache"() {
                                    this.manifest.allowCache = entry.allowed;
                                    if (!("allowed" in entry)) {
                                        this.trigger("info", {
                                            message: "defaulting allowCache to YES"
                                        });
                                        this.manifest.allowCache = true;
                                    }
                                },
                                byterange() {
                                    const byterange = {};
                                    if ("length" in entry) {
                                        currentUri.byterange = byterange;
                                        byterange.length = entry.length;
                                        if (!("offset" in entry)) entry.offset = lastByterangeEnd;
                                    }
                                    if ("offset" in entry) {
                                        currentUri.byterange = byterange;
                                        byterange.offset = entry.offset;
                                    }
                                    lastByterangeEnd = byterange.offset + byterange.length;
                                },
                                endlist() {
                                    this.manifest.endList = true;
                                },
                                inf() {
                                    if (!("mediaSequence" in this.manifest)) {
                                        this.manifest.mediaSequence = 0;
                                        this.trigger("info", {
                                            message: "defaulting media sequence to zero"
                                        });
                                    }
                                    if (!("discontinuitySequence" in this.manifest)) {
                                        this.manifest.discontinuitySequence = 0;
                                        this.trigger("info", {
                                            message: "defaulting discontinuity sequence to zero"
                                        });
                                    }
                                    if (entry.duration > 0) currentUri.duration = entry.duration;
                                    if (entry.duration === 0) {
                                        currentUri.duration = .01;
                                        this.trigger("info", {
                                            message: "updating zero segment duration to a small value"
                                        });
                                    }
                                    this.manifest.segments = uris;
                                },
                                key() {
                                    if (!entry.attributes) {
                                        this.trigger("warn", {
                                            message: "ignoring key declaration without attribute list"
                                        });
                                        return;
                                    }
                                    if (entry.attributes.METHOD === "NONE") {
                                        key = null;
                                        return;
                                    }
                                    if (!entry.attributes.URI) {
                                        this.trigger("warn", {
                                            message: "ignoring key declaration without URI"
                                        });
                                        return;
                                    }
                                    if (entry.attributes.KEYFORMAT === "com.apple.streamingkeydelivery") {
                                        this.manifest.contentProtection = this.manifest.contentProtection || {};
                                        this.manifest.contentProtection["com.apple.fps.1_0"] = {
                                            attributes: entry.attributes
                                        };
                                        return;
                                    }
                                    if (entry.attributes.KEYFORMAT === "com.microsoft.playready") {
                                        this.manifest.contentProtection = this.manifest.contentProtection || {};
                                        this.manifest.contentProtection["com.microsoft.playready"] = {
                                            uri: entry.attributes.URI
                                        };
                                        return;
                                    }
                                    if (entry.attributes.KEYFORMAT === widevineUuid) {
                                        const VALID_METHODS = [ "SAMPLE-AES", "SAMPLE-AES-CTR", "SAMPLE-AES-CENC" ];
                                        if (VALID_METHODS.indexOf(entry.attributes.METHOD) === -1) {
                                            this.trigger("warn", {
                                                message: "invalid key method provided for Widevine"
                                            });
                                            return;
                                        }
                                        if (entry.attributes.METHOD === "SAMPLE-AES-CENC") this.trigger("warn", {
                                            message: "SAMPLE-AES-CENC is deprecated, please use SAMPLE-AES-CTR instead"
                                        });
                                        if (entry.attributes.URI.substring(0, 23) !== "data:text/plain;base64,") {
                                            this.trigger("warn", {
                                                message: "invalid key URI provided for Widevine"
                                            });
                                            return;
                                        }
                                        if (!(entry.attributes.KEYID && entry.attributes.KEYID.substring(0, 2) === "0x")) {
                                            this.trigger("warn", {
                                                message: "invalid key ID provided for Widevine"
                                            });
                                            return;
                                        }
                                        this.manifest.contentProtection = this.manifest.contentProtection || {};
                                        this.manifest.contentProtection["com.widevine.alpha"] = {
                                            attributes: {
                                                schemeIdUri: entry.attributes.KEYFORMAT,
                                                keyId: entry.attributes.KEYID.substring(2)
                                            },
                                            pssh: decodeB64ToUint8Array(entry.attributes.URI.split(",")[1])
                                        };
                                        return;
                                    }
                                    if (!entry.attributes.METHOD) this.trigger("warn", {
                                        message: "defaulting key method to AES-128"
                                    });
                                    key = {
                                        method: entry.attributes.METHOD || "AES-128",
                                        uri: entry.attributes.URI
                                    };
                                    if (typeof entry.attributes.IV !== "undefined") key.iv = entry.attributes.IV;
                                },
                                "media-sequence"() {
                                    if (!isFinite(entry.number)) {
                                        this.trigger("warn", {
                                            message: "ignoring invalid media sequence: " + entry.number
                                        });
                                        return;
                                    }
                                    this.manifest.mediaSequence = entry.number;
                                },
                                "discontinuity-sequence"() {
                                    if (!isFinite(entry.number)) {
                                        this.trigger("warn", {
                                            message: "ignoring invalid discontinuity sequence: " + entry.number
                                        });
                                        return;
                                    }
                                    this.manifest.discontinuitySequence = entry.number;
                                    currentTimeline = entry.number;
                                },
                                "playlist-type"() {
                                    if (!/VOD|EVENT/.test(entry.playlistType)) {
                                        this.trigger("warn", {
                                            message: "ignoring unknown playlist type: " + entry.playlist
                                        });
                                        return;
                                    }
                                    this.manifest.playlistType = entry.playlistType;
                                },
                                map() {
                                    currentMap = {};
                                    if (entry.uri) currentMap.uri = entry.uri;
                                    if (entry.byterange) currentMap.byterange = entry.byterange;
                                    if (key) currentMap.key = key;
                                },
                                "stream-inf"() {
                                    this.manifest.playlists = uris;
                                    this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
                                    if (!entry.attributes) {
                                        this.trigger("warn", {
                                            message: "ignoring empty stream-inf attributes"
                                        });
                                        return;
                                    }
                                    if (!currentUri.attributes) currentUri.attributes = {};
                                    _extends(currentUri.attributes, entry.attributes);
                                },
                                media() {
                                    this.manifest.mediaGroups = this.manifest.mediaGroups || defaultMediaGroups;
                                    if (!(entry.attributes && entry.attributes.TYPE && entry.attributes["GROUP-ID"] && entry.attributes.NAME)) {
                                        this.trigger("warn", {
                                            message: "ignoring incomplete or missing media group"
                                        });
                                        return;
                                    }
                                    const mediaGroupType = this.manifest.mediaGroups[entry.attributes.TYPE];
                                    mediaGroupType[entry.attributes["GROUP-ID"]] = mediaGroupType[entry.attributes["GROUP-ID"]] || {};
                                    mediaGroup = mediaGroupType[entry.attributes["GROUP-ID"]];
                                    rendition = {
                                        default: /yes/i.test(entry.attributes.DEFAULT)
                                    };
                                    if (rendition.default) rendition.autoselect = true; else rendition.autoselect = /yes/i.test(entry.attributes.AUTOSELECT);
                                    if (entry.attributes.LANGUAGE) rendition.language = entry.attributes.LANGUAGE;
                                    if (entry.attributes.URI) rendition.uri = entry.attributes.URI;
                                    if (entry.attributes["INSTREAM-ID"]) rendition.instreamId = entry.attributes["INSTREAM-ID"];
                                    if (entry.attributes.CHARACTERISTICS) rendition.characteristics = entry.attributes.CHARACTERISTICS;
                                    if (entry.attributes.FORCED) rendition.forced = /yes/i.test(entry.attributes.FORCED);
                                    mediaGroup[entry.attributes.NAME] = rendition;
                                },
                                discontinuity() {
                                    currentTimeline += 1;
                                    currentUri.discontinuity = true;
                                    this.manifest.discontinuityStarts.push(uris.length);
                                },
                                "program-date-time"() {
                                    if (typeof this.manifest.dateTimeString === "undefined") {
                                        this.manifest.dateTimeString = entry.dateTimeString;
                                        this.manifest.dateTimeObject = entry.dateTimeObject;
                                    }
                                    currentUri.dateTimeString = entry.dateTimeString;
                                    currentUri.dateTimeObject = entry.dateTimeObject;
                                },
                                targetduration() {
                                    if (!isFinite(entry.duration) || entry.duration < 0) {
                                        this.trigger("warn", {
                                            message: "ignoring invalid target duration: " + entry.duration
                                        });
                                        return;
                                    }
                                    this.manifest.targetDuration = entry.duration;
                                    setHoldBack.call(this, this.manifest);
                                },
                                start() {
                                    if (!entry.attributes || isNaN(entry.attributes["TIME-OFFSET"])) {
                                        this.trigger("warn", {
                                            message: "ignoring start declaration without appropriate attribute list"
                                        });
                                        return;
                                    }
                                    this.manifest.start = {
                                        timeOffset: entry.attributes["TIME-OFFSET"],
                                        precise: entry.attributes.PRECISE
                                    };
                                },
                                "cue-out"() {
                                    currentUri.cueOut = entry.data;
                                },
                                "cue-out-cont"() {
                                    currentUri.cueOutCont = entry.data;
                                },
                                "cue-in"() {
                                    currentUri.cueIn = entry.data;
                                },
                                skip() {
                                    this.manifest.skip = camelCaseKeys(entry.attributes);
                                    this.warnOnMissingAttributes_("#EXT-X-SKIP", entry.attributes, [ "SKIPPED-SEGMENTS" ]);
                                },
                                part() {
                                    hasParts = true;
                                    const segmentIndex = this.manifest.segments.length;
                                    const part = camelCaseKeys(entry.attributes);
                                    currentUri.parts = currentUri.parts || [];
                                    currentUri.parts.push(part);
                                    if (part.byterange) {
                                        if (!part.byterange.hasOwnProperty("offset")) part.byterange.offset = lastPartByterangeEnd;
                                        lastPartByterangeEnd = part.byterange.offset + part.byterange.length;
                                    }
                                    const partIndex = currentUri.parts.length - 1;
                                    this.warnOnMissingAttributes_(`#EXT-X-PART #${partIndex} for segment #${segmentIndex}`, entry.attributes, [ "URI", "DURATION" ]);
                                    if (this.manifest.renditionReports) this.manifest.renditionReports.forEach(((r, i) => {
                                        if (!r.hasOwnProperty("lastPart")) this.trigger("warn", {
                                            message: `#EXT-X-RENDITION-REPORT #${i} lacks required attribute(s): LAST-PART`
                                        });
                                    }));
                                },
                                "server-control"() {
                                    const attrs = this.manifest.serverControl = camelCaseKeys(entry.attributes);
                                    if (!attrs.hasOwnProperty("canBlockReload")) {
                                        attrs.canBlockReload = false;
                                        this.trigger("info", {
                                            message: "#EXT-X-SERVER-CONTROL defaulting CAN-BLOCK-RELOAD to false"
                                        });
                                    }
                                    setHoldBack.call(this, this.manifest);
                                    if (attrs.canSkipDateranges && !attrs.hasOwnProperty("canSkipUntil")) this.trigger("warn", {
                                        message: "#EXT-X-SERVER-CONTROL lacks required attribute CAN-SKIP-UNTIL which is required when CAN-SKIP-DATERANGES is set"
                                    });
                                },
                                "preload-hint"() {
                                    const segmentIndex = this.manifest.segments.length;
                                    const hint = camelCaseKeys(entry.attributes);
                                    const isPart = hint.type && hint.type === "PART";
                                    currentUri.preloadHints = currentUri.preloadHints || [];
                                    currentUri.preloadHints.push(hint);
                                    if (hint.byterange) if (!hint.byterange.hasOwnProperty("offset")) {
                                        hint.byterange.offset = isPart ? lastPartByterangeEnd : 0;
                                        if (isPart) lastPartByterangeEnd = hint.byterange.offset + hint.byterange.length;
                                    }
                                    const index = currentUri.preloadHints.length - 1;
                                    this.warnOnMissingAttributes_(`#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex}`, entry.attributes, [ "TYPE", "URI" ]);
                                    if (!hint.type) return;
                                    for (let i = 0; i < currentUri.preloadHints.length - 1; i++) {
                                        const otherHint = currentUri.preloadHints[i];
                                        if (!otherHint.type) continue;
                                        if (otherHint.type === hint.type) this.trigger("warn", {
                                            message: `#EXT-X-PRELOAD-HINT #${index} for segment #${segmentIndex} has the same TYPE ${hint.type} as preload hint #${i}`
                                        });
                                    }
                                },
                                "rendition-report"() {
                                    const report = camelCaseKeys(entry.attributes);
                                    this.manifest.renditionReports = this.manifest.renditionReports || [];
                                    this.manifest.renditionReports.push(report);
                                    const index = this.manifest.renditionReports.length - 1;
                                    const required = [ "LAST-MSN", "URI" ];
                                    if (hasParts) required.push("LAST-PART");
                                    this.warnOnMissingAttributes_(`#EXT-X-RENDITION-REPORT #${index}`, entry.attributes, required);
                                },
                                "part-inf"() {
                                    this.manifest.partInf = camelCaseKeys(entry.attributes);
                                    this.warnOnMissingAttributes_("#EXT-X-PART-INF", entry.attributes, [ "PART-TARGET" ]);
                                    if (this.manifest.partInf.partTarget) this.manifest.partTargetDuration = this.manifest.partInf.partTarget;
                                    setHoldBack.call(this, this.manifest);
                                },
                                daterange() {
                                    this.manifest.daterange = this.manifest.daterange || [];
                                    this.manifest.daterange.push(camelCaseKeys(entry.attributes));
                                    const index = this.manifest.daterange.length - 1;
                                    this.warnOnMissingAttributes_(`#EXT-X-DATERANGE #${index}`, entry.attributes, [ "ID", "START-DATE" ]);
                                    const daterange = this.manifest.daterange[index];
                                    if (daterange.endDate && daterange.startDate && new Date(daterange.endDate) < new Date(daterange.startDate)) this.trigger("warn", {
                                        message: "EXT-X-DATERANGE END-DATE must be equal to or later than the value of the START-DATE"
                                    });
                                    if (daterange.duration && daterange.duration < 0) this.trigger("warn", {
                                        message: "EXT-X-DATERANGE DURATION must not be negative"
                                    });
                                    if (daterange.plannedDuration && daterange.plannedDuration < 0) this.trigger("warn", {
                                        message: "EXT-X-DATERANGE PLANNED-DURATION must not be negative"
                                    });
                                    const endOnNextYes = !!daterange.endOnNext;
                                    if (endOnNextYes && !daterange.class) this.trigger("warn", {
                                        message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must have a CLASS attribute"
                                    });
                                    if (endOnNextYes && (daterange.duration || daterange.endDate)) this.trigger("warn", {
                                        message: "EXT-X-DATERANGE with an END-ON-NEXT=YES attribute must not contain DURATION or END-DATE attributes"
                                    });
                                    if (daterange.duration && daterange.endDate) {
                                        const startDate = daterange.startDate;
                                        const newDateInSeconds = startDate.setSeconds(startDate.getSeconds() + daterange.duration);
                                        this.manifest.daterange[index].endDate = new Date(newDateInSeconds);
                                    }
                                    if (daterange && !this.manifest.dateTimeString) this.trigger("warn", {
                                        message: "A playlist with EXT-X-DATERANGE tag must contain atleast one EXT-X-PROGRAM-DATE-TIME tag"
                                    });
                                    if (!daterangeTags[daterange.id]) daterangeTags[daterange.id] = daterange; else for (const attribute in daterangeTags[daterange.id]) if (daterangeTags[daterange.id][attribute] !== daterange[attribute]) {
                                        this.trigger("warn", {
                                            message: "EXT-X-DATERANGE tags with the same ID in a playlist must have the same attributes and same attribute values"
                                        });
                                        break;
                                    }
                                },
                                "independent-segments"() {
                                    this.manifest.independentSegments = true;
                                }
                            }[entry.tagType] || noop).call(self);
                        },
                        uri() {
                            currentUri.uri = entry.uri;
                            uris.push(currentUri);
                            if (this.manifest.targetDuration && !("duration" in currentUri)) {
                                this.trigger("warn", {
                                    message: "defaulting segment duration to the target duration"
                                });
                                currentUri.duration = this.manifest.targetDuration;
                            }
                            if (key) currentUri.key = key;
                            currentUri.timeline = currentTimeline;
                            if (currentMap) currentUri.map = currentMap;
                            lastPartByterangeEnd = 0;
                            currentUri = {};
                        },
                        comment() {},
                        custom() {
                            if (entry.segment) {
                                currentUri.custom = currentUri.custom || {};
                                currentUri.custom[entry.customType] = entry.data;
                            } else {
                                this.manifest.custom = this.manifest.custom || {};
                                this.manifest.custom[entry.customType] = entry.data;
                            }
                        }
                    })[entry.type].call(self);
                }));
            }
            warnOnMissingAttributes_(identifier, attributes, required) {
                const missing = [];
                required.forEach((function(key) {
                    if (!attributes.hasOwnProperty(key)) missing.push(key);
                }));
                if (missing.length) this.trigger("warn", {
                    message: `${identifier} lacks required attribute(s): ${missing.join(", ")}`
                });
            }
            push(chunk) {
                this.lineStream.push(chunk);
            }
            end() {
                this.lineStream.push("\n");
                this.trigger("end");
            }
            addParser(options) {
                this.parseStream.addParser(options);
            }
            addTagMapper(options) {
                this.parseStream.addTagMapper(options);
            }
        }
        var regexs = {
            mp4: /^(av0?1|avc0?[1234]|vp0?9|flac|opus|mp3|mp4a|mp4v|stpp.ttml.im1t)/,
            webm: /^(vp0?[89]|av0?1|opus|vorbis)/,
            ogg: /^(vp0?[89]|theora|flac|opus|vorbis)/,
            video: /^(av0?1|avc0?[1234]|vp0?[89]|hvc1|hev1|theora|mp4v)/,
            audio: /^(mp4a|flac|vorbis|opus|ac-[34]|ec-3|alac|mp3|speex|aac)/,
            text: /^(stpp.ttml.im1t)/,
            muxerVideo: /^(avc0?1)/,
            muxerAudio: /^(mp4a)/,
            muxerText: /a^/
        };
        var mediaTypes = [ "video", "audio", "text" ];
        var upperMediaTypes = [ "Video", "Audio", "Text" ];
        var translateLegacyCodec = function translateLegacyCodec(codec) {
            if (!codec) return codec;
            return codec.replace(/avc1\.(\d+)\.(\d+)/i, (function(orig, profile, avcLevel) {
                var profileHex = ("00" + Number(profile).toString(16)).slice(-2);
                var avcLevelHex = ("00" + Number(avcLevel).toString(16)).slice(-2);
                return "avc1." + profileHex + "00" + avcLevelHex;
            }));
        };
        var parseCodecs = function parseCodecs(codecString) {
            if (codecString === void 0) codecString = "";
            var codecs = codecString.split(",");
            var result = [];
            codecs.forEach((function(codec) {
                codec = codec.trim();
                var codecType;
                mediaTypes.forEach((function(name) {
                    var match = regexs[name].exec(codec.toLowerCase());
                    if (!match || match.length <= 1) return;
                    codecType = name;
                    var type = codec.substring(0, match[1].length);
                    var details = codec.replace(type, "");
                    result.push({
                        type,
                        details,
                        mediaType: name
                    });
                }));
                if (!codecType) result.push({
                    type: codec,
                    details: "",
                    mediaType: "unknown"
                });
            }));
            return result;
        };
        var codecsFromDefault = function codecsFromDefault(master, audioGroupId) {
            if (!master.mediaGroups.AUDIO || !audioGroupId) return null;
            var audioGroup = master.mediaGroups.AUDIO[audioGroupId];
            if (!audioGroup) return null;
            for (var name in audioGroup) {
                var audioType = audioGroup[name];
                if (audioType.default && audioType.playlists) return parseCodecs(audioType.playlists[0].attributes.CODECS);
            }
            return null;
        };
        var isAudioCodec = function isAudioCodec(codec) {
            if (codec === void 0) codec = "";
            return regexs.audio.test(codec.trim().toLowerCase());
        };
        var isTextCodec = function isTextCodec(codec) {
            if (codec === void 0) codec = "";
            return regexs.text.test(codec.trim().toLowerCase());
        };
        var getMimeForCodec = function getMimeForCodec(codecString) {
            if (!codecString || typeof codecString !== "string") return;
            var codecs = codecString.toLowerCase().split(",").map((function(c) {
                return translateLegacyCodec(c.trim());
            }));
            var type = "video";
            if (codecs.length === 1 && isAudioCodec(codecs[0])) type = "audio"; else if (codecs.length === 1 && isTextCodec(codecs[0])) type = "application";
            var container = "mp4";
            if (codecs.every((function(c) {
                return regexs.mp4.test(c);
            }))) container = "mp4"; else if (codecs.every((function(c) {
                return regexs.webm.test(c);
            }))) container = "webm"; else if (codecs.every((function(c) {
                return regexs.ogg.test(c);
            }))) container = "ogg";
            return type + "/" + container + ';codecs="' + codecString + '"';
        };
        var browserSupportsCodec = function browserSupportsCodec(codecString) {
            if (codecString === void 0) codecString = "";
            return window_default().MediaSource && window_default().MediaSource.isTypeSupported && window_default().MediaSource.isTypeSupported(getMimeForCodec(codecString)) || false;
        };
        var muxerSupportsCodec = function muxerSupportsCodec(codecString) {
            if (codecString === void 0) codecString = "";
            return codecString.toLowerCase().split(",").every((function(codec) {
                codec = codec.trim();
                for (var i = 0; i < upperMediaTypes.length; i++) {
                    var type = upperMediaTypes[i];
                    if (regexs["muxer" + type].test(codec)) return true;
                }
                return false;
            }));
        };
        var DEFAULT_AUDIO_CODEC = "mp4a.40.2";
        var DEFAULT_VIDEO_CODEC = "avc1.4d400d";
        var MPEGURL_REGEX = /^(audio|video|application)\/(x-|vnd\.apple\.)?mpegurl/i;
        var DASH_REGEX = /^application\/dash\+xml/i;
        var simpleTypeFromSourceType = function simpleTypeFromSourceType(type) {
            if (MPEGURL_REGEX.test(type)) return "hls";
            if (DASH_REGEX.test(type)) return "dash";
            if (type === "application/vnd.videojs.vhs+json") return "vhs-json";
            return null;
        };
        var countBits = function countBits(x) {
            return x.toString(2).length;
        };
        var countBytes = function countBytes(x) {
            return Math.ceil(countBits(x) / 8);
        };
        var isArrayBufferView = function isArrayBufferView(obj) {
            if (ArrayBuffer.isView === "function") return ArrayBuffer.isView(obj);
            return obj && obj.buffer instanceof ArrayBuffer;
        };
        var isTypedArray = function isTypedArray(obj) {
            return isArrayBufferView(obj);
        };
        var byte_helpers_toUint8 = function toUint8(bytes) {
            if (bytes instanceof Uint8Array) return bytes;
            if (!Array.isArray(bytes) && !isTypedArray(bytes) && !(bytes instanceof ArrayBuffer)) if (typeof bytes !== "number" || typeof bytes === "number" && bytes !== bytes) bytes = 0; else bytes = [ bytes ];
            return new Uint8Array(bytes && bytes.buffer || bytes, bytes && bytes.byteOffset || 0, bytes && bytes.byteLength || 0);
        };
        var BigInt = window_default().BigInt || Number;
        var BYTE_TABLE = [ BigInt("0x1"), BigInt("0x100"), BigInt("0x10000"), BigInt("0x1000000"), BigInt("0x100000000"), BigInt("0x10000000000"), BigInt("0x1000000000000"), BigInt("0x100000000000000"), BigInt("0x10000000000000000") ];
        (function() {
            var a = new Uint16Array([ 65484 ]);
            var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
            if (b[0] === 255) return "big";
            if (b[0] === 204) return "little";
        })();
        var byte_helpers_bytesToNumber = function bytesToNumber(bytes, _temp) {
            var _ref = _temp === void 0 ? {} : _temp, _ref$signed = _ref.signed, signed = _ref$signed === void 0 ? false : _ref$signed, _ref$le = _ref.le, le = _ref$le === void 0 ? false : _ref$le;
            bytes = byte_helpers_toUint8(bytes);
            var fn = le ? "reduce" : "reduceRight";
            var obj = bytes[fn] ? bytes[fn] : Array.prototype[fn];
            var number = obj.call(bytes, (function(total, byte, i) {
                var exponent = le ? i : Math.abs(i + 1 - bytes.length);
                return total + BigInt(byte) * BYTE_TABLE[exponent];
            }), BigInt(0));
            if (signed) {
                var max = BYTE_TABLE[bytes.length] / BigInt(2) - BigInt(1);
                number = BigInt(number);
                if (number > max) {
                    number -= max;
                    number -= max;
                    number -= BigInt(2);
                }
            }
            return Number(number);
        };
        var numberToBytes = function numberToBytes(number, _temp2) {
            var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$le = _ref2.le, le = _ref2$le === void 0 ? false : _ref2$le;
            if (typeof number !== "bigint" && typeof number !== "number" || typeof number === "number" && number !== number) number = 0;
            number = BigInt(number);
            var byteCount = countBytes(number);
            var bytes = new Uint8Array(new ArrayBuffer(byteCount));
            for (var i = 0; i < byteCount; i++) {
                var byteIndex = le ? i : Math.abs(i + 1 - bytes.length);
                bytes[byteIndex] = Number(number / BYTE_TABLE[i] & BigInt(255));
                if (number < 0) {
                    bytes[byteIndex] = Math.abs(~bytes[byteIndex]);
                    bytes[byteIndex] -= i === 0 ? 1 : 2;
                }
            }
            return bytes;
        };
        var byte_helpers_bytesToString = function bytesToString(bytes) {
            if (!bytes) return "";
            bytes = Array.prototype.slice.call(bytes);
            var string = String.fromCharCode.apply(null, byte_helpers_toUint8(bytes));
            try {
                return decodeURIComponent(escape(string));
            } catch (e) {}
            return string;
        };
        var stringToBytes = function stringToBytes(string, stringIsBytes) {
            if (typeof string !== "string" && string && typeof string.toString === "function") string = string.toString();
            if (typeof string !== "string") return new Uint8Array;
            if (!stringIsBytes) string = unescape(encodeURIComponent(string));
            var view = new Uint8Array(string.length);
            for (var i = 0; i < string.length; i++) view[i] = string.charCodeAt(i);
            return view;
        };
        var concatTypedArrays = function concatTypedArrays() {
            for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) buffers[_key] = arguments[_key];
            buffers = buffers.filter((function(b) {
                return b && (b.byteLength || b.length) && typeof b !== "string";
            }));
            if (buffers.length <= 1) return byte_helpers_toUint8(buffers[0]);
            var totalLen = buffers.reduce((function(total, buf, i) {
                return total + (buf.byteLength || buf.length);
            }), 0);
            var tempBuffer = new Uint8Array(totalLen);
            var offset = 0;
            buffers.forEach((function(buf) {
                buf = byte_helpers_toUint8(buf);
                tempBuffer.set(buf, offset);
                offset += buf.byteLength;
            }));
            return tempBuffer;
        };
        var byte_helpers_bytesMatch = function bytesMatch(a, b, _temp3) {
            var _ref3 = _temp3 === void 0 ? {} : _temp3, _ref3$offset = _ref3.offset, offset = _ref3$offset === void 0 ? 0 : _ref3$offset, _ref3$mask = _ref3.mask, mask = _ref3$mask === void 0 ? [] : _ref3$mask;
            a = byte_helpers_toUint8(a);
            b = byte_helpers_toUint8(b);
            var fn = b.every ? b.every : Array.prototype.every;
            return b.length && a.length - offset >= b.length && fn.call(b, (function(bByte, i) {
                var aByte = mask[i] ? mask[i] & a[offset + i] : a[offset + i];
                return bByte === aByte;
            }));
        };
        var resolve_url_DEFAULT_LOCATION = "http://example.com";
        var resolve_url_resolveUrl = function resolveUrl(baseUrl, relativeUrl) {
            if (/^[a-z]+:/i.test(relativeUrl)) return relativeUrl;
            if (/^data:/.test(baseUrl)) baseUrl = window_default().location && window_default().location.href || "";
            var nativeURL = typeof window_default().URL === "function";
            var protocolLess = /^\/\//.test(baseUrl);
            var removeLocation = !window_default().location && !/\/\//i.test(baseUrl);
            if (nativeURL) baseUrl = new (window_default().URL)(baseUrl, window_default().location || resolve_url_DEFAULT_LOCATION); else if (!/\/\//i.test(baseUrl)) baseUrl = url_toolkit_default().buildAbsoluteURL(window_default().location && window_default().location.href || "", baseUrl);
            if (nativeURL) {
                var newUrl = new URL(relativeUrl, baseUrl);
                if (removeLocation) return newUrl.href.slice(resolve_url_DEFAULT_LOCATION.length); else if (protocolLess) return newUrl.href.slice(newUrl.protocol.length);
                return newUrl.href;
            }
            return url_toolkit_default().buildAbsoluteURL(baseUrl, relativeUrl);
        };
        const es_resolve_url = resolve_url_resolveUrl;
        var forEachMediaGroup = function forEachMediaGroup(master, groups, callback) {
            groups.forEach((function(mediaType) {
                for (var groupKey in master.mediaGroups[mediaType]) for (var labelKey in master.mediaGroups[mediaType][groupKey]) {
                    var mediaProperties = master.mediaGroups[mediaType][groupKey][labelKey];
                    callback(mediaProperties, mediaType, groupKey, labelKey);
                }
            }));
        };
        var decode_b64_to_uint8_array_atob = function atob(s) {
            return window_default().atob ? window_default().atob(s) : Buffer.from(s, "base64").toString("binary");
        };
        function decode_b64_to_uint8_array_decodeB64ToUint8Array(b64Text) {
            var decodedString = decode_b64_to_uint8_array_atob(b64Text);
            var array = new Uint8Array(decodedString.length);
            for (var i = 0; i < decodedString.length; i++) array[i] = decodedString.charCodeAt(i);
            return array;
        }
        var xmldom_lib = __webpack_require__(969);
        const mpd_parser_es_isObject = obj => !!obj && typeof obj === "object";
        const merge = (...objects) => objects.reduce(((result, source) => {
            if (typeof source !== "object") return result;
            Object.keys(source).forEach((key => {
                if (Array.isArray(result[key]) && Array.isArray(source[key])) result[key] = result[key].concat(source[key]); else if (mpd_parser_es_isObject(result[key]) && mpd_parser_es_isObject(source[key])) result[key] = merge(result[key], source[key]); else result[key] = source[key];
            }));
            return result;
        }), {});
        const values = o => Object.keys(o).map((k => o[k]));
        const range = (start, end) => {
            const result = [];
            for (let i = start; i < end; i++) result.push(i);
            return result;
        };
        const flatten = lists => lists.reduce(((x, y) => x.concat(y)), []);
        const from = list => {
            if (!list.length) return [];
            const result = [];
            for (let i = 0; i < list.length; i++) result.push(list[i]);
            return result;
        };
        const findIndexes = (l, key) => l.reduce(((a, e, i) => {
            if (e[key]) a.push(i);
            return a;
        }), []);
        const union = (lists, keyFunction) => values(lists.reduce(((acc, list) => {
            list.forEach((el => {
                acc[keyFunction(el)] = el;
            }));
            return acc;
        }), {}));
        var errors = {
            INVALID_NUMBER_OF_PERIOD: "INVALID_NUMBER_OF_PERIOD",
            DASH_EMPTY_MANIFEST: "DASH_EMPTY_MANIFEST",
            DASH_INVALID_XML: "DASH_INVALID_XML",
            NO_BASE_URL: "NO_BASE_URL",
            MISSING_SEGMENT_INFORMATION: "MISSING_SEGMENT_INFORMATION",
            SEGMENT_TIME_UNSPECIFIED: "SEGMENT_TIME_UNSPECIFIED",
            UNSUPPORTED_UTC_TIMING_SCHEME: "UNSUPPORTED_UTC_TIMING_SCHEME"
        };
        const urlTypeToSegment = ({baseUrl = "", source = "", range = "", indexRange = ""}) => {
            const segment = {
                uri: source,
                resolvedUri: es_resolve_url(baseUrl || "", source)
            };
            if (range || indexRange) {
                const rangeStr = range ? range : indexRange;
                const ranges = rangeStr.split("-");
                let startRange = window_default().BigInt ? window_default().BigInt(ranges[0]) : parseInt(ranges[0], 10);
                let endRange = window_default().BigInt ? window_default().BigInt(ranges[1]) : parseInt(ranges[1], 10);
                if (startRange < Number.MAX_SAFE_INTEGER && typeof startRange === "bigint") startRange = Number(startRange);
                if (endRange < Number.MAX_SAFE_INTEGER && typeof endRange === "bigint") endRange = Number(endRange);
                let length;
                if (typeof endRange === "bigint" || typeof startRange === "bigint") length = window_default().BigInt(endRange) - window_default().BigInt(startRange) + window_default().BigInt(1); else length = endRange - startRange + 1;
                if (typeof length === "bigint" && length < Number.MAX_SAFE_INTEGER) length = Number(length);
                segment.byterange = {
                    length,
                    offset: startRange
                };
            }
            return segment;
        };
        const byteRangeToString = byterange => {
            let endRange;
            if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") endRange = window_default().BigInt(byterange.offset) + window_default().BigInt(byterange.length) - window_default().BigInt(1); else endRange = byterange.offset + byterange.length - 1;
            return `${byterange.offset}-${endRange}`;
        };
        const parseEndNumber = endNumber => {
            if (endNumber && typeof endNumber !== "number") endNumber = parseInt(endNumber, 10);
            if (isNaN(endNumber)) return null;
            return endNumber;
        };
        const segmentRange = {
            static(attributes) {
                const {duration, timescale = 1, sourceDuration, periodDuration} = attributes;
                const endNumber = parseEndNumber(attributes.endNumber);
                const segmentDuration = duration / timescale;
                if (typeof endNumber === "number") return {
                    start: 0,
                    end: endNumber
                };
                if (typeof periodDuration === "number") return {
                    start: 0,
                    end: periodDuration / segmentDuration
                };
                return {
                    start: 0,
                    end: sourceDuration / segmentDuration
                };
            },
            dynamic(attributes) {
                const {NOW, clientOffset, availabilityStartTime, timescale = 1, duration, periodStart = 0, minimumUpdatePeriod = 0, timeShiftBufferDepth = 1 / 0} = attributes;
                const endNumber = parseEndNumber(attributes.endNumber);
                const now = (NOW + clientOffset) / 1e3;
                const periodStartWC = availabilityStartTime + periodStart;
                const periodEndWC = now + minimumUpdatePeriod;
                const periodDuration = periodEndWC - periodStartWC;
                const segmentCount = Math.ceil(periodDuration * timescale / duration);
                const availableStart = Math.floor((now - periodStartWC - timeShiftBufferDepth) * timescale / duration);
                const availableEnd = Math.floor((now - periodStartWC) * timescale / duration);
                return {
                    start: Math.max(0, availableStart),
                    end: typeof endNumber === "number" ? endNumber : Math.min(segmentCount, availableEnd)
                };
            }
        };
        const toSegments = attributes => number => {
            const {duration, timescale = 1, periodStart, startNumber = 1} = attributes;
            return {
                number: startNumber + number,
                duration: duration / timescale,
                timeline: periodStart,
                time: number * duration
            };
        };
        const parseByDuration = attributes => {
            const {type, duration, timescale = 1, periodDuration, sourceDuration} = attributes;
            const {start, end} = segmentRange[type](attributes);
            const segments = range(start, end).map(toSegments(attributes));
            if (type === "static") {
                const index = segments.length - 1;
                const sectionDuration = typeof periodDuration === "number" ? periodDuration : sourceDuration;
                segments[index].duration = sectionDuration - duration / timescale * index;
            }
            return segments;
        };
        const segmentsFromBase = attributes => {
            const {baseUrl, initialization = {}, sourceDuration, indexRange = "", periodStart, presentationTime, number = 0, duration} = attributes;
            if (!baseUrl) throw new Error(errors.NO_BASE_URL);
            const initSegment = urlTypeToSegment({
                baseUrl,
                source: initialization.sourceURL,
                range: initialization.range
            });
            const segment = urlTypeToSegment({
                baseUrl,
                source: baseUrl,
                indexRange
            });
            segment.map = initSegment;
            if (duration) {
                const segmentTimeInfo = parseByDuration(attributes);
                if (segmentTimeInfo.length) {
                    segment.duration = segmentTimeInfo[0].duration;
                    segment.timeline = segmentTimeInfo[0].timeline;
                }
            } else if (sourceDuration) {
                segment.duration = sourceDuration;
                segment.timeline = periodStart;
            }
            segment.presentationTime = presentationTime || periodStart;
            segment.number = number;
            return [ segment ];
        };
        const addSidxSegmentsToPlaylist$1 = (playlist, sidx, baseUrl) => {
            const initSegment = playlist.sidx.map ? playlist.sidx.map : null;
            const sourceDuration = playlist.sidx.duration;
            const timeline = playlist.timeline || 0;
            const sidxByteRange = playlist.sidx.byterange;
            const sidxEnd = sidxByteRange.offset + sidxByteRange.length;
            const timescale = sidx.timescale;
            const mediaReferences = sidx.references.filter((r => r.referenceType !== 1));
            const segments = [];
            const type = playlist.endList ? "static" : "dynamic";
            const periodStart = playlist.sidx.timeline;
            let presentationTime = periodStart;
            let number = playlist.mediaSequence || 0;
            let startIndex;
            if (typeof sidx.firstOffset === "bigint") startIndex = window_default().BigInt(sidxEnd) + sidx.firstOffset; else startIndex = sidxEnd + sidx.firstOffset;
            for (let i = 0; i < mediaReferences.length; i++) {
                const reference = sidx.references[i];
                const size = reference.referencedSize;
                const duration = reference.subsegmentDuration;
                let endIndex;
                if (typeof startIndex === "bigint") endIndex = startIndex + window_default().BigInt(size) - window_default().BigInt(1); else endIndex = startIndex + size - 1;
                const indexRange = `${startIndex}-${endIndex}`;
                const attributes = {
                    baseUrl,
                    timescale,
                    timeline,
                    periodStart,
                    presentationTime,
                    number,
                    duration,
                    sourceDuration,
                    indexRange,
                    type
                };
                const segment = segmentsFromBase(attributes)[0];
                if (initSegment) segment.map = initSegment;
                segments.push(segment);
                if (typeof startIndex === "bigint") startIndex += window_default().BigInt(size); else startIndex += size;
                presentationTime += duration / timescale;
                number++;
            }
            playlist.segments = segments;
            return playlist;
        };
        const SUPPORTED_MEDIA_TYPES = [ "AUDIO", "SUBTITLES" ];
        const TIME_FUDGE = 1 / 60;
        const getUniqueTimelineStarts = timelineStarts => union(timelineStarts, (({timeline}) => timeline)).sort(((a, b) => a.timeline > b.timeline ? 1 : -1));
        const findPlaylistWithName = (playlists, name) => {
            for (let i = 0; i < playlists.length; i++) if (playlists[i].attributes.NAME === name) return playlists[i];
            return null;
        };
        const getMediaGroupPlaylists = manifest => {
            let mediaGroupPlaylists = [];
            forEachMediaGroup(manifest, SUPPORTED_MEDIA_TYPES, ((properties, type, group, label) => {
                mediaGroupPlaylists = mediaGroupPlaylists.concat(properties.playlists || []);
            }));
            return mediaGroupPlaylists;
        };
        const updateMediaSequenceForPlaylist = ({playlist, mediaSequence}) => {
            playlist.mediaSequence = mediaSequence;
            playlist.segments.forEach(((segment, index) => {
                segment.number = playlist.mediaSequence + index;
            }));
        };
        const updateSequenceNumbers = ({oldPlaylists, newPlaylists, timelineStarts}) => {
            newPlaylists.forEach((playlist => {
                playlist.discontinuitySequence = timelineStarts.findIndex((function({timeline}) {
                    return timeline === playlist.timeline;
                }));
                const oldPlaylist = findPlaylistWithName(oldPlaylists, playlist.attributes.NAME);
                if (!oldPlaylist) return;
                if (playlist.sidx) return;
                const firstNewSegment = playlist.segments[0];
                const oldMatchingSegmentIndex = oldPlaylist.segments.findIndex((function(oldSegment) {
                    return Math.abs(oldSegment.presentationTime - firstNewSegment.presentationTime) < TIME_FUDGE;
                }));
                if (oldMatchingSegmentIndex === -1) {
                    updateMediaSequenceForPlaylist({
                        playlist,
                        mediaSequence: oldPlaylist.mediaSequence + oldPlaylist.segments.length
                    });
                    playlist.segments[0].discontinuity = true;
                    playlist.discontinuityStarts.unshift(0);
                    if (!oldPlaylist.segments.length && playlist.timeline > oldPlaylist.timeline || oldPlaylist.segments.length && playlist.timeline > oldPlaylist.segments[oldPlaylist.segments.length - 1].timeline) playlist.discontinuitySequence--;
                    return;
                }
                const oldMatchingSegment = oldPlaylist.segments[oldMatchingSegmentIndex];
                if (oldMatchingSegment.discontinuity && !firstNewSegment.discontinuity) {
                    firstNewSegment.discontinuity = true;
                    playlist.discontinuityStarts.unshift(0);
                    playlist.discontinuitySequence--;
                }
                updateMediaSequenceForPlaylist({
                    playlist,
                    mediaSequence: oldPlaylist.segments[oldMatchingSegmentIndex].number
                });
            }));
        };
        const positionManifestOnTimeline = ({oldManifest, newManifest}) => {
            const oldPlaylists = oldManifest.playlists.concat(getMediaGroupPlaylists(oldManifest));
            const newPlaylists = newManifest.playlists.concat(getMediaGroupPlaylists(newManifest));
            newManifest.timelineStarts = getUniqueTimelineStarts([ oldManifest.timelineStarts, newManifest.timelineStarts ]);
            updateSequenceNumbers({
                oldPlaylists,
                newPlaylists,
                timelineStarts: newManifest.timelineStarts
            });
            return newManifest;
        };
        const generateSidxKey = sidx => sidx && sidx.uri + "-" + byteRangeToString(sidx.byterange);
        const mergeDiscontiguousPlaylists = playlists => {
            const mergedPlaylists = values(playlists.reduce(((acc, playlist) => {
                const name = playlist.attributes.id + (playlist.attributes.lang || "");
                if (!acc[name]) {
                    acc[name] = playlist;
                    acc[name].attributes.timelineStarts = [];
                } else {
                    if (playlist.segments) {
                        if (playlist.segments[0]) playlist.segments[0].discontinuity = true;
                        acc[name].segments.push(...playlist.segments);
                    }
                    if (playlist.attributes.contentProtection) acc[name].attributes.contentProtection = playlist.attributes.contentProtection;
                }
                acc[name].attributes.timelineStarts.push({
                    start: playlist.attributes.periodStart,
                    timeline: playlist.attributes.periodStart
                });
                return acc;
            }), {}));
            return mergedPlaylists.map((playlist => {
                playlist.discontinuityStarts = findIndexes(playlist.segments || [], "discontinuity");
                return playlist;
            }));
        };
        const addSidxSegmentsToPlaylist = (playlist, sidxMapping) => {
            const sidxKey = generateSidxKey(playlist.sidx);
            const sidxMatch = sidxKey && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx;
            if (sidxMatch) addSidxSegmentsToPlaylist$1(playlist, sidxMatch, playlist.sidx.resolvedUri);
            return playlist;
        };
        const addSidxSegmentsToPlaylists = (playlists, sidxMapping = {}) => {
            if (!Object.keys(sidxMapping).length) return playlists;
            for (const i in playlists) playlists[i] = addSidxSegmentsToPlaylist(playlists[i], sidxMapping);
            return playlists;
        };
        const formatAudioPlaylist = ({attributes, segments, sidx, mediaSequence, discontinuitySequence, discontinuityStarts}, isAudioOnly) => {
            const playlist = {
                attributes: {
                    NAME: attributes.id,
                    BANDWIDTH: attributes.bandwidth,
                    CODECS: attributes.codecs,
                    ["PROGRAM-ID"]: 1
                },
                uri: "",
                endList: attributes.type === "static",
                timeline: attributes.periodStart,
                resolvedUri: "",
                targetDuration: attributes.duration,
                discontinuitySequence,
                discontinuityStarts,
                timelineStarts: attributes.timelineStarts,
                mediaSequence,
                segments
            };
            if (attributes.contentProtection) playlist.contentProtection = attributes.contentProtection;
            if (sidx) playlist.sidx = sidx;
            if (isAudioOnly) {
                playlist.attributes.AUDIO = "audio";
                playlist.attributes.SUBTITLES = "subs";
            }
            return playlist;
        };
        const formatVttPlaylist = ({attributes, segments, mediaSequence, discontinuityStarts, discontinuitySequence}) => {
            if (typeof segments === "undefined") {
                segments = [ {
                    uri: attributes.baseUrl,
                    timeline: attributes.periodStart,
                    resolvedUri: attributes.baseUrl || "",
                    duration: attributes.sourceDuration,
                    number: 0
                } ];
                attributes.duration = attributes.sourceDuration;
            }
            const m3u8Attributes = {
                NAME: attributes.id,
                BANDWIDTH: attributes.bandwidth,
                ["PROGRAM-ID"]: 1
            };
            if (attributes.codecs) m3u8Attributes.CODECS = attributes.codecs;
            return {
                attributes: m3u8Attributes,
                uri: "",
                endList: attributes.type === "static",
                timeline: attributes.periodStart,
                resolvedUri: attributes.baseUrl || "",
                targetDuration: attributes.duration,
                timelineStarts: attributes.timelineStarts,
                discontinuityStarts,
                discontinuitySequence,
                mediaSequence,
                segments
            };
        };
        const organizeAudioPlaylists = (playlists, sidxMapping = {}, isAudioOnly = false) => {
            let mainPlaylist;
            const formattedPlaylists = playlists.reduce(((a, playlist) => {
                const role = playlist.attributes.role && playlist.attributes.role.value || "";
                const language = playlist.attributes.lang || "";
                let label = playlist.attributes.label || "main";
                if (language && !playlist.attributes.label) {
                    const roleLabel = role ? ` (${role})` : "";
                    label = `${playlist.attributes.lang}${roleLabel}`;
                }
                if (!a[label]) a[label] = {
                    language,
                    autoselect: true,
                    default: role === "main",
                    playlists: [],
                    uri: ""
                };
                const formatted = addSidxSegmentsToPlaylist(formatAudioPlaylist(playlist, isAudioOnly), sidxMapping);
                a[label].playlists.push(formatted);
                if (typeof mainPlaylist === "undefined" && role === "main") {
                    mainPlaylist = playlist;
                    mainPlaylist.default = true;
                }
                return a;
            }), {});
            if (!mainPlaylist) {
                const firstLabel = Object.keys(formattedPlaylists)[0];
                formattedPlaylists[firstLabel].default = true;
            }
            return formattedPlaylists;
        };
        const organizeVttPlaylists = (playlists, sidxMapping = {}) => playlists.reduce(((a, playlist) => {
            const label = playlist.attributes.label || playlist.attributes.lang || "text";
            if (!a[label]) a[label] = {
                language: label,
                default: false,
                autoselect: false,
                playlists: [],
                uri: ""
            };
            a[label].playlists.push(addSidxSegmentsToPlaylist(formatVttPlaylist(playlist), sidxMapping));
            return a;
        }), {});
        const organizeCaptionServices = captionServices => captionServices.reduce(((svcObj, svc) => {
            if (!svc) return svcObj;
            svc.forEach((service => {
                const {channel, language} = service;
                svcObj[language] = {
                    autoselect: false,
                    default: false,
                    instreamId: channel,
                    language
                };
                if (service.hasOwnProperty("aspectRatio")) svcObj[language].aspectRatio = service.aspectRatio;
                if (service.hasOwnProperty("easyReader")) svcObj[language].easyReader = service.easyReader;
                if (service.hasOwnProperty("3D")) svcObj[language]["3D"] = service["3D"];
            }));
            return svcObj;
        }), {});
        const formatVideoPlaylist = ({attributes, segments, sidx, discontinuityStarts}) => {
            const playlist = {
                attributes: {
                    NAME: attributes.id,
                    AUDIO: "audio",
                    SUBTITLES: "subs",
                    RESOLUTION: {
                        width: attributes.width,
                        height: attributes.height
                    },
                    CODECS: attributes.codecs,
                    BANDWIDTH: attributes.bandwidth,
                    ["PROGRAM-ID"]: 1
                },
                uri: "",
                endList: attributes.type === "static",
                timeline: attributes.periodStart,
                resolvedUri: "",
                targetDuration: attributes.duration,
                discontinuityStarts,
                timelineStarts: attributes.timelineStarts,
                segments
            };
            if (attributes.frameRate) playlist.attributes["FRAME-RATE"] = attributes.frameRate;
            if (attributes.contentProtection) playlist.contentProtection = attributes.contentProtection;
            if (sidx) playlist.sidx = sidx;
            return playlist;
        };
        const videoOnly = ({attributes}) => attributes.mimeType === "video/mp4" || attributes.mimeType === "video/webm" || attributes.contentType === "video";
        const audioOnly = ({attributes}) => attributes.mimeType === "audio/mp4" || attributes.mimeType === "audio/webm" || attributes.contentType === "audio";
        const vttOnly = ({attributes}) => attributes.mimeType === "text/vtt" || attributes.contentType === "text";
        const addMediaSequenceValues = (playlists, timelineStarts) => {
            playlists.forEach((playlist => {
                playlist.mediaSequence = 0;
                playlist.discontinuitySequence = timelineStarts.findIndex((function({timeline}) {
                    return timeline === playlist.timeline;
                }));
                if (!playlist.segments) return;
                playlist.segments.forEach(((segment, index) => {
                    segment.number = index;
                }));
            }));
        };
        const flattenMediaGroupPlaylists = mediaGroupObject => {
            if (!mediaGroupObject) return [];
            return Object.keys(mediaGroupObject).reduce(((acc, label) => {
                const labelContents = mediaGroupObject[label];
                return acc.concat(labelContents.playlists);
            }), []);
        };
        const toM3u8 = ({dashPlaylists, locations, sidxMapping = {}, previousManifest, eventStream}) => {
            if (!dashPlaylists.length) return {};
            const {sourceDuration: duration, type, suggestedPresentationDelay, minimumUpdatePeriod} = dashPlaylists[0].attributes;
            const videoPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(videoOnly)).map(formatVideoPlaylist);
            const audioPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(audioOnly));
            const vttPlaylists = mergeDiscontiguousPlaylists(dashPlaylists.filter(vttOnly));
            const captions = dashPlaylists.map((playlist => playlist.attributes.captionServices)).filter(Boolean);
            const manifest = {
                allowCache: true,
                discontinuityStarts: [],
                segments: [],
                endList: true,
                mediaGroups: {
                    AUDIO: {},
                    VIDEO: {},
                    ["CLOSED-CAPTIONS"]: {},
                    SUBTITLES: {}
                },
                uri: "",
                duration,
                playlists: addSidxSegmentsToPlaylists(videoPlaylists, sidxMapping)
            };
            if (minimumUpdatePeriod >= 0) manifest.minimumUpdatePeriod = minimumUpdatePeriod * 1e3;
            if (locations) manifest.locations = locations;
            if (type === "dynamic") manifest.suggestedPresentationDelay = suggestedPresentationDelay;
            if (eventStream && eventStream.length > 0) manifest.eventStream = eventStream;
            const isAudioOnly = manifest.playlists.length === 0;
            const organizedAudioGroup = audioPlaylists.length ? organizeAudioPlaylists(audioPlaylists, sidxMapping, isAudioOnly) : null;
            const organizedVttGroup = vttPlaylists.length ? organizeVttPlaylists(vttPlaylists, sidxMapping) : null;
            const formattedPlaylists = videoPlaylists.concat(flattenMediaGroupPlaylists(organizedAudioGroup), flattenMediaGroupPlaylists(organizedVttGroup));
            const playlistTimelineStarts = formattedPlaylists.map((({timelineStarts}) => timelineStarts));
            manifest.timelineStarts = getUniqueTimelineStarts(playlistTimelineStarts);
            addMediaSequenceValues(formattedPlaylists, manifest.timelineStarts);
            if (organizedAudioGroup) manifest.mediaGroups.AUDIO.audio = organizedAudioGroup;
            if (organizedVttGroup) manifest.mediaGroups.SUBTITLES.subs = organizedVttGroup;
            if (captions.length) manifest.mediaGroups["CLOSED-CAPTIONS"].cc = organizeCaptionServices(captions);
            if (previousManifest) return positionManifestOnTimeline({
                oldManifest: previousManifest,
                newManifest: manifest
            });
            return manifest;
        };
        const getLiveRValue = (attributes, time, duration) => {
            const {NOW, clientOffset, availabilityStartTime, timescale = 1, periodStart = 0, minimumUpdatePeriod = 0} = attributes;
            const now = (NOW + clientOffset) / 1e3;
            const periodStartWC = availabilityStartTime + periodStart;
            const periodEndWC = now + minimumUpdatePeriod;
            const periodDuration = periodEndWC - periodStartWC;
            return Math.ceil((periodDuration * timescale - time) / duration);
        };
        const parseByTimeline = (attributes, segmentTimeline) => {
            const {type, minimumUpdatePeriod = 0, media = "", sourceDuration, timescale = 1, startNumber = 1, periodStart: timeline} = attributes;
            const segments = [];
            let time = -1;
            for (let sIndex = 0; sIndex < segmentTimeline.length; sIndex++) {
                const S = segmentTimeline[sIndex];
                const duration = S.d;
                const repeat = S.r || 0;
                const segmentTime = S.t || 0;
                if (time < 0) time = segmentTime;
                if (segmentTime && segmentTime > time) time = segmentTime;
                let count;
                if (repeat < 0) {
                    const nextS = sIndex + 1;
                    if (nextS === segmentTimeline.length) if (type === "dynamic" && minimumUpdatePeriod > 0 && media.indexOf("$Number$") > 0) count = getLiveRValue(attributes, time, duration); else count = (sourceDuration * timescale - time) / duration; else count = (segmentTimeline[nextS].t - time) / duration;
                } else count = repeat + 1;
                const end = startNumber + segments.length + count;
                let number = startNumber + segments.length;
                while (number < end) {
                    segments.push({
                        number,
                        duration: duration / timescale,
                        time,
                        timeline
                    });
                    time += duration;
                    number++;
                }
            }
            return segments;
        };
        const identifierPattern = /\$([A-z]*)(?:(%0)([0-9]+)d)?\$/g;
        const identifierReplacement = values => (match, identifier, format, width) => {
            if (match === "$$") return "$";
            if (typeof values[identifier] === "undefined") return match;
            const value = "" + values[identifier];
            if (identifier === "RepresentationID") return value;
            if (!format) width = 1; else width = parseInt(width, 10);
            if (value.length >= width) return value;
            return `${new Array(width - value.length + 1).join("0")}${value}`;
        };
        const constructTemplateUrl = (url, values) => url.replace(identifierPattern, identifierReplacement(values));
        const parseTemplateInfo = (attributes, segmentTimeline) => {
            if (!attributes.duration && !segmentTimeline) return [ {
                number: attributes.startNumber || 1,
                duration: attributes.sourceDuration,
                time: 0,
                timeline: attributes.periodStart
            } ];
            if (attributes.duration) return parseByDuration(attributes);
            return parseByTimeline(attributes, segmentTimeline);
        };
        const segmentsFromTemplate = (attributes, segmentTimeline) => {
            const templateValues = {
                RepresentationID: attributes.id,
                Bandwidth: attributes.bandwidth || 0
            };
            const {initialization = {
                sourceURL: "",
                range: ""
            }} = attributes;
            const mapSegment = urlTypeToSegment({
                baseUrl: attributes.baseUrl,
                source: constructTemplateUrl(initialization.sourceURL, templateValues),
                range: initialization.range
            });
            const segments = parseTemplateInfo(attributes, segmentTimeline);
            return segments.map((segment => {
                templateValues.Number = segment.number;
                templateValues.Time = segment.time;
                const uri = constructTemplateUrl(attributes.media || "", templateValues);
                const timescale = attributes.timescale || 1;
                const presentationTimeOffset = attributes.presentationTimeOffset || 0;
                const presentationTime = attributes.periodStart + (segment.time - presentationTimeOffset) / timescale;
                const map = {
                    uri,
                    timeline: segment.timeline,
                    duration: segment.duration,
                    resolvedUri: es_resolve_url(attributes.baseUrl || "", uri),
                    map: mapSegment,
                    number: segment.number,
                    presentationTime
                };
                return map;
            }));
        };
        const SegmentURLToSegmentObject = (attributes, segmentUrl) => {
            const {baseUrl, initialization = {}} = attributes;
            const initSegment = urlTypeToSegment({
                baseUrl,
                source: initialization.sourceURL,
                range: initialization.range
            });
            const segment = urlTypeToSegment({
                baseUrl,
                source: segmentUrl.media,
                range: segmentUrl.mediaRange
            });
            segment.map = initSegment;
            return segment;
        };
        const segmentsFromList = (attributes, segmentTimeline) => {
            const {duration, segmentUrls = [], periodStart} = attributes;
            if (!duration && !segmentTimeline || duration && segmentTimeline) throw new Error(errors.SEGMENT_TIME_UNSPECIFIED);
            const segmentUrlMap = segmentUrls.map((segmentUrlObject => SegmentURLToSegmentObject(attributes, segmentUrlObject)));
            let segmentTimeInfo;
            if (duration) segmentTimeInfo = parseByDuration(attributes);
            if (segmentTimeline) segmentTimeInfo = parseByTimeline(attributes, segmentTimeline);
            const segments = segmentTimeInfo.map(((segmentTime, index) => {
                if (segmentUrlMap[index]) {
                    const segment = segmentUrlMap[index];
                    const timescale = attributes.timescale || 1;
                    const presentationTimeOffset = attributes.presentationTimeOffset || 0;
                    segment.timeline = segmentTime.timeline;
                    segment.duration = segmentTime.duration;
                    segment.number = segmentTime.number;
                    segment.presentationTime = periodStart + (segmentTime.time - presentationTimeOffset) / timescale;
                    return segment;
                }
            })).filter((segment => segment));
            return segments;
        };
        const generateSegments = ({attributes, segmentInfo}) => {
            let segmentAttributes;
            let segmentsFn;
            if (segmentInfo.template) {
                segmentsFn = segmentsFromTemplate;
                segmentAttributes = merge(attributes, segmentInfo.template);
            } else if (segmentInfo.base) {
                segmentsFn = segmentsFromBase;
                segmentAttributes = merge(attributes, segmentInfo.base);
            } else if (segmentInfo.list) {
                segmentsFn = segmentsFromList;
                segmentAttributes = merge(attributes, segmentInfo.list);
            }
            const segmentsInfo = {
                attributes
            };
            if (!segmentsFn) return segmentsInfo;
            const segments = segmentsFn(segmentAttributes, segmentInfo.segmentTimeline);
            if (segmentAttributes.duration) {
                const {duration, timescale = 1} = segmentAttributes;
                segmentAttributes.duration = duration / timescale;
            } else if (segments.length) segmentAttributes.duration = segments.reduce(((max, segment) => Math.max(max, Math.ceil(segment.duration))), 0); else segmentAttributes.duration = 0;
            segmentsInfo.attributes = segmentAttributes;
            segmentsInfo.segments = segments;
            if (segmentInfo.base && segmentAttributes.indexRange) {
                segmentsInfo.sidx = segments[0];
                segmentsInfo.segments = [];
            }
            return segmentsInfo;
        };
        const toPlaylists = representations => representations.map(generateSegments);
        const findChildren = (element, name) => from(element.childNodes).filter((({tagName}) => tagName === name));
        const getContent = element => element.textContent.trim();
        const parseDivisionValue = value => parseFloat(value.split("/").reduce(((prev, current) => prev / current)));
        const parseDuration = str => {
            const SECONDS_IN_YEAR = 365 * 24 * 60 * 60;
            const SECONDS_IN_MONTH = 30 * 24 * 60 * 60;
            const SECONDS_IN_DAY = 24 * 60 * 60;
            const SECONDS_IN_HOUR = 60 * 60;
            const SECONDS_IN_MIN = 60;
            const durationRegex = /P(?:(\d*)Y)?(?:(\d*)M)?(?:(\d*)D)?(?:T(?:(\d*)H)?(?:(\d*)M)?(?:([\d.]*)S)?)?/;
            const match = durationRegex.exec(str);
            if (!match) return 0;
            const [year, month, day, hour, minute, second] = match.slice(1);
            return parseFloat(year || 0) * SECONDS_IN_YEAR + parseFloat(month || 0) * SECONDS_IN_MONTH + parseFloat(day || 0) * SECONDS_IN_DAY + parseFloat(hour || 0) * SECONDS_IN_HOUR + parseFloat(minute || 0) * SECONDS_IN_MIN + parseFloat(second || 0);
        };
        const parseDate = str => {
            const dateRegex = /^\d+-\d+-\d+T\d+:\d+:\d+(\.\d+)?$/;
            if (dateRegex.test(str)) str += "Z";
            return Date.parse(str);
        };
        const parsers = {
            mediaPresentationDuration(value) {
                return parseDuration(value);
            },
            availabilityStartTime(value) {
                return parseDate(value) / 1e3;
            },
            minimumUpdatePeriod(value) {
                return parseDuration(value);
            },
            suggestedPresentationDelay(value) {
                return parseDuration(value);
            },
            type(value) {
                return value;
            },
            timeShiftBufferDepth(value) {
                return parseDuration(value);
            },
            start(value) {
                return parseDuration(value);
            },
            width(value) {
                return parseInt(value, 10);
            },
            height(value) {
                return parseInt(value, 10);
            },
            bandwidth(value) {
                return parseInt(value, 10);
            },
            frameRate(value) {
                return parseDivisionValue(value);
            },
            startNumber(value) {
                return parseInt(value, 10);
            },
            timescale(value) {
                return parseInt(value, 10);
            },
            presentationTimeOffset(value) {
                return parseInt(value, 10);
            },
            duration(value) {
                const parsedValue = parseInt(value, 10);
                if (isNaN(parsedValue)) return parseDuration(value);
                return parsedValue;
            },
            d(value) {
                return parseInt(value, 10);
            },
            t(value) {
                return parseInt(value, 10);
            },
            r(value) {
                return parseInt(value, 10);
            },
            presentationTime(value) {
                return parseInt(value, 10);
            },
            DEFAULT(value) {
                return value;
            }
        };
        const mpd_parser_es_parseAttributes = el => {
            if (!(el && el.attributes)) return {};
            return from(el.attributes).reduce(((a, e) => {
                const parseFn = parsers[e.name] || parsers.DEFAULT;
                a[e.name] = parseFn(e.value);
                return a;
            }), {});
        };
        const keySystemsMap = {
            "urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b": "org.w3.clearkey",
            "urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed": "com.widevine.alpha",
            "urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95": "com.microsoft.playready",
            "urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb": "com.adobe.primetime"
        };
        const buildBaseUrls = (referenceUrls, baseUrlElements) => {
            if (!baseUrlElements.length) return referenceUrls;
            return flatten(referenceUrls.map((function(reference) {
                return baseUrlElements.map((function(baseUrlElement) {
                    return es_resolve_url(reference, getContent(baseUrlElement));
                }));
            })));
        };
        const getSegmentInformation = adaptationSet => {
            const segmentTemplate = findChildren(adaptationSet, "SegmentTemplate")[0];
            const segmentList = findChildren(adaptationSet, "SegmentList")[0];
            const segmentUrls = segmentList && findChildren(segmentList, "SegmentURL").map((s => merge({
                tag: "SegmentURL"
            }, mpd_parser_es_parseAttributes(s))));
            const segmentBase = findChildren(adaptationSet, "SegmentBase")[0];
            const segmentTimelineParentNode = segmentList || segmentTemplate;
            const segmentTimeline = segmentTimelineParentNode && findChildren(segmentTimelineParentNode, "SegmentTimeline")[0];
            const segmentInitializationParentNode = segmentList || segmentBase || segmentTemplate;
            const segmentInitialization = segmentInitializationParentNode && findChildren(segmentInitializationParentNode, "Initialization")[0];
            const template = segmentTemplate && mpd_parser_es_parseAttributes(segmentTemplate);
            if (template && segmentInitialization) template.initialization = segmentInitialization && mpd_parser_es_parseAttributes(segmentInitialization); else if (template && template.initialization) template.initialization = {
                sourceURL: template.initialization
            };
            const segmentInfo = {
                template,
                segmentTimeline: segmentTimeline && findChildren(segmentTimeline, "S").map((s => mpd_parser_es_parseAttributes(s))),
                list: segmentList && merge(mpd_parser_es_parseAttributes(segmentList), {
                    segmentUrls,
                    initialization: mpd_parser_es_parseAttributes(segmentInitialization)
                }),
                base: segmentBase && merge(mpd_parser_es_parseAttributes(segmentBase), {
                    initialization: mpd_parser_es_parseAttributes(segmentInitialization)
                })
            };
            Object.keys(segmentInfo).forEach((key => {
                if (!segmentInfo[key]) delete segmentInfo[key];
            }));
            return segmentInfo;
        };
        const inheritBaseUrls = (adaptationSetAttributes, adaptationSetBaseUrls, adaptationSetSegmentInfo) => representation => {
            const repBaseUrlElements = findChildren(representation, "BaseURL");
            const repBaseUrls = buildBaseUrls(adaptationSetBaseUrls, repBaseUrlElements);
            const attributes = merge(adaptationSetAttributes, mpd_parser_es_parseAttributes(representation));
            const representationSegmentInfo = getSegmentInformation(representation);
            return repBaseUrls.map((baseUrl => ({
                segmentInfo: merge(adaptationSetSegmentInfo, representationSegmentInfo),
                attributes: merge(attributes, {
                    baseUrl
                })
            })));
        };
        const generateKeySystemInformation = contentProtectionNodes => contentProtectionNodes.reduce(((acc, node) => {
            const attributes = mpd_parser_es_parseAttributes(node);
            if (attributes.schemeIdUri) attributes.schemeIdUri = attributes.schemeIdUri.toLowerCase();
            const keySystem = keySystemsMap[attributes.schemeIdUri];
            if (keySystem) {
                acc[keySystem] = {
                    attributes
                };
                const psshNode = findChildren(node, "cenc:pssh")[0];
                if (psshNode) {
                    const pssh = getContent(psshNode);
                    acc[keySystem].pssh = pssh && decode_b64_to_uint8_array_decodeB64ToUint8Array(pssh);
                }
            }
            return acc;
        }), {});
        const parseCaptionServiceMetadata = service => {
            if (service.schemeIdUri === "urn:scte:dash:cc:cea-608:2015") {
                const values = typeof service.value !== "string" ? [] : service.value.split(";");
                return values.map((value => {
                    let channel;
                    let language;
                    language = value;
                    if (/^CC\d=/.test(value)) [channel, language] = value.split("="); else if (/^CC\d$/.test(value)) channel = value;
                    return {
                        channel,
                        language
                    };
                }));
            } else if (service.schemeIdUri === "urn:scte:dash:cc:cea-708:2015") {
                const values = typeof service.value !== "string" ? [] : service.value.split(";");
                return values.map((value => {
                    const flags = {
                        channel: void 0,
                        language: void 0,
                        aspectRatio: 1,
                        easyReader: 0,
                        "3D": 0
                    };
                    if (/=/.test(value)) {
                        const [channel, opts = ""] = value.split("=");
                        flags.channel = channel;
                        flags.language = value;
                        opts.split(",").forEach((opt => {
                            const [name, val] = opt.split(":");
                            if (name === "lang") flags.language = val; else if (name === "er") flags.easyReader = Number(val); else if (name === "war") flags.aspectRatio = Number(val); else if (name === "3D") flags["3D"] = Number(val);
                        }));
                    } else flags.language = value;
                    if (flags.channel) flags.channel = "SERVICE" + flags.channel;
                    return flags;
                }));
            }
        };
        const toEventStream = period => flatten(findChildren(period.node, "EventStream").map((eventStream => {
            const eventStreamAttributes = mpd_parser_es_parseAttributes(eventStream);
            const schemeIdUri = eventStreamAttributes.schemeIdUri;
            return findChildren(eventStream, "Event").map((event => {
                const eventAttributes = mpd_parser_es_parseAttributes(event);
                const presentationTime = eventAttributes.presentationTime || 0;
                const timescale = eventStreamAttributes.timescale || 1;
                const duration = eventAttributes.duration || 0;
                const start = presentationTime / timescale + period.attributes.start;
                return {
                    schemeIdUri,
                    value: eventStreamAttributes.value,
                    id: eventAttributes.id,
                    start,
                    end: start + duration / timescale,
                    messageData: getContent(event) || eventAttributes.messageData,
                    contentEncoding: eventStreamAttributes.contentEncoding,
                    presentationTimeOffset: eventStreamAttributes.presentationTimeOffset || 0
                };
            }));
        })));
        const toRepresentations = (periodAttributes, periodBaseUrls, periodSegmentInfo) => adaptationSet => {
            const adaptationSetAttributes = mpd_parser_es_parseAttributes(adaptationSet);
            const adaptationSetBaseUrls = buildBaseUrls(periodBaseUrls, findChildren(adaptationSet, "BaseURL"));
            const role = findChildren(adaptationSet, "Role")[0];
            const roleAttributes = {
                role: mpd_parser_es_parseAttributes(role)
            };
            let attrs = merge(periodAttributes, adaptationSetAttributes, roleAttributes);
            const accessibility = findChildren(adaptationSet, "Accessibility")[0];
            const captionServices = parseCaptionServiceMetadata(mpd_parser_es_parseAttributes(accessibility));
            if (captionServices) attrs = merge(attrs, {
                captionServices
            });
            const label = findChildren(adaptationSet, "Label")[0];
            if (label && label.childNodes.length) {
                const labelVal = label.childNodes[0].nodeValue.trim();
                attrs = merge(attrs, {
                    label: labelVal
                });
            }
            const contentProtection = generateKeySystemInformation(findChildren(adaptationSet, "ContentProtection"));
            if (Object.keys(contentProtection).length) attrs = merge(attrs, {
                contentProtection
            });
            const segmentInfo = getSegmentInformation(adaptationSet);
            const representations = findChildren(adaptationSet, "Representation");
            const adaptationSetSegmentInfo = merge(periodSegmentInfo, segmentInfo);
            return flatten(representations.map(inheritBaseUrls(attrs, adaptationSetBaseUrls, adaptationSetSegmentInfo)));
        };
        const toAdaptationSets = (mpdAttributes, mpdBaseUrls) => (period, index) => {
            const periodBaseUrls = buildBaseUrls(mpdBaseUrls, findChildren(period.node, "BaseURL"));
            const periodAttributes = merge(mpdAttributes, {
                periodStart: period.attributes.start
            });
            if (typeof period.attributes.duration === "number") periodAttributes.periodDuration = period.attributes.duration;
            const adaptationSets = findChildren(period.node, "AdaptationSet");
            const periodSegmentInfo = getSegmentInformation(period.node);
            return flatten(adaptationSets.map(toRepresentations(periodAttributes, periodBaseUrls, periodSegmentInfo)));
        };
        const getPeriodStart = ({attributes, priorPeriodAttributes, mpdType}) => {
            if (typeof attributes.start === "number") return attributes.start;
            if (priorPeriodAttributes && typeof priorPeriodAttributes.start === "number" && typeof priorPeriodAttributes.duration === "number") return priorPeriodAttributes.start + priorPeriodAttributes.duration;
            if (!priorPeriodAttributes && mpdType === "static") return 0;
            return null;
        };
        const inheritAttributes = (mpd, options = {}) => {
            const {manifestUri = "", NOW = Date.now(), clientOffset = 0} = options;
            const periodNodes = findChildren(mpd, "Period");
            if (!periodNodes.length) throw new Error(errors.INVALID_NUMBER_OF_PERIOD);
            const locations = findChildren(mpd, "Location");
            const mpdAttributes = mpd_parser_es_parseAttributes(mpd);
            const mpdBaseUrls = buildBaseUrls([ manifestUri ], findChildren(mpd, "BaseURL"));
            mpdAttributes.type = mpdAttributes.type || "static";
            mpdAttributes.sourceDuration = mpdAttributes.mediaPresentationDuration || 0;
            mpdAttributes.NOW = NOW;
            mpdAttributes.clientOffset = clientOffset;
            if (locations.length) mpdAttributes.locations = locations.map(getContent);
            const periods = [];
            periodNodes.forEach(((node, index) => {
                const attributes = mpd_parser_es_parseAttributes(node);
                const priorPeriod = periods[index - 1];
                attributes.start = getPeriodStart({
                    attributes,
                    priorPeriodAttributes: priorPeriod ? priorPeriod.attributes : null,
                    mpdType: mpdAttributes.type
                });
                periods.push({
                    node,
                    attributes
                });
            }));
            return {
                locations: mpdAttributes.locations,
                representationInfo: flatten(periods.map(toAdaptationSets(mpdAttributes, mpdBaseUrls))),
                eventStream: flatten(periods.map(toEventStream))
            };
        };
        const stringToMpdXml = manifestString => {
            if (manifestString === "") throw new Error(errors.DASH_EMPTY_MANIFEST);
            const parser = new xmldom_lib.DOMParser;
            let xml;
            let mpd;
            try {
                xml = parser.parseFromString(manifestString, "application/xml");
                mpd = xml && xml.documentElement.tagName === "MPD" ? xml.documentElement : null;
            } catch (e) {}
            if (!mpd || mpd && mpd.getElementsByTagName("parsererror").length > 0) throw new Error(errors.DASH_INVALID_XML);
            return mpd;
        };
        const parseUTCTimingScheme = mpd => {
            const UTCTimingNode = findChildren(mpd, "UTCTiming")[0];
            if (!UTCTimingNode) return null;
            const attributes = mpd_parser_es_parseAttributes(UTCTimingNode);
            switch (attributes.schemeIdUri) {
              case "urn:mpeg:dash:utc:http-head:2014":
              case "urn:mpeg:dash:utc:http-head:2012":
                attributes.method = "HEAD";
                break;

              case "urn:mpeg:dash:utc:http-xsdate:2014":
              case "urn:mpeg:dash:utc:http-iso:2014":
              case "urn:mpeg:dash:utc:http-xsdate:2012":
              case "urn:mpeg:dash:utc:http-iso:2012":
                attributes.method = "GET";
                break;

              case "urn:mpeg:dash:utc:direct:2014":
              case "urn:mpeg:dash:utc:direct:2012":
                attributes.method = "DIRECT";
                attributes.value = Date.parse(attributes.value);
                break;

              case "urn:mpeg:dash:utc:http-ntp:2014":
              case "urn:mpeg:dash:utc:ntp:2014":
              case "urn:mpeg:dash:utc:sntp:2014":
              default:
                throw new Error(errors.UNSUPPORTED_UTC_TIMING_SCHEME);
            }
            return attributes;
        };
        const parse = (manifestString, options = {}) => {
            const parsedManifestInfo = inheritAttributes(stringToMpdXml(manifestString), options);
            const playlists = toPlaylists(parsedManifestInfo.representationInfo);
            return toM3u8({
                dashPlaylists: playlists,
                locations: parsedManifestInfo.locations,
                sidxMapping: options.sidxMapping,
                previousManifest: options.previousManifest,
                eventStream: parsedManifestInfo.eventStream
            });
        };
        const parseUTCTiming = manifestString => parseUTCTimingScheme(stringToMpdXml(manifestString));
        var parse_sidx = __webpack_require__(221);
        var parse_sidx_default = __webpack_require__.n(parse_sidx);
        var ID3 = byte_helpers_toUint8([ 73, 68, 51 ]);
        var getId3Size = function getId3Size(bytes, offset) {
            if (offset === void 0) offset = 0;
            bytes = byte_helpers_toUint8(bytes);
            var flags = bytes[offset + 5];
            var returnSize = bytes[offset + 6] << 21 | bytes[offset + 7] << 14 | bytes[offset + 8] << 7 | bytes[offset + 9];
            var footerPresent = (flags & 16) >> 4;
            if (footerPresent) return returnSize + 20;
            return returnSize + 10;
        };
        var getId3Offset = function getId3Offset(bytes, offset) {
            if (offset === void 0) offset = 0;
            bytes = byte_helpers_toUint8(bytes);
            if (bytes.length - offset < 10 || !byte_helpers_bytesMatch(bytes, ID3, {
                offset
            })) return offset;
            offset += getId3Size(bytes, offset);
            return getId3Offset(bytes, offset);
        };
        new Uint8Array([ 79, 112, 117, 115, 72, 101, 97, 100 ]);
        var normalizePath = function normalizePath(path) {
            if (typeof path === "string") return stringToBytes(path);
            if (typeof path === "number") return path;
            return path;
        };
        var normalizePaths = function normalizePaths(paths) {
            if (!Array.isArray(paths)) return [ normalizePath(paths) ];
            return paths.map((function(p) {
                return normalizePath(p);
            }));
        };
        var DESCRIPTORS;
        var parseDescriptors = function parseDescriptors(bytes) {
            bytes = byte_helpers_toUint8(bytes);
            var results = [];
            var i = 0;
            while (bytes.length > i) {
                var tag = bytes[i];
                var size = 0;
                var headerSize = 0;
                headerSize++;
                var byte = bytes[headerSize];
                headerSize++;
                while (byte & 128) {
                    size = (byte & 127) << 7;
                    byte = bytes[headerSize];
                    headerSize++;
                }
                size += byte & 127;
                for (var z = 0; z < DESCRIPTORS.length; z++) {
                    var _DESCRIPTORS$z = DESCRIPTORS[z], id = _DESCRIPTORS$z.id, parser = _DESCRIPTORS$z.parser;
                    if (tag === id) {
                        results.push(parser(bytes.subarray(headerSize, headerSize + size)));
                        break;
                    }
                }
                i += size + headerSize;
            }
            return results;
        };
        DESCRIPTORS = [ {
            id: 3,
            parser: function parser(bytes) {
                var desc = {
                    tag: 3,
                    id: bytes[0] << 8 | bytes[1],
                    flags: bytes[2],
                    size: 3,
                    dependsOnEsId: 0,
                    ocrEsId: 0,
                    descriptors: [],
                    url: ""
                };
                if (desc.flags & 128) {
                    desc.dependsOnEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];
                    desc.size += 2;
                }
                if (desc.flags & 64) {
                    var len = bytes[desc.size];
                    desc.url = byte_helpers_bytesToString(bytes.subarray(desc.size + 1, desc.size + 1 + len));
                    desc.size += len;
                }
                if (desc.flags & 32) {
                    desc.ocrEsId = bytes[desc.size] << 8 | bytes[desc.size + 1];
                    desc.size += 2;
                }
                desc.descriptors = parseDescriptors(bytes.subarray(desc.size)) || [];
                return desc;
            }
        }, {
            id: 4,
            parser: function parser(bytes) {
                var desc = {
                    tag: 4,
                    oti: bytes[0],
                    streamType: bytes[1],
                    bufferSize: bytes[2] << 16 | bytes[3] << 8 | bytes[4],
                    maxBitrate: bytes[5] << 24 | bytes[6] << 16 | bytes[7] << 8 | bytes[8],
                    avgBitrate: bytes[9] << 24 | bytes[10] << 16 | bytes[11] << 8 | bytes[12],
                    descriptors: parseDescriptors(bytes.subarray(13))
                };
                return desc;
            }
        }, {
            id: 5,
            parser: function parser(bytes) {
                return {
                    tag: 5,
                    bytes
                };
            }
        }, {
            id: 6,
            parser: function parser(bytes) {
                return {
                    tag: 6,
                    bytes
                };
            }
        } ];
        var findBox = function findBox(bytes, paths, complete) {
            if (complete === void 0) complete = false;
            paths = normalizePaths(paths);
            bytes = byte_helpers_toUint8(bytes);
            var results = [];
            if (!paths.length) return results;
            var i = 0;
            while (i < bytes.length) {
                var size = (bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]) >>> 0;
                var type = bytes.subarray(i + 4, i + 8);
                if (size === 0) break;
                var end = i + size;
                if (end > bytes.length) {
                    if (complete) break;
                    end = bytes.length;
                }
                var data = bytes.subarray(i + 8, end);
                if (byte_helpers_bytesMatch(type, paths[0])) if (paths.length === 1) results.push(data); else results.push.apply(results, findBox(data, paths.slice(1), complete));
                i = end;
            }
            return results;
        };
        var EBML_TAGS = {
            EBML: byte_helpers_toUint8([ 26, 69, 223, 163 ]),
            DocType: byte_helpers_toUint8([ 66, 130 ]),
            Segment: byte_helpers_toUint8([ 24, 83, 128, 103 ]),
            SegmentInfo: byte_helpers_toUint8([ 21, 73, 169, 102 ]),
            Tracks: byte_helpers_toUint8([ 22, 84, 174, 107 ]),
            Track: byte_helpers_toUint8([ 174 ]),
            TrackNumber: byte_helpers_toUint8([ 215 ]),
            DefaultDuration: byte_helpers_toUint8([ 35, 227, 131 ]),
            TrackEntry: byte_helpers_toUint8([ 174 ]),
            TrackType: byte_helpers_toUint8([ 131 ]),
            FlagDefault: byte_helpers_toUint8([ 136 ]),
            CodecID: byte_helpers_toUint8([ 134 ]),
            CodecPrivate: byte_helpers_toUint8([ 99, 162 ]),
            VideoTrack: byte_helpers_toUint8([ 224 ]),
            AudioTrack: byte_helpers_toUint8([ 225 ]),
            Cluster: byte_helpers_toUint8([ 31, 67, 182, 117 ]),
            Timestamp: byte_helpers_toUint8([ 231 ]),
            TimestampScale: byte_helpers_toUint8([ 42, 215, 177 ]),
            BlockGroup: byte_helpers_toUint8([ 160 ]),
            BlockDuration: byte_helpers_toUint8([ 155 ]),
            Block: byte_helpers_toUint8([ 161 ]),
            SimpleBlock: byte_helpers_toUint8([ 163 ])
        };
        var LENGTH_TABLE = [ 128, 64, 32, 16, 8, 4, 2, 1 ];
        var getLength = function getLength(byte) {
            var len = 1;
            for (var i = 0; i < LENGTH_TABLE.length; i++) {
                if (byte & LENGTH_TABLE[i]) break;
                len++;
            }
            return len;
        };
        var getvint = function getvint(bytes, offset, removeLength, signed) {
            if (removeLength === void 0) removeLength = true;
            if (signed === void 0) signed = false;
            var length = getLength(bytes[offset]);
            var valueBytes = bytes.subarray(offset, offset + length);
            if (removeLength) {
                valueBytes = Array.prototype.slice.call(bytes, offset, offset + length);
                valueBytes[0] ^= LENGTH_TABLE[length - 1];
            }
            return {
                length,
                value: byte_helpers_bytesToNumber(valueBytes, {
                    signed
                }),
                bytes: valueBytes
            };
        };
        var ebml_helpers_normalizePath = function normalizePath(path) {
            if (typeof path === "string") return path.match(/.{1,2}/g).map((function(p) {
                return normalizePath(p);
            }));
            if (typeof path === "number") return numberToBytes(path);
            return path;
        };
        var ebml_helpers_normalizePaths = function normalizePaths(paths) {
            if (!Array.isArray(paths)) return [ ebml_helpers_normalizePath(paths) ];
            return paths.map((function(p) {
                return ebml_helpers_normalizePath(p);
            }));
        };
        var getInfinityDataSize = function getInfinityDataSize(id, bytes, offset) {
            if (offset >= bytes.length) return bytes.length;
            var innerid = getvint(bytes, offset, false);
            if (byte_helpers_bytesMatch(id.bytes, innerid.bytes)) return offset;
            var dataHeader = getvint(bytes, offset + innerid.length);
            return getInfinityDataSize(id, bytes, offset + dataHeader.length + dataHeader.value + innerid.length);
        };
        var findEbml = function findEbml(bytes, paths) {
            paths = ebml_helpers_normalizePaths(paths);
            bytes = byte_helpers_toUint8(bytes);
            var results = [];
            if (!paths.length) return results;
            var i = 0;
            while (i < bytes.length) {
                var id = getvint(bytes, i, false);
                var dataHeader = getvint(bytes, i + id.length);
                var dataStart = i + id.length + dataHeader.length;
                if (dataHeader.value === 127) {
                    dataHeader.value = getInfinityDataSize(id, bytes, dataStart);
                    if (dataHeader.value !== bytes.length) dataHeader.value -= dataStart;
                }
                var dataEnd = dataStart + dataHeader.value > bytes.length ? bytes.length : dataStart + dataHeader.value;
                var data = bytes.subarray(dataStart, dataEnd);
                if (byte_helpers_bytesMatch(paths[0], id.bytes)) if (paths.length === 1) results.push(data); else results = results.concat(findEbml(data, paths.slice(1)));
                var totalLength = id.length + dataHeader.length + data.length;
                i += totalLength;
            }
            return results;
        };
        var NAL_TYPE_ONE = byte_helpers_toUint8([ 0, 0, 0, 1 ]);
        var NAL_TYPE_TWO = byte_helpers_toUint8([ 0, 0, 1 ]);
        var EMULATION_PREVENTION = byte_helpers_toUint8([ 0, 0, 3 ]);
        var discardEmulationPreventionBytes = function discardEmulationPreventionBytes(bytes) {
            var positions = [];
            var i = 1;
            while (i < bytes.length - 2) {
                if (byte_helpers_bytesMatch(bytes.subarray(i, i + 3), EMULATION_PREVENTION)) {
                    positions.push(i + 2);
                    i++;
                }
                i++;
            }
            if (positions.length === 0) return bytes;
            var newLength = bytes.length - positions.length;
            var newData = new Uint8Array(newLength);
            var sourceIndex = 0;
            for (i = 0; i < newLength; sourceIndex++, i++) {
                if (sourceIndex === positions[0]) {
                    sourceIndex++;
                    positions.shift();
                }
                newData[i] = bytes[sourceIndex];
            }
            return newData;
        };
        var findNal = function findNal(bytes, dataType, types, nalLimit) {
            if (nalLimit === void 0) nalLimit = 1 / 0;
            bytes = byte_helpers_toUint8(bytes);
            types = [].concat(types);
            var i = 0;
            var nalStart;
            var nalsFound = 0;
            while (i < bytes.length && (nalsFound < nalLimit || nalStart)) {
                var nalOffset = void 0;
                if (byte_helpers_bytesMatch(bytes.subarray(i), NAL_TYPE_ONE)) nalOffset = 4; else if (byte_helpers_bytesMatch(bytes.subarray(i), NAL_TYPE_TWO)) nalOffset = 3;
                if (!nalOffset) {
                    i++;
                    continue;
                }
                nalsFound++;
                if (nalStart) return discardEmulationPreventionBytes(bytes.subarray(nalStart, i));
                var nalType = void 0;
                if (dataType === "h264") nalType = bytes[i + nalOffset] & 31; else if (dataType === "h265") nalType = bytes[i + nalOffset] >> 1 & 63;
                if (types.indexOf(nalType) !== -1) nalStart = i + nalOffset;
                i += nalOffset + (dataType === "h264" ? 1 : 2);
            }
            return bytes.subarray(0, 0);
        };
        var findH264Nal = function findH264Nal(bytes, type, nalLimit) {
            return findNal(bytes, "h264", type, nalLimit);
        };
        var findH265Nal = function findH265Nal(bytes, type, nalLimit) {
            return findNal(bytes, "h265", type, nalLimit);
        };
        var CONSTANTS = {
            webm: byte_helpers_toUint8([ 119, 101, 98, 109 ]),
            matroska: byte_helpers_toUint8([ 109, 97, 116, 114, 111, 115, 107, 97 ]),
            flac: byte_helpers_toUint8([ 102, 76, 97, 67 ]),
            ogg: byte_helpers_toUint8([ 79, 103, 103, 83 ]),
            ac3: byte_helpers_toUint8([ 11, 119 ]),
            riff: byte_helpers_toUint8([ 82, 73, 70, 70 ]),
            avi: byte_helpers_toUint8([ 65, 86, 73 ]),
            wav: byte_helpers_toUint8([ 87, 65, 86, 69 ]),
            "3gp": byte_helpers_toUint8([ 102, 116, 121, 112, 51, 103 ]),
            mp4: byte_helpers_toUint8([ 102, 116, 121, 112 ]),
            fmp4: byte_helpers_toUint8([ 115, 116, 121, 112 ]),
            mov: byte_helpers_toUint8([ 102, 116, 121, 112, 113, 116 ]),
            moov: byte_helpers_toUint8([ 109, 111, 111, 118 ]),
            moof: byte_helpers_toUint8([ 109, 111, 111, 102 ])
        };
        var _isLikely = {
            aac: function aac(bytes) {
                var offset = getId3Offset(bytes);
                return byte_helpers_bytesMatch(bytes, [ 255, 16 ], {
                    offset,
                    mask: [ 255, 22 ]
                });
            },
            mp3: function mp3(bytes) {
                var offset = getId3Offset(bytes);
                return byte_helpers_bytesMatch(bytes, [ 255, 2 ], {
                    offset,
                    mask: [ 255, 6 ]
                });
            },
            webm: function webm(bytes) {
                var docType = findEbml(bytes, [ EBML_TAGS.EBML, EBML_TAGS.DocType ])[0];
                return byte_helpers_bytesMatch(docType, CONSTANTS.webm);
            },
            mkv: function mkv(bytes) {
                var docType = findEbml(bytes, [ EBML_TAGS.EBML, EBML_TAGS.DocType ])[0];
                return byte_helpers_bytesMatch(docType, CONSTANTS.matroska);
            },
            mp4: function mp4(bytes) {
                if (_isLikely["3gp"](bytes) || _isLikely.mov(bytes)) return false;
                if (byte_helpers_bytesMatch(bytes, CONSTANTS.mp4, {
                    offset: 4
                }) || byte_helpers_bytesMatch(bytes, CONSTANTS.fmp4, {
                    offset: 4
                })) return true;
                if (byte_helpers_bytesMatch(bytes, CONSTANTS.moof, {
                    offset: 4
                }) || byte_helpers_bytesMatch(bytes, CONSTANTS.moov, {
                    offset: 4
                })) return true;
            },
            mov: function mov(bytes) {
                return byte_helpers_bytesMatch(bytes, CONSTANTS.mov, {
                    offset: 4
                });
            },
            "3gp": function gp(bytes) {
                return byte_helpers_bytesMatch(bytes, CONSTANTS["3gp"], {
                    offset: 4
                });
            },
            ac3: function ac3(bytes) {
                var offset = getId3Offset(bytes);
                return byte_helpers_bytesMatch(bytes, CONSTANTS.ac3, {
                    offset
                });
            },
            ts: function ts(bytes) {
                if (bytes.length < 189 && bytes.length >= 1) return bytes[0] === 71;
                var i = 0;
                while (i + 188 < bytes.length && i < 188) {
                    if (bytes[i] === 71 && bytes[i + 188] === 71) return true;
                    i += 1;
                }
                return false;
            },
            flac: function flac(bytes) {
                var offset = getId3Offset(bytes);
                return byte_helpers_bytesMatch(bytes, CONSTANTS.flac, {
                    offset
                });
            },
            ogg: function ogg(bytes) {
                return byte_helpers_bytesMatch(bytes, CONSTANTS.ogg);
            },
            avi: function avi(bytes) {
                return byte_helpers_bytesMatch(bytes, CONSTANTS.riff) && byte_helpers_bytesMatch(bytes, CONSTANTS.avi, {
                    offset: 8
                });
            },
            wav: function wav(bytes) {
                return byte_helpers_bytesMatch(bytes, CONSTANTS.riff) && byte_helpers_bytesMatch(bytes, CONSTANTS.wav, {
                    offset: 8
                });
            },
            h264: function h264(bytes) {
                return findH264Nal(bytes, 7, 3).length;
            },
            h265: function h265(bytes) {
                return findH265Nal(bytes, [ 32, 33 ], 3).length;
            }
        };
        var isLikelyTypes = Object.keys(_isLikely).filter((function(t) {
            return t !== "ts" && t !== "h264" && t !== "h265";
        })).concat([ "ts", "h264", "h265" ]);
        isLikelyTypes.forEach((function(type) {
            var isLikelyFn = _isLikely[type];
            _isLikely[type] = function(bytes) {
                return isLikelyFn(byte_helpers_toUint8(bytes));
            };
        }));
        var isLikely = _isLikely;
        var detectContainerForBytes = function detectContainerForBytes(bytes) {
            bytes = byte_helpers_toUint8(bytes);
            for (var i = 0; i < isLikelyTypes.length; i++) {
                var type = isLikelyTypes[i];
                if (isLikely[type](bytes)) return type;
            }
            return "";
        };
        var isLikelyFmp4MediaSegment = function isLikelyFmp4MediaSegment(bytes) {
            return findBox(bytes, [ "moof" ]).length > 0;
        };
        var clock = __webpack_require__(489);
        /**
 * @license
 * Video.js 8.3.0 <http://videojs.com/>
 * Copyright Brightcove, Inc. <https://www.brightcove.com/>
 * Available under Apache License Version 2.0
 * <https://github.com/videojs/video.js/blob/main/LICENSE>
 *
 * Includes vtt.js <https://github.com/mozilla/vtt.js>
 * Available under Apache License Version 2.0
 * <https://github.com/mozilla/vtt.js/blob/main/LICENSE>
 */
        var version$6 = "8.3.0";
        const hooks_ = {};
        const hooks = function(type, fn) {
            hooks_[type] = hooks_[type] || [];
            if (fn) hooks_[type] = hooks_[type].concat(fn);
            return hooks_[type];
        };
        const hook = function(type, fn) {
            hooks(type, fn);
        };
        const removeHook = function(type, fn) {
            const index = hooks(type).indexOf(fn);
            if (index <= -1) return false;
            hooks_[type] = hooks_[type].slice();
            hooks_[type].splice(index, 1);
            return true;
        };
        const hookOnce = function(type, fn) {
            hooks(type, [].concat(fn).map((original => {
                const wrapper = (...args) => {
                    removeHook(type, wrapper);
                    return original(...args);
                };
                return wrapper;
            })));
        };
        const FullscreenApi = {
            prefixed: true
        };
        const apiMap = [ [ "requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror", "fullscreen" ], [ "webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror", "-webkit-full-screen" ], [ "mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror", "-moz-full-screen" ], [ "msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError", "-ms-fullscreen" ] ];
        const specApi = apiMap[0];
        let browserApi;
        for (let i = 0; i < apiMap.length; i++) if (apiMap[i][1] in document_default()) {
            browserApi = apiMap[i];
            break;
        }
        if (browserApi) {
            for (let i = 0; i < browserApi.length; i++) FullscreenApi[specApi[i]] = browserApi[i];
            FullscreenApi.prefixed = browserApi[0] !== specApi[0];
        }
        let video_es_history = [];
        const LogByTypeFactory = (name, log) => (type, level, args) => {
            const lvl = log.levels[level];
            const lvlRegExp = new RegExp(`^(${lvl})$`);
            if (type !== "log") args.unshift(type.toUpperCase() + ":");
            args.unshift(name + ":");
            if (video_es_history) {
                video_es_history.push([].concat(args));
                const splice = video_es_history.length - 1e3;
                video_es_history.splice(0, splice > 0 ? splice : 0);
            }
            if (!window_default().console) return;
            let fn = window_default().console[type];
            if (!fn && type === "debug") fn = window_default().console.info || window_default().console.log;
            if (!fn || !lvl || !lvlRegExp.test(type)) return;
            fn[Array.isArray(args) ? "apply" : "call"](window_default().console, args);
        };
        function createLogger$1(name) {
            let level = "info";
            let logByType;
            const log = function(...args) {
                logByType("log", level, args);
            };
            logByType = LogByTypeFactory(name, log);
            log.createLogger = subname => createLogger$1(name + ": " + subname);
            log.levels = {
                all: "debug|log|warn|error",
                off: "",
                debug: "debug|log|warn|error",
                info: "log|warn|error",
                warn: "warn|error",
                error: "error",
                DEFAULT: level
            };
            log.level = lvl => {
                if (typeof lvl === "string") {
                    if (!log.levels.hasOwnProperty(lvl)) throw new Error(`"${lvl}" in not a valid log level`);
                    level = lvl;
                }
                return level;
            };
            log.history = () => video_es_history ? [].concat(video_es_history) : [];
            log.history.filter = fname => (video_es_history || []).filter((historyItem => new RegExp(`.*${fname}.*`).test(historyItem[0])));
            log.history.clear = () => {
                if (video_es_history) video_es_history.length = 0;
            };
            log.history.disable = () => {
                if (video_es_history !== null) {
                    video_es_history.length = 0;
                    video_es_history = null;
                }
            };
            log.history.enable = () => {
                if (video_es_history === null) video_es_history = [];
            };
            log.error = (...args) => logByType("error", level, args);
            log.warn = (...args) => logByType("warn", level, args);
            log.debug = (...args) => logByType("debug", level, args);
            return log;
        }
        const log$1 = createLogger$1("VIDEOJS");
        const createLogger = log$1.createLogger;
        const video_es_toString = Object.prototype.toString;
        const keys = function(object) {
            return video_es_isObject(object) ? Object.keys(object) : [];
        };
        function each(object, fn) {
            keys(object).forEach((key => fn(object[key], key)));
        }
        function reduce(object, fn, initial = 0) {
            return keys(object).reduce(((accum, key) => fn(accum, object[key], key)), initial);
        }
        function video_es_isObject(value) {
            return !!value && typeof value === "object";
        }
        function isPlain(value) {
            return video_es_isObject(value) && video_es_toString.call(value) === "[object Object]" && value.constructor === Object;
        }
        function merge$1(...sources) {
            const result = {};
            sources.forEach((source => {
                if (!source) return;
                each(source, ((value, key) => {
                    if (!isPlain(value)) {
                        result[key] = value;
                        return;
                    }
                    if (!isPlain(result[key])) result[key] = {};
                    result[key] = merge$1(result[key], value);
                }));
            }));
            return result;
        }
        function defineLazyProperty(obj, key, getValue, setter = true) {
            const set = value => Object.defineProperty(obj, key, {
                value,
                enumerable: true,
                writable: true
            });
            const options = {
                configurable: true,
                enumerable: true,
                get() {
                    const value = getValue();
                    set(value);
                    return value;
                }
            };
            if (setter) options.set = set;
            return Object.defineProperty(obj, key, options);
        }
        var Obj = Object.freeze({
            __proto__: null,
            each,
            reduce,
            isObject: video_es_isObject,
            isPlain,
            merge: merge$1,
            defineLazyProperty
        });
        let IS_IPOD = false;
        let IOS_VERSION = null;
        let IS_ANDROID = false;
        let ANDROID_VERSION;
        let IS_FIREFOX = false;
        let IS_EDGE = false;
        let IS_CHROMIUM = false;
        let IS_CHROME = false;
        let CHROMIUM_VERSION = null;
        let CHROME_VERSION = null;
        let IE_VERSION = null;
        let IS_SAFARI = false;
        let IS_WINDOWS = false;
        let IS_IPAD = false;
        let IS_IPHONE = false;
        const TOUCH_ENABLED = Boolean(isReal() && ("ontouchstart" in window_default() || window_default().navigator.maxTouchPoints || window_default().DocumentTouch && window_default().document instanceof window_default().DocumentTouch));
        const UAD = window_default().navigator && window_default().navigator.userAgentData;
        if (UAD) {
            IS_ANDROID = UAD.platform === "Android";
            IS_EDGE = Boolean(UAD.brands.find((b => b.brand === "Microsoft Edge")));
            IS_CHROMIUM = Boolean(UAD.brands.find((b => b.brand === "Chromium")));
            IS_CHROME = !IS_EDGE && IS_CHROMIUM;
            CHROMIUM_VERSION = CHROME_VERSION = (UAD.brands.find((b => b.brand === "Chromium")) || {}).version || null;
            IS_WINDOWS = UAD.platform === "Windows";
        }
        if (!IS_CHROMIUM) {
            const USER_AGENT = window_default().navigator && window_default().navigator.userAgent || "";
            IS_IPOD = /iPod/i.test(USER_AGENT);
            IOS_VERSION = function() {
                const match = USER_AGENT.match(/OS (\d+)_/i);
                if (match && match[1]) return match[1];
                return null;
            }();
            IS_ANDROID = /Android/i.test(USER_AGENT);
            ANDROID_VERSION = function() {
                const match = USER_AGENT.match(/Android (\d+)(?:\.(\d+))?(?:\.(\d+))*/i);
                if (!match) return null;
                const major = match[1] && parseFloat(match[1]);
                const minor = match[2] && parseFloat(match[2]);
                if (major && minor) return parseFloat(match[1] + "." + match[2]); else if (major) return major;
                return null;
            }();
            IS_FIREFOX = /Firefox/i.test(USER_AGENT);
            IS_EDGE = /Edg/i.test(USER_AGENT);
            IS_CHROMIUM = /Chrome/i.test(USER_AGENT) || /CriOS/i.test(USER_AGENT);
            IS_CHROME = !IS_EDGE && IS_CHROMIUM;
            CHROMIUM_VERSION = CHROME_VERSION = function() {
                const match = USER_AGENT.match(/(Chrome|CriOS)\/(\d+)/);
                if (match && match[2]) return parseFloat(match[2]);
                return null;
            }();
            IE_VERSION = function() {
                const result = /MSIE\s(\d+)\.\d/.exec(USER_AGENT);
                let version = result && parseFloat(result[1]);
                if (!version && /Trident\/7.0/i.test(USER_AGENT) && /rv:11.0/.test(USER_AGENT)) version = 11;
                return version;
            }();
            IS_SAFARI = /Safari/i.test(USER_AGENT) && !IS_CHROME && !IS_ANDROID && !IS_EDGE;
            IS_WINDOWS = /Windows/i.test(USER_AGENT);
            IS_IPAD = /iPad/i.test(USER_AGENT) || IS_SAFARI && TOUCH_ENABLED && !/iPhone/i.test(USER_AGENT);
            IS_IPHONE = /iPhone/i.test(USER_AGENT) && !IS_IPAD;
        }
        const IS_IOS = IS_IPHONE || IS_IPAD || IS_IPOD;
        const IS_ANY_SAFARI = (IS_SAFARI || IS_IOS) && !IS_CHROME;
        var video_es_browser = Object.freeze({
            __proto__: null,
            get IS_IPOD() {
                return IS_IPOD;
            },
            get IOS_VERSION() {
                return IOS_VERSION;
            },
            get IS_ANDROID() {
                return IS_ANDROID;
            },
            get ANDROID_VERSION() {
                return ANDROID_VERSION;
            },
            get IS_FIREFOX() {
                return IS_FIREFOX;
            },
            get IS_EDGE() {
                return IS_EDGE;
            },
            get IS_CHROMIUM() {
                return IS_CHROMIUM;
            },
            get IS_CHROME() {
                return IS_CHROME;
            },
            get CHROMIUM_VERSION() {
                return CHROMIUM_VERSION;
            },
            get CHROME_VERSION() {
                return CHROME_VERSION;
            },
            get IE_VERSION() {
                return IE_VERSION;
            },
            get IS_SAFARI() {
                return IS_SAFARI;
            },
            get IS_WINDOWS() {
                return IS_WINDOWS;
            },
            get IS_IPAD() {
                return IS_IPAD;
            },
            get IS_IPHONE() {
                return IS_IPHONE;
            },
            TOUCH_ENABLED,
            IS_IOS,
            IS_ANY_SAFARI
        });
        function isNonBlankString(str) {
            return typeof str === "string" && Boolean(str.trim());
        }
        function throwIfWhitespace(str) {
            if (str.indexOf(" ") >= 0) throw new Error("class has illegal whitespace characters");
        }
        function isReal() {
            return document_default() === window_default().document;
        }
        function isEl(value) {
            return video_es_isObject(value) && value.nodeType === 1;
        }
        function isInFrame() {
            try {
                return window_default().parent !== window_default().self;
            } catch (x) {
                return true;
            }
        }
        function createQuerier(method) {
            return function(selector, context) {
                if (!isNonBlankString(selector)) return document_default()[method](null);
                if (isNonBlankString(context)) context = document_default().querySelector(context);
                const ctx = isEl(context) ? context : document_default();
                return ctx[method] && ctx[method](selector);
            };
        }
        function createEl(tagName = "div", properties = {}, attributes = {}, content) {
            const el = document_default().createElement(tagName);
            Object.getOwnPropertyNames(properties).forEach((function(propName) {
                const val = properties[propName];
                if (propName === "textContent") textContent(el, val); else if (el[propName] !== val || propName === "tabIndex") el[propName] = val;
            }));
            Object.getOwnPropertyNames(attributes).forEach((function(attrName) {
                el.setAttribute(attrName, attributes[attrName]);
            }));
            if (content) appendContent(el, content);
            return el;
        }
        function textContent(el, text) {
            if (typeof el.textContent === "undefined") el.innerText = text; else el.textContent = text;
            return el;
        }
        function prependTo(child, parent) {
            if (parent.firstChild) parent.insertBefore(child, parent.firstChild); else parent.appendChild(child);
        }
        function hasClass(element, classToCheck) {
            throwIfWhitespace(classToCheck);
            return element.classList.contains(classToCheck);
        }
        function addClass(element, ...classesToAdd) {
            element.classList.add(...classesToAdd.reduce(((prev, current) => prev.concat(current.split(/\s+/))), []));
            return element;
        }
        function removeClass(element, ...classesToRemove) {
            if (!element) {
                log$1.warn("removeClass was called with an element that doesn't exist");
                return null;
            }
            element.classList.remove(...classesToRemove.reduce(((prev, current) => prev.concat(current.split(/\s+/))), []));
            return element;
        }
        function toggleClass(element, classToToggle, predicate) {
            if (typeof predicate === "function") predicate = predicate(element, classToToggle);
            if (typeof predicate !== "boolean") predicate = void 0;
            classToToggle.split(/\s+/).forEach((className => element.classList.toggle(className, predicate)));
            return element;
        }
        function setAttributes(el, attributes) {
            Object.getOwnPropertyNames(attributes).forEach((function(attrName) {
                const attrValue = attributes[attrName];
                if (attrValue === null || typeof attrValue === "undefined" || attrValue === false) el.removeAttribute(attrName); else el.setAttribute(attrName, attrValue === true ? "" : attrValue);
            }));
        }
        function getAttributes(tag) {
            const obj = {};
            const knownBooleans = "," + "autoplay,controls,playsinline,loop,muted,default,defaultMuted" + ",";
            if (tag && tag.attributes && tag.attributes.length > 0) {
                const attrs = tag.attributes;
                for (let i = attrs.length - 1; i >= 0; i--) {
                    const attrName = attrs[i].name;
                    let attrVal = attrs[i].value;
                    if (typeof tag[attrName] === "boolean" || knownBooleans.indexOf("," + attrName + ",") !== -1) attrVal = attrVal !== null ? true : false;
                    obj[attrName] = attrVal;
                }
            }
            return obj;
        }
        function getAttribute(el, attribute) {
            return el.getAttribute(attribute);
        }
        function setAttribute(el, attribute, value) {
            el.setAttribute(attribute, value);
        }
        function removeAttribute(el, attribute) {
            el.removeAttribute(attribute);
        }
        function blockTextSelection() {
            document_default().body.focus();
            document_default().onselectstart = function() {
                return false;
            };
        }
        function unblockTextSelection() {
            document_default().onselectstart = function() {
                return true;
            };
        }
        function getBoundingClientRect(el) {
            if (el && el.getBoundingClientRect && el.parentNode) {
                const rect = el.getBoundingClientRect();
                const result = {};
                [ "bottom", "height", "left", "right", "top", "width" ].forEach((k => {
                    if (rect[k] !== void 0) result[k] = rect[k];
                }));
                if (!result.height) result.height = parseFloat(computedStyle(el, "height"));
                if (!result.width) result.width = parseFloat(computedStyle(el, "width"));
                return result;
            }
        }
        function findPosition(el) {
            if (!el || el && !el.offsetParent) return {
                left: 0,
                top: 0,
                width: 0,
                height: 0
            };
            const width = el.offsetWidth;
            const height = el.offsetHeight;
            let left = 0;
            let top = 0;
            while (el.offsetParent && el !== document_default()[FullscreenApi.fullscreenElement]) {
                left += el.offsetLeft;
                top += el.offsetTop;
                el = el.offsetParent;
            }
            return {
                left,
                top,
                width,
                height
            };
        }
        function getPointerPosition(el, event) {
            const translated = {
                x: 0,
                y: 0
            };
            if (IS_IOS) {
                let item = el;
                while (item && item.nodeName.toLowerCase() !== "html") {
                    const transform = computedStyle(item, "transform");
                    if (/^matrix/.test(transform)) {
                        const values = transform.slice(7, -1).split(/,\s/).map(Number);
                        translated.x += values[4];
                        translated.y += values[5];
                    } else if (/^matrix3d/.test(transform)) {
                        const values = transform.slice(9, -1).split(/,\s/).map(Number);
                        translated.x += values[12];
                        translated.y += values[13];
                    }
                    item = item.parentNode;
                }
            }
            const position = {};
            const boxTarget = findPosition(event.target);
            const box = findPosition(el);
            const boxW = box.width;
            const boxH = box.height;
            let offsetY = event.offsetY - (box.top - boxTarget.top);
            let offsetX = event.offsetX - (box.left - boxTarget.left);
            if (event.changedTouches) {
                offsetX = event.changedTouches[0].pageX - box.left;
                offsetY = event.changedTouches[0].pageY + box.top;
                if (IS_IOS) {
                    offsetX -= translated.x;
                    offsetY -= translated.y;
                }
            }
            position.y = 1 - Math.max(0, Math.min(1, offsetY / boxH));
            position.x = Math.max(0, Math.min(1, offsetX / boxW));
            return position;
        }
        function isTextNode(value) {
            return video_es_isObject(value) && value.nodeType === 3;
        }
        function emptyEl(el) {
            while (el.firstChild) el.removeChild(el.firstChild);
            return el;
        }
        function normalizeContent(content) {
            if (typeof content === "function") content = content();
            return (Array.isArray(content) ? content : [ content ]).map((value => {
                if (typeof value === "function") value = value();
                if (isEl(value) || isTextNode(value)) return value;
                if (typeof value === "string" && /\S/.test(value)) return document_default().createTextNode(value);
            })).filter((value => value));
        }
        function appendContent(el, content) {
            normalizeContent(content).forEach((node => el.appendChild(node)));
            return el;
        }
        function insertContent(el, content) {
            return appendContent(emptyEl(el), content);
        }
        function isSingleLeftClick(event) {
            if (event.button === void 0 && event.buttons === void 0) return true;
            if (event.button === 0 && event.buttons === void 0) return true;
            if (event.type === "mouseup" && event.button === 0 && event.buttons === 0) return true;
            if (event.button !== 0 || event.buttons !== 1) return false;
            return true;
        }
        const video_es_$ = createQuerier("querySelector");
        const $$ = createQuerier("querySelectorAll");
        function computedStyle(el, prop) {
            if (!el || !prop) return "";
            if (typeof window_default().getComputedStyle === "function") {
                let computedStyleValue;
                try {
                    computedStyleValue = window_default().getComputedStyle(el);
                } catch (e) {
                    return "";
                }
                return computedStyleValue ? computedStyleValue.getPropertyValue(prop) || computedStyleValue[prop] : "";
            }
            return "";
        }
        var Dom = Object.freeze({
            __proto__: null,
            isReal,
            isEl,
            isInFrame,
            createEl,
            textContent,
            prependTo,
            hasClass,
            addClass,
            removeClass,
            toggleClass,
            setAttributes,
            getAttributes,
            getAttribute,
            setAttribute,
            removeAttribute,
            blockTextSelection,
            unblockTextSelection,
            getBoundingClientRect,
            findPosition,
            getPointerPosition,
            isTextNode,
            emptyEl,
            normalizeContent,
            appendContent,
            insertContent,
            isSingleLeftClick,
            $: video_es_$,
            $$,
            computedStyle
        });
        let _windowLoaded = false;
        let videojs$1;
        const autoSetup = function() {
            if (videojs$1.options.autoSetup === false) return;
            const vids = Array.prototype.slice.call(document_default().getElementsByTagName("video"));
            const audios = Array.prototype.slice.call(document_default().getElementsByTagName("audio"));
            const divs = Array.prototype.slice.call(document_default().getElementsByTagName("video-js"));
            const mediaEls = vids.concat(audios, divs);
            if (mediaEls && mediaEls.length > 0) for (let i = 0, e = mediaEls.length; i < e; i++) {
                const mediaEl = mediaEls[i];
                if (mediaEl && mediaEl.getAttribute) {
                    if (mediaEl.player === void 0) {
                        const options = mediaEl.getAttribute("data-setup");
                        if (options !== null) videojs$1(mediaEl);
                    }
                } else {
                    autoSetupTimeout(1);
                    break;
                }
            } else if (!_windowLoaded) autoSetupTimeout(1);
        };
        function autoSetupTimeout(wait, vjs) {
            if (!isReal()) return;
            if (vjs) videojs$1 = vjs;
            window_default().setTimeout(autoSetup, wait);
        }
        function setWindowLoaded() {
            _windowLoaded = true;
            window_default().removeEventListener("load", setWindowLoaded);
        }
        if (isReal()) if (document_default().readyState === "complete") setWindowLoaded(); else window_default().addEventListener("load", setWindowLoaded);
        const createStyleElement = function(className) {
            const style = document_default().createElement("style");
            style.className = className;
            return style;
        };
        const setTextContent = function(el, content) {
            if (el.styleSheet) el.styleSheet.cssText = content; else el.textContent = content;
        };
        var DomData = new WeakMap;
        const _initialGuid = 3;
        let _guid = _initialGuid;
        function newGUID() {
            return _guid++;
        }
        function _cleanUpEvents(elem, type) {
            if (!DomData.has(elem)) return;
            const data = DomData.get(elem);
            if (data.handlers[type].length === 0) {
                delete data.handlers[type];
                if (elem.removeEventListener) elem.removeEventListener(type, data.dispatcher, false); else if (elem.detachEvent) elem.detachEvent("on" + type, data.dispatcher);
            }
            if (Object.getOwnPropertyNames(data.handlers).length <= 0) {
                delete data.handlers;
                delete data.dispatcher;
                delete data.disabled;
            }
            if (Object.getOwnPropertyNames(data).length === 0) DomData.delete(elem);
        }
        function _handleMultipleEvents(fn, elem, types, callback) {
            types.forEach((function(type) {
                fn(elem, type, callback);
            }));
        }
        function fixEvent(event) {
            if (event.fixed_) return event;
            function returnTrue() {
                return true;
            }
            function returnFalse() {
                return false;
            }
            if (!event || !event.isPropagationStopped || !event.isImmediatePropagationStopped) {
                const old = event || window_default().event;
                event = {};
                for (const key in old) if (key !== "layerX" && key !== "layerY" && key !== "keyLocation" && key !== "webkitMovementX" && key !== "webkitMovementY" && key !== "path") if (!(key === "returnValue" && old.preventDefault)) event[key] = old[key];
                if (!event.target) event.target = event.srcElement || document_default();
                if (!event.relatedTarget) event.relatedTarget = event.fromElement === event.target ? event.toElement : event.fromElement;
                event.preventDefault = function() {
                    if (old.preventDefault) old.preventDefault();
                    event.returnValue = false;
                    old.returnValue = false;
                    event.defaultPrevented = true;
                };
                event.defaultPrevented = false;
                event.stopPropagation = function() {
                    if (old.stopPropagation) old.stopPropagation();
                    event.cancelBubble = true;
                    old.cancelBubble = true;
                    event.isPropagationStopped = returnTrue;
                };
                event.isPropagationStopped = returnFalse;
                event.stopImmediatePropagation = function() {
                    if (old.stopImmediatePropagation) old.stopImmediatePropagation();
                    event.isImmediatePropagationStopped = returnTrue;
                    event.stopPropagation();
                };
                event.isImmediatePropagationStopped = returnFalse;
                if (event.clientX !== null && event.clientX !== void 0) {
                    const doc = document_default().documentElement;
                    const body = document_default().body;
                    event.pageX = event.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = event.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }
                event.which = event.charCode || event.keyCode;
                if (event.button !== null && event.button !== void 0) event.button = event.button & 1 ? 0 : event.button & 4 ? 1 : event.button & 2 ? 2 : 0;
            }
            event.fixed_ = true;
            return event;
        }
        let _supportsPassive;
        const supportsPassive = function() {
            if (typeof _supportsPassive !== "boolean") {
                _supportsPassive = false;
                try {
                    const opts = Object.defineProperty({}, "passive", {
                        get() {
                            _supportsPassive = true;
                        }
                    });
                    window_default().addEventListener("test", null, opts);
                    window_default().removeEventListener("test", null, opts);
                } catch (e) {}
            }
            return _supportsPassive;
        };
        const passiveEvents = [ "touchstart", "touchmove" ];
        function on(elem, type, fn) {
            if (Array.isArray(type)) return _handleMultipleEvents(on, elem, type, fn);
            if (!DomData.has(elem)) DomData.set(elem, {});
            const data = DomData.get(elem);
            if (!data.handlers) data.handlers = {};
            if (!data.handlers[type]) data.handlers[type] = [];
            if (!fn.guid) fn.guid = newGUID();
            data.handlers[type].push(fn);
            if (!data.dispatcher) {
                data.disabled = false;
                data.dispatcher = function(event, hash) {
                    if (data.disabled) return;
                    event = fixEvent(event);
                    const handlers = data.handlers[event.type];
                    if (handlers) {
                        const handlersCopy = handlers.slice(0);
                        for (let m = 0, n = handlersCopy.length; m < n; m++) if (event.isImmediatePropagationStopped()) break; else try {
                            handlersCopy[m].call(elem, event, hash);
                        } catch (e) {
                            log$1.error(e);
                        }
                    }
                };
            }
            if (data.handlers[type].length === 1) if (elem.addEventListener) {
                let options = false;
                if (supportsPassive() && passiveEvents.indexOf(type) > -1) options = {
                    passive: true
                };
                elem.addEventListener(type, data.dispatcher, options);
            } else if (elem.attachEvent) elem.attachEvent("on" + type, data.dispatcher);
        }
        function off(elem, type, fn) {
            if (!DomData.has(elem)) return;
            const data = DomData.get(elem);
            if (!data.handlers) return;
            if (Array.isArray(type)) return _handleMultipleEvents(off, elem, type, fn);
            const removeType = function(el, t) {
                data.handlers[t] = [];
                _cleanUpEvents(el, t);
            };
            if (type === void 0) {
                for (const t in data.handlers) if (Object.prototype.hasOwnProperty.call(data.handlers || {}, t)) removeType(elem, t);
                return;
            }
            const handlers = data.handlers[type];
            if (!handlers) return;
            if (!fn) {
                removeType(elem, type);
                return;
            }
            if (fn.guid) for (let n = 0; n < handlers.length; n++) if (handlers[n].guid === fn.guid) handlers.splice(n--, 1);
            _cleanUpEvents(elem, type);
        }
        function trigger(elem, event, hash) {
            const elemData = DomData.has(elem) ? DomData.get(elem) : {};
            const parent = elem.parentNode || elem.ownerDocument;
            if (typeof event === "string") event = {
                type: event,
                target: elem
            }; else if (!event.target) event.target = elem;
            event = fixEvent(event);
            if (elemData.dispatcher) elemData.dispatcher.call(elem, event, hash);
            if (parent && !event.isPropagationStopped() && event.bubbles === true) trigger.call(null, parent, event, hash); else if (!parent && !event.defaultPrevented && event.target && event.target[event.type]) {
                if (!DomData.has(event.target)) DomData.set(event.target, {});
                const targetData = DomData.get(event.target);
                if (event.target[event.type]) {
                    targetData.disabled = true;
                    if (typeof event.target[event.type] === "function") event.target[event.type]();
                    targetData.disabled = false;
                }
            }
            return !event.defaultPrevented;
        }
        function one(elem, type, fn) {
            if (Array.isArray(type)) return _handleMultipleEvents(one, elem, type, fn);
            const func = function() {
                off(elem, type, func);
                fn.apply(this, arguments);
            };
            func.guid = fn.guid = fn.guid || newGUID();
            on(elem, type, func);
        }
        function any(elem, type, fn) {
            const func = function() {
                off(elem, type, func);
                fn.apply(this, arguments);
            };
            func.guid = fn.guid = fn.guid || newGUID();
            on(elem, type, func);
        }
        var Events = Object.freeze({
            __proto__: null,
            fixEvent,
            on,
            off,
            trigger,
            one,
            any
        });
        const UPDATE_REFRESH_INTERVAL = 30;
        const bind_ = function(context, fn, uid) {
            if (!fn.guid) fn.guid = newGUID();
            const bound = fn.bind(context);
            bound.guid = uid ? uid + "_" + fn.guid : fn.guid;
            return bound;
        };
        const throttle = function(fn, wait) {
            let last = window_default().performance.now();
            const throttled = function(...args) {
                const now = window_default().performance.now();
                if (now - last >= wait) {
                    fn(...args);
                    last = now;
                }
            };
            return throttled;
        };
        const debounce = function(func, wait, immediate, context = window_default()) {
            let timeout;
            const cancel = () => {
                context.clearTimeout(timeout);
                timeout = null;
            };
            const debounced = function() {
                const self = this;
                const args = arguments;
                let later = function() {
                    timeout = null;
                    later = null;
                    if (!immediate) func.apply(self, args);
                };
                if (!timeout && immediate) func.apply(self, args);
                context.clearTimeout(timeout);
                timeout = context.setTimeout(later, wait);
            };
            debounced.cancel = cancel;
            return debounced;
        };
        var Fn = Object.freeze({
            __proto__: null,
            UPDATE_REFRESH_INTERVAL,
            bind_,
            throttle,
            debounce
        });
        let EVENT_MAP;
        class EventTarget$2 {
            on(type, fn) {
                const ael = this.addEventListener;
                this.addEventListener = () => {};
                on(this, type, fn);
                this.addEventListener = ael;
            }
            off(type, fn) {
                off(this, type, fn);
            }
            one(type, fn) {
                const ael = this.addEventListener;
                this.addEventListener = () => {};
                one(this, type, fn);
                this.addEventListener = ael;
            }
            any(type, fn) {
                const ael = this.addEventListener;
                this.addEventListener = () => {};
                any(this, type, fn);
                this.addEventListener = ael;
            }
            trigger(event) {
                const type = event.type || event;
                if (typeof event === "string") event = {
                    type
                };
                event = fixEvent(event);
                if (this.allowedEvents_[type] && this["on" + type]) this["on" + type](event);
                trigger(this, event);
            }
            queueTrigger(event) {
                if (!EVENT_MAP) EVENT_MAP = new Map;
                const type = event.type || event;
                let map = EVENT_MAP.get(this);
                if (!map) {
                    map = new Map;
                    EVENT_MAP.set(this, map);
                }
                const oldTimeout = map.get(type);
                map.delete(type);
                window_default().clearTimeout(oldTimeout);
                const timeout = window_default().setTimeout((() => {
                    map.delete(type);
                    if (map.size === 0) {
                        map = null;
                        EVENT_MAP.delete(this);
                    }
                    this.trigger(event);
                }), 0);
                map.set(type, timeout);
            }
        }
        EventTarget$2.prototype.allowedEvents_ = {};
        EventTarget$2.prototype.addEventListener = EventTarget$2.prototype.on;
        EventTarget$2.prototype.removeEventListener = EventTarget$2.prototype.off;
        EventTarget$2.prototype.dispatchEvent = EventTarget$2.prototype.trigger;
        const objName = obj => {
            if (typeof obj.name === "function") return obj.name();
            if (typeof obj.name === "string") return obj.name;
            if (obj.name_) return obj.name_;
            if (obj.constructor && obj.constructor.name) return obj.constructor.name;
            return typeof obj;
        };
        const isEvented = object => object instanceof EventTarget$2 || !!object.eventBusEl_ && [ "on", "one", "off", "trigger" ].every((k => typeof object[k] === "function"));
        const addEventedCallback = (target, callback) => {
            if (isEvented(target)) callback(); else {
                if (!target.eventedCallbacks) target.eventedCallbacks = [];
                target.eventedCallbacks.push(callback);
            }
        };
        const isValidEventType = type => typeof type === "string" && /\S/.test(type) || Array.isArray(type) && !!type.length;
        const validateTarget = (target, obj, fnName) => {
            if (!target || !target.nodeName && !isEvented(target)) throw new Error(`Invalid target for ${objName(obj)}#${fnName}; must be a DOM node or evented object.`);
        };
        const validateEventType = (type, obj, fnName) => {
            if (!isValidEventType(type)) throw new Error(`Invalid event type for ${objName(obj)}#${fnName}; must be a non-empty string or array.`);
        };
        const validateListener = (listener, obj, fnName) => {
            if (typeof listener !== "function") throw new Error(`Invalid listener for ${objName(obj)}#${fnName}; must be a function.`);
        };
        const normalizeListenArgs = (self, args, fnName) => {
            const isTargetingSelf = args.length < 3 || args[0] === self || args[0] === self.eventBusEl_;
            let target;
            let type;
            let listener;
            if (isTargetingSelf) {
                target = self.eventBusEl_;
                if (args.length >= 3) args.shift();
                [type, listener] = args;
            } else [target, type, listener] = args;
            validateTarget(target, self, fnName);
            validateEventType(type, self, fnName);
            validateListener(listener, self, fnName);
            listener = bind_(self, listener);
            return {
                isTargetingSelf,
                target,
                type,
                listener
            };
        };
        const listen = (target, method, type, listener) => {
            validateTarget(target, target, method);
            if (target.nodeName) Events[method](target, type, listener); else target[method](type, listener);
        };
        const EventedMixin = {
            on(...args) {
                const {isTargetingSelf, target, type, listener} = normalizeListenArgs(this, args, "on");
                listen(target, "on", type, listener);
                if (!isTargetingSelf) {
                    const removeListenerOnDispose = () => this.off(target, type, listener);
                    removeListenerOnDispose.guid = listener.guid;
                    const removeRemoverOnTargetDispose = () => this.off("dispose", removeListenerOnDispose);
                    removeRemoverOnTargetDispose.guid = listener.guid;
                    listen(this, "on", "dispose", removeListenerOnDispose);
                    listen(target, "on", "dispose", removeRemoverOnTargetDispose);
                }
            },
            one(...args) {
                const {isTargetingSelf, target, type, listener} = normalizeListenArgs(this, args, "one");
                if (isTargetingSelf) listen(target, "one", type, listener); else {
                    const wrapper = (...largs) => {
                        this.off(target, type, wrapper);
                        listener.apply(null, largs);
                    };
                    wrapper.guid = listener.guid;
                    listen(target, "one", type, wrapper);
                }
            },
            any(...args) {
                const {isTargetingSelf, target, type, listener} = normalizeListenArgs(this, args, "any");
                if (isTargetingSelf) listen(target, "any", type, listener); else {
                    const wrapper = (...largs) => {
                        this.off(target, type, wrapper);
                        listener.apply(null, largs);
                    };
                    wrapper.guid = listener.guid;
                    listen(target, "any", type, wrapper);
                }
            },
            off(targetOrType, typeOrListener, listener) {
                if (!targetOrType || isValidEventType(targetOrType)) off(this.eventBusEl_, targetOrType, typeOrListener); else {
                    const target = targetOrType;
                    const type = typeOrListener;
                    validateTarget(target, this, "off");
                    validateEventType(type, this, "off");
                    validateListener(listener, this, "off");
                    listener = bind_(this, listener);
                    this.off("dispose", listener);
                    if (target.nodeName) {
                        off(target, type, listener);
                        off(target, "dispose", listener);
                    } else if (isEvented(target)) {
                        target.off(type, listener);
                        target.off("dispose", listener);
                    }
                }
            },
            trigger(event, hash) {
                validateTarget(this.eventBusEl_, this, "trigger");
                const type = event && typeof event !== "string" ? event.type : event;
                if (!isValidEventType(type)) throw new Error(`Invalid event type for ${objName(this)}#trigger; ` + "must be a non-empty string or object with a type key that has a non-empty value.");
                return trigger(this.eventBusEl_, event, hash);
            }
        };
        function evented(target, options = {}) {
            const {eventBusKey} = options;
            if (eventBusKey) {
                if (!target[eventBusKey].nodeName) throw new Error(`The eventBusKey "${eventBusKey}" does not refer to an element.`);
                target.eventBusEl_ = target[eventBusKey];
            } else target.eventBusEl_ = createEl("span", {
                className: "vjs-event-bus"
            });
            Object.assign(target, EventedMixin);
            if (target.eventedCallbacks) target.eventedCallbacks.forEach((callback => {
                callback();
            }));
            target.on("dispose", (() => {
                target.off();
                [ target, target.el_, target.eventBusEl_ ].forEach((function(val) {
                    if (val && DomData.has(val)) DomData.delete(val);
                }));
                window_default().setTimeout((() => {
                    target.eventBusEl_ = null;
                }), 0);
            }));
            return target;
        }
        const StatefulMixin = {
            state: {},
            setState(stateUpdates) {
                if (typeof stateUpdates === "function") stateUpdates = stateUpdates();
                let changes;
                each(stateUpdates, ((value, key) => {
                    if (this.state[key] !== value) {
                        changes = changes || {};
                        changes[key] = {
                            from: this.state[key],
                            to: value
                        };
                    }
                    this.state[key] = value;
                }));
                if (changes && isEvented(this)) this.trigger({
                    changes,
                    type: "statechanged"
                });
                return changes;
            }
        };
        function stateful(target, defaultState) {
            Object.assign(target, StatefulMixin);
            target.state = Object.assign({}, target.state, defaultState);
            if (typeof target.handleStateChanged === "function" && isEvented(target)) target.on("statechanged", target.handleStateChanged);
            return target;
        }
        const toLowerCase = function(string) {
            if (typeof string !== "string") return string;
            return string.replace(/./, (w => w.toLowerCase()));
        };
        const toTitleCase$1 = function(string) {
            if (typeof string !== "string") return string;
            return string.replace(/./, (w => w.toUpperCase()));
        };
        const titleCaseEquals = function(str1, str2) {
            return toTitleCase$1(str1) === toTitleCase$1(str2);
        };
        var Str = Object.freeze({
            __proto__: null,
            toLowerCase,
            toTitleCase: toTitleCase$1,
            titleCaseEquals
        });
        class Component$1 {
            constructor(player, options, ready) {
                if (!player && this.play) this.player_ = player = this; else this.player_ = player;
                this.isDisposed_ = false;
                this.parentComponent_ = null;
                this.options_ = merge$1({}, this.options_);
                options = this.options_ = merge$1(this.options_, options);
                this.id_ = options.id || options.el && options.el.id;
                if (!this.id_) {
                    const id = player && player.id && player.id() || "no_player";
                    this.id_ = `${id}_component_${newGUID()}`;
                }
                this.name_ = options.name || null;
                if (options.el) this.el_ = options.el; else if (options.createEl !== false) this.el_ = this.createEl();
                if (options.className && this.el_) options.className.split(" ").forEach((c => this.addClass(c)));
                [ "on", "off", "one", "any", "trigger" ].forEach((fn => {
                    this[fn] = void 0;
                }));
                if (options.evented !== false) {
                    evented(this, {
                        eventBusKey: this.el_ ? "el_" : null
                    });
                    this.handleLanguagechange = this.handleLanguagechange.bind(this);
                    this.on(this.player_, "languagechange", this.handleLanguagechange);
                }
                stateful(this, this.constructor.defaultState);
                this.children_ = [];
                this.childIndex_ = {};
                this.childNameIndex_ = {};
                this.setTimeoutIds_ = new Set;
                this.setIntervalIds_ = new Set;
                this.rafIds_ = new Set;
                this.namedRafs_ = new Map;
                this.clearingTimersOnDispose_ = false;
                if (options.initChildren !== false) this.initChildren();
                this.ready(ready);
                if (options.reportTouchActivity !== false) this.enableTouchActivity();
            }
            on(type, fn) {}
            off(type, fn) {}
            one(type, fn) {}
            any(type, fn) {}
            trigger(event) {}
            dispose(options = {}) {
                if (this.isDisposed_) return;
                if (this.readyQueue_) this.readyQueue_.length = 0;
                this.trigger({
                    type: "dispose",
                    bubbles: false
                });
                this.isDisposed_ = true;
                if (this.children_) for (let i = this.children_.length - 1; i >= 0; i--) if (this.children_[i].dispose) this.children_[i].dispose();
                this.children_ = null;
                this.childIndex_ = null;
                this.childNameIndex_ = null;
                this.parentComponent_ = null;
                if (this.el_) {
                    if (this.el_.parentNode) if (options.restoreEl) this.el_.parentNode.replaceChild(options.restoreEl, this.el_); else this.el_.parentNode.removeChild(this.el_);
                    this.el_ = null;
                }
                this.player_ = null;
            }
            isDisposed() {
                return Boolean(this.isDisposed_);
            }
            player() {
                return this.player_;
            }
            options(obj) {
                if (!obj) return this.options_;
                this.options_ = merge$1(this.options_, obj);
                return this.options_;
            }
            el() {
                return this.el_;
            }
            createEl(tagName, properties, attributes) {
                return createEl(tagName, properties, attributes);
            }
            localize(string, tokens, defaultValue = string) {
                const code = this.player_.language && this.player_.language();
                const languages = this.player_.languages && this.player_.languages();
                const language = languages && languages[code];
                const primaryCode = code && code.split("-")[0];
                const primaryLang = languages && languages[primaryCode];
                let localizedString = defaultValue;
                if (language && language[string]) localizedString = language[string]; else if (primaryLang && primaryLang[string]) localizedString = primaryLang[string];
                if (tokens) localizedString = localizedString.replace(/\{(\d+)\}/g, (function(match, index) {
                    const value = tokens[index - 1];
                    let ret = value;
                    if (typeof value === "undefined") ret = match;
                    return ret;
                }));
                return localizedString;
            }
            handleLanguagechange() {}
            contentEl() {
                return this.contentEl_ || this.el_;
            }
            id() {
                return this.id_;
            }
            name() {
                return this.name_;
            }
            children() {
                return this.children_;
            }
            getChildById(id) {
                return this.childIndex_[id];
            }
            getChild(name) {
                if (!name) return;
                return this.childNameIndex_[name];
            }
            getDescendant(...names) {
                names = names.reduce(((acc, n) => acc.concat(n)), []);
                let currentChild = this;
                for (let i = 0; i < names.length; i++) {
                    currentChild = currentChild.getChild(names[i]);
                    if (!currentChild || !currentChild.getChild) return;
                }
                return currentChild;
            }
            addChild(child, options = {}, index = this.children_.length) {
                let component;
                let componentName;
                if (typeof child === "string") {
                    componentName = toTitleCase$1(child);
                    const componentClassName = options.componentClass || componentName;
                    options.name = componentName;
                    const ComponentClass = Component$1.getComponent(componentClassName);
                    if (!ComponentClass) throw new Error(`Component ${componentClassName} does not exist`);
                    if (typeof ComponentClass !== "function") return null;
                    component = new ComponentClass(this.player_ || this, options);
                } else component = child;
                if (component.parentComponent_) component.parentComponent_.removeChild(component);
                this.children_.splice(index, 0, component);
                component.parentComponent_ = this;
                if (typeof component.id === "function") this.childIndex_[component.id()] = component;
                componentName = componentName || component.name && toTitleCase$1(component.name());
                if (componentName) {
                    this.childNameIndex_[componentName] = component;
                    this.childNameIndex_[toLowerCase(componentName)] = component;
                }
                if (typeof component.el === "function" && component.el()) {
                    let refNode = null;
                    if (this.children_[index + 1]) if (this.children_[index + 1].el_) refNode = this.children_[index + 1].el_; else if (isEl(this.children_[index + 1])) refNode = this.children_[index + 1];
                    this.contentEl().insertBefore(component.el(), refNode);
                }
                return component;
            }
            removeChild(component) {
                if (typeof component === "string") component = this.getChild(component);
                if (!component || !this.children_) return;
                let childFound = false;
                for (let i = this.children_.length - 1; i >= 0; i--) if (this.children_[i] === component) {
                    childFound = true;
                    this.children_.splice(i, 1);
                    break;
                }
                if (!childFound) return;
                component.parentComponent_ = null;
                this.childIndex_[component.id()] = null;
                this.childNameIndex_[toTitleCase$1(component.name())] = null;
                this.childNameIndex_[toLowerCase(component.name())] = null;
                const compEl = component.el();
                if (compEl && compEl.parentNode === this.contentEl()) this.contentEl().removeChild(component.el());
            }
            initChildren() {
                const children = this.options_.children;
                if (children) {
                    const parentOptions = this.options_;
                    const handleAdd = child => {
                        const name = child.name;
                        let opts = child.opts;
                        if (parentOptions[name] !== void 0) opts = parentOptions[name];
                        if (opts === false) return;
                        if (opts === true) opts = {};
                        opts.playerOptions = this.options_.playerOptions;
                        const newChild = this.addChild(name, opts);
                        if (newChild) this[name] = newChild;
                    };
                    let workingChildren;
                    const Tech = Component$1.getComponent("Tech");
                    if (Array.isArray(children)) workingChildren = children; else workingChildren = Object.keys(children);
                    workingChildren.concat(Object.keys(this.options_).filter((function(child) {
                        return !workingChildren.some((function(wchild) {
                            if (typeof wchild === "string") return child === wchild;
                            return child === wchild.name;
                        }));
                    }))).map((child => {
                        let name;
                        let opts;
                        if (typeof child === "string") {
                            name = child;
                            opts = children[name] || this.options_[name] || {};
                        } else {
                            name = child.name;
                            opts = child;
                        }
                        return {
                            name,
                            opts
                        };
                    })).filter((child => {
                        const c = Component$1.getComponent(child.opts.componentClass || toTitleCase$1(child.name));
                        return c && !Tech.isTech(c);
                    })).forEach(handleAdd);
                }
            }
            buildCSSClass() {
                return "";
            }
            ready(fn, sync = false) {
                if (!fn) return;
                if (!this.isReady_) {
                    this.readyQueue_ = this.readyQueue_ || [];
                    this.readyQueue_.push(fn);
                    return;
                }
                if (sync) fn.call(this); else this.setTimeout(fn, 1);
            }
            triggerReady() {
                this.isReady_ = true;
                this.setTimeout((function() {
                    const readyQueue = this.readyQueue_;
                    this.readyQueue_ = [];
                    if (readyQueue && readyQueue.length > 0) readyQueue.forEach((function(fn) {
                        fn.call(this);
                    }), this);
                    this.trigger("ready");
                }), 1);
            }
            $(selector, context) {
                return video_es_$(selector, context || this.contentEl());
            }
            $$(selector, context) {
                return $$(selector, context || this.contentEl());
            }
            hasClass(classToCheck) {
                return hasClass(this.el_, classToCheck);
            }
            addClass(...classesToAdd) {
                addClass(this.el_, ...classesToAdd);
            }
            removeClass(...classesToRemove) {
                removeClass(this.el_, ...classesToRemove);
            }
            toggleClass(classToToggle, predicate) {
                toggleClass(this.el_, classToToggle, predicate);
            }
            show() {
                this.removeClass("vjs-hidden");
            }
            hide() {
                this.addClass("vjs-hidden");
            }
            lockShowing() {
                this.addClass("vjs-lock-showing");
            }
            unlockShowing() {
                this.removeClass("vjs-lock-showing");
            }
            getAttribute(attribute) {
                return getAttribute(this.el_, attribute);
            }
            setAttribute(attribute, value) {
                setAttribute(this.el_, attribute, value);
            }
            removeAttribute(attribute) {
                removeAttribute(this.el_, attribute);
            }
            width(num, skipListeners) {
                return this.dimension("width", num, skipListeners);
            }
            height(num, skipListeners) {
                return this.dimension("height", num, skipListeners);
            }
            dimensions(width, height) {
                this.width(width, true);
                this.height(height);
            }
            dimension(widthOrHeight, num, skipListeners) {
                if (num !== void 0) {
                    if (num === null || num !== num) num = 0;
                    if (("" + num).indexOf("%") !== -1 || ("" + num).indexOf("px") !== -1) this.el_.style[widthOrHeight] = num; else if (num === "auto") this.el_.style[widthOrHeight] = ""; else this.el_.style[widthOrHeight] = num + "px";
                    if (!skipListeners) this.trigger("componentresize");
                    return;
                }
                if (!this.el_) return 0;
                const val = this.el_.style[widthOrHeight];
                const pxIndex = val.indexOf("px");
                if (pxIndex !== -1) return parseInt(val.slice(0, pxIndex), 10);
                return parseInt(this.el_["offset" + toTitleCase$1(widthOrHeight)], 10);
            }
            currentDimension(widthOrHeight) {
                let computedWidthOrHeight = 0;
                if (widthOrHeight !== "width" && widthOrHeight !== "height") throw new Error("currentDimension only accepts width or height value");
                computedWidthOrHeight = computedStyle(this.el_, widthOrHeight);
                computedWidthOrHeight = parseFloat(computedWidthOrHeight);
                if (computedWidthOrHeight === 0 || isNaN(computedWidthOrHeight)) {
                    const rule = `offset${toTitleCase$1(widthOrHeight)}`;
                    computedWidthOrHeight = this.el_[rule];
                }
                return computedWidthOrHeight;
            }
            currentDimensions() {
                return {
                    width: this.currentDimension("width"),
                    height: this.currentDimension("height")
                };
            }
            currentWidth() {
                return this.currentDimension("width");
            }
            currentHeight() {
                return this.currentDimension("height");
            }
            focus() {
                this.el_.focus();
            }
            blur() {
                this.el_.blur();
            }
            handleKeyDown(event) {
                if (this.player_) {
                    if (!keycode_default().isEventKey(event, "Tab")) event.stopPropagation();
                    this.player_.handleKeyDown(event);
                }
            }
            handleKeyPress(event) {
                this.handleKeyDown(event);
            }
            emitTapEvents() {
                let touchStart = 0;
                let firstTouch = null;
                const tapMovementThreshold = 10;
                const touchTimeThreshold = 200;
                let couldBeTap;
                this.on("touchstart", (function(event) {
                    if (event.touches.length === 1) {
                        firstTouch = {
                            pageX: event.touches[0].pageX,
                            pageY: event.touches[0].pageY
                        };
                        touchStart = window_default().performance.now();
                        couldBeTap = true;
                    }
                }));
                this.on("touchmove", (function(event) {
                    if (event.touches.length > 1) couldBeTap = false; else if (firstTouch) {
                        const xdiff = event.touches[0].pageX - firstTouch.pageX;
                        const ydiff = event.touches[0].pageY - firstTouch.pageY;
                        const touchDistance = Math.sqrt(xdiff * xdiff + ydiff * ydiff);
                        if (touchDistance > tapMovementThreshold) couldBeTap = false;
                    }
                }));
                const noTap = function() {
                    couldBeTap = false;
                };
                this.on("touchleave", noTap);
                this.on("touchcancel", noTap);
                this.on("touchend", (function(event) {
                    firstTouch = null;
                    if (couldBeTap === true) {
                        const touchTime = window_default().performance.now() - touchStart;
                        if (touchTime < touchTimeThreshold) {
                            event.preventDefault();
                            this.trigger("tap");
                        }
                    }
                }));
            }
            enableTouchActivity() {
                if (!this.player() || !this.player().reportUserActivity) return;
                const report = bind_(this.player(), this.player().reportUserActivity);
                let touchHolding;
                this.on("touchstart", (function() {
                    report();
                    this.clearInterval(touchHolding);
                    touchHolding = this.setInterval(report, 250);
                }));
                const touchEnd = function(event) {
                    report();
                    this.clearInterval(touchHolding);
                };
                this.on("touchmove", report);
                this.on("touchend", touchEnd);
                this.on("touchcancel", touchEnd);
            }
            setTimeout(fn, timeout) {
                var timeoutId;
                fn = bind_(this, fn);
                this.clearTimersOnDispose_();
                timeoutId = window_default().setTimeout((() => {
                    if (this.setTimeoutIds_.has(timeoutId)) this.setTimeoutIds_.delete(timeoutId);
                    fn();
                }), timeout);
                this.setTimeoutIds_.add(timeoutId);
                return timeoutId;
            }
            clearTimeout(timeoutId) {
                if (this.setTimeoutIds_.has(timeoutId)) {
                    this.setTimeoutIds_.delete(timeoutId);
                    window_default().clearTimeout(timeoutId);
                }
                return timeoutId;
            }
            setInterval(fn, interval) {
                fn = bind_(this, fn);
                this.clearTimersOnDispose_();
                const intervalId = window_default().setInterval(fn, interval);
                this.setIntervalIds_.add(intervalId);
                return intervalId;
            }
            clearInterval(intervalId) {
                if (this.setIntervalIds_.has(intervalId)) {
                    this.setIntervalIds_.delete(intervalId);
                    window_default().clearInterval(intervalId);
                }
                return intervalId;
            }
            requestAnimationFrame(fn) {
                this.clearTimersOnDispose_();
                var id;
                fn = bind_(this, fn);
                id = window_default().requestAnimationFrame((() => {
                    if (this.rafIds_.has(id)) this.rafIds_.delete(id);
                    fn();
                }));
                this.rafIds_.add(id);
                return id;
            }
            requestNamedAnimationFrame(name, fn) {
                if (this.namedRafs_.has(name)) return;
                this.clearTimersOnDispose_();
                fn = bind_(this, fn);
                const id = this.requestAnimationFrame((() => {
                    fn();
                    if (this.namedRafs_.has(name)) this.namedRafs_.delete(name);
                }));
                this.namedRafs_.set(name, id);
                return name;
            }
            cancelNamedAnimationFrame(name) {
                if (!this.namedRafs_.has(name)) return;
                this.cancelAnimationFrame(this.namedRafs_.get(name));
                this.namedRafs_.delete(name);
            }
            cancelAnimationFrame(id) {
                if (this.rafIds_.has(id)) {
                    this.rafIds_.delete(id);
                    window_default().cancelAnimationFrame(id);
                }
                return id;
            }
            clearTimersOnDispose_() {
                if (this.clearingTimersOnDispose_) return;
                this.clearingTimersOnDispose_ = true;
                this.one("dispose", (() => {
                    [ [ "namedRafs_", "cancelNamedAnimationFrame" ], [ "rafIds_", "cancelAnimationFrame" ], [ "setTimeoutIds_", "clearTimeout" ], [ "setIntervalIds_", "clearInterval" ] ].forEach((([idName, cancelName]) => {
                        this[idName].forEach(((val, key) => this[cancelName](key)));
                    }));
                    this.clearingTimersOnDispose_ = false;
                }));
            }
            static registerComponent(name, ComponentToRegister) {
                if (typeof name !== "string" || !name) throw new Error(`Illegal component name, "${name}"; must be a non-empty string.`);
                const Tech = Component$1.getComponent("Tech");
                const isTech = Tech && Tech.isTech(ComponentToRegister);
                const isComp = Component$1 === ComponentToRegister || Component$1.prototype.isPrototypeOf(ComponentToRegister.prototype);
                if (isTech || !isComp) {
                    let reason;
                    if (isTech) reason = "techs must be registered using Tech.registerTech()"; else reason = "must be a Component subclass";
                    throw new Error(`Illegal component, "${name}"; ${reason}.`);
                }
                name = toTitleCase$1(name);
                if (!Component$1.components_) Component$1.components_ = {};
                const Player = Component$1.getComponent("Player");
                if (name === "Player" && Player && Player.players) {
                    const players = Player.players;
                    const playerNames = Object.keys(players);
                    if (players && playerNames.length > 0 && playerNames.map((pname => players[pname])).every(Boolean)) throw new Error("Can not register Player component after player has been created.");
                }
                Component$1.components_[name] = ComponentToRegister;
                Component$1.components_[toLowerCase(name)] = ComponentToRegister;
                return ComponentToRegister;
            }
            static getComponent(name) {
                if (!name || !Component$1.components_) return;
                return Component$1.components_[name];
            }
        }
        Component$1.registerComponent("Component", Component$1);
        function rangeCheck(fnName, index, maxIndex) {
            if (typeof index !== "number" || index < 0 || index > maxIndex) throw new Error(`Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${maxIndex}).`);
        }
        function getRange(fnName, valueIndex, ranges, rangeIndex) {
            rangeCheck(fnName, rangeIndex, ranges.length - 1);
            return ranges[rangeIndex][valueIndex];
        }
        function createTimeRangesObj(ranges) {
            let timeRangesObj;
            if (ranges === void 0 || ranges.length === 0) timeRangesObj = {
                length: 0,
                start() {
                    throw new Error("This TimeRanges object is empty");
                },
                end() {
                    throw new Error("This TimeRanges object is empty");
                }
            }; else timeRangesObj = {
                length: ranges.length,
                start: getRange.bind(null, "start", 0, ranges),
                end: getRange.bind(null, "end", 1, ranges)
            };
            if (window_default().Symbol && window_default().Symbol.iterator) timeRangesObj[window_default().Symbol.iterator] = () => (ranges || []).values();
            return timeRangesObj;
        }
        function createTimeRanges$1(start, end) {
            if (Array.isArray(start)) return createTimeRangesObj(start); else if (start === void 0 || end === void 0) return createTimeRangesObj();
            return createTimeRangesObj([ [ start, end ] ]);
        }
        const defaultImplementation = function(seconds, guide) {
            seconds = seconds < 0 ? 0 : seconds;
            let s = Math.floor(seconds % 60);
            let m = Math.floor(seconds / 60 % 60);
            let h = Math.floor(seconds / 3600);
            const gm = Math.floor(guide / 60 % 60);
            const gh = Math.floor(guide / 3600);
            if (isNaN(seconds) || seconds === 1 / 0) h = m = s = "-";
            h = h > 0 || gh > 0 ? h + ":" : "";
            m = ((h || gm >= 10) && m < 10 ? "0" + m : m) + ":";
            s = s < 10 ? "0" + s : s;
            return h + m + s;
        };
        let implementation = defaultImplementation;
        function setFormatTime(customImplementation) {
            implementation = customImplementation;
        }
        function resetFormatTime() {
            implementation = defaultImplementation;
        }
        function formatTime(seconds, guide = seconds) {
            return implementation(seconds, guide);
        }
        var Time = Object.freeze({
            __proto__: null,
            createTimeRanges: createTimeRanges$1,
            createTimeRange: createTimeRanges$1,
            setFormatTime,
            resetFormatTime,
            formatTime
        });
        function bufferedPercent(buffered, duration) {
            let bufferedDuration = 0;
            let start;
            let end;
            if (!duration) return 0;
            if (!buffered || !buffered.length) buffered = createTimeRanges$1(0, 0);
            for (let i = 0; i < buffered.length; i++) {
                start = buffered.start(i);
                end = buffered.end(i);
                if (end > duration) end = duration;
                bufferedDuration += end - start;
            }
            return bufferedDuration / duration;
        }
        function MediaError(value) {
            if (value instanceof MediaError) return value;
            if (typeof value === "number") this.code = value; else if (typeof value === "string") this.message = value; else if (video_es_isObject(value)) {
                if (typeof value.code === "number") this.code = value.code;
                Object.assign(this, value);
            }
            if (!this.message) this.message = MediaError.defaultMessages[this.code] || "";
        }
        MediaError.prototype.code = 0;
        MediaError.prototype.message = "";
        MediaError.prototype.status = null;
        MediaError.errorTypes = [ "MEDIA_ERR_CUSTOM", "MEDIA_ERR_ABORTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_DECODE", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_ERR_ENCRYPTED" ];
        MediaError.defaultMessages = {
            1: "You aborted the media playback",
            2: "A network error caused the media download to fail part-way.",
            3: "The media playback was aborted due to a corruption problem or because the media used features your browser did not support.",
            4: "The media could not be loaded, either because the server or network failed or because the format is not supported.",
            5: "The media is encrypted and we do not have the keys to decrypt it."
        };
        for (let errNum = 0; errNum < MediaError.errorTypes.length; errNum++) {
            MediaError[MediaError.errorTypes[errNum]] = errNum;
            MediaError.prototype[MediaError.errorTypes[errNum]] = errNum;
        }
        function isPromise(value) {
            return value !== void 0 && value !== null && typeof value.then === "function";
        }
        function silencePromise(value) {
            if (isPromise(value)) value.then(null, (e => {}));
        }
        const trackToJson_ = function(track) {
            const ret = [ "kind", "label", "language", "id", "inBandMetadataTrackDispatchType", "mode", "src" ].reduce(((acc, prop, i) => {
                if (track[prop]) acc[prop] = track[prop];
                return acc;
            }), {
                cues: track.cues && Array.prototype.map.call(track.cues, (function(cue) {
                    return {
                        startTime: cue.startTime,
                        endTime: cue.endTime,
                        text: cue.text,
                        id: cue.id
                    };
                }))
            });
            return ret;
        };
        const textTracksToJson = function(tech) {
            const trackEls = tech.$$("track");
            const trackObjs = Array.prototype.map.call(trackEls, (t => t.track));
            const tracks = Array.prototype.map.call(trackEls, (function(trackEl) {
                const json = trackToJson_(trackEl.track);
                if (trackEl.src) json.src = trackEl.src;
                return json;
            }));
            return tracks.concat(Array.prototype.filter.call(tech.textTracks(), (function(track) {
                return trackObjs.indexOf(track) === -1;
            })).map(trackToJson_));
        };
        const jsonToTextTracks = function(json, tech) {
            json.forEach((function(track) {
                const addedTrack = tech.addRemoteTextTrack(track).track;
                if (!track.src && track.cues) track.cues.forEach((cue => addedTrack.addCue(cue)));
            }));
            return tech.textTracks();
        };
        var textTrackConverter = {
            textTracksToJson,
            jsonToTextTracks,
            trackToJson_
        };
        const MODAL_CLASS_NAME = "vjs-modal-dialog";
        class ModalDialog extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.handleKeyDown_ = e => this.handleKeyDown(e);
                this.close_ = e => this.close(e);
                this.opened_ = this.hasBeenOpened_ = this.hasBeenFilled_ = false;
                this.closeable(!this.options_.uncloseable);
                this.content(this.options_.content);
                this.contentEl_ = createEl("div", {
                    className: `${MODAL_CLASS_NAME}-content`
                }, {
                    role: "document"
                });
                this.descEl_ = createEl("p", {
                    className: `${MODAL_CLASS_NAME}-description vjs-control-text`,
                    id: this.el().getAttribute("aria-describedby")
                });
                textContent(this.descEl_, this.description());
                this.el_.appendChild(this.descEl_);
                this.el_.appendChild(this.contentEl_);
            }
            createEl() {
                return super.createEl("div", {
                    className: this.buildCSSClass(),
                    tabIndex: -1
                }, {
                    "aria-describedby": `${this.id()}_description`,
                    "aria-hidden": "true",
                    "aria-label": this.label(),
                    role: "dialog"
                });
            }
            dispose() {
                this.contentEl_ = null;
                this.descEl_ = null;
                this.previouslyActiveEl_ = null;
                super.dispose();
            }
            buildCSSClass() {
                return `${MODAL_CLASS_NAME} vjs-hidden ${super.buildCSSClass()}`;
            }
            label() {
                return this.localize(this.options_.label || "Modal Window");
            }
            description() {
                let desc = this.options_.description || this.localize("This is a modal window.");
                if (this.closeable()) desc += " " + this.localize("This modal can be closed by pressing the Escape key or activating the close button.");
                return desc;
            }
            open() {
                if (!this.opened_) {
                    const player = this.player();
                    this.trigger("beforemodalopen");
                    this.opened_ = true;
                    if (this.options_.fillAlways || !this.hasBeenOpened_ && !this.hasBeenFilled_) this.fill();
                    this.wasPlaying_ = !player.paused();
                    if (this.options_.pauseOnOpen && this.wasPlaying_) player.pause();
                    this.on("keydown", this.handleKeyDown_);
                    this.hadControls_ = player.controls();
                    player.controls(false);
                    this.show();
                    this.conditionalFocus_();
                    this.el().setAttribute("aria-hidden", "false");
                    this.trigger("modalopen");
                    this.hasBeenOpened_ = true;
                }
            }
            opened(value) {
                if (typeof value === "boolean") this[value ? "open" : "close"]();
                return this.opened_;
            }
            close() {
                if (!this.opened_) return;
                const player = this.player();
                this.trigger("beforemodalclose");
                this.opened_ = false;
                if (this.wasPlaying_ && this.options_.pauseOnOpen) player.play();
                this.off("keydown", this.handleKeyDown_);
                if (this.hadControls_) player.controls(true);
                this.hide();
                this.el().setAttribute("aria-hidden", "true");
                this.trigger("modalclose");
                this.conditionalBlur_();
                if (this.options_.temporary) this.dispose();
            }
            closeable(value) {
                if (typeof value === "boolean") {
                    const closeable = this.closeable_ = !!value;
                    let close = this.getChild("closeButton");
                    if (closeable && !close) {
                        const temp = this.contentEl_;
                        this.contentEl_ = this.el_;
                        close = this.addChild("closeButton", {
                            controlText: "Close Modal Dialog"
                        });
                        this.contentEl_ = temp;
                        this.on(close, "close", this.close_);
                    }
                    if (!closeable && close) {
                        this.off(close, "close", this.close_);
                        this.removeChild(close);
                        close.dispose();
                    }
                }
                return this.closeable_;
            }
            fill() {
                this.fillWith(this.content());
            }
            fillWith(content) {
                const contentEl = this.contentEl();
                const parentEl = contentEl.parentNode;
                const nextSiblingEl = contentEl.nextSibling;
                this.trigger("beforemodalfill");
                this.hasBeenFilled_ = true;
                parentEl.removeChild(contentEl);
                this.empty();
                insertContent(contentEl, content);
                this.trigger("modalfill");
                if (nextSiblingEl) parentEl.insertBefore(contentEl, nextSiblingEl); else parentEl.appendChild(contentEl);
                const closeButton = this.getChild("closeButton");
                if (closeButton) parentEl.appendChild(closeButton.el_);
            }
            empty() {
                this.trigger("beforemodalempty");
                emptyEl(this.contentEl());
                this.trigger("modalempty");
            }
            content(value) {
                if (typeof value !== "undefined") this.content_ = value;
                return this.content_;
            }
            conditionalFocus_() {
                const activeEl = document_default().activeElement;
                const playerEl = this.player_.el_;
                this.previouslyActiveEl_ = null;
                if (playerEl.contains(activeEl) || playerEl === activeEl) {
                    this.previouslyActiveEl_ = activeEl;
                    this.focus();
                }
            }
            conditionalBlur_() {
                if (this.previouslyActiveEl_) {
                    this.previouslyActiveEl_.focus();
                    this.previouslyActiveEl_ = null;
                }
            }
            handleKeyDown(event) {
                event.stopPropagation();
                if (keycode_default().isEventKey(event, "Escape") && this.closeable()) {
                    event.preventDefault();
                    this.close();
                    return;
                }
                if (!keycode_default().isEventKey(event, "Tab")) return;
                const focusableEls = this.focusableEls_();
                const activeEl = this.el_.querySelector(":focus");
                let focusIndex;
                for (let i = 0; i < focusableEls.length; i++) if (activeEl === focusableEls[i]) {
                    focusIndex = i;
                    break;
                }
                if (document_default().activeElement === this.el_) focusIndex = 0;
                if (event.shiftKey && focusIndex === 0) {
                    focusableEls[focusableEls.length - 1].focus();
                    event.preventDefault();
                } else if (!event.shiftKey && focusIndex === focusableEls.length - 1) {
                    focusableEls[0].focus();
                    event.preventDefault();
                }
            }
            focusableEls_() {
                const allChildren = this.el_.querySelectorAll("*");
                return Array.prototype.filter.call(allChildren, (child => (child instanceof window_default().HTMLAnchorElement || child instanceof window_default().HTMLAreaElement) && child.hasAttribute("href") || (child instanceof window_default().HTMLInputElement || child instanceof window_default().HTMLSelectElement || child instanceof window_default().HTMLTextAreaElement || child instanceof window_default().HTMLButtonElement) && !child.hasAttribute("disabled") || child instanceof window_default().HTMLIFrameElement || child instanceof window_default().HTMLObjectElement || child instanceof window_default().HTMLEmbedElement || child.hasAttribute("tabindex") && child.getAttribute("tabindex") !== -1 || child.hasAttribute("contenteditable")));
            }
        }
        ModalDialog.prototype.options_ = {
            pauseOnOpen: true,
            temporary: true
        };
        Component$1.registerComponent("ModalDialog", ModalDialog);
        class TrackList extends EventTarget$2 {
            constructor(tracks = []) {
                super();
                this.tracks_ = [];
                Object.defineProperty(this, "length", {
                    get() {
                        return this.tracks_.length;
                    }
                });
                for (let i = 0; i < tracks.length; i++) this.addTrack(tracks[i]);
            }
            addTrack(track) {
                const index = this.tracks_.length;
                if (!("" + index in this)) Object.defineProperty(this, index, {
                    get() {
                        return this.tracks_[index];
                    }
                });
                if (this.tracks_.indexOf(track) === -1) {
                    this.tracks_.push(track);
                    this.trigger({
                        track,
                        type: "addtrack",
                        target: this
                    });
                }
                track.labelchange_ = () => {
                    this.trigger({
                        track,
                        type: "labelchange",
                        target: this
                    });
                };
                if (isEvented(track)) track.addEventListener("labelchange", track.labelchange_);
            }
            removeTrack(rtrack) {
                let track;
                for (let i = 0, l = this.length; i < l; i++) if (this[i] === rtrack) {
                    track = this[i];
                    if (track.off) track.off();
                    this.tracks_.splice(i, 1);
                    break;
                }
                if (!track) return;
                this.trigger({
                    track,
                    type: "removetrack",
                    target: this
                });
            }
            getTrackById(id) {
                let result = null;
                for (let i = 0, l = this.length; i < l; i++) {
                    const track = this[i];
                    if (track.id === id) {
                        result = track;
                        break;
                    }
                }
                return result;
            }
        }
        TrackList.prototype.allowedEvents_ = {
            change: "change",
            addtrack: "addtrack",
            removetrack: "removetrack",
            labelchange: "labelchange"
        };
        for (const event in TrackList.prototype.allowedEvents_) TrackList.prototype["on" + event] = null;
        const disableOthers$1 = function(list, track) {
            for (let i = 0; i < list.length; i++) {
                if (!Object.keys(list[i]).length || track.id === list[i].id) continue;
                list[i].enabled = false;
            }
        };
        class AudioTrackList extends TrackList {
            constructor(tracks = []) {
                for (let i = tracks.length - 1; i >= 0; i--) if (tracks[i].enabled) {
                    disableOthers$1(tracks, tracks[i]);
                    break;
                }
                super(tracks);
                this.changing_ = false;
            }
            addTrack(track) {
                if (track.enabled) disableOthers$1(this, track);
                super.addTrack(track);
                if (!track.addEventListener) return;
                track.enabledChange_ = () => {
                    if (this.changing_) return;
                    this.changing_ = true;
                    disableOthers$1(this, track);
                    this.changing_ = false;
                    this.trigger("change");
                };
                track.addEventListener("enabledchange", track.enabledChange_);
            }
            removeTrack(rtrack) {
                super.removeTrack(rtrack);
                if (rtrack.removeEventListener && rtrack.enabledChange_) {
                    rtrack.removeEventListener("enabledchange", rtrack.enabledChange_);
                    rtrack.enabledChange_ = null;
                }
            }
        }
        const disableOthers = function(list, track) {
            for (let i = 0; i < list.length; i++) {
                if (!Object.keys(list[i]).length || track.id === list[i].id) continue;
                list[i].selected = false;
            }
        };
        class VideoTrackList extends TrackList {
            constructor(tracks = []) {
                for (let i = tracks.length - 1; i >= 0; i--) if (tracks[i].selected) {
                    disableOthers(tracks, tracks[i]);
                    break;
                }
                super(tracks);
                this.changing_ = false;
                Object.defineProperty(this, "selectedIndex", {
                    get() {
                        for (let i = 0; i < this.length; i++) if (this[i].selected) return i;
                        return -1;
                    },
                    set() {}
                });
            }
            addTrack(track) {
                if (track.selected) disableOthers(this, track);
                super.addTrack(track);
                if (!track.addEventListener) return;
                track.selectedChange_ = () => {
                    if (this.changing_) return;
                    this.changing_ = true;
                    disableOthers(this, track);
                    this.changing_ = false;
                    this.trigger("change");
                };
                track.addEventListener("selectedchange", track.selectedChange_);
            }
            removeTrack(rtrack) {
                super.removeTrack(rtrack);
                if (rtrack.removeEventListener && rtrack.selectedChange_) {
                    rtrack.removeEventListener("selectedchange", rtrack.selectedChange_);
                    rtrack.selectedChange_ = null;
                }
            }
        }
        class TextTrackList extends TrackList {
            addTrack(track) {
                super.addTrack(track);
                if (!this.queueChange_) this.queueChange_ = () => this.queueTrigger("change");
                if (!this.triggerSelectedlanguagechange) this.triggerSelectedlanguagechange_ = () => this.trigger("selectedlanguagechange");
                track.addEventListener("modechange", this.queueChange_);
                const nonLanguageTextTrackKind = [ "metadata", "chapters" ];
                if (nonLanguageTextTrackKind.indexOf(track.kind) === -1) track.addEventListener("modechange", this.triggerSelectedlanguagechange_);
            }
            removeTrack(rtrack) {
                super.removeTrack(rtrack);
                if (rtrack.removeEventListener) {
                    if (this.queueChange_) rtrack.removeEventListener("modechange", this.queueChange_);
                    if (this.selectedlanguagechange_) rtrack.removeEventListener("modechange", this.triggerSelectedlanguagechange_);
                }
            }
        }
        class HtmlTrackElementList {
            constructor(trackElements = []) {
                this.trackElements_ = [];
                Object.defineProperty(this, "length", {
                    get() {
                        return this.trackElements_.length;
                    }
                });
                for (let i = 0, length = trackElements.length; i < length; i++) this.addTrackElement_(trackElements[i]);
            }
            addTrackElement_(trackElement) {
                const index = this.trackElements_.length;
                if (!("" + index in this)) Object.defineProperty(this, index, {
                    get() {
                        return this.trackElements_[index];
                    }
                });
                if (this.trackElements_.indexOf(trackElement) === -1) this.trackElements_.push(trackElement);
            }
            getTrackElementByTrack_(track) {
                let trackElement_;
                for (let i = 0, length = this.trackElements_.length; i < length; i++) if (track === this.trackElements_[i].track) {
                    trackElement_ = this.trackElements_[i];
                    break;
                }
                return trackElement_;
            }
            removeTrackElement_(trackElement) {
                for (let i = 0, length = this.trackElements_.length; i < length; i++) if (trackElement === this.trackElements_[i]) {
                    if (this.trackElements_[i].track && typeof this.trackElements_[i].track.off === "function") this.trackElements_[i].track.off();
                    if (typeof this.trackElements_[i].off === "function") this.trackElements_[i].off();
                    this.trackElements_.splice(i, 1);
                    break;
                }
            }
        }
        class TextTrackCueList {
            constructor(cues) {
                TextTrackCueList.prototype.setCues_.call(this, cues);
                Object.defineProperty(this, "length", {
                    get() {
                        return this.length_;
                    }
                });
            }
            setCues_(cues) {
                const oldLength = this.length || 0;
                let i = 0;
                const l = cues.length;
                this.cues_ = cues;
                this.length_ = cues.length;
                const defineProp = function(index) {
                    if (!("" + index in this)) Object.defineProperty(this, "" + index, {
                        get() {
                            return this.cues_[index];
                        }
                    });
                };
                if (oldLength < l) {
                    i = oldLength;
                    for (;i < l; i++) defineProp.call(this, i);
                }
            }
            getCueById(id) {
                let result = null;
                for (let i = 0, l = this.length; i < l; i++) {
                    const cue = this[i];
                    if (cue.id === id) {
                        result = cue;
                        break;
                    }
                }
                return result;
            }
        }
        const VideoTrackKind = {
            alternative: "alternative",
            captions: "captions",
            main: "main",
            sign: "sign",
            subtitles: "subtitles",
            commentary: "commentary"
        };
        const AudioTrackKind = {
            alternative: "alternative",
            descriptions: "descriptions",
            main: "main",
            "main-desc": "main-desc",
            translation: "translation",
            commentary: "commentary"
        };
        const TextTrackKind = {
            subtitles: "subtitles",
            captions: "captions",
            descriptions: "descriptions",
            chapters: "chapters",
            metadata: "metadata"
        };
        const TextTrackMode = {
            disabled: "disabled",
            hidden: "hidden",
            showing: "showing"
        };
        class Track extends EventTarget$2 {
            constructor(options = {}) {
                super();
                const trackProps = {
                    id: options.id || "vjs_track_" + newGUID(),
                    kind: options.kind || "",
                    language: options.language || ""
                };
                let label = options.label || "";
                for (const key in trackProps) Object.defineProperty(this, key, {
                    get() {
                        return trackProps[key];
                    },
                    set() {}
                });
                Object.defineProperty(this, "label", {
                    get() {
                        return label;
                    },
                    set(newLabel) {
                        if (newLabel !== label) {
                            label = newLabel;
                            this.trigger("labelchange");
                        }
                    }
                });
            }
        }
        const parseUrl = function(url) {
            const props = [ "protocol", "hostname", "port", "pathname", "search", "hash", "host" ];
            const a = document_default().createElement("a");
            a.href = url;
            const details = {};
            for (let i = 0; i < props.length; i++) details[props[i]] = a[props[i]];
            if (details.protocol === "http:") details.host = details.host.replace(/:80$/, "");
            if (details.protocol === "https:") details.host = details.host.replace(/:443$/, "");
            if (!details.protocol) details.protocol = window_default().location.protocol;
            if (!details.host) details.host = window_default().location.host;
            return details;
        };
        const getAbsoluteURL = function(url) {
            if (!url.match(/^https?:\/\//)) {
                const a = document_default().createElement("a");
                a.href = url;
                url = a.href;
            }
            return url;
        };
        const getFileExtension = function(path) {
            if (typeof path === "string") {
                const splitPathRe = /^(\/?)([\s\S]*?)((?:\.{1,2}|[^\/]+?)(\.([^\.\/\?]+)))(?:[\/]*|[\?].*)$/;
                const pathParts = splitPathRe.exec(path);
                if (pathParts) return pathParts.pop().toLowerCase();
            }
            return "";
        };
        const isCrossOrigin = function(url, winLoc = window_default().location) {
            const urlInfo = parseUrl(url);
            const srcProtocol = urlInfo.protocol === ":" ? winLoc.protocol : urlInfo.protocol;
            const crossOrigin = srcProtocol + urlInfo.host !== winLoc.protocol + winLoc.host;
            return crossOrigin;
        };
        var Url = Object.freeze({
            __proto__: null,
            parseUrl,
            getAbsoluteURL,
            getFileExtension,
            isCrossOrigin
        });
        const parseCues = function(srcContent, track) {
            const parser = new (window_default().WebVTT.Parser)(window_default(), window_default().vttjs, window_default().WebVTT.StringDecoder());
            const errors = [];
            parser.oncue = function(cue) {
                track.addCue(cue);
            };
            parser.onparsingerror = function(error) {
                errors.push(error);
            };
            parser.onflush = function() {
                track.trigger({
                    type: "loadeddata",
                    target: track
                });
            };
            parser.parse(srcContent);
            if (errors.length > 0) {
                if (window_default().console && window_default().console.groupCollapsed) window_default().console.groupCollapsed(`Text Track parsing errors for ${track.src}`);
                errors.forEach((error => log$1.error(error)));
                if (window_default().console && window_default().console.groupEnd) window_default().console.groupEnd();
            }
            parser.flush();
        };
        const loadTrack = function(src, track) {
            const opts = {
                uri: src
            };
            const crossOrigin = isCrossOrigin(src);
            if (crossOrigin) opts.cors = crossOrigin;
            const withCredentials = track.tech_.crossOrigin() === "use-credentials";
            if (withCredentials) opts.withCredentials = withCredentials;
            lib_default()(opts, bind_(this, (function(err, response, responseBody) {
                if (err) return log$1.error(err, response);
                track.loaded_ = true;
                if (typeof window_default().WebVTT !== "function") {
                    if (track.tech_) track.tech_.any([ "vttjsloaded", "vttjserror" ], (event => {
                        if (event.type === "vttjserror") {
                            log$1.error(`vttjs failed to load, stopping trying to process ${track.src}`);
                            return;
                        }
                        return parseCues(responseBody, track);
                    }));
                } else parseCues(responseBody, track);
            })));
        };
        class TextTrack extends Track {
            constructor(options = {}) {
                if (!options.tech) throw new Error("A tech was not provided.");
                const settings = merge$1(options, {
                    kind: TextTrackKind[options.kind] || "subtitles",
                    language: options.language || options.srclang || ""
                });
                let mode = TextTrackMode[settings.mode] || "disabled";
                const default_ = settings.default;
                if (settings.kind === "metadata" || settings.kind === "chapters") mode = "hidden";
                super(settings);
                this.tech_ = settings.tech;
                this.cues_ = [];
                this.activeCues_ = [];
                this.preload_ = this.tech_.preloadTextTracks !== false;
                const cues = new TextTrackCueList(this.cues_);
                const activeCues = new TextTrackCueList(this.activeCues_);
                let changed = false;
                this.timeupdateHandler = bind_(this, (function(event = {}) {
                    if (this.tech_.isDisposed()) return;
                    if (!this.tech_.isReady_) {
                        if (event.type !== "timeupdate") this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
                        return;
                    }
                    this.activeCues = this.activeCues;
                    if (changed) {
                        this.trigger("cuechange");
                        changed = false;
                    }
                    if (event.type !== "timeupdate") this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
                }));
                const disposeHandler = () => {
                    this.stopTracking();
                };
                this.tech_.one("dispose", disposeHandler);
                if (mode !== "disabled") this.startTracking();
                Object.defineProperties(this, {
                    default: {
                        get() {
                            return default_;
                        },
                        set() {}
                    },
                    mode: {
                        get() {
                            return mode;
                        },
                        set(newMode) {
                            if (!TextTrackMode[newMode]) return;
                            if (mode === newMode) return;
                            mode = newMode;
                            if (!this.preload_ && mode !== "disabled" && this.cues.length === 0) loadTrack(this.src, this);
                            this.stopTracking();
                            if (mode !== "disabled") this.startTracking();
                            this.trigger("modechange");
                        }
                    },
                    cues: {
                        get() {
                            if (!this.loaded_) return null;
                            return cues;
                        },
                        set() {}
                    },
                    activeCues: {
                        get() {
                            if (!this.loaded_) return null;
                            if (this.cues.length === 0) return activeCues;
                            const ct = this.tech_.currentTime();
                            const active = [];
                            for (let i = 0, l = this.cues.length; i < l; i++) {
                                const cue = this.cues[i];
                                if (cue.startTime <= ct && cue.endTime >= ct) active.push(cue);
                            }
                            changed = false;
                            if (active.length !== this.activeCues_.length) changed = true; else for (let i = 0; i < active.length; i++) if (this.activeCues_.indexOf(active[i]) === -1) changed = true;
                            this.activeCues_ = active;
                            activeCues.setCues_(this.activeCues_);
                            return activeCues;
                        },
                        set() {}
                    }
                });
                if (settings.src) {
                    this.src = settings.src;
                    if (!this.preload_) this.loaded_ = true;
                    if (this.preload_ || settings.kind !== "subtitles" && settings.kind !== "captions") loadTrack(this.src, this);
                } else this.loaded_ = true;
            }
            startTracking() {
                this.rvf_ = this.tech_.requestVideoFrameCallback(this.timeupdateHandler);
                this.tech_.on("timeupdate", this.timeupdateHandler);
            }
            stopTracking() {
                if (this.rvf_) {
                    this.tech_.cancelVideoFrameCallback(this.rvf_);
                    this.rvf_ = void 0;
                }
                this.tech_.off("timeupdate", this.timeupdateHandler);
            }
            addCue(originalCue) {
                let cue = originalCue;
                if (window_default().vttjs && !(originalCue instanceof window_default().vttjs.VTTCue)) {
                    cue = new (window_default().vttjs.VTTCue)(originalCue.startTime, originalCue.endTime, originalCue.text);
                    for (const prop in originalCue) if (!(prop in cue)) cue[prop] = originalCue[prop];
                    cue.id = originalCue.id;
                    cue.originalCue_ = originalCue;
                }
                const tracks = this.tech_.textTracks();
                for (let i = 0; i < tracks.length; i++) if (tracks[i] !== this) tracks[i].removeCue(cue);
                this.cues_.push(cue);
                this.cues.setCues_(this.cues_);
            }
            removeCue(removeCue) {
                let i = this.cues_.length;
                while (i--) {
                    const cue = this.cues_[i];
                    if (cue === removeCue || cue.originalCue_ && cue.originalCue_ === removeCue) {
                        this.cues_.splice(i, 1);
                        this.cues.setCues_(this.cues_);
                        break;
                    }
                }
            }
        }
        TextTrack.prototype.allowedEvents_ = {
            cuechange: "cuechange"
        };
        class AudioTrack extends Track {
            constructor(options = {}) {
                const settings = merge$1(options, {
                    kind: AudioTrackKind[options.kind] || ""
                });
                super(settings);
                let enabled = false;
                Object.defineProperty(this, "enabled", {
                    get() {
                        return enabled;
                    },
                    set(newEnabled) {
                        if (typeof newEnabled !== "boolean" || newEnabled === enabled) return;
                        enabled = newEnabled;
                        this.trigger("enabledchange");
                    }
                });
                if (settings.enabled) this.enabled = settings.enabled;
                this.loaded_ = true;
            }
        }
        class VideoTrack extends Track {
            constructor(options = {}) {
                const settings = merge$1(options, {
                    kind: VideoTrackKind[options.kind] || ""
                });
                super(settings);
                let selected = false;
                Object.defineProperty(this, "selected", {
                    get() {
                        return selected;
                    },
                    set(newSelected) {
                        if (typeof newSelected !== "boolean" || newSelected === selected) return;
                        selected = newSelected;
                        this.trigger("selectedchange");
                    }
                });
                if (settings.selected) this.selected = settings.selected;
            }
        }
        class HTMLTrackElement extends EventTarget$2 {
            constructor(options = {}) {
                super();
                let readyState;
                const track = new TextTrack(options);
                this.kind = track.kind;
                this.src = track.src;
                this.srclang = track.language;
                this.label = track.label;
                this.default = track.default;
                Object.defineProperties(this, {
                    readyState: {
                        get() {
                            return readyState;
                        }
                    },
                    track: {
                        get() {
                            return track;
                        }
                    }
                });
                readyState = HTMLTrackElement.NONE;
                track.addEventListener("loadeddata", (() => {
                    readyState = HTMLTrackElement.LOADED;
                    this.trigger({
                        type: "load",
                        target: this
                    });
                }));
            }
        }
        HTMLTrackElement.prototype.allowedEvents_ = {
            load: "load"
        };
        HTMLTrackElement.NONE = 0;
        HTMLTrackElement.LOADING = 1;
        HTMLTrackElement.LOADED = 2;
        HTMLTrackElement.ERROR = 3;
        const NORMAL = {
            audio: {
                ListClass: AudioTrackList,
                TrackClass: AudioTrack,
                capitalName: "Audio"
            },
            video: {
                ListClass: VideoTrackList,
                TrackClass: VideoTrack,
                capitalName: "Video"
            },
            text: {
                ListClass: TextTrackList,
                TrackClass: TextTrack,
                capitalName: "Text"
            }
        };
        Object.keys(NORMAL).forEach((function(type) {
            NORMAL[type].getterName = `${type}Tracks`;
            NORMAL[type].privateName = `${type}Tracks_`;
        }));
        const REMOTE = {
            remoteText: {
                ListClass: TextTrackList,
                TrackClass: TextTrack,
                capitalName: "RemoteText",
                getterName: "remoteTextTracks",
                privateName: "remoteTextTracks_"
            },
            remoteTextEl: {
                ListClass: HtmlTrackElementList,
                TrackClass: HTMLTrackElement,
                capitalName: "RemoteTextTrackEls",
                getterName: "remoteTextTrackEls",
                privateName: "remoteTextTrackEls_"
            }
        };
        const ALL = Object.assign({}, NORMAL, REMOTE);
        REMOTE.names = Object.keys(REMOTE);
        NORMAL.names = Object.keys(NORMAL);
        ALL.names = [].concat(REMOTE.names).concat(NORMAL.names);
        function createTrackHelper(self, kind, label, language, options = {}) {
            const tracks = self.textTracks();
            options.kind = kind;
            if (label) options.label = label;
            if (language) options.language = language;
            options.tech = self;
            const track = new ALL.text.TrackClass(options);
            tracks.addTrack(track);
            return track;
        }
        class Tech extends Component$1 {
            constructor(options = {}, ready = function() {}) {
                options.reportTouchActivity = false;
                super(null, options, ready);
                this.onDurationChange_ = e => this.onDurationChange(e);
                this.trackProgress_ = e => this.trackProgress(e);
                this.trackCurrentTime_ = e => this.trackCurrentTime(e);
                this.stopTrackingCurrentTime_ = e => this.stopTrackingCurrentTime(e);
                this.disposeSourceHandler_ = e => this.disposeSourceHandler(e);
                this.queuedHanders_ = new Set;
                this.hasStarted_ = false;
                this.on("playing", (function() {
                    this.hasStarted_ = true;
                }));
                this.on("loadstart", (function() {
                    this.hasStarted_ = false;
                }));
                ALL.names.forEach((name => {
                    const props = ALL[name];
                    if (options && options[props.getterName]) this[props.privateName] = options[props.getterName];
                }));
                if (!this.featuresProgressEvents) this.manualProgressOn();
                if (!this.featuresTimeupdateEvents) this.manualTimeUpdatesOn();
                [ "Text", "Audio", "Video" ].forEach((track => {
                    if (options[`native${track}Tracks`] === false) this[`featuresNative${track}Tracks`] = false;
                }));
                if (options.nativeCaptions === false || options.nativeTextTracks === false) this.featuresNativeTextTracks = false; else if (options.nativeCaptions === true || options.nativeTextTracks === true) this.featuresNativeTextTracks = true;
                if (!this.featuresNativeTextTracks) this.emulateTextTracks();
                this.preloadTextTracks = options.preloadTextTracks !== false;
                this.autoRemoteTextTracks_ = new ALL.text.ListClass;
                this.initTrackListeners();
                if (!options.nativeControlsForTouch) this.emitTapEvents();
                if (this.constructor) this.name_ = this.constructor.name || "Unknown Tech";
            }
            triggerSourceset(src) {
                if (!this.isReady_) this.one("ready", (() => this.setTimeout((() => this.triggerSourceset(src)), 1)));
                this.trigger({
                    src,
                    type: "sourceset"
                });
            }
            manualProgressOn() {
                this.on("durationchange", this.onDurationChange_);
                this.manualProgress = true;
                this.one("ready", this.trackProgress_);
            }
            manualProgressOff() {
                this.manualProgress = false;
                this.stopTrackingProgress();
                this.off("durationchange", this.onDurationChange_);
            }
            trackProgress(event) {
                this.stopTrackingProgress();
                this.progressInterval = this.setInterval(bind_(this, (function() {
                    const numBufferedPercent = this.bufferedPercent();
                    if (this.bufferedPercent_ !== numBufferedPercent) this.trigger("progress");
                    this.bufferedPercent_ = numBufferedPercent;
                    if (numBufferedPercent === 1) this.stopTrackingProgress();
                })), 500);
            }
            onDurationChange(event) {
                this.duration_ = this.duration();
            }
            buffered() {
                return createTimeRanges$1(0, 0);
            }
            bufferedPercent() {
                return bufferedPercent(this.buffered(), this.duration_);
            }
            stopTrackingProgress() {
                this.clearInterval(this.progressInterval);
            }
            manualTimeUpdatesOn() {
                this.manualTimeUpdates = true;
                this.on("play", this.trackCurrentTime_);
                this.on("pause", this.stopTrackingCurrentTime_);
            }
            manualTimeUpdatesOff() {
                this.manualTimeUpdates = false;
                this.stopTrackingCurrentTime();
                this.off("play", this.trackCurrentTime_);
                this.off("pause", this.stopTrackingCurrentTime_);
            }
            trackCurrentTime() {
                if (this.currentTimeInterval) this.stopTrackingCurrentTime();
                this.currentTimeInterval = this.setInterval((function() {
                    this.trigger({
                        type: "timeupdate",
                        target: this,
                        manuallyTriggered: true
                    });
                }), 250);
            }
            stopTrackingCurrentTime() {
                this.clearInterval(this.currentTimeInterval);
                this.trigger({
                    type: "timeupdate",
                    target: this,
                    manuallyTriggered: true
                });
            }
            dispose() {
                this.clearTracks(NORMAL.names);
                if (this.manualProgress) this.manualProgressOff();
                if (this.manualTimeUpdates) this.manualTimeUpdatesOff();
                super.dispose();
            }
            clearTracks(types) {
                types = [].concat(types);
                types.forEach((type => {
                    const list = this[`${type}Tracks`]() || [];
                    let i = list.length;
                    while (i--) {
                        const track = list[i];
                        if (type === "text") this.removeRemoteTextTrack(track);
                        list.removeTrack(track);
                    }
                }));
            }
            cleanupAutoTextTracks() {
                const list = this.autoRemoteTextTracks_ || [];
                let i = list.length;
                while (i--) {
                    const track = list[i];
                    this.removeRemoteTextTrack(track);
                }
            }
            reset() {}
            crossOrigin() {}
            setCrossOrigin() {}
            error(err) {
                if (err !== void 0) {
                    this.error_ = new MediaError(err);
                    this.trigger("error");
                }
                return this.error_;
            }
            played() {
                if (this.hasStarted_) return createTimeRanges$1(0, 0);
                return createTimeRanges$1();
            }
            play() {}
            setScrubbing(_isScrubbing) {}
            scrubbing() {}
            setCurrentTime(_seconds) {
                if (this.manualTimeUpdates) this.trigger({
                    type: "timeupdate",
                    target: this,
                    manuallyTriggered: true
                });
            }
            initTrackListeners() {
                NORMAL.names.forEach((name => {
                    const props = NORMAL[name];
                    const trackListChanges = () => {
                        this.trigger(`${name}trackchange`);
                    };
                    const tracks = this[props.getterName]();
                    tracks.addEventListener("removetrack", trackListChanges);
                    tracks.addEventListener("addtrack", trackListChanges);
                    this.on("dispose", (() => {
                        tracks.removeEventListener("removetrack", trackListChanges);
                        tracks.removeEventListener("addtrack", trackListChanges);
                    }));
                }));
            }
            addWebVttScript_() {
                if (window_default().WebVTT) return;
                if (document_default().body.contains(this.el())) {
                    if (!this.options_["vtt.js"] && isPlain(browser_index_default()) && Object.keys(browser_index_default()).length > 0) {
                        this.trigger("vttjsloaded");
                        return;
                    }
                    const script = document_default().createElement("script");
                    script.src = this.options_["vtt.js"] || "https://vjs.zencdn.net/vttjs/0.14.1/vtt.min.js";
                    script.onload = () => {
                        this.trigger("vttjsloaded");
                    };
                    script.onerror = () => {
                        this.trigger("vttjserror");
                    };
                    this.on("dispose", (() => {
                        script.onload = null;
                        script.onerror = null;
                    }));
                    window_default().WebVTT = true;
                    this.el().parentNode.appendChild(script);
                } else this.ready(this.addWebVttScript_);
            }
            emulateTextTracks() {
                const tracks = this.textTracks();
                const remoteTracks = this.remoteTextTracks();
                const handleAddTrack = e => tracks.addTrack(e.track);
                const handleRemoveTrack = e => tracks.removeTrack(e.track);
                remoteTracks.on("addtrack", handleAddTrack);
                remoteTracks.on("removetrack", handleRemoveTrack);
                this.addWebVttScript_();
                const updateDisplay = () => this.trigger("texttrackchange");
                const textTracksChanges = () => {
                    updateDisplay();
                    for (let i = 0; i < tracks.length; i++) {
                        const track = tracks[i];
                        track.removeEventListener("cuechange", updateDisplay);
                        if (track.mode === "showing") track.addEventListener("cuechange", updateDisplay);
                    }
                };
                textTracksChanges();
                tracks.addEventListener("change", textTracksChanges);
                tracks.addEventListener("addtrack", textTracksChanges);
                tracks.addEventListener("removetrack", textTracksChanges);
                this.on("dispose", (function() {
                    remoteTracks.off("addtrack", handleAddTrack);
                    remoteTracks.off("removetrack", handleRemoveTrack);
                    tracks.removeEventListener("change", textTracksChanges);
                    tracks.removeEventListener("addtrack", textTracksChanges);
                    tracks.removeEventListener("removetrack", textTracksChanges);
                    for (let i = 0; i < tracks.length; i++) {
                        const track = tracks[i];
                        track.removeEventListener("cuechange", updateDisplay);
                    }
                }));
            }
            addTextTrack(kind, label, language) {
                if (!kind) throw new Error("TextTrack kind is required but was not provided");
                return createTrackHelper(this, kind, label, language);
            }
            createRemoteTextTrack(options) {
                const track = merge$1(options, {
                    tech: this
                });
                return new REMOTE.remoteTextEl.TrackClass(track);
            }
            addRemoteTextTrack(options = {}, manualCleanup) {
                const htmlTrackElement = this.createRemoteTextTrack(options);
                if (typeof manualCleanup !== "boolean") manualCleanup = false;
                this.remoteTextTrackEls().addTrackElement_(htmlTrackElement);
                this.remoteTextTracks().addTrack(htmlTrackElement.track);
                if (manualCleanup === false) this.ready((() => this.autoRemoteTextTracks_.addTrack(htmlTrackElement.track)));
                return htmlTrackElement;
            }
            removeRemoteTextTrack(track) {
                const trackElement = this.remoteTextTrackEls().getTrackElementByTrack_(track);
                this.remoteTextTrackEls().removeTrackElement_(trackElement);
                this.remoteTextTracks().removeTrack(track);
                this.autoRemoteTextTracks_.removeTrack(track);
            }
            getVideoPlaybackQuality() {
                return {};
            }
            requestPictureInPicture() {
                return Promise.reject();
            }
            disablePictureInPicture() {
                return true;
            }
            setDisablePictureInPicture() {}
            requestVideoFrameCallback(cb) {
                const id = newGUID();
                if (!this.isReady_ || this.paused()) {
                    this.queuedHanders_.add(id);
                    this.one("playing", (() => {
                        if (this.queuedHanders_.has(id)) {
                            this.queuedHanders_.delete(id);
                            cb();
                        }
                    }));
                } else this.requestNamedAnimationFrame(id, cb);
                return id;
            }
            cancelVideoFrameCallback(id) {
                if (this.queuedHanders_.has(id)) this.queuedHanders_.delete(id); else this.cancelNamedAnimationFrame(id);
            }
            setPoster() {}
            playsinline() {}
            setPlaysinline() {}
            overrideNativeAudioTracks(override) {}
            overrideNativeVideoTracks(override) {}
            canPlayType(_type) {
                return "";
            }
            static canPlayType(_type) {
                return "";
            }
            static canPlaySource(srcObj, options) {
                return Tech.canPlayType(srcObj.type);
            }
            static isTech(component) {
                return component.prototype instanceof Tech || component instanceof Tech || component === Tech;
            }
            static registerTech(name, tech) {
                if (!Tech.techs_) Tech.techs_ = {};
                if (!Tech.isTech(tech)) throw new Error(`Tech ${name} must be a Tech`);
                if (!Tech.canPlayType) throw new Error("Techs must have a static canPlayType method on them");
                if (!Tech.canPlaySource) throw new Error("Techs must have a static canPlaySource method on them");
                name = toTitleCase$1(name);
                Tech.techs_[name] = tech;
                Tech.techs_[toLowerCase(name)] = tech;
                if (name !== "Tech") Tech.defaultTechOrder_.push(name);
                return tech;
            }
            static getTech(name) {
                if (!name) return;
                if (Tech.techs_ && Tech.techs_[name]) return Tech.techs_[name];
                name = toTitleCase$1(name);
                if (window_default() && window_default().videojs && window_default().videojs[name]) {
                    log$1.warn(`The ${name} tech was added to the videojs object when it should be registered using videojs.registerTech(name, tech)`);
                    return window_default().videojs[name];
                }
            }
        }
        ALL.names.forEach((function(name) {
            const props = ALL[name];
            Tech.prototype[props.getterName] = function() {
                this[props.privateName] = this[props.privateName] || new props.ListClass;
                return this[props.privateName];
            };
        }));
        Tech.prototype.featuresVolumeControl = true;
        Tech.prototype.featuresMuteControl = true;
        Tech.prototype.featuresFullscreenResize = false;
        Tech.prototype.featuresPlaybackRate = false;
        Tech.prototype.featuresProgressEvents = false;
        Tech.prototype.featuresSourceset = false;
        Tech.prototype.featuresTimeupdateEvents = false;
        Tech.prototype.featuresNativeTextTracks = false;
        Tech.prototype.featuresVideoFrameCallback = false;
        Tech.withSourceHandlers = function(_Tech) {
            _Tech.registerSourceHandler = function(handler, index) {
                let handlers = _Tech.sourceHandlers;
                if (!handlers) handlers = _Tech.sourceHandlers = [];
                if (index === void 0) index = handlers.length;
                handlers.splice(index, 0, handler);
            };
            _Tech.canPlayType = function(type) {
                const handlers = _Tech.sourceHandlers || [];
                let can;
                for (let i = 0; i < handlers.length; i++) {
                    can = handlers[i].canPlayType(type);
                    if (can) return can;
                }
                return "";
            };
            _Tech.selectSourceHandler = function(source, options) {
                const handlers = _Tech.sourceHandlers || [];
                let can;
                for (let i = 0; i < handlers.length; i++) {
                    can = handlers[i].canHandleSource(source, options);
                    if (can) return handlers[i];
                }
                return null;
            };
            _Tech.canPlaySource = function(srcObj, options) {
                const sh = _Tech.selectSourceHandler(srcObj, options);
                if (sh) return sh.canHandleSource(srcObj, options);
                return "";
            };
            const deferrable = [ "seekable", "seeking", "duration" ];
            deferrable.forEach((function(fnName) {
                const originalFn = this[fnName];
                if (typeof originalFn !== "function") return;
                this[fnName] = function() {
                    if (this.sourceHandler_ && this.sourceHandler_[fnName]) return this.sourceHandler_[fnName].apply(this.sourceHandler_, arguments);
                    return originalFn.apply(this, arguments);
                };
            }), _Tech.prototype);
            _Tech.prototype.setSource = function(source) {
                let sh = _Tech.selectSourceHandler(source, this.options_);
                if (!sh) if (_Tech.nativeSourceHandler) sh = _Tech.nativeSourceHandler; else log$1.error("No source handler found for the current source.");
                this.disposeSourceHandler();
                this.off("dispose", this.disposeSourceHandler_);
                if (sh !== _Tech.nativeSourceHandler) this.currentSource_ = source;
                this.sourceHandler_ = sh.handleSource(source, this, this.options_);
                this.one("dispose", this.disposeSourceHandler_);
            };
            _Tech.prototype.disposeSourceHandler = function() {
                if (this.currentSource_) {
                    this.clearTracks([ "audio", "video" ]);
                    this.currentSource_ = null;
                }
                this.cleanupAutoTextTracks();
                if (this.sourceHandler_) {
                    if (this.sourceHandler_.dispose) this.sourceHandler_.dispose();
                    this.sourceHandler_ = null;
                }
            };
        };
        Component$1.registerComponent("Tech", Tech);
        Tech.registerTech("Tech", Tech);
        Tech.defaultTechOrder_ = [];
        const middlewares = {};
        const middlewareInstances = {};
        const TERMINATOR = {};
        function use(type, middleware) {
            middlewares[type] = middlewares[type] || [];
            middlewares[type].push(middleware);
        }
        function setSource(player, src, next) {
            player.setTimeout((() => setSourceHelper(src, middlewares[src.type], next, player)), 1);
        }
        function setTech(middleware, tech) {
            middleware.forEach((mw => mw.setTech && mw.setTech(tech)));
        }
        function get(middleware, tech, method) {
            return middleware.reduceRight(middlewareIterator(method), tech[method]());
        }
        function set(middleware, tech, method, arg) {
            return tech[method](middleware.reduce(middlewareIterator(method), arg));
        }
        function mediate(middleware, tech, method, arg = null) {
            const callMethod = "call" + toTitleCase$1(method);
            const middlewareValue = middleware.reduce(middlewareIterator(callMethod), arg);
            const terminated = middlewareValue === TERMINATOR;
            const returnValue = terminated ? null : tech[method](middlewareValue);
            executeRight(middleware, method, returnValue, terminated);
            return returnValue;
        }
        const allowedGetters = {
            buffered: 1,
            currentTime: 1,
            duration: 1,
            muted: 1,
            played: 1,
            paused: 1,
            seekable: 1,
            volume: 1,
            ended: 1
        };
        const allowedSetters = {
            setCurrentTime: 1,
            setMuted: 1,
            setVolume: 1
        };
        const allowedMediators = {
            play: 1,
            pause: 1
        };
        function middlewareIterator(method) {
            return (value, mw) => {
                if (value === TERMINATOR) return TERMINATOR;
                if (mw[method]) return mw[method](value);
                return value;
            };
        }
        function executeRight(mws, method, value, terminated) {
            for (let i = mws.length - 1; i >= 0; i--) {
                const mw = mws[i];
                if (mw[method]) mw[method](terminated, value);
            }
        }
        function clearCacheForPlayer(player) {
            middlewareInstances[player.id()] = null;
        }
        function getOrCreateFactory(player, mwFactory) {
            const mws = middlewareInstances[player.id()];
            let mw = null;
            if (mws === void 0 || mws === null) {
                mw = mwFactory(player);
                middlewareInstances[player.id()] = [ [ mwFactory, mw ] ];
                return mw;
            }
            for (let i = 0; i < mws.length; i++) {
                const [mwf, mwi] = mws[i];
                if (mwf !== mwFactory) continue;
                mw = mwi;
            }
            if (mw === null) {
                mw = mwFactory(player);
                mws.push([ mwFactory, mw ]);
            }
            return mw;
        }
        function setSourceHelper(src = {}, middleware = [], next, player, acc = [], lastRun = false) {
            const [mwFactory, ...mwrest] = middleware;
            if (typeof mwFactory === "string") setSourceHelper(src, middlewares[mwFactory], next, player, acc, lastRun); else if (mwFactory) {
                const mw = getOrCreateFactory(player, mwFactory);
                if (!mw.setSource) {
                    acc.push(mw);
                    return setSourceHelper(src, mwrest, next, player, acc, lastRun);
                }
                mw.setSource(Object.assign({}, src), (function(err, _src) {
                    if (err) return setSourceHelper(src, mwrest, next, player, acc, lastRun);
                    acc.push(mw);
                    setSourceHelper(_src, src.type === _src.type ? mwrest : middlewares[_src.type], next, player, acc, lastRun);
                }));
            } else if (mwrest.length) setSourceHelper(src, mwrest, next, player, acc, lastRun); else if (lastRun) next(src, acc); else setSourceHelper(src, middlewares["*"], next, player, acc, true);
        }
        const MimetypesKind = {
            opus: "video/ogg",
            ogv: "video/ogg",
            mp4: "video/mp4",
            mov: "video/mp4",
            m4v: "video/mp4",
            mkv: "video/x-matroska",
            m4a: "audio/mp4",
            mp3: "audio/mpeg",
            aac: "audio/aac",
            caf: "audio/x-caf",
            flac: "audio/flac",
            oga: "audio/ogg",
            wav: "audio/wav",
            m3u8: "application/x-mpegURL",
            mpd: "application/dash+xml",
            jpg: "image/jpeg",
            jpeg: "image/jpeg",
            gif: "image/gif",
            png: "image/png",
            svg: "image/svg+xml",
            webp: "image/webp"
        };
        const getMimetype = function(src = "") {
            const ext = getFileExtension(src);
            const mimetype = MimetypesKind[ext.toLowerCase()];
            return mimetype || "";
        };
        const findMimetype = (player, src) => {
            if (!src) return "";
            if (player.cache_.source.src === src && player.cache_.source.type) return player.cache_.source.type;
            const matchingSources = player.cache_.sources.filter((s => s.src === src));
            if (matchingSources.length) return matchingSources[0].type;
            const sources = player.$$("source");
            for (let i = 0; i < sources.length; i++) {
                const s = sources[i];
                if (s.type && s.src && s.src === src) return s.type;
            }
            return getMimetype(src);
        };
        const filterSource = function(src) {
            if (Array.isArray(src)) {
                let newsrc = [];
                src.forEach((function(srcobj) {
                    srcobj = filterSource(srcobj);
                    if (Array.isArray(srcobj)) newsrc = newsrc.concat(srcobj); else if (video_es_isObject(srcobj)) newsrc.push(srcobj);
                }));
                src = newsrc;
            } else if (typeof src === "string" && src.trim()) src = [ fixSource({
                src
            }) ]; else if (video_es_isObject(src) && typeof src.src === "string" && src.src && src.src.trim()) src = [ fixSource(src) ]; else src = [];
            return src;
        };
        function fixSource(src) {
            if (!src.type) {
                const mimetype = getMimetype(src.src);
                if (mimetype) src.type = mimetype;
            }
            return src;
        }
        class MediaLoader extends Component$1 {
            constructor(player, options, ready) {
                const options_ = merge$1({
                    createEl: false
                }, options);
                super(player, options_, ready);
                if (!options.playerOptions.sources || options.playerOptions.sources.length === 0) for (let i = 0, j = options.playerOptions.techOrder; i < j.length; i++) {
                    const techName = toTitleCase$1(j[i]);
                    let tech = Tech.getTech(techName);
                    if (!techName) tech = Component$1.getComponent(techName);
                    if (tech && tech.isSupported()) {
                        player.loadTech_(techName);
                        break;
                    }
                } else player.src(options.playerOptions.sources);
            }
        }
        Component$1.registerComponent("MediaLoader", MediaLoader);
        class ClickableComponent extends Component$1 {
            constructor(player, options) {
                super(player, options);
                if (this.options_.controlText) this.controlText(this.options_.controlText);
                this.handleMouseOver_ = e => this.handleMouseOver(e);
                this.handleMouseOut_ = e => this.handleMouseOut(e);
                this.handleClick_ = e => this.handleClick(e);
                this.handleKeyDown_ = e => this.handleKeyDown(e);
                this.emitTapEvents();
                this.enable();
            }
            createEl(tag = "div", props = {}, attributes = {}) {
                props = Object.assign({
                    className: this.buildCSSClass(),
                    tabIndex: 0
                }, props);
                if (tag === "button") log$1.error(`Creating a ClickableComponent with an HTML element of ${tag} is not supported; use a Button instead.`);
                attributes = Object.assign({
                    role: "button"
                }, attributes);
                this.tabIndex_ = props.tabIndex;
                const el = createEl(tag, props, attributes);
                el.appendChild(createEl("span", {
                    className: "vjs-icon-placeholder"
                }, {
                    "aria-hidden": true
                }));
                this.createControlTextEl(el);
                return el;
            }
            dispose() {
                this.controlTextEl_ = null;
                super.dispose();
            }
            createControlTextEl(el) {
                this.controlTextEl_ = createEl("span", {
                    className: "vjs-control-text"
                }, {
                    "aria-live": "polite"
                });
                if (el) el.appendChild(this.controlTextEl_);
                this.controlText(this.controlText_, el);
                return this.controlTextEl_;
            }
            controlText(text, el = this.el()) {
                if (text === void 0) return this.controlText_ || "Need Text";
                const localizedText = this.localize(text);
                this.controlText_ = text;
                textContent(this.controlTextEl_, localizedText);
                if (!this.nonIconControl && !this.player_.options_.noUITitleAttributes) el.setAttribute("title", localizedText);
            }
            buildCSSClass() {
                return `vjs-control vjs-button ${super.buildCSSClass()}`;
            }
            enable() {
                if (!this.enabled_) {
                    this.enabled_ = true;
                    this.removeClass("vjs-disabled");
                    this.el_.setAttribute("aria-disabled", "false");
                    if (typeof this.tabIndex_ !== "undefined") this.el_.setAttribute("tabIndex", this.tabIndex_);
                    this.on([ "tap", "click" ], this.handleClick_);
                    this.on("keydown", this.handleKeyDown_);
                }
            }
            disable() {
                this.enabled_ = false;
                this.addClass("vjs-disabled");
                this.el_.setAttribute("aria-disabled", "true");
                if (typeof this.tabIndex_ !== "undefined") this.el_.removeAttribute("tabIndex");
                this.off("mouseover", this.handleMouseOver_);
                this.off("mouseout", this.handleMouseOut_);
                this.off([ "tap", "click" ], this.handleClick_);
                this.off("keydown", this.handleKeyDown_);
            }
            handleLanguagechange() {
                this.controlText(this.controlText_);
            }
            handleClick(event) {
                if (this.options_.clickHandler) this.options_.clickHandler.call(this, arguments);
            }
            handleKeyDown(event) {
                if (keycode_default().isEventKey(event, "Space") || keycode_default().isEventKey(event, "Enter")) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.trigger("click");
                } else super.handleKeyDown(event);
            }
        }
        Component$1.registerComponent("ClickableComponent", ClickableComponent);
        class PosterImage extends ClickableComponent {
            constructor(player, options) {
                super(player, options);
                this.update();
                this.update_ = e => this.update(e);
                player.on("posterchange", this.update_);
            }
            dispose() {
                this.player().off("posterchange", this.update_);
                super.dispose();
            }
            createEl() {
                return createEl("div", {
                    className: "vjs-poster"
                });
            }
            crossOrigin(value) {
                if (typeof value === "undefined") {
                    if (this.$("img")) return this.$("img").crossOrigin; else if (this.player_.tech_ && this.player_.tech_.isReady_) return this.player_.crossOrigin();
                    return this.player_.options_.crossOrigin || this.player_.options_.crossorigin || null;
                }
                if (value !== null && value !== "anonymous" && value !== "use-credentials") {
                    this.player_.log.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${value}"`);
                    return;
                }
                if (this.$("img")) this.$("img").crossOrigin = value;
                return;
            }
            update(event) {
                const url = this.player().poster();
                this.setSrc(url);
                if (url) this.show(); else this.hide();
            }
            setSrc(url) {
                if (!url) {
                    this.el_.textContent = "";
                    return;
                }
                if (!this.$("img")) this.el_.appendChild(createEl("picture", {
                    className: "vjs-poster",
                    tabIndex: -1
                }, {}, createEl("img", {
                    loading: "lazy",
                    crossOrigin: this.crossOrigin()
                }, {
                    alt: ""
                })));
                this.$("img").src = url;
            }
            handleClick(event) {
                if (!this.player_.controls()) return;
                if (this.player_.tech(true)) this.player_.tech(true).focus();
                if (this.player_.paused()) silencePromise(this.player_.play()); else this.player_.pause();
            }
        }
        PosterImage.prototype.crossorigin = PosterImage.prototype.crossOrigin;
        Component$1.registerComponent("PosterImage", PosterImage);
        const darkGray = "#222";
        const lightGray = "#ccc";
        const fontMap = {
            monospace: "monospace",
            sansSerif: "sans-serif",
            serif: "serif",
            monospaceSansSerif: '"Andale Mono", "Lucida Console", monospace',
            monospaceSerif: '"Courier New", monospace',
            proportionalSansSerif: "sans-serif",
            proportionalSerif: "serif",
            casual: '"Comic Sans MS", Impact, fantasy',
            script: '"Monotype Corsiva", cursive',
            smallcaps: '"Andale Mono", "Lucida Console", monospace, sans-serif'
        };
        function constructColor(color, opacity) {
            let hex;
            if (color.length === 4) hex = color[1] + color[1] + color[2] + color[2] + color[3] + color[3]; else if (color.length === 7) hex = color.slice(1); else throw new Error("Invalid color code provided, " + color + "; must be formatted as e.g. #f0e or #f604e2.");
            return "rgba(" + parseInt(hex.slice(0, 2), 16) + "," + parseInt(hex.slice(2, 4), 16) + "," + parseInt(hex.slice(4, 6), 16) + "," + opacity + ")";
        }
        function tryUpdateStyle(el, style, rule) {
            try {
                el.style[style] = rule;
            } catch (e) {
                return;
            }
        }
        class TextTrackDisplay extends Component$1 {
            constructor(player, options, ready) {
                super(player, options, ready);
                const updateDisplayHandler = e => this.updateDisplay(e);
                player.on("loadstart", (e => this.toggleDisplay(e)));
                player.on("texttrackchange", updateDisplayHandler);
                player.on("loadedmetadata", (e => this.preselectTrack(e)));
                player.ready(bind_(this, (function() {
                    if (player.tech_ && player.tech_.featuresNativeTextTracks) {
                        this.hide();
                        return;
                    }
                    player.on("fullscreenchange", updateDisplayHandler);
                    player.on("playerresize", updateDisplayHandler);
                    const screenOrientation = window_default().screen.orientation || window_default();
                    const changeOrientationEvent = window_default().screen.orientation ? "change" : "orientationchange";
                    screenOrientation.addEventListener(changeOrientationEvent, updateDisplayHandler);
                    player.on("dispose", (() => screenOrientation.removeEventListener(changeOrientationEvent, updateDisplayHandler)));
                    const tracks = this.options_.playerOptions.tracks || [];
                    for (let i = 0; i < tracks.length; i++) this.player_.addRemoteTextTrack(tracks[i], true);
                    this.preselectTrack();
                })));
            }
            preselectTrack() {
                const modes = {
                    captions: 1,
                    subtitles: 1
                };
                const trackList = this.player_.textTracks();
                const userPref = this.player_.cache_.selectedLanguage;
                let firstDesc;
                let firstCaptions;
                let preferredTrack;
                for (let i = 0; i < trackList.length; i++) {
                    const track = trackList[i];
                    if (userPref && userPref.enabled && userPref.language && userPref.language === track.language && track.kind in modes) {
                        if (track.kind === userPref.kind) preferredTrack = track; else if (!preferredTrack) preferredTrack = track;
                    } else if (userPref && !userPref.enabled) {
                        preferredTrack = null;
                        firstDesc = null;
                        firstCaptions = null;
                    } else if (track.default) if (track.kind === "descriptions" && !firstDesc) firstDesc = track; else if (track.kind in modes && !firstCaptions) firstCaptions = track;
                }
                if (preferredTrack) preferredTrack.mode = "showing"; else if (firstCaptions) firstCaptions.mode = "showing"; else if (firstDesc) firstDesc.mode = "showing";
            }
            toggleDisplay() {
                if (this.player_.tech_ && this.player_.tech_.featuresNativeTextTracks) this.hide(); else this.show();
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-text-track-display"
                }, {
                    translate: "yes",
                    "aria-live": "off",
                    "aria-atomic": "true"
                });
            }
            clearDisplay() {
                if (typeof window_default().WebVTT === "function") window_default().WebVTT.processCues(window_default(), [], this.el_);
            }
            updateDisplay() {
                const tracks = this.player_.textTracks();
                const allowMultipleShowingTracks = this.options_.allowMultipleShowingTracks;
                this.clearDisplay();
                if (allowMultipleShowingTracks) {
                    const showingTracks = [];
                    for (let i = 0; i < tracks.length; ++i) {
                        const track = tracks[i];
                        if (track.mode !== "showing") continue;
                        showingTracks.push(track);
                    }
                    this.updateForTrack(showingTracks);
                    return;
                }
                let descriptionsTrack = null;
                let captionsSubtitlesTrack = null;
                let i = tracks.length;
                while (i--) {
                    const track = tracks[i];
                    if (track.mode === "showing") if (track.kind === "descriptions") descriptionsTrack = track; else captionsSubtitlesTrack = track;
                }
                if (captionsSubtitlesTrack) {
                    if (this.getAttribute("aria-live") !== "off") this.setAttribute("aria-live", "off");
                    this.updateForTrack(captionsSubtitlesTrack);
                } else if (descriptionsTrack) {
                    if (this.getAttribute("aria-live") !== "assertive") this.setAttribute("aria-live", "assertive");
                    this.updateForTrack(descriptionsTrack);
                }
            }
            updateDisplayState(track) {
                const overrides = this.player_.textTrackSettings.getValues();
                const cues = track.activeCues;
                let i = cues.length;
                while (i--) {
                    const cue = cues[i];
                    if (!cue) continue;
                    const cueDiv = cue.displayState;
                    if (overrides.color) cueDiv.firstChild.style.color = overrides.color;
                    if (overrides.textOpacity) tryUpdateStyle(cueDiv.firstChild, "color", constructColor(overrides.color || "#fff", overrides.textOpacity));
                    if (overrides.backgroundColor) cueDiv.firstChild.style.backgroundColor = overrides.backgroundColor;
                    if (overrides.backgroundOpacity) tryUpdateStyle(cueDiv.firstChild, "backgroundColor", constructColor(overrides.backgroundColor || "#000", overrides.backgroundOpacity));
                    if (overrides.windowColor) if (overrides.windowOpacity) tryUpdateStyle(cueDiv, "backgroundColor", constructColor(overrides.windowColor, overrides.windowOpacity)); else cueDiv.style.backgroundColor = overrides.windowColor;
                    if (overrides.edgeStyle) if (overrides.edgeStyle === "dropshadow") cueDiv.firstChild.style.textShadow = `2px 2px 3px ${darkGray}, 2px 2px 4px ${darkGray}, 2px 2px 5px ${darkGray}`; else if (overrides.edgeStyle === "raised") cueDiv.firstChild.style.textShadow = `1px 1px ${darkGray}, 2px 2px ${darkGray}, 3px 3px ${darkGray}`; else if (overrides.edgeStyle === "depressed") cueDiv.firstChild.style.textShadow = `1px 1px ${lightGray}, 0 1px ${lightGray}, -1px -1px ${darkGray}, 0 -1px ${darkGray}`; else if (overrides.edgeStyle === "uniform") cueDiv.firstChild.style.textShadow = `0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}, 0 0 4px ${darkGray}`;
                    if (overrides.fontPercent && overrides.fontPercent !== 1) {
                        const fontSize = window_default().parseFloat(cueDiv.style.fontSize);
                        cueDiv.style.fontSize = fontSize * overrides.fontPercent + "px";
                        cueDiv.style.height = "auto";
                        cueDiv.style.top = "auto";
                    }
                    if (overrides.fontFamily && overrides.fontFamily !== "default") if (overrides.fontFamily === "small-caps") cueDiv.firstChild.style.fontVariant = "small-caps"; else cueDiv.firstChild.style.fontFamily = fontMap[overrides.fontFamily];
                }
            }
            updateForTrack(tracks) {
                if (!Array.isArray(tracks)) tracks = [ tracks ];
                if (typeof window_default().WebVTT !== "function" || tracks.every((track => !track.activeCues))) return;
                const cues = [];
                for (let i = 0; i < tracks.length; ++i) {
                    const track = tracks[i];
                    for (let j = 0; j < track.activeCues.length; ++j) cues.push(track.activeCues[j]);
                }
                window_default().WebVTT.processCues(window_default(), cues, this.el_);
                for (let i = 0; i < tracks.length; ++i) {
                    const track = tracks[i];
                    for (let j = 0; j < track.activeCues.length; ++j) {
                        const cueEl = track.activeCues[j].displayState;
                        addClass(cueEl, "vjs-text-track-cue", "vjs-text-track-cue-" + (track.language ? track.language : i));
                        if (track.language) setAttribute(cueEl, "lang", track.language);
                    }
                    if (this.player_.textTrackSettings) this.updateDisplayState(track);
                }
            }
        }
        Component$1.registerComponent("TextTrackDisplay", TextTrackDisplay);
        class LoadingSpinner extends Component$1 {
            createEl() {
                const isAudio = this.player_.isAudio();
                const playerType = this.localize(isAudio ? "Audio Player" : "Video Player");
                const controlText = createEl("span", {
                    className: "vjs-control-text",
                    textContent: this.localize("{1} is loading.", [ playerType ])
                });
                const el = super.createEl("div", {
                    className: "vjs-loading-spinner",
                    dir: "ltr"
                });
                el.appendChild(controlText);
                return el;
            }
            handleLanguagechange() {
                this.$(".vjs-control-text").textContent = this.localize("{1} is loading.", [ this.player_.isAudio() ? "Audio Player" : "Video Player" ]);
            }
        }
        Component$1.registerComponent("LoadingSpinner", LoadingSpinner);
        class Button extends ClickableComponent {
            createEl(tag, props = {}, attributes = {}) {
                tag = "button";
                props = Object.assign({
                    className: this.buildCSSClass()
                }, props);
                attributes = Object.assign({
                    type: "button"
                }, attributes);
                const el = createEl(tag, props, attributes);
                el.appendChild(createEl("span", {
                    className: "vjs-icon-placeholder"
                }, {
                    "aria-hidden": true
                }));
                this.createControlTextEl(el);
                return el;
            }
            addChild(child, options = {}) {
                const className = this.constructor.name;
                log$1.warn(`Adding an actionable (user controllable) child to a Button (${className}) is not supported; use a ClickableComponent instead.`);
                return Component$1.prototype.addChild.call(this, child, options);
            }
            enable() {
                super.enable();
                this.el_.removeAttribute("disabled");
            }
            disable() {
                super.disable();
                this.el_.setAttribute("disabled", "disabled");
            }
            handleKeyDown(event) {
                if (keycode_default().isEventKey(event, "Space") || keycode_default().isEventKey(event, "Enter")) {
                    event.stopPropagation();
                    return;
                }
                super.handleKeyDown(event);
            }
        }
        Component$1.registerComponent("Button", Button);
        class BigPlayButton extends Button {
            constructor(player, options) {
                super(player, options);
                this.mouseused_ = false;
                this.on("mousedown", (e => this.handleMouseDown(e)));
            }
            buildCSSClass() {
                return "vjs-big-play-button";
            }
            handleClick(event) {
                const playPromise = this.player_.play();
                if (this.mouseused_ && event.clientX && event.clientY) {
                    silencePromise(playPromise);
                    if (this.player_.tech(true)) this.player_.tech(true).focus();
                    return;
                }
                const cb = this.player_.getChild("controlBar");
                const playToggle = cb && cb.getChild("playToggle");
                if (!playToggle) {
                    this.player_.tech(true).focus();
                    return;
                }
                const playFocus = () => playToggle.focus();
                if (isPromise(playPromise)) playPromise.then(playFocus, (() => {})); else this.setTimeout(playFocus, 1);
            }
            handleKeyDown(event) {
                this.mouseused_ = false;
                super.handleKeyDown(event);
            }
            handleMouseDown(event) {
                this.mouseused_ = true;
            }
        }
        BigPlayButton.prototype.controlText_ = "Play Video";
        Component$1.registerComponent("BigPlayButton", BigPlayButton);
        class CloseButton extends Button {
            constructor(player, options) {
                super(player, options);
                this.controlText(options && options.controlText || this.localize("Close"));
            }
            buildCSSClass() {
                return `vjs-close-button ${super.buildCSSClass()}`;
            }
            handleClick(event) {
                this.trigger({
                    type: "close",
                    bubbles: false
                });
            }
            handleKeyDown(event) {
                if (keycode_default().isEventKey(event, "Esc")) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.trigger("click");
                } else super.handleKeyDown(event);
            }
        }
        Component$1.registerComponent("CloseButton", CloseButton);
        class PlayToggle extends Button {
            constructor(player, options = {}) {
                super(player, options);
                options.replay = options.replay === void 0 || options.replay;
                this.on(player, "play", (e => this.handlePlay(e)));
                this.on(player, "pause", (e => this.handlePause(e)));
                if (options.replay) this.on(player, "ended", (e => this.handleEnded(e)));
            }
            buildCSSClass() {
                return `vjs-play-control ${super.buildCSSClass()}`;
            }
            handleClick(event) {
                if (this.player_.paused()) silencePromise(this.player_.play()); else this.player_.pause();
            }
            handleSeeked(event) {
                this.removeClass("vjs-ended");
                if (this.player_.paused()) this.handlePause(event); else this.handlePlay(event);
            }
            handlePlay(event) {
                this.removeClass("vjs-ended", "vjs-paused");
                this.addClass("vjs-playing");
                this.controlText("Pause");
            }
            handlePause(event) {
                this.removeClass("vjs-playing");
                this.addClass("vjs-paused");
                this.controlText("Play");
            }
            handleEnded(event) {
                this.removeClass("vjs-playing");
                this.addClass("vjs-ended");
                this.controlText("Replay");
                this.one(this.player_, "seeked", (e => this.handleSeeked(e)));
            }
        }
        PlayToggle.prototype.controlText_ = "Play";
        Component$1.registerComponent("PlayToggle", PlayToggle);
        class TimeDisplay extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.on(player, [ "timeupdate", "ended" ], (e => this.updateContent(e)));
                this.updateTextNode_();
            }
            createEl() {
                const className = this.buildCSSClass();
                const el = super.createEl("div", {
                    className: `${className} vjs-time-control vjs-control`
                });
                const span = createEl("span", {
                    className: "vjs-control-text",
                    textContent: `${this.localize(this.labelText_)}¬†`
                }, {
                    role: "presentation"
                });
                el.appendChild(span);
                this.contentEl_ = createEl("span", {
                    className: `${className}-display`
                }, {
                    role: "presentation"
                });
                el.appendChild(this.contentEl_);
                return el;
            }
            dispose() {
                this.contentEl_ = null;
                this.textNode_ = null;
                super.dispose();
            }
            updateTextNode_(time = 0) {
                time = formatTime(time);
                if (this.formattedTime_ === time) return;
                this.formattedTime_ = time;
                this.requestNamedAnimationFrame("TimeDisplay#updateTextNode_", (() => {
                    if (!this.contentEl_) return;
                    let oldNode = this.textNode_;
                    if (oldNode && this.contentEl_.firstChild !== oldNode) {
                        oldNode = null;
                        log$1.warn("TimeDisplay#updateTextnode_: Prevented replacement of text node element since it was no longer a child of this node. Appending a new node instead.");
                    }
                    this.textNode_ = document_default().createTextNode(this.formattedTime_);
                    if (!this.textNode_) return;
                    if (oldNode) this.contentEl_.replaceChild(this.textNode_, oldNode); else this.contentEl_.appendChild(this.textNode_);
                }));
            }
            updateContent(event) {}
        }
        TimeDisplay.prototype.labelText_ = "Time";
        TimeDisplay.prototype.controlText_ = "Time";
        Component$1.registerComponent("TimeDisplay", TimeDisplay);
        class CurrentTimeDisplay extends TimeDisplay {
            buildCSSClass() {
                return "vjs-current-time";
            }
            updateContent(event) {
                let time;
                if (this.player_.ended()) time = this.player_.duration(); else time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
                this.updateTextNode_(time);
            }
        }
        CurrentTimeDisplay.prototype.labelText_ = "Current Time";
        CurrentTimeDisplay.prototype.controlText_ = "Current Time";
        Component$1.registerComponent("CurrentTimeDisplay", CurrentTimeDisplay);
        class DurationDisplay extends TimeDisplay {
            constructor(player, options) {
                super(player, options);
                const updateContent = e => this.updateContent(e);
                this.on(player, "durationchange", updateContent);
                this.on(player, "loadstart", updateContent);
                this.on(player, "loadedmetadata", updateContent);
            }
            buildCSSClass() {
                return "vjs-duration";
            }
            updateContent(event) {
                const duration = this.player_.duration();
                this.updateTextNode_(duration);
            }
        }
        DurationDisplay.prototype.labelText_ = "Duration";
        DurationDisplay.prototype.controlText_ = "Duration";
        Component$1.registerComponent("DurationDisplay", DurationDisplay);
        class TimeDivider extends Component$1 {
            createEl() {
                const el = super.createEl("div", {
                    className: "vjs-time-control vjs-time-divider"
                }, {
                    "aria-hidden": true
                });
                const div = super.createEl("div");
                const span = super.createEl("span", {
                    textContent: "/"
                });
                div.appendChild(span);
                el.appendChild(div);
                return el;
            }
        }
        Component$1.registerComponent("TimeDivider", TimeDivider);
        class RemainingTimeDisplay extends TimeDisplay {
            constructor(player, options) {
                super(player, options);
                this.on(player, "durationchange", (e => this.updateContent(e)));
            }
            buildCSSClass() {
                return "vjs-remaining-time";
            }
            createEl() {
                const el = super.createEl();
                if (this.options_.displayNegative !== false) el.insertBefore(createEl("span", {}, {
                    "aria-hidden": true
                }, "-"), this.contentEl_);
                return el;
            }
            updateContent(event) {
                if (typeof this.player_.duration() !== "number") return;
                let time;
                if (this.player_.ended()) time = 0; else if (this.player_.remainingTimeDisplay) time = this.player_.remainingTimeDisplay(); else time = this.player_.remainingTime();
                this.updateTextNode_(time);
            }
        }
        RemainingTimeDisplay.prototype.labelText_ = "Remaining Time";
        RemainingTimeDisplay.prototype.controlText_ = "Remaining Time";
        Component$1.registerComponent("RemainingTimeDisplay", RemainingTimeDisplay);
        class LiveDisplay extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.updateShowing();
                this.on(this.player(), "durationchange", (e => this.updateShowing(e)));
            }
            createEl() {
                const el = super.createEl("div", {
                    className: "vjs-live-control vjs-control"
                });
                this.contentEl_ = createEl("div", {
                    className: "vjs-live-display"
                }, {
                    "aria-live": "off"
                });
                this.contentEl_.appendChild(createEl("span", {
                    className: "vjs-control-text",
                    textContent: `${this.localize("Stream Type")}¬†`
                }));
                this.contentEl_.appendChild(document_default().createTextNode(this.localize("LIVE")));
                el.appendChild(this.contentEl_);
                return el;
            }
            dispose() {
                this.contentEl_ = null;
                super.dispose();
            }
            updateShowing(event) {
                if (this.player().duration() === 1 / 0) this.show(); else this.hide();
            }
        }
        Component$1.registerComponent("LiveDisplay", LiveDisplay);
        class SeekToLive extends Button {
            constructor(player, options) {
                super(player, options);
                this.updateLiveEdgeStatus();
                if (this.player_.liveTracker) {
                    this.updateLiveEdgeStatusHandler_ = e => this.updateLiveEdgeStatus(e);
                    this.on(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
                }
            }
            createEl() {
                const el = super.createEl("button", {
                    className: "vjs-seek-to-live-control vjs-control"
                });
                this.textEl_ = createEl("span", {
                    className: "vjs-seek-to-live-text",
                    textContent: this.localize("LIVE")
                }, {
                    "aria-hidden": "true"
                });
                el.appendChild(this.textEl_);
                return el;
            }
            updateLiveEdgeStatus() {
                if (!this.player_.liveTracker || this.player_.liveTracker.atLiveEdge()) {
                    this.setAttribute("aria-disabled", true);
                    this.addClass("vjs-at-live-edge");
                    this.controlText("Seek to live, currently playing live");
                } else {
                    this.setAttribute("aria-disabled", false);
                    this.removeClass("vjs-at-live-edge");
                    this.controlText("Seek to live, currently behind live");
                }
            }
            handleClick() {
                this.player_.liveTracker.seekToLiveEdge();
            }
            dispose() {
                if (this.player_.liveTracker) this.off(this.player_.liveTracker, "liveedgechange", this.updateLiveEdgeStatusHandler_);
                this.textEl_ = null;
                super.dispose();
            }
        }
        SeekToLive.prototype.controlText_ = "Seek to live, currently playing live";
        Component$1.registerComponent("SeekToLive", SeekToLive);
        function clamp(number, min, max) {
            number = Number(number);
            return Math.min(max, Math.max(min, isNaN(number) ? min : number));
        }
        var Num = Object.freeze({
            __proto__: null,
            clamp
        });
        class Slider extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.handleMouseDown_ = e => this.handleMouseDown(e);
                this.handleMouseUp_ = e => this.handleMouseUp(e);
                this.handleKeyDown_ = e => this.handleKeyDown(e);
                this.handleClick_ = e => this.handleClick(e);
                this.handleMouseMove_ = e => this.handleMouseMove(e);
                this.update_ = e => this.update(e);
                this.bar = this.getChild(this.options_.barName);
                this.vertical(!!this.options_.vertical);
                this.enable();
            }
            enabled() {
                return this.enabled_;
            }
            enable() {
                if (this.enabled()) return;
                this.on("mousedown", this.handleMouseDown_);
                this.on("touchstart", this.handleMouseDown_);
                this.on("keydown", this.handleKeyDown_);
                this.on("click", this.handleClick_);
                this.on(this.player_, "controlsvisible", this.update);
                if (this.playerEvent) this.on(this.player_, this.playerEvent, this.update);
                this.removeClass("disabled");
                this.setAttribute("tabindex", 0);
                this.enabled_ = true;
            }
            disable() {
                if (!this.enabled()) return;
                const doc = this.bar.el_.ownerDocument;
                this.off("mousedown", this.handleMouseDown_);
                this.off("touchstart", this.handleMouseDown_);
                this.off("keydown", this.handleKeyDown_);
                this.off("click", this.handleClick_);
                this.off(this.player_, "controlsvisible", this.update_);
                this.off(doc, "mousemove", this.handleMouseMove_);
                this.off(doc, "mouseup", this.handleMouseUp_);
                this.off(doc, "touchmove", this.handleMouseMove_);
                this.off(doc, "touchend", this.handleMouseUp_);
                this.removeAttribute("tabindex");
                this.addClass("disabled");
                if (this.playerEvent) this.off(this.player_, this.playerEvent, this.update);
                this.enabled_ = false;
            }
            createEl(type, props = {}, attributes = {}) {
                props.className = props.className + " vjs-slider";
                props = Object.assign({
                    tabIndex: 0
                }, props);
                attributes = Object.assign({
                    role: "slider",
                    "aria-valuenow": 0,
                    "aria-valuemin": 0,
                    "aria-valuemax": 100
                }, attributes);
                return super.createEl(type, props, attributes);
            }
            handleMouseDown(event) {
                const doc = this.bar.el_.ownerDocument;
                if (event.type === "mousedown") event.preventDefault();
                if (event.type === "touchstart" && !IS_CHROME) event.preventDefault();
                blockTextSelection();
                this.addClass("vjs-sliding");
                this.trigger("slideractive");
                this.on(doc, "mousemove", this.handleMouseMove_);
                this.on(doc, "mouseup", this.handleMouseUp_);
                this.on(doc, "touchmove", this.handleMouseMove_);
                this.on(doc, "touchend", this.handleMouseUp_);
                this.handleMouseMove(event, true);
            }
            handleMouseMove(event) {}
            handleMouseUp(event) {
                const doc = this.bar.el_.ownerDocument;
                unblockTextSelection();
                this.removeClass("vjs-sliding");
                this.trigger("sliderinactive");
                this.off(doc, "mousemove", this.handleMouseMove_);
                this.off(doc, "mouseup", this.handleMouseUp_);
                this.off(doc, "touchmove", this.handleMouseMove_);
                this.off(doc, "touchend", this.handleMouseUp_);
                this.update();
            }
            update() {
                if (!this.el_ || !this.bar) return;
                const progress = this.getProgress();
                if (progress === this.progress_) return progress;
                this.progress_ = progress;
                this.requestNamedAnimationFrame("Slider#update", (() => {
                    const sizeKey = this.vertical() ? "height" : "width";
                    this.bar.el().style[sizeKey] = (progress * 100).toFixed(2) + "%";
                }));
                return progress;
            }
            getProgress() {
                return Number(clamp(this.getPercent(), 0, 1).toFixed(4));
            }
            calculateDistance(event) {
                const position = getPointerPosition(this.el_, event);
                if (this.vertical()) return position.y;
                return position.x;
            }
            handleKeyDown(event) {
                if (keycode_default().isEventKey(event, "Left") || keycode_default().isEventKey(event, "Down")) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.stepBack();
                } else if (keycode_default().isEventKey(event, "Right") || keycode_default().isEventKey(event, "Up")) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.stepForward();
                } else super.handleKeyDown(event);
            }
            handleClick(event) {
                event.stopPropagation();
                event.preventDefault();
            }
            vertical(bool) {
                if (bool === void 0) return this.vertical_ || false;
                this.vertical_ = !!bool;
                if (this.vertical_) this.addClass("vjs-slider-vertical"); else this.addClass("vjs-slider-horizontal");
            }
        }
        Component$1.registerComponent("Slider", Slider);
        const percentify = (time, end) => clamp(time / end * 100, 0, 100).toFixed(2) + "%";
        class LoadProgressBar extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.partEls_ = [];
                this.on(player, "progress", (e => this.update(e)));
            }
            createEl() {
                const el = super.createEl("div", {
                    className: "vjs-load-progress"
                });
                const wrapper = createEl("span", {
                    className: "vjs-control-text"
                });
                const loadedText = createEl("span", {
                    textContent: this.localize("Loaded")
                });
                const separator = document_default().createTextNode(": ");
                this.percentageEl_ = createEl("span", {
                    className: "vjs-control-text-loaded-percentage",
                    textContent: "0%"
                });
                el.appendChild(wrapper);
                wrapper.appendChild(loadedText);
                wrapper.appendChild(separator);
                wrapper.appendChild(this.percentageEl_);
                return el;
            }
            dispose() {
                this.partEls_ = null;
                this.percentageEl_ = null;
                super.dispose();
            }
            update(event) {
                this.requestNamedAnimationFrame("LoadProgressBar#update", (() => {
                    const liveTracker = this.player_.liveTracker;
                    const buffered = this.player_.buffered();
                    const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
                    const bufferedEnd = this.player_.bufferedEnd();
                    const children = this.partEls_;
                    const percent = percentify(bufferedEnd, duration);
                    if (this.percent_ !== percent) {
                        this.el_.style.width = percent;
                        textContent(this.percentageEl_, percent);
                        this.percent_ = percent;
                    }
                    for (let i = 0; i < buffered.length; i++) {
                        const start = buffered.start(i);
                        const end = buffered.end(i);
                        let part = children[i];
                        if (!part) {
                            part = this.el_.appendChild(createEl());
                            children[i] = part;
                        }
                        if (part.dataset.start === start && part.dataset.end === end) continue;
                        part.dataset.start = start;
                        part.dataset.end = end;
                        part.style.left = percentify(start, bufferedEnd);
                        part.style.width = percentify(end - start, bufferedEnd);
                    }
                    for (let i = children.length; i > buffered.length; i--) this.el_.removeChild(children[i - 1]);
                    children.length = buffered.length;
                }));
            }
        }
        Component$1.registerComponent("LoadProgressBar", LoadProgressBar);
        class TimeTooltip extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-time-tooltip"
                }, {
                    "aria-hidden": "true"
                });
            }
            update(seekBarRect, seekBarPoint, content) {
                const tooltipRect = findPosition(this.el_);
                const playerRect = getBoundingClientRect(this.player_.el());
                const seekBarPointPx = seekBarRect.width * seekBarPoint;
                if (!playerRect || !tooltipRect) return;
                const spaceLeftOfPoint = seekBarRect.left - playerRect.left + seekBarPointPx;
                const spaceRightOfPoint = seekBarRect.width - seekBarPointPx + (playerRect.right - seekBarRect.right);
                let pullTooltipBy = tooltipRect.width / 2;
                if (spaceLeftOfPoint < pullTooltipBy) pullTooltipBy += pullTooltipBy - spaceLeftOfPoint; else if (spaceRightOfPoint < pullTooltipBy) pullTooltipBy = spaceRightOfPoint;
                if (pullTooltipBy < 0) pullTooltipBy = 0; else if (pullTooltipBy > tooltipRect.width) pullTooltipBy = tooltipRect.width;
                pullTooltipBy = Math.round(pullTooltipBy);
                this.el_.style.right = `-${pullTooltipBy}px`;
                this.write(content);
            }
            write(content) {
                textContent(this.el_, content);
            }
            updateTime(seekBarRect, seekBarPoint, time, cb) {
                this.requestNamedAnimationFrame("TimeTooltip#updateTime", (() => {
                    let content;
                    const duration = this.player_.duration();
                    if (this.player_.liveTracker && this.player_.liveTracker.isLive()) {
                        const liveWindow = this.player_.liveTracker.liveWindow();
                        const secondsBehind = liveWindow - seekBarPoint * liveWindow;
                        content = (secondsBehind < 1 ? "" : "-") + formatTime(secondsBehind, liveWindow);
                    } else content = formatTime(time, duration);
                    this.update(seekBarRect, seekBarPoint, content);
                    if (cb) cb();
                }));
            }
        }
        Component$1.registerComponent("TimeTooltip", TimeTooltip);
        class PlayProgressBar extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-play-progress vjs-slider-bar"
                }, {
                    "aria-hidden": "true"
                });
            }
            update(seekBarRect, seekBarPoint) {
                const timeTooltip = this.getChild("timeTooltip");
                if (!timeTooltip) return;
                const time = this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
                timeTooltip.updateTime(seekBarRect, seekBarPoint, time);
            }
        }
        PlayProgressBar.prototype.options_ = {
            children: []
        };
        if (!IS_IOS && !IS_ANDROID) PlayProgressBar.prototype.options_.children.push("timeTooltip");
        Component$1.registerComponent("PlayProgressBar", PlayProgressBar);
        class MouseTimeDisplay extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-mouse-display"
                });
            }
            update(seekBarRect, seekBarPoint) {
                const time = seekBarPoint * this.player_.duration();
                this.getChild("timeTooltip").updateTime(seekBarRect, seekBarPoint, time, (() => {
                    this.el_.style.left = `${seekBarRect.width * seekBarPoint}px`;
                }));
            }
        }
        MouseTimeDisplay.prototype.options_ = {
            children: [ "timeTooltip" ]
        };
        Component$1.registerComponent("MouseTimeDisplay", MouseTimeDisplay);
        const STEP_SECONDS = 5;
        const PAGE_KEY_MULTIPLIER = 12;
        class SeekBar extends Slider {
            constructor(player, options) {
                super(player, options);
                this.setEventHandlers_();
            }
            setEventHandlers_() {
                this.update_ = bind_(this, this.update);
                this.update = throttle(this.update_, UPDATE_REFRESH_INTERVAL);
                this.on(this.player_, [ "ended", "durationchange", "timeupdate" ], this.update);
                if (this.player_.liveTracker) this.on(this.player_.liveTracker, "liveedgechange", this.update);
                this.updateInterval = null;
                this.enableIntervalHandler_ = e => this.enableInterval_(e);
                this.disableIntervalHandler_ = e => this.disableInterval_(e);
                this.on(this.player_, [ "playing" ], this.enableIntervalHandler_);
                this.on(this.player_, [ "ended", "pause", "waiting" ], this.disableIntervalHandler_);
                if ("hidden" in document_default() && "visibilityState" in document_default()) this.on(document_default(), "visibilitychange", this.toggleVisibility_);
            }
            toggleVisibility_(e) {
                if (document_default().visibilityState === "hidden") {
                    this.cancelNamedAnimationFrame("SeekBar#update");
                    this.cancelNamedAnimationFrame("Slider#update");
                    this.disableInterval_(e);
                } else {
                    if (!this.player_.ended() && !this.player_.paused()) this.enableInterval_();
                    this.update();
                }
            }
            enableInterval_() {
                if (this.updateInterval) return;
                this.updateInterval = this.setInterval(this.update, UPDATE_REFRESH_INTERVAL);
            }
            disableInterval_(e) {
                if (this.player_.liveTracker && this.player_.liveTracker.isLive() && e && e.type !== "ended") return;
                if (!this.updateInterval) return;
                this.clearInterval(this.updateInterval);
                this.updateInterval = null;
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-progress-holder"
                }, {
                    "aria-label": this.localize("Progress Bar")
                });
            }
            update(event) {
                if (document_default().visibilityState === "hidden") return;
                const percent = super.update();
                this.requestNamedAnimationFrame("SeekBar#update", (() => {
                    const currentTime = this.player_.ended() ? this.player_.duration() : this.getCurrentTime_();
                    const liveTracker = this.player_.liveTracker;
                    let duration = this.player_.duration();
                    if (liveTracker && liveTracker.isLive()) duration = this.player_.liveTracker.liveCurrentTime();
                    if (this.percent_ !== percent) {
                        this.el_.setAttribute("aria-valuenow", (percent * 100).toFixed(2));
                        this.percent_ = percent;
                    }
                    if (this.currentTime_ !== currentTime || this.duration_ !== duration) {
                        this.el_.setAttribute("aria-valuetext", this.localize("progress bar timing: currentTime={1} duration={2}", [ formatTime(currentTime, duration), formatTime(duration, duration) ], "{1} of {2}"));
                        this.currentTime_ = currentTime;
                        this.duration_ = duration;
                    }
                    if (this.bar) this.bar.update(getBoundingClientRect(this.el()), this.getProgress());
                }));
                return percent;
            }
            userSeek_(ct) {
                if (this.player_.liveTracker && this.player_.liveTracker.isLive()) this.player_.liveTracker.nextSeekedFromUser();
                this.player_.currentTime(ct);
            }
            getCurrentTime_() {
                return this.player_.scrubbing() ? this.player_.getCache().currentTime : this.player_.currentTime();
            }
            getPercent() {
                const currentTime = this.getCurrentTime_();
                let percent;
                const liveTracker = this.player_.liveTracker;
                if (liveTracker && liveTracker.isLive()) {
                    percent = (currentTime - liveTracker.seekableStart()) / liveTracker.liveWindow();
                    if (liveTracker.atLiveEdge()) percent = 1;
                } else percent = currentTime / this.player_.duration();
                return percent;
            }
            handleMouseDown(event) {
                if (!isSingleLeftClick(event)) return;
                event.stopPropagation();
                this.videoWasPlaying = !this.player_.paused();
                this.player_.pause();
                super.handleMouseDown(event);
            }
            handleMouseMove(event, mouseDown = false) {
                if (!isSingleLeftClick(event)) return;
                if (!mouseDown && !this.player_.scrubbing()) this.player_.scrubbing(true);
                let newTime;
                const distance = this.calculateDistance(event);
                const liveTracker = this.player_.liveTracker;
                if (!liveTracker || !liveTracker.isLive()) {
                    newTime = distance * this.player_.duration();
                    if (newTime === this.player_.duration()) newTime -= .1;
                } else {
                    if (distance >= .99) {
                        liveTracker.seekToLiveEdge();
                        return;
                    }
                    const seekableStart = liveTracker.seekableStart();
                    const seekableEnd = liveTracker.liveCurrentTime();
                    newTime = seekableStart + distance * liveTracker.liveWindow();
                    if (newTime >= seekableEnd) newTime = seekableEnd;
                    if (newTime <= seekableStart) newTime = seekableStart + .1;
                    if (newTime === 1 / 0) return;
                }
                this.userSeek_(newTime);
            }
            enable() {
                super.enable();
                const mouseTimeDisplay = this.getChild("mouseTimeDisplay");
                if (!mouseTimeDisplay) return;
                mouseTimeDisplay.show();
            }
            disable() {
                super.disable();
                const mouseTimeDisplay = this.getChild("mouseTimeDisplay");
                if (!mouseTimeDisplay) return;
                mouseTimeDisplay.hide();
            }
            handleMouseUp(event) {
                super.handleMouseUp(event);
                if (event) event.stopPropagation();
                this.player_.scrubbing(false);
                this.player_.trigger({
                    type: "timeupdate",
                    target: this,
                    manuallyTriggered: true
                });
                if (this.videoWasPlaying) silencePromise(this.player_.play()); else this.update_();
            }
            stepForward() {
                this.userSeek_(this.player_.currentTime() + STEP_SECONDS);
            }
            stepBack() {
                this.userSeek_(this.player_.currentTime() - STEP_SECONDS);
            }
            handleAction(event) {
                if (this.player_.paused()) this.player_.play(); else this.player_.pause();
            }
            handleKeyDown(event) {
                const liveTracker = this.player_.liveTracker;
                if (keycode_default().isEventKey(event, "Space") || keycode_default().isEventKey(event, "Enter")) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.handleAction(event);
                } else if (keycode_default().isEventKey(event, "Home")) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.userSeek_(0);
                } else if (keycode_default().isEventKey(event, "End")) {
                    event.preventDefault();
                    event.stopPropagation();
                    if (liveTracker && liveTracker.isLive()) this.userSeek_(liveTracker.liveCurrentTime()); else this.userSeek_(this.player_.duration());
                } else if (/^[0-9]$/.test(keycode_default()(event))) {
                    event.preventDefault();
                    event.stopPropagation();
                    const gotoFraction = (keycode_default().codes[keycode_default()(event)] - keycode_default().codes["0"]) * 10 / 100;
                    if (liveTracker && liveTracker.isLive()) this.userSeek_(liveTracker.seekableStart() + liveTracker.liveWindow() * gotoFraction); else this.userSeek_(this.player_.duration() * gotoFraction);
                } else if (keycode_default().isEventKey(event, "PgDn")) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.userSeek_(this.player_.currentTime() - STEP_SECONDS * PAGE_KEY_MULTIPLIER);
                } else if (keycode_default().isEventKey(event, "PgUp")) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.userSeek_(this.player_.currentTime() + STEP_SECONDS * PAGE_KEY_MULTIPLIER);
                } else super.handleKeyDown(event);
            }
            dispose() {
                this.disableInterval_();
                this.off(this.player_, [ "ended", "durationchange", "timeupdate" ], this.update);
                if (this.player_.liveTracker) this.off(this.player_.liveTracker, "liveedgechange", this.update);
                this.off(this.player_, [ "playing" ], this.enableIntervalHandler_);
                this.off(this.player_, [ "ended", "pause", "waiting" ], this.disableIntervalHandler_);
                if ("hidden" in document_default() && "visibilityState" in document_default()) this.off(document_default(), "visibilitychange", this.toggleVisibility_);
                super.dispose();
            }
        }
        SeekBar.prototype.options_ = {
            children: [ "loadProgressBar", "playProgressBar" ],
            barName: "playProgressBar"
        };
        if (!IS_IOS && !IS_ANDROID) SeekBar.prototype.options_.children.splice(1, 0, "mouseTimeDisplay");
        Component$1.registerComponent("SeekBar", SeekBar);
        class ProgressControl extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.handleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
                this.throttledHandleMouseSeek = throttle(bind_(this, this.handleMouseSeek), UPDATE_REFRESH_INTERVAL);
                this.handleMouseUpHandler_ = e => this.handleMouseUp(e);
                this.handleMouseDownHandler_ = e => this.handleMouseDown(e);
                this.enable();
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-progress-control vjs-control"
                });
            }
            handleMouseMove(event) {
                const seekBar = this.getChild("seekBar");
                if (!seekBar) return;
                const playProgressBar = seekBar.getChild("playProgressBar");
                const mouseTimeDisplay = seekBar.getChild("mouseTimeDisplay");
                if (!playProgressBar && !mouseTimeDisplay) return;
                const seekBarEl = seekBar.el();
                const seekBarRect = findPosition(seekBarEl);
                let seekBarPoint = getPointerPosition(seekBarEl, event).x;
                seekBarPoint = clamp(seekBarPoint, 0, 1);
                if (mouseTimeDisplay) mouseTimeDisplay.update(seekBarRect, seekBarPoint);
                if (playProgressBar) playProgressBar.update(seekBarRect, seekBar.getProgress());
            }
            handleMouseSeek(event) {
                const seekBar = this.getChild("seekBar");
                if (seekBar) seekBar.handleMouseMove(event);
            }
            enabled() {
                return this.enabled_;
            }
            disable() {
                this.children().forEach((child => child.disable && child.disable()));
                if (!this.enabled()) return;
                this.off([ "mousedown", "touchstart" ], this.handleMouseDownHandler_);
                this.off(this.el_, "mousemove", this.handleMouseMove);
                this.removeListenersAddedOnMousedownAndTouchstart();
                this.addClass("disabled");
                this.enabled_ = false;
                if (this.player_.scrubbing()) {
                    const seekBar = this.getChild("seekBar");
                    this.player_.scrubbing(false);
                    if (seekBar.videoWasPlaying) silencePromise(this.player_.play());
                }
            }
            enable() {
                this.children().forEach((child => child.enable && child.enable()));
                if (this.enabled()) return;
                this.on([ "mousedown", "touchstart" ], this.handleMouseDownHandler_);
                this.on(this.el_, "mousemove", this.handleMouseMove);
                this.removeClass("disabled");
                this.enabled_ = true;
            }
            removeListenersAddedOnMousedownAndTouchstart() {
                const doc = this.el_.ownerDocument;
                this.off(doc, "mousemove", this.throttledHandleMouseSeek);
                this.off(doc, "touchmove", this.throttledHandleMouseSeek);
                this.off(doc, "mouseup", this.handleMouseUpHandler_);
                this.off(doc, "touchend", this.handleMouseUpHandler_);
            }
            handleMouseDown(event) {
                const doc = this.el_.ownerDocument;
                const seekBar = this.getChild("seekBar");
                if (seekBar) seekBar.handleMouseDown(event);
                this.on(doc, "mousemove", this.throttledHandleMouseSeek);
                this.on(doc, "touchmove", this.throttledHandleMouseSeek);
                this.on(doc, "mouseup", this.handleMouseUpHandler_);
                this.on(doc, "touchend", this.handleMouseUpHandler_);
            }
            handleMouseUp(event) {
                const seekBar = this.getChild("seekBar");
                if (seekBar) seekBar.handleMouseUp(event);
                this.removeListenersAddedOnMousedownAndTouchstart();
            }
        }
        ProgressControl.prototype.options_ = {
            children: [ "seekBar" ]
        };
        Component$1.registerComponent("ProgressControl", ProgressControl);
        class PictureInPictureToggle extends Button {
            constructor(player, options) {
                super(player, options);
                this.on(player, [ "enterpictureinpicture", "leavepictureinpicture" ], (e => this.handlePictureInPictureChange(e)));
                this.on(player, [ "disablepictureinpicturechanged", "loadedmetadata" ], (e => this.handlePictureInPictureEnabledChange(e)));
                this.on(player, [ "loadedmetadata", "audioonlymodechange", "audiopostermodechange" ], (() => {
                    const isSourceAudio = player.currentType().substring(0, 5) === "audio";
                    if (isSourceAudio || player.audioPosterMode() || player.audioOnlyMode()) {
                        if (player.isInPictureInPicture()) player.exitPictureInPicture();
                        this.hide();
                    } else this.show();
                }));
                this.disable();
            }
            buildCSSClass() {
                return `vjs-picture-in-picture-control ${super.buildCSSClass()}`;
            }
            handlePictureInPictureEnabledChange() {
                if (document_default().pictureInPictureEnabled && this.player_.disablePictureInPicture() === false || this.player_.options_.enableDocumentPictureInPicture && "documentPictureInPicture" in window_default()) this.enable(); else this.disable();
            }
            handlePictureInPictureChange(event) {
                if (this.player_.isInPictureInPicture()) this.controlText("Exit Picture-in-Picture"); else this.controlText("Picture-in-Picture");
                this.handlePictureInPictureEnabledChange();
            }
            handleClick(event) {
                if (!this.player_.isInPictureInPicture()) this.player_.requestPictureInPicture(); else this.player_.exitPictureInPicture();
            }
        }
        PictureInPictureToggle.prototype.controlText_ = "Picture-in-Picture";
        Component$1.registerComponent("PictureInPictureToggle", PictureInPictureToggle);
        class FullscreenToggle extends Button {
            constructor(player, options) {
                super(player, options);
                this.on(player, "fullscreenchange", (e => this.handleFullscreenChange(e)));
                if (document_default()[player.fsApi_.fullscreenEnabled] === false) this.disable();
            }
            buildCSSClass() {
                return `vjs-fullscreen-control ${super.buildCSSClass()}`;
            }
            handleFullscreenChange(event) {
                if (this.player_.isFullscreen()) this.controlText("Exit Fullscreen"); else this.controlText("Fullscreen");
            }
            handleClick(event) {
                if (!this.player_.isFullscreen()) this.player_.requestFullscreen(); else this.player_.exitFullscreen();
            }
        }
        FullscreenToggle.prototype.controlText_ = "Fullscreen";
        Component$1.registerComponent("FullscreenToggle", FullscreenToggle);
        const checkVolumeSupport = function(self, player) {
            if (player.tech_ && !player.tech_.featuresVolumeControl) self.addClass("vjs-hidden");
            self.on(player, "loadstart", (function() {
                if (!player.tech_.featuresVolumeControl) self.addClass("vjs-hidden"); else self.removeClass("vjs-hidden");
            }));
        };
        class VolumeLevel extends Component$1 {
            createEl() {
                const el = super.createEl("div", {
                    className: "vjs-volume-level"
                });
                el.appendChild(super.createEl("span", {
                    className: "vjs-control-text"
                }));
                return el;
            }
        }
        Component$1.registerComponent("VolumeLevel", VolumeLevel);
        class VolumeLevelTooltip extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-volume-tooltip"
                }, {
                    "aria-hidden": "true"
                });
            }
            update(rangeBarRect, rangeBarPoint, vertical, content) {
                if (!vertical) {
                    const tooltipRect = getBoundingClientRect(this.el_);
                    const playerRect = getBoundingClientRect(this.player_.el());
                    const volumeBarPointPx = rangeBarRect.width * rangeBarPoint;
                    if (!playerRect || !tooltipRect) return;
                    const spaceLeftOfPoint = rangeBarRect.left - playerRect.left + volumeBarPointPx;
                    const spaceRightOfPoint = rangeBarRect.width - volumeBarPointPx + (playerRect.right - rangeBarRect.right);
                    let pullTooltipBy = tooltipRect.width / 2;
                    if (spaceLeftOfPoint < pullTooltipBy) pullTooltipBy += pullTooltipBy - spaceLeftOfPoint; else if (spaceRightOfPoint < pullTooltipBy) pullTooltipBy = spaceRightOfPoint;
                    if (pullTooltipBy < 0) pullTooltipBy = 0; else if (pullTooltipBy > tooltipRect.width) pullTooltipBy = tooltipRect.width;
                    this.el_.style.right = `-${pullTooltipBy}px`;
                }
                this.write(`${content}%`);
            }
            write(content) {
                textContent(this.el_, content);
            }
            updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, cb) {
                this.requestNamedAnimationFrame("VolumeLevelTooltip#updateVolume", (() => {
                    this.update(rangeBarRect, rangeBarPoint, vertical, volume.toFixed(0));
                    if (cb) cb();
                }));
            }
        }
        Component$1.registerComponent("VolumeLevelTooltip", VolumeLevelTooltip);
        class MouseVolumeLevelDisplay extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.update = throttle(bind_(this, this.update), UPDATE_REFRESH_INTERVAL);
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-mouse-display"
                });
            }
            update(rangeBarRect, rangeBarPoint, vertical) {
                const volume = 100 * rangeBarPoint;
                this.getChild("volumeLevelTooltip").updateVolume(rangeBarRect, rangeBarPoint, vertical, volume, (() => {
                    if (vertical) this.el_.style.bottom = `${rangeBarRect.height * rangeBarPoint}px`; else this.el_.style.left = `${rangeBarRect.width * rangeBarPoint}px`;
                }));
            }
        }
        MouseVolumeLevelDisplay.prototype.options_ = {
            children: [ "volumeLevelTooltip" ]
        };
        Component$1.registerComponent("MouseVolumeLevelDisplay", MouseVolumeLevelDisplay);
        class VolumeBar extends Slider {
            constructor(player, options) {
                super(player, options);
                this.on("slideractive", (e => this.updateLastVolume_(e)));
                this.on(player, "volumechange", (e => this.updateARIAAttributes(e)));
                player.ready((() => this.updateARIAAttributes()));
            }
            createEl() {
                return super.createEl("div", {
                    className: "vjs-volume-bar vjs-slider-bar"
                }, {
                    "aria-label": this.localize("Volume Level"),
                    "aria-live": "polite"
                });
            }
            handleMouseDown(event) {
                if (!isSingleLeftClick(event)) return;
                super.handleMouseDown(event);
            }
            handleMouseMove(event) {
                const mouseVolumeLevelDisplay = this.getChild("mouseVolumeLevelDisplay");
                if (mouseVolumeLevelDisplay) {
                    const volumeBarEl = this.el();
                    const volumeBarRect = getBoundingClientRect(volumeBarEl);
                    const vertical = this.vertical();
                    let volumeBarPoint = getPointerPosition(volumeBarEl, event);
                    volumeBarPoint = vertical ? volumeBarPoint.y : volumeBarPoint.x;
                    volumeBarPoint = clamp(volumeBarPoint, 0, 1);
                    mouseVolumeLevelDisplay.update(volumeBarRect, volumeBarPoint, vertical);
                }
                if (!isSingleLeftClick(event)) return;
                this.checkMuted();
                this.player_.volume(this.calculateDistance(event));
            }
            checkMuted() {
                if (this.player_.muted()) this.player_.muted(false);
            }
            getPercent() {
                if (this.player_.muted()) return 0;
                return this.player_.volume();
            }
            stepForward() {
                this.checkMuted();
                this.player_.volume(this.player_.volume() + .1);
            }
            stepBack() {
                this.checkMuted();
                this.player_.volume(this.player_.volume() - .1);
            }
            updateARIAAttributes(event) {
                const ariaValue = this.player_.muted() ? 0 : this.volumeAsPercentage_();
                this.el_.setAttribute("aria-valuenow", ariaValue);
                this.el_.setAttribute("aria-valuetext", ariaValue + "%");
            }
            volumeAsPercentage_() {
                return Math.round(this.player_.volume() * 100);
            }
            updateLastVolume_() {
                const volumeBeforeDrag = this.player_.volume();
                this.one("sliderinactive", (() => {
                    if (this.player_.volume() === 0) this.player_.lastVolume_(volumeBeforeDrag);
                }));
            }
        }
        VolumeBar.prototype.options_ = {
            children: [ "volumeLevel" ],
            barName: "volumeLevel"
        };
        if (!IS_IOS && !IS_ANDROID) VolumeBar.prototype.options_.children.splice(0, 0, "mouseVolumeLevelDisplay");
        VolumeBar.prototype.playerEvent = "volumechange";
        Component$1.registerComponent("VolumeBar", VolumeBar);
        class VolumeControl extends Component$1 {
            constructor(player, options = {}) {
                options.vertical = options.vertical || false;
                if (typeof options.volumeBar === "undefined" || isPlain(options.volumeBar)) {
                    options.volumeBar = options.volumeBar || {};
                    options.volumeBar.vertical = options.vertical;
                }
                super(player, options);
                checkVolumeSupport(this, player);
                this.throttledHandleMouseMove = throttle(bind_(this, this.handleMouseMove), UPDATE_REFRESH_INTERVAL);
                this.handleMouseUpHandler_ = e => this.handleMouseUp(e);
                this.on("mousedown", (e => this.handleMouseDown(e)));
                this.on("touchstart", (e => this.handleMouseDown(e)));
                this.on("mousemove", (e => this.handleMouseMove(e)));
                this.on(this.volumeBar, [ "focus", "slideractive" ], (() => {
                    this.volumeBar.addClass("vjs-slider-active");
                    this.addClass("vjs-slider-active");
                    this.trigger("slideractive");
                }));
                this.on(this.volumeBar, [ "blur", "sliderinactive" ], (() => {
                    this.volumeBar.removeClass("vjs-slider-active");
                    this.removeClass("vjs-slider-active");
                    this.trigger("sliderinactive");
                }));
            }
            createEl() {
                let orientationClass = "vjs-volume-horizontal";
                if (this.options_.vertical) orientationClass = "vjs-volume-vertical";
                return super.createEl("div", {
                    className: `vjs-volume-control vjs-control ${orientationClass}`
                });
            }
            handleMouseDown(event) {
                const doc = this.el_.ownerDocument;
                this.on(doc, "mousemove", this.throttledHandleMouseMove);
                this.on(doc, "touchmove", this.throttledHandleMouseMove);
                this.on(doc, "mouseup", this.handleMouseUpHandler_);
                this.on(doc, "touchend", this.handleMouseUpHandler_);
            }
            handleMouseUp(event) {
                const doc = this.el_.ownerDocument;
                this.off(doc, "mousemove", this.throttledHandleMouseMove);
                this.off(doc, "touchmove", this.throttledHandleMouseMove);
                this.off(doc, "mouseup", this.handleMouseUpHandler_);
                this.off(doc, "touchend", this.handleMouseUpHandler_);
            }
            handleMouseMove(event) {
                this.volumeBar.handleMouseMove(event);
            }
        }
        VolumeControl.prototype.options_ = {
            children: [ "volumeBar" ]
        };
        Component$1.registerComponent("VolumeControl", VolumeControl);
        const checkMuteSupport = function(self, player) {
            if (player.tech_ && !player.tech_.featuresMuteControl) self.addClass("vjs-hidden");
            self.on(player, "loadstart", (function() {
                if (!player.tech_.featuresMuteControl) self.addClass("vjs-hidden"); else self.removeClass("vjs-hidden");
            }));
        };
        class MuteToggle extends Button {
            constructor(player, options) {
                super(player, options);
                checkMuteSupport(this, player);
                this.on(player, [ "loadstart", "volumechange" ], (e => this.update(e)));
            }
            buildCSSClass() {
                return `vjs-mute-control ${super.buildCSSClass()}`;
            }
            handleClick(event) {
                const vol = this.player_.volume();
                const lastVolume = this.player_.lastVolume_();
                if (vol === 0) {
                    const volumeToSet = lastVolume < .1 ? .1 : lastVolume;
                    this.player_.volume(volumeToSet);
                    this.player_.muted(false);
                } else this.player_.muted(this.player_.muted() ? false : true);
            }
            update(event) {
                this.updateIcon_();
                this.updateControlText_();
            }
            updateIcon_() {
                const vol = this.player_.volume();
                let level = 3;
                if (IS_IOS && this.player_.tech_ && this.player_.tech_.el_) this.player_.muted(this.player_.tech_.el_.muted);
                if (vol === 0 || this.player_.muted()) level = 0; else if (vol < .33) level = 1; else if (vol < .67) level = 2;
                removeClass(this.el_, [ 0, 1, 2, 3 ].reduce(((str, i) => str + `${i ? " " : ""}vjs-vol-${i}`), ""));
                addClass(this.el_, `vjs-vol-${level}`);
            }
            updateControlText_() {
                const soundOff = this.player_.muted() || this.player_.volume() === 0;
                const text = soundOff ? "Unmute" : "Mute";
                if (this.controlText() !== text) this.controlText(text);
            }
        }
        MuteToggle.prototype.controlText_ = "Mute";
        Component$1.registerComponent("MuteToggle", MuteToggle);
        class VolumePanel extends Component$1 {
            constructor(player, options = {}) {
                if (typeof options.inline !== "undefined") options.inline = options.inline; else options.inline = true;
                if (typeof options.volumeControl === "undefined" || isPlain(options.volumeControl)) {
                    options.volumeControl = options.volumeControl || {};
                    options.volumeControl.vertical = !options.inline;
                }
                super(player, options);
                this.handleKeyPressHandler_ = e => this.handleKeyPress(e);
                this.on(player, [ "loadstart" ], (e => this.volumePanelState_(e)));
                this.on(this.muteToggle, "keyup", (e => this.handleKeyPress(e)));
                this.on(this.volumeControl, "keyup", (e => this.handleVolumeControlKeyUp(e)));
                this.on("keydown", (e => this.handleKeyPress(e)));
                this.on("mouseover", (e => this.handleMouseOver(e)));
                this.on("mouseout", (e => this.handleMouseOut(e)));
                this.on(this.volumeControl, [ "slideractive" ], this.sliderActive_);
                this.on(this.volumeControl, [ "sliderinactive" ], this.sliderInactive_);
            }
            sliderActive_() {
                this.addClass("vjs-slider-active");
            }
            sliderInactive_() {
                this.removeClass("vjs-slider-active");
            }
            volumePanelState_() {
                if (this.volumeControl.hasClass("vjs-hidden") && this.muteToggle.hasClass("vjs-hidden")) this.addClass("vjs-hidden");
                if (this.volumeControl.hasClass("vjs-hidden") && !this.muteToggle.hasClass("vjs-hidden")) this.addClass("vjs-mute-toggle-only");
            }
            createEl() {
                let orientationClass = "vjs-volume-panel-horizontal";
                if (!this.options_.inline) orientationClass = "vjs-volume-panel-vertical";
                return super.createEl("div", {
                    className: `vjs-volume-panel vjs-control ${orientationClass}`
                });
            }
            dispose() {
                this.handleMouseOut();
                super.dispose();
            }
            handleVolumeControlKeyUp(event) {
                if (keycode_default().isEventKey(event, "Esc")) this.muteToggle.focus();
            }
            handleMouseOver(event) {
                this.addClass("vjs-hover");
                on(document_default(), "keyup", this.handleKeyPressHandler_);
            }
            handleMouseOut(event) {
                this.removeClass("vjs-hover");
                off(document_default(), "keyup", this.handleKeyPressHandler_);
            }
            handleKeyPress(event) {
                if (keycode_default().isEventKey(event, "Esc")) this.handleMouseOut();
            }
        }
        VolumePanel.prototype.options_ = {
            children: [ "muteToggle", "volumeControl" ]
        };
        Component$1.registerComponent("VolumePanel", VolumePanel);
        class SkipForward extends Button {
            constructor(player, options) {
                super(player, options);
                this.validOptions = [ 5, 10, 30 ];
                this.skipTime = this.getSkipForwardTime();
                if (this.skipTime && this.validOptions.includes(this.skipTime)) {
                    this.controlText(this.localize("Skip forward {1} seconds", [ this.skipTime ]));
                    this.show();
                } else this.hide();
            }
            getSkipForwardTime() {
                const playerOptions = this.options_.playerOptions;
                return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.forward;
            }
            buildCSSClass() {
                return `vjs-skip-forward-${this.getSkipForwardTime()} ${super.buildCSSClass()}`;
            }
            handleClick(event) {
                const currentVideoTime = this.player_.currentTime();
                const liveTracker = this.player_.liveTracker;
                const duration = liveTracker && liveTracker.isLive() ? liveTracker.seekableEnd() : this.player_.duration();
                let newTime;
                if (currentVideoTime + this.skipTime <= duration) newTime = currentVideoTime + this.skipTime; else newTime = duration;
                this.player_.currentTime(newTime);
            }
            handleLanguagechange() {
                this.controlText(this.localize("Skip forward {1} seconds", [ this.skipTime ]));
            }
        }
        Component$1.registerComponent("SkipForward", SkipForward);
        class SkipBackward extends Button {
            constructor(player, options) {
                super(player, options);
                this.validOptions = [ 5, 10, 30 ];
                this.skipTime = this.getSkipBackwardTime();
                if (this.skipTime && this.validOptions.includes(this.skipTime)) {
                    this.controlText(this.localize("Skip backward {1} seconds", [ this.skipTime ]));
                    this.show();
                } else this.hide();
            }
            getSkipBackwardTime() {
                const playerOptions = this.options_.playerOptions;
                return playerOptions.controlBar && playerOptions.controlBar.skipButtons && playerOptions.controlBar.skipButtons.backward;
            }
            buildCSSClass() {
                return `vjs-skip-backward-${this.getSkipBackwardTime()} ${super.buildCSSClass()}`;
            }
            handleClick(event) {
                const currentVideoTime = this.player_.currentTime();
                const liveTracker = this.player_.liveTracker;
                const seekableStart = liveTracker && liveTracker.isLive() && liveTracker.seekableStart();
                let newTime;
                if (seekableStart && currentVideoTime - this.skipTime <= seekableStart) newTime = seekableStart; else if (currentVideoTime >= this.skipTime) newTime = currentVideoTime - this.skipTime; else newTime = 0;
                this.player_.currentTime(newTime);
            }
            handleLanguagechange() {
                this.controlText(this.localize("Skip backward {1} seconds", [ this.skipTime ]));
            }
        }
        SkipBackward.prototype.controlText_ = "Skip Backward";
        Component$1.registerComponent("SkipBackward", SkipBackward);
        class Menu extends Component$1 {
            constructor(player, options) {
                super(player, options);
                if (options) this.menuButton_ = options.menuButton;
                this.focusedChild_ = -1;
                this.on("keydown", (e => this.handleKeyDown(e)));
                this.boundHandleBlur_ = e => this.handleBlur(e);
                this.boundHandleTapClick_ = e => this.handleTapClick(e);
            }
            addEventListenerForItem(component) {
                if (!(component instanceof Component$1)) return;
                this.on(component, "blur", this.boundHandleBlur_);
                this.on(component, [ "tap", "click" ], this.boundHandleTapClick_);
            }
            removeEventListenerForItem(component) {
                if (!(component instanceof Component$1)) return;
                this.off(component, "blur", this.boundHandleBlur_);
                this.off(component, [ "tap", "click" ], this.boundHandleTapClick_);
            }
            removeChild(component) {
                if (typeof component === "string") component = this.getChild(component);
                this.removeEventListenerForItem(component);
                super.removeChild(component);
            }
            addItem(component) {
                const childComponent = this.addChild(component);
                if (childComponent) this.addEventListenerForItem(childComponent);
            }
            createEl() {
                const contentElType = this.options_.contentElType || "ul";
                this.contentEl_ = createEl(contentElType, {
                    className: "vjs-menu-content"
                });
                this.contentEl_.setAttribute("role", "menu");
                const el = super.createEl("div", {
                    append: this.contentEl_,
                    className: "vjs-menu"
                });
                el.appendChild(this.contentEl_);
                on(el, "click", (function(event) {
                    event.preventDefault();
                    event.stopImmediatePropagation();
                }));
                return el;
            }
            dispose() {
                this.contentEl_ = null;
                this.boundHandleBlur_ = null;
                this.boundHandleTapClick_ = null;
                super.dispose();
            }
            handleBlur(event) {
                const relatedTarget = event.relatedTarget || document_default().activeElement;
                if (!this.children().some((element => element.el() === relatedTarget))) {
                    const btn = this.menuButton_;
                    if (btn && btn.buttonPressed_ && relatedTarget !== btn.el().firstChild) btn.unpressButton();
                }
            }
            handleTapClick(event) {
                if (this.menuButton_) {
                    this.menuButton_.unpressButton();
                    const childComponents = this.children();
                    if (!Array.isArray(childComponents)) return;
                    const foundComponent = childComponents.filter((component => component.el() === event.target))[0];
                    if (!foundComponent) return;
                    if (foundComponent.name() !== "CaptionSettingsMenuItem") this.menuButton_.focus();
                }
            }
            handleKeyDown(event) {
                if (keycode_default().isEventKey(event, "Left") || keycode_default().isEventKey(event, "Down")) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.stepForward();
                } else if (keycode_default().isEventKey(event, "Right") || keycode_default().isEventKey(event, "Up")) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.stepBack();
                }
            }
            stepForward() {
                let stepChild = 0;
                if (this.focusedChild_ !== void 0) stepChild = this.focusedChild_ + 1;
                this.focus(stepChild);
            }
            stepBack() {
                let stepChild = 0;
                if (this.focusedChild_ !== void 0) stepChild = this.focusedChild_ - 1;
                this.focus(stepChild);
            }
            focus(item = 0) {
                const children = this.children().slice();
                const haveTitle = children.length && children[0].hasClass("vjs-menu-title");
                if (haveTitle) children.shift();
                if (children.length > 0) {
                    if (item < 0) item = 0; else if (item >= children.length) item = children.length - 1;
                    this.focusedChild_ = item;
                    children[item].el_.focus();
                }
            }
        }
        Component$1.registerComponent("Menu", Menu);
        class MenuButton extends Component$1 {
            constructor(player, options = {}) {
                super(player, options);
                this.menuButton_ = new Button(player, options);
                this.menuButton_.controlText(this.controlText_);
                this.menuButton_.el_.setAttribute("aria-haspopup", "true");
                const buttonClass = Button.prototype.buildCSSClass();
                this.menuButton_.el_.className = this.buildCSSClass() + " " + buttonClass;
                this.menuButton_.removeClass("vjs-control");
                this.addChild(this.menuButton_);
                this.update();
                this.enabled_ = true;
                const handleClick = e => this.handleClick(e);
                this.handleMenuKeyUp_ = e => this.handleMenuKeyUp(e);
                this.on(this.menuButton_, "tap", handleClick);
                this.on(this.menuButton_, "click", handleClick);
                this.on(this.menuButton_, "keydown", (e => this.handleKeyDown(e)));
                this.on(this.menuButton_, "mouseenter", (() => {
                    this.addClass("vjs-hover");
                    this.menu.show();
                    on(document_default(), "keyup", this.handleMenuKeyUp_);
                }));
                this.on("mouseleave", (e => this.handleMouseLeave(e)));
                this.on("keydown", (e => this.handleSubmenuKeyDown(e)));
            }
            update() {
                const menu = this.createMenu();
                if (this.menu) {
                    this.menu.dispose();
                    this.removeChild(this.menu);
                }
                this.menu = menu;
                this.addChild(menu);
                this.buttonPressed_ = false;
                this.menuButton_.el_.setAttribute("aria-expanded", "false");
                if (this.items && this.items.length <= this.hideThreshold_) {
                    this.hide();
                    this.menu.contentEl_.removeAttribute("role");
                } else {
                    this.show();
                    this.menu.contentEl_.setAttribute("role", "menu");
                }
            }
            createMenu() {
                const menu = new Menu(this.player_, {
                    menuButton: this
                });
                this.hideThreshold_ = 0;
                if (this.options_.title) {
                    const titleEl = createEl("li", {
                        className: "vjs-menu-title",
                        textContent: toTitleCase$1(this.options_.title),
                        tabIndex: -1
                    });
                    const titleComponent = new Component$1(this.player_, {
                        el: titleEl
                    });
                    menu.addItem(titleComponent);
                }
                this.items = this.createItems();
                if (this.items) for (let i = 0; i < this.items.length; i++) menu.addItem(this.items[i]);
                return menu;
            }
            createItems() {}
            createEl() {
                return super.createEl("div", {
                    className: this.buildWrapperCSSClass()
                }, {});
            }
            buildWrapperCSSClass() {
                let menuButtonClass = "vjs-menu-button";
                if (this.options_.inline === true) menuButtonClass += "-inline"; else menuButtonClass += "-popup";
                const buttonClass = Button.prototype.buildCSSClass();
                return `vjs-menu-button ${menuButtonClass} ${buttonClass} ${super.buildCSSClass()}`;
            }
            buildCSSClass() {
                let menuButtonClass = "vjs-menu-button";
                if (this.options_.inline === true) menuButtonClass += "-inline"; else menuButtonClass += "-popup";
                return `vjs-menu-button ${menuButtonClass} ${super.buildCSSClass()}`;
            }
            controlText(text, el = this.menuButton_.el()) {
                return this.menuButton_.controlText(text, el);
            }
            dispose() {
                this.handleMouseLeave();
                super.dispose();
            }
            handleClick(event) {
                if (this.buttonPressed_) this.unpressButton(); else this.pressButton();
            }
            handleMouseLeave(event) {
                this.removeClass("vjs-hover");
                off(document_default(), "keyup", this.handleMenuKeyUp_);
            }
            focus() {
                this.menuButton_.focus();
            }
            blur() {
                this.menuButton_.blur();
            }
            handleKeyDown(event) {
                if (keycode_default().isEventKey(event, "Esc") || keycode_default().isEventKey(event, "Tab")) {
                    if (this.buttonPressed_) this.unpressButton();
                    if (!keycode_default().isEventKey(event, "Tab")) {
                        event.preventDefault();
                        this.menuButton_.focus();
                    }
                } else if (keycode_default().isEventKey(event, "Up") || keycode_default().isEventKey(event, "Down")) if (!this.buttonPressed_) {
                    event.preventDefault();
                    this.pressButton();
                }
            }
            handleMenuKeyUp(event) {
                if (keycode_default().isEventKey(event, "Esc") || keycode_default().isEventKey(event, "Tab")) this.removeClass("vjs-hover");
            }
            handleSubmenuKeyPress(event) {
                this.handleSubmenuKeyDown(event);
            }
            handleSubmenuKeyDown(event) {
                if (keycode_default().isEventKey(event, "Esc") || keycode_default().isEventKey(event, "Tab")) {
                    if (this.buttonPressed_) this.unpressButton();
                    if (!keycode_default().isEventKey(event, "Tab")) {
                        event.preventDefault();
                        this.menuButton_.focus();
                    }
                }
            }
            pressButton() {
                if (this.enabled_) {
                    this.buttonPressed_ = true;
                    this.menu.show();
                    this.menu.lockShowing();
                    this.menuButton_.el_.setAttribute("aria-expanded", "true");
                    if (IS_IOS && isInFrame()) return;
                    this.menu.focus();
                }
            }
            unpressButton() {
                if (this.enabled_) {
                    this.buttonPressed_ = false;
                    this.menu.unlockShowing();
                    this.menu.hide();
                    this.menuButton_.el_.setAttribute("aria-expanded", "false");
                }
            }
            disable() {
                this.unpressButton();
                this.enabled_ = false;
                this.addClass("vjs-disabled");
                this.menuButton_.disable();
            }
            enable() {
                this.enabled_ = true;
                this.removeClass("vjs-disabled");
                this.menuButton_.enable();
            }
        }
        Component$1.registerComponent("MenuButton", MenuButton);
        class TrackButton extends MenuButton {
            constructor(player, options) {
                const tracks = options.tracks;
                super(player, options);
                if (this.items.length <= 1) this.hide();
                if (!tracks) return;
                const updateHandler = bind_(this, this.update);
                tracks.addEventListener("removetrack", updateHandler);
                tracks.addEventListener("addtrack", updateHandler);
                tracks.addEventListener("labelchange", updateHandler);
                this.player_.on("ready", updateHandler);
                this.player_.on("dispose", (function() {
                    tracks.removeEventListener("removetrack", updateHandler);
                    tracks.removeEventListener("addtrack", updateHandler);
                    tracks.removeEventListener("labelchange", updateHandler);
                }));
            }
        }
        Component$1.registerComponent("TrackButton", TrackButton);
        const MenuKeys = [ "Tab", "Esc", "Up", "Down", "Right", "Left" ];
        class MenuItem extends ClickableComponent {
            constructor(player, options) {
                super(player, options);
                this.selectable = options.selectable;
                this.isSelected_ = options.selected || false;
                this.multiSelectable = options.multiSelectable;
                this.selected(this.isSelected_);
                if (this.selectable) if (this.multiSelectable) this.el_.setAttribute("role", "menuitemcheckbox"); else this.el_.setAttribute("role", "menuitemradio"); else this.el_.setAttribute("role", "menuitem");
            }
            createEl(type, props, attrs) {
                this.nonIconControl = true;
                const el = super.createEl("li", Object.assign({
                    className: "vjs-menu-item",
                    tabIndex: -1
                }, props), attrs);
                el.replaceChild(createEl("span", {
                    className: "vjs-menu-item-text",
                    textContent: this.localize(this.options_.label)
                }), el.querySelector(".vjs-icon-placeholder"));
                return el;
            }
            handleKeyDown(event) {
                if (!MenuKeys.some((key => keycode_default().isEventKey(event, key)))) super.handleKeyDown(event);
            }
            handleClick(event) {
                this.selected(true);
            }
            selected(selected) {
                if (this.selectable) if (selected) {
                    this.addClass("vjs-selected");
                    this.el_.setAttribute("aria-checked", "true");
                    this.controlText(", selected");
                    this.isSelected_ = true;
                } else {
                    this.removeClass("vjs-selected");
                    this.el_.setAttribute("aria-checked", "false");
                    this.controlText("");
                    this.isSelected_ = false;
                }
            }
        }
        Component$1.registerComponent("MenuItem", MenuItem);
        class TextTrackMenuItem extends MenuItem {
            constructor(player, options) {
                const track = options.track;
                const tracks = player.textTracks();
                options.label = track.label || track.language || "Unknown";
                options.selected = track.mode === "showing";
                super(player, options);
                this.track = track;
                this.kinds = (options.kinds || [ options.kind || this.track.kind ]).filter(Boolean);
                const changeHandler = (...args) => {
                    this.handleTracksChange.apply(this, args);
                };
                const selectedLanguageChangeHandler = (...args) => {
                    this.handleSelectedLanguageChange.apply(this, args);
                };
                player.on([ "loadstart", "texttrackchange" ], changeHandler);
                tracks.addEventListener("change", changeHandler);
                tracks.addEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
                this.on("dispose", (function() {
                    player.off([ "loadstart", "texttrackchange" ], changeHandler);
                    tracks.removeEventListener("change", changeHandler);
                    tracks.removeEventListener("selectedlanguagechange", selectedLanguageChangeHandler);
                }));
                if (tracks.onchange === void 0) {
                    let event;
                    this.on([ "tap", "click" ], (function() {
                        if (typeof window_default().Event !== "object") try {
                            event = new (window_default().Event)("change");
                        } catch (err) {}
                        if (!event) {
                            event = document_default().createEvent("Event");
                            event.initEvent("change", true, true);
                        }
                        tracks.dispatchEvent(event);
                    }));
                }
                this.handleTracksChange();
            }
            handleClick(event) {
                const referenceTrack = this.track;
                const tracks = this.player_.textTracks();
                super.handleClick(event);
                if (!tracks) return;
                for (let i = 0; i < tracks.length; i++) {
                    const track = tracks[i];
                    if (this.kinds.indexOf(track.kind) === -1) continue;
                    if (track === referenceTrack) {
                        if (track.mode !== "showing") track.mode = "showing";
                    } else if (track.mode !== "disabled") track.mode = "disabled";
                }
            }
            handleTracksChange(event) {
                const shouldBeSelected = this.track.mode === "showing";
                if (shouldBeSelected !== this.isSelected_) this.selected(shouldBeSelected);
            }
            handleSelectedLanguageChange(event) {
                if (this.track.mode === "showing") {
                    const selectedLanguage = this.player_.cache_.selectedLanguage;
                    if (selectedLanguage && selectedLanguage.enabled && selectedLanguage.language === this.track.language && selectedLanguage.kind !== this.track.kind) return;
                    this.player_.cache_.selectedLanguage = {
                        enabled: true,
                        language: this.track.language,
                        kind: this.track.kind
                    };
                }
            }
            dispose() {
                this.track = null;
                super.dispose();
            }
        }
        Component$1.registerComponent("TextTrackMenuItem", TextTrackMenuItem);
        class OffTextTrackMenuItem extends TextTrackMenuItem {
            constructor(player, options) {
                options.track = {
                    player,
                    kind: options.kind,
                    kinds: options.kinds,
                    default: false,
                    mode: "disabled"
                };
                if (!options.kinds) options.kinds = [ options.kind ];
                if (options.label) options.track.label = options.label; else options.track.label = options.kinds.join(" and ") + " off";
                options.selectable = true;
                options.multiSelectable = false;
                super(player, options);
            }
            handleTracksChange(event) {
                const tracks = this.player().textTracks();
                let shouldBeSelected = true;
                for (let i = 0, l = tracks.length; i < l; i++) {
                    const track = tracks[i];
                    if (this.options_.kinds.indexOf(track.kind) > -1 && track.mode === "showing") {
                        shouldBeSelected = false;
                        break;
                    }
                }
                if (shouldBeSelected !== this.isSelected_) this.selected(shouldBeSelected);
            }
            handleSelectedLanguageChange(event) {
                const tracks = this.player().textTracks();
                let allHidden = true;
                for (let i = 0, l = tracks.length; i < l; i++) {
                    const track = tracks[i];
                    if ([ "captions", "descriptions", "subtitles" ].indexOf(track.kind) > -1 && track.mode === "showing") {
                        allHidden = false;
                        break;
                    }
                }
                if (allHidden) this.player_.cache_.selectedLanguage = {
                    enabled: false
                };
            }
            handleLanguagechange() {
                this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.label);
                super.handleLanguagechange();
            }
        }
        Component$1.registerComponent("OffTextTrackMenuItem", OffTextTrackMenuItem);
        class TextTrackButton extends TrackButton {
            constructor(player, options = {}) {
                options.tracks = player.textTracks();
                super(player, options);
            }
            createItems(items = [], TrackMenuItem = TextTrackMenuItem) {
                let label;
                if (this.label_) label = `${this.label_} off`;
                items.push(new OffTextTrackMenuItem(this.player_, {
                    kinds: this.kinds_,
                    kind: this.kind_,
                    label
                }));
                this.hideThreshold_ += 1;
                const tracks = this.player_.textTracks();
                if (!Array.isArray(this.kinds_)) this.kinds_ = [ this.kind_ ];
                for (let i = 0; i < tracks.length; i++) {
                    const track = tracks[i];
                    if (this.kinds_.indexOf(track.kind) > -1) {
                        const item = new TrackMenuItem(this.player_, {
                            track,
                            kinds: this.kinds_,
                            kind: this.kind_,
                            selectable: true,
                            multiSelectable: false
                        });
                        item.addClass(`vjs-${track.kind}-menu-item`);
                        items.push(item);
                    }
                }
                return items;
            }
        }
        Component$1.registerComponent("TextTrackButton", TextTrackButton);
        class ChaptersTrackMenuItem extends MenuItem {
            constructor(player, options) {
                const track = options.track;
                const cue = options.cue;
                const currentTime = player.currentTime();
                options.selectable = true;
                options.multiSelectable = false;
                options.label = cue.text;
                options.selected = cue.startTime <= currentTime && currentTime < cue.endTime;
                super(player, options);
                this.track = track;
                this.cue = cue;
            }
            handleClick(event) {
                super.handleClick();
                this.player_.currentTime(this.cue.startTime);
            }
        }
        Component$1.registerComponent("ChaptersTrackMenuItem", ChaptersTrackMenuItem);
        class ChaptersButton extends TextTrackButton {
            constructor(player, options, ready) {
                super(player, options, ready);
                this.selectCurrentItem_ = () => {
                    this.items.forEach((item => {
                        item.selected(this.track_.activeCues[0] === item.cue);
                    }));
                };
            }
            buildCSSClass() {
                return `vjs-chapters-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-chapters-button ${super.buildWrapperCSSClass()}`;
            }
            update(event) {
                if (event && event.track && event.track.kind !== "chapters") return;
                const track = this.findChaptersTrack();
                if (track !== this.track_) {
                    this.setTrack(track);
                    super.update();
                } else if (!this.items || track && track.cues && track.cues.length !== this.items.length) super.update();
            }
            setTrack(track) {
                if (this.track_ === track) return;
                if (!this.updateHandler_) this.updateHandler_ = this.update.bind(this);
                if (this.track_) {
                    const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                    if (remoteTextTrackEl) remoteTextTrackEl.removeEventListener("load", this.updateHandler_);
                    this.track_.removeEventListener("cuechange", this.selectCurrentItem_);
                    this.track_ = null;
                }
                this.track_ = track;
                if (this.track_) {
                    this.track_.mode = "hidden";
                    const remoteTextTrackEl = this.player_.remoteTextTrackEls().getTrackElementByTrack_(this.track_);
                    if (remoteTextTrackEl) remoteTextTrackEl.addEventListener("load", this.updateHandler_);
                    this.track_.addEventListener("cuechange", this.selectCurrentItem_);
                }
            }
            findChaptersTrack() {
                const tracks = this.player_.textTracks() || [];
                for (let i = tracks.length - 1; i >= 0; i--) {
                    const track = tracks[i];
                    if (track.kind === this.kind_) return track;
                }
            }
            getMenuCaption() {
                if (this.track_ && this.track_.label) return this.track_.label;
                return this.localize(toTitleCase$1(this.kind_));
            }
            createMenu() {
                this.options_.title = this.getMenuCaption();
                return super.createMenu();
            }
            createItems() {
                const items = [];
                if (!this.track_) return items;
                const cues = this.track_.cues;
                if (!cues) return items;
                for (let i = 0, l = cues.length; i < l; i++) {
                    const cue = cues[i];
                    const mi = new ChaptersTrackMenuItem(this.player_, {
                        track: this.track_,
                        cue
                    });
                    items.push(mi);
                }
                return items;
            }
        }
        ChaptersButton.prototype.kind_ = "chapters";
        ChaptersButton.prototype.controlText_ = "Chapters";
        Component$1.registerComponent("ChaptersButton", ChaptersButton);
        class DescriptionsButton extends TextTrackButton {
            constructor(player, options, ready) {
                super(player, options, ready);
                const tracks = player.textTracks();
                const changeHandler = bind_(this, this.handleTracksChange);
                tracks.addEventListener("change", changeHandler);
                this.on("dispose", (function() {
                    tracks.removeEventListener("change", changeHandler);
                }));
            }
            handleTracksChange(event) {
                const tracks = this.player().textTracks();
                let disabled = false;
                for (let i = 0, l = tracks.length; i < l; i++) {
                    const track = tracks[i];
                    if (track.kind !== this.kind_ && track.mode === "showing") {
                        disabled = true;
                        break;
                    }
                }
                if (disabled) this.disable(); else this.enable();
            }
            buildCSSClass() {
                return `vjs-descriptions-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-descriptions-button ${super.buildWrapperCSSClass()}`;
            }
        }
        DescriptionsButton.prototype.kind_ = "descriptions";
        DescriptionsButton.prototype.controlText_ = "Descriptions";
        Component$1.registerComponent("DescriptionsButton", DescriptionsButton);
        class SubtitlesButton extends TextTrackButton {
            constructor(player, options, ready) {
                super(player, options, ready);
            }
            buildCSSClass() {
                return `vjs-subtitles-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-subtitles-button ${super.buildWrapperCSSClass()}`;
            }
        }
        SubtitlesButton.prototype.kind_ = "subtitles";
        SubtitlesButton.prototype.controlText_ = "Subtitles";
        Component$1.registerComponent("SubtitlesButton", SubtitlesButton);
        class CaptionSettingsMenuItem extends TextTrackMenuItem {
            constructor(player, options) {
                options.track = {
                    player,
                    kind: options.kind,
                    label: options.kind + " settings",
                    selectable: false,
                    default: false,
                    mode: "disabled"
                };
                options.selectable = false;
                options.name = "CaptionSettingsMenuItem";
                super(player, options);
                this.addClass("vjs-texttrack-settings");
                this.controlText(", opens " + options.kind + " settings dialog");
            }
            handleClick(event) {
                this.player().getChild("textTrackSettings").open();
            }
            handleLanguagechange() {
                this.$(".vjs-menu-item-text").textContent = this.player_.localize(this.options_.kind + " settings");
                super.handleLanguagechange();
            }
        }
        Component$1.registerComponent("CaptionSettingsMenuItem", CaptionSettingsMenuItem);
        class CaptionsButton extends TextTrackButton {
            constructor(player, options, ready) {
                super(player, options, ready);
            }
            buildCSSClass() {
                return `vjs-captions-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-captions-button ${super.buildWrapperCSSClass()}`;
            }
            createItems() {
                const items = [];
                if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
                    items.push(new CaptionSettingsMenuItem(this.player_, {
                        kind: this.kind_
                    }));
                    this.hideThreshold_ += 1;
                }
                return super.createItems(items);
            }
        }
        CaptionsButton.prototype.kind_ = "captions";
        CaptionsButton.prototype.controlText_ = "Captions";
        Component$1.registerComponent("CaptionsButton", CaptionsButton);
        class SubsCapsMenuItem extends TextTrackMenuItem {
            createEl(type, props, attrs) {
                const el = super.createEl(type, props, attrs);
                const parentSpan = el.querySelector(".vjs-menu-item-text");
                if (this.options_.track.kind === "captions") {
                    parentSpan.appendChild(createEl("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": true
                    }));
                    parentSpan.appendChild(createEl("span", {
                        className: "vjs-control-text",
                        textContent: ` ${this.localize("Captions")}`
                    }));
                }
                return el;
            }
        }
        Component$1.registerComponent("SubsCapsMenuItem", SubsCapsMenuItem);
        class SubsCapsButton extends TextTrackButton {
            constructor(player, options = {}) {
                super(player, options);
                this.label_ = "subtitles";
                if ([ "en", "en-us", "en-ca", "fr-ca" ].indexOf(this.player_.language_) > -1) this.label_ = "captions";
                this.menuButton_.controlText(toTitleCase$1(this.label_));
            }
            buildCSSClass() {
                return `vjs-subs-caps-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-subs-caps-button ${super.buildWrapperCSSClass()}`;
            }
            createItems() {
                let items = [];
                if (!(this.player().tech_ && this.player().tech_.featuresNativeTextTracks) && this.player().getChild("textTrackSettings")) {
                    items.push(new CaptionSettingsMenuItem(this.player_, {
                        kind: this.label_
                    }));
                    this.hideThreshold_ += 1;
                }
                items = super.createItems(items, SubsCapsMenuItem);
                return items;
            }
        }
        SubsCapsButton.prototype.kinds_ = [ "captions", "subtitles" ];
        SubsCapsButton.prototype.controlText_ = "Subtitles";
        Component$1.registerComponent("SubsCapsButton", SubsCapsButton);
        class AudioTrackMenuItem extends MenuItem {
            constructor(player, options) {
                const track = options.track;
                const tracks = player.audioTracks();
                options.label = track.label || track.language || "Unknown";
                options.selected = track.enabled;
                super(player, options);
                this.track = track;
                this.addClass(`vjs-${track.kind}-menu-item`);
                const changeHandler = (...args) => {
                    this.handleTracksChange.apply(this, args);
                };
                tracks.addEventListener("change", changeHandler);
                this.on("dispose", (() => {
                    tracks.removeEventListener("change", changeHandler);
                }));
            }
            createEl(type, props, attrs) {
                const el = super.createEl(type, props, attrs);
                const parentSpan = el.querySelector(".vjs-menu-item-text");
                if (this.options_.track.kind === "main-desc") {
                    parentSpan.appendChild(createEl("span", {
                        className: "vjs-icon-placeholder"
                    }, {
                        "aria-hidden": true
                    }));
                    parentSpan.appendChild(createEl("span", {
                        className: "vjs-control-text",
                        textContent: " " + this.localize("Descriptions")
                    }));
                }
                return el;
            }
            handleClick(event) {
                super.handleClick(event);
                this.track.enabled = true;
                if (this.player_.tech_.featuresNativeAudioTracks) {
                    const tracks = this.player_.audioTracks();
                    for (let i = 0; i < tracks.length; i++) {
                        const track = tracks[i];
                        if (track === this.track) continue;
                        track.enabled = track === this.track;
                    }
                }
            }
            handleTracksChange(event) {
                this.selected(this.track.enabled);
            }
        }
        Component$1.registerComponent("AudioTrackMenuItem", AudioTrackMenuItem);
        class AudioTrackButton extends TrackButton {
            constructor(player, options = {}) {
                options.tracks = player.audioTracks();
                super(player, options);
            }
            buildCSSClass() {
                return `vjs-audio-button ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-audio-button ${super.buildWrapperCSSClass()}`;
            }
            createItems(items = []) {
                this.hideThreshold_ = 1;
                const tracks = this.player_.audioTracks();
                for (let i = 0; i < tracks.length; i++) {
                    const track = tracks[i];
                    items.push(new AudioTrackMenuItem(this.player_, {
                        track,
                        selectable: true,
                        multiSelectable: false
                    }));
                }
                return items;
            }
        }
        AudioTrackButton.prototype.controlText_ = "Audio Track";
        Component$1.registerComponent("AudioTrackButton", AudioTrackButton);
        class PlaybackRateMenuItem extends MenuItem {
            constructor(player, options) {
                const label = options.rate;
                const rate = parseFloat(label, 10);
                options.label = label;
                options.selected = rate === player.playbackRate();
                options.selectable = true;
                options.multiSelectable = false;
                super(player, options);
                this.label = label;
                this.rate = rate;
                this.on(player, "ratechange", (e => this.update(e)));
            }
            handleClick(event) {
                super.handleClick();
                this.player().playbackRate(this.rate);
            }
            update(event) {
                this.selected(this.player().playbackRate() === this.rate);
            }
        }
        PlaybackRateMenuItem.prototype.contentElType = "button";
        Component$1.registerComponent("PlaybackRateMenuItem", PlaybackRateMenuItem);
        class PlaybackRateMenuButton extends MenuButton {
            constructor(player, options) {
                super(player, options);
                this.menuButton_.el_.setAttribute("aria-describedby", this.labelElId_);
                this.updateVisibility();
                this.updateLabel();
                this.on(player, "loadstart", (e => this.updateVisibility(e)));
                this.on(player, "ratechange", (e => this.updateLabel(e)));
                this.on(player, "playbackrateschange", (e => this.handlePlaybackRateschange(e)));
            }
            createEl() {
                const el = super.createEl();
                this.labelElId_ = "vjs-playback-rate-value-label-" + this.id_;
                this.labelEl_ = createEl("div", {
                    className: "vjs-playback-rate-value",
                    id: this.labelElId_,
                    textContent: "1x"
                });
                el.appendChild(this.labelEl_);
                return el;
            }
            dispose() {
                this.labelEl_ = null;
                super.dispose();
            }
            buildCSSClass() {
                return `vjs-playback-rate ${super.buildCSSClass()}`;
            }
            buildWrapperCSSClass() {
                return `vjs-playback-rate ${super.buildWrapperCSSClass()}`;
            }
            createItems() {
                const rates = this.playbackRates();
                const items = [];
                for (let i = rates.length - 1; i >= 0; i--) items.push(new PlaybackRateMenuItem(this.player(), {
                    rate: rates[i] + "x"
                }));
                return items;
            }
            handlePlaybackRateschange(event) {
                this.update();
            }
            playbackRates() {
                const player = this.player();
                return player.playbackRates && player.playbackRates() || [];
            }
            playbackRateSupported() {
                return this.player().tech_ && this.player().tech_.featuresPlaybackRate && this.playbackRates() && this.playbackRates().length > 0;
            }
            updateVisibility(event) {
                if (this.playbackRateSupported()) this.removeClass("vjs-hidden"); else this.addClass("vjs-hidden");
            }
            updateLabel(event) {
                if (this.playbackRateSupported()) this.labelEl_.textContent = this.player().playbackRate() + "x";
            }
        }
        PlaybackRateMenuButton.prototype.controlText_ = "Playback Rate";
        Component$1.registerComponent("PlaybackRateMenuButton", PlaybackRateMenuButton);
        class Spacer extends Component$1 {
            buildCSSClass() {
                return `vjs-spacer ${super.buildCSSClass()}`;
            }
            createEl(tag = "div", props = {}, attributes = {}) {
                if (!props.className) props.className = this.buildCSSClass();
                return super.createEl(tag, props, attributes);
            }
        }
        Component$1.registerComponent("Spacer", Spacer);
        class CustomControlSpacer extends Spacer {
            buildCSSClass() {
                return `vjs-custom-control-spacer ${super.buildCSSClass()}`;
            }
            createEl() {
                return super.createEl("div", {
                    className: this.buildCSSClass(),
                    textContent: "¬†"
                });
            }
        }
        Component$1.registerComponent("CustomControlSpacer", CustomControlSpacer);
        class ControlBar extends Component$1 {
            createEl() {
                return super.createEl("div", {
                    className: "vjs-control-bar",
                    dir: "ltr"
                });
            }
        }
        ControlBar.prototype.options_ = {
            children: [ "playToggle", "skipBackward", "skipForward", "volumePanel", "currentTimeDisplay", "timeDivider", "durationDisplay", "progressControl", "liveDisplay", "seekToLive", "remainingTimeDisplay", "customControlSpacer", "playbackRateMenuButton", "chaptersButton", "descriptionsButton", "subsCapsButton", "audioTrackButton", "fullscreenToggle" ]
        };
        if ("exitPictureInPicture" in document_default()) ControlBar.prototype.options_.children.splice(ControlBar.prototype.options_.children.length - 1, 0, "pictureInPictureToggle");
        Component$1.registerComponent("ControlBar", ControlBar);
        class ErrorDisplay extends ModalDialog {
            constructor(player, options) {
                super(player, options);
                this.on(player, "error", (e => this.open(e)));
            }
            buildCSSClass() {
                return `vjs-error-display ${super.buildCSSClass()}`;
            }
            content() {
                const error = this.player().error();
                return error ? this.localize(error.message) : "";
            }
        }
        ErrorDisplay.prototype.options_ = Object.assign({}, ModalDialog.prototype.options_, {
            pauseOnOpen: false,
            fillAlways: true,
            temporary: false,
            uncloseable: true
        });
        Component$1.registerComponent("ErrorDisplay", ErrorDisplay);
        const LOCAL_STORAGE_KEY$1 = "vjs-text-track-settings";
        const COLOR_BLACK = [ "#000", "Black" ];
        const COLOR_BLUE = [ "#00F", "Blue" ];
        const COLOR_CYAN = [ "#0FF", "Cyan" ];
        const COLOR_GREEN = [ "#0F0", "Green" ];
        const COLOR_MAGENTA = [ "#F0F", "Magenta" ];
        const COLOR_RED = [ "#F00", "Red" ];
        const COLOR_WHITE = [ "#FFF", "White" ];
        const COLOR_YELLOW = [ "#FF0", "Yellow" ];
        const OPACITY_OPAQUE = [ "1", "Opaque" ];
        const OPACITY_SEMI = [ "0.5", "Semi-Transparent" ];
        const OPACITY_TRANS = [ "0", "Transparent" ];
        const selectConfigs = {
            backgroundColor: {
                selector: ".vjs-bg-color > select",
                id: "captions-background-color-%s",
                label: "Color",
                options: [ COLOR_BLACK, COLOR_WHITE, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN ]
            },
            backgroundOpacity: {
                selector: ".vjs-bg-opacity > select",
                id: "captions-background-opacity-%s",
                label: "Opacity",
                options: [ OPACITY_OPAQUE, OPACITY_SEMI, OPACITY_TRANS ]
            },
            color: {
                selector: ".vjs-text-color > select",
                id: "captions-foreground-color-%s",
                label: "Color",
                options: [ COLOR_WHITE, COLOR_BLACK, COLOR_RED, COLOR_GREEN, COLOR_BLUE, COLOR_YELLOW, COLOR_MAGENTA, COLOR_CYAN ]
            },
            edgeStyle: {
                selector: ".vjs-edge-style > select",
                id: "%s",
                label: "Text Edge Style",
                options: [ [ "none", "None" ], [ "raised", "Raised" ], [ "depressed", "Depressed" ], [ "uniform", "Uniform" ], [ "dropshadow", "Dropshadow" ] ]
            },
            fontFamily: {
                selector: ".vjs-font-family > select",
                id: "captions-font-family-%s",
                label: "Font Family",
                options: [ [ "proportionalSansSerif", "Proportional Sans-Serif" ], [ "monospaceSansSerif", "Monospace Sans-Serif" ], [ "proportionalSerif", "Proportional Serif" ], [ "monospaceSerif", "Monospace Serif" ], [ "casual", "Casual" ], [ "script", "Script" ], [ "small-caps", "Small Caps" ] ]
            },
            fontPercent: {
                selector: ".vjs-font-percent > select",
                id: "captions-font-size-%s",
                label: "Font Size",
                options: [ [ "0.50", "50%" ], [ "0.75", "75%" ], [ "1.00", "100%" ], [ "1.25", "125%" ], [ "1.50", "150%" ], [ "1.75", "175%" ], [ "2.00", "200%" ], [ "3.00", "300%" ], [ "4.00", "400%" ] ],
                default: 2,
                parser: v => v === "1.00" ? null : Number(v)
            },
            textOpacity: {
                selector: ".vjs-text-opacity > select",
                id: "captions-foreground-opacity-%s",
                label: "Opacity",
                options: [ OPACITY_OPAQUE, OPACITY_SEMI ]
            },
            windowColor: {
                selector: ".vjs-window-color > select",
                id: "captions-window-color-%s",
                label: "Color"
            },
            windowOpacity: {
                selector: ".vjs-window-opacity > select",
                id: "captions-window-opacity-%s",
                label: "Opacity",
                options: [ OPACITY_TRANS, OPACITY_SEMI, OPACITY_OPAQUE ]
            }
        };
        selectConfigs.windowColor.options = selectConfigs.backgroundColor.options;
        function parseOptionValue(value, parser) {
            if (parser) value = parser(value);
            if (value && value !== "none") return value;
        }
        function getSelectedOptionValue(el, parser) {
            const value = el.options[el.options.selectedIndex].value;
            return parseOptionValue(value, parser);
        }
        function setSelectedOption(el, value, parser) {
            if (!value) return;
            for (let i = 0; i < el.options.length; i++) if (parseOptionValue(el.options[i].value, parser) === value) {
                el.selectedIndex = i;
                break;
            }
        }
        class TextTrackSettings extends ModalDialog {
            constructor(player, options) {
                options.temporary = false;
                super(player, options);
                this.updateDisplay = this.updateDisplay.bind(this);
                this.fill();
                this.hasBeenOpened_ = this.hasBeenFilled_ = true;
                this.endDialog = createEl("p", {
                    className: "vjs-control-text",
                    textContent: this.localize("End of dialog window.")
                });
                this.el().appendChild(this.endDialog);
                this.setDefaults();
                if (options.persistTextTrackSettings === void 0) this.options_.persistTextTrackSettings = this.options_.playerOptions.persistTextTrackSettings;
                this.on(this.$(".vjs-done-button"), "click", (() => {
                    this.saveSettings();
                    this.close();
                }));
                this.on(this.$(".vjs-default-button"), "click", (() => {
                    this.setDefaults();
                    this.updateDisplay();
                }));
                each(selectConfigs, (config => {
                    this.on(this.$(config.selector), "change", this.updateDisplay);
                }));
                if (this.options_.persistTextTrackSettings) this.restoreSettings();
            }
            dispose() {
                this.endDialog = null;
                super.dispose();
            }
            createElSelect_(key, legendId = "", type = "label") {
                const config = selectConfigs[key];
                const id = config.id.replace("%s", this.id_);
                const selectLabelledbyIds = [ legendId, id ].join(" ").trim();
                return [ `<${type} id="${id}" class="${type === "label" ? "vjs-label" : ""}">`, this.localize(config.label), `</${type}>`, `<select aria-labelledby="${selectLabelledbyIds}">` ].concat(config.options.map((o => {
                    const optionId = id + "-" + o[1].replace(/\W+/g, "");
                    return [ `<option id="${optionId}" value="${o[0]}" `, `aria-labelledby="${selectLabelledbyIds} ${optionId}">`, this.localize(o[1]), "</option>" ].join("");
                }))).concat("</select>").join("");
            }
            createElFgColor_() {
                const legendId = `captions-text-legend-${this.id_}`;
                return [ '<fieldset class="vjs-fg vjs-track-setting">', `<legend id="${legendId}">`, this.localize("Text"), "</legend>", '<span class="vjs-text-color">', this.createElSelect_("color", legendId), "</span>", '<span class="vjs-text-opacity vjs-opacity">', this.createElSelect_("textOpacity", legendId), "</span>", "</fieldset>" ].join("");
            }
            createElBgColor_() {
                const legendId = `captions-background-${this.id_}`;
                return [ '<fieldset class="vjs-bg vjs-track-setting">', `<legend id="${legendId}">`, this.localize("Text Background"), "</legend>", '<span class="vjs-bg-color">', this.createElSelect_("backgroundColor", legendId), "</span>", '<span class="vjs-bg-opacity vjs-opacity">', this.createElSelect_("backgroundOpacity", legendId), "</span>", "</fieldset>" ].join("");
            }
            createElWinColor_() {
                const legendId = `captions-window-${this.id_}`;
                return [ '<fieldset class="vjs-window vjs-track-setting">', `<legend id="${legendId}">`, this.localize("Caption Area Background"), "</legend>", '<span class="vjs-window-color">', this.createElSelect_("windowColor", legendId), "</span>", '<span class="vjs-window-opacity vjs-opacity">', this.createElSelect_("windowOpacity", legendId), "</span>", "</fieldset>" ].join("");
            }
            createElColors_() {
                return createEl("div", {
                    className: "vjs-track-settings-colors",
                    innerHTML: [ this.createElFgColor_(), this.createElBgColor_(), this.createElWinColor_() ].join("")
                });
            }
            createElFont_() {
                return createEl("div", {
                    className: "vjs-track-settings-font",
                    innerHTML: [ '<fieldset class="vjs-font-percent vjs-track-setting">', this.createElSelect_("fontPercent", "", "legend"), "</fieldset>", '<fieldset class="vjs-edge-style vjs-track-setting">', this.createElSelect_("edgeStyle", "", "legend"), "</fieldset>", '<fieldset class="vjs-font-family vjs-track-setting">', this.createElSelect_("fontFamily", "", "legend"), "</fieldset>" ].join("")
                });
            }
            createElControls_() {
                const defaultsDescription = this.localize("restore all settings to the default values");
                return createEl("div", {
                    className: "vjs-track-settings-controls",
                    innerHTML: [ `<button type="button" class="vjs-default-button" title="${defaultsDescription}">`, this.localize("Reset"), `<span class="vjs-control-text"> ${defaultsDescription}</span>`, "</button>", `<button type="button" class="vjs-done-button">${this.localize("Done")}</button>` ].join("")
                });
            }
            content() {
                return [ this.createElColors_(), this.createElFont_(), this.createElControls_() ];
            }
            label() {
                return this.localize("Caption Settings Dialog");
            }
            description() {
                return this.localize("Beginning of dialog window. Escape will cancel and close the window.");
            }
            buildCSSClass() {
                return super.buildCSSClass() + " vjs-text-track-settings";
            }
            getValues() {
                return reduce(selectConfigs, ((accum, config, key) => {
                    const value = getSelectedOptionValue(this.$(config.selector), config.parser);
                    if (value !== void 0) accum[key] = value;
                    return accum;
                }), {});
            }
            setValues(values) {
                each(selectConfigs, ((config, key) => {
                    setSelectedOption(this.$(config.selector), values[key], config.parser);
                }));
            }
            setDefaults() {
                each(selectConfigs, (config => {
                    const index = config.hasOwnProperty("default") ? config.default : 0;
                    this.$(config.selector).selectedIndex = index;
                }));
            }
            restoreSettings() {
                let values;
                try {
                    values = JSON.parse(window_default().localStorage.getItem(LOCAL_STORAGE_KEY$1));
                } catch (err) {
                    log$1.warn(err);
                }
                if (values) this.setValues(values);
            }
            saveSettings() {
                if (!this.options_.persistTextTrackSettings) return;
                const values = this.getValues();
                try {
                    if (Object.keys(values).length) window_default().localStorage.setItem(LOCAL_STORAGE_KEY$1, JSON.stringify(values)); else window_default().localStorage.removeItem(LOCAL_STORAGE_KEY$1);
                } catch (err) {
                    log$1.warn(err);
                }
            }
            updateDisplay() {
                const ttDisplay = this.player_.getChild("textTrackDisplay");
                if (ttDisplay) ttDisplay.updateDisplay();
            }
            conditionalBlur_() {
                this.previouslyActiveEl_ = null;
                const cb = this.player_.controlBar;
                const subsCapsBtn = cb && cb.subsCapsButton;
                const ccBtn = cb && cb.captionsButton;
                if (subsCapsBtn) subsCapsBtn.focus(); else if (ccBtn) ccBtn.focus();
            }
            handleLanguagechange() {
                this.fill();
            }
        }
        Component$1.registerComponent("TextTrackSettings", TextTrackSettings);
        class ResizeManager extends Component$1 {
            constructor(player, options) {
                let RESIZE_OBSERVER_AVAILABLE = options.ResizeObserver || window_default().ResizeObserver;
                if (options.ResizeObserver === null) RESIZE_OBSERVER_AVAILABLE = false;
                const options_ = merge$1({
                    createEl: !RESIZE_OBSERVER_AVAILABLE,
                    reportTouchActivity: false
                }, options);
                super(player, options_);
                this.ResizeObserver = options.ResizeObserver || window_default().ResizeObserver;
                this.loadListener_ = null;
                this.resizeObserver_ = null;
                this.debouncedHandler_ = debounce((() => {
                    this.resizeHandler();
                }), 100, false, this);
                if (RESIZE_OBSERVER_AVAILABLE) {
                    this.resizeObserver_ = new this.ResizeObserver(this.debouncedHandler_);
                    this.resizeObserver_.observe(player.el());
                } else {
                    this.loadListener_ = () => {
                        if (!this.el_ || !this.el_.contentWindow) return;
                        const debouncedHandler_ = this.debouncedHandler_;
                        let unloadListener_ = this.unloadListener_ = function() {
                            off(this, "resize", debouncedHandler_);
                            off(this, "unload", unloadListener_);
                            unloadListener_ = null;
                        };
                        on(this.el_.contentWindow, "unload", unloadListener_);
                        on(this.el_.contentWindow, "resize", debouncedHandler_);
                    };
                    this.one("load", this.loadListener_);
                }
            }
            createEl() {
                return super.createEl("iframe", {
                    className: "vjs-resize-manager",
                    tabIndex: -1,
                    title: this.localize("No content")
                }, {
                    "aria-hidden": "true"
                });
            }
            resizeHandler() {
                if (!this.player_ || !this.player_.trigger) return;
                this.player_.trigger("playerresize");
            }
            dispose() {
                if (this.debouncedHandler_) this.debouncedHandler_.cancel();
                if (this.resizeObserver_) {
                    if (this.player_.el()) this.resizeObserver_.unobserve(this.player_.el());
                    this.resizeObserver_.disconnect();
                }
                if (this.loadListener_) this.off("load", this.loadListener_);
                if (this.el_ && this.el_.contentWindow && this.unloadListener_) this.unloadListener_.call(this.el_.contentWindow);
                this.ResizeObserver = null;
                this.resizeObserver = null;
                this.debouncedHandler_ = null;
                this.loadListener_ = null;
                super.dispose();
            }
        }
        Component$1.registerComponent("ResizeManager", ResizeManager);
        const video_es_defaults = {
            trackingThreshold: 20,
            liveTolerance: 15
        };
        class LiveTracker extends Component$1 {
            constructor(player, options) {
                const options_ = merge$1(video_es_defaults, options, {
                    createEl: false
                });
                super(player, options_);
                this.trackLiveHandler_ = () => this.trackLive_();
                this.handlePlay_ = e => this.handlePlay(e);
                this.handleFirstTimeupdate_ = e => this.handleFirstTimeupdate(e);
                this.handleSeeked_ = e => this.handleSeeked(e);
                this.seekToLiveEdge_ = e => this.seekToLiveEdge(e);
                this.reset_();
                this.on(this.player_, "durationchange", (e => this.handleDurationchange(e)));
                this.on(this.player_, "canplay", (() => this.toggleTracking()));
            }
            trackLive_() {
                const seekable = this.player_.seekable();
                if (!seekable || !seekable.length) return;
                const newTime = Number(window_default().performance.now().toFixed(4));
                const deltaTime = this.lastTime_ === -1 ? 0 : (newTime - this.lastTime_) / 1e3;
                this.lastTime_ = newTime;
                this.pastSeekEnd_ = this.pastSeekEnd() + deltaTime;
                const liveCurrentTime = this.liveCurrentTime();
                const currentTime = this.player_.currentTime();
                let isBehind = this.player_.paused() || this.seekedBehindLive_ || Math.abs(liveCurrentTime - currentTime) > this.options_.liveTolerance;
                if (!this.timeupdateSeen_ || liveCurrentTime === 1 / 0) isBehind = false;
                if (isBehind !== this.behindLiveEdge_) {
                    this.behindLiveEdge_ = isBehind;
                    this.trigger("liveedgechange");
                }
            }
            handleDurationchange() {
                this.toggleTracking();
            }
            toggleTracking() {
                if (this.player_.duration() === 1 / 0 && this.liveWindow() >= this.options_.trackingThreshold) {
                    if (this.player_.options_.liveui) this.player_.addClass("vjs-liveui");
                    this.startTracking();
                } else {
                    this.player_.removeClass("vjs-liveui");
                    this.stopTracking();
                }
            }
            startTracking() {
                if (this.isTracking()) return;
                if (!this.timeupdateSeen_) this.timeupdateSeen_ = this.player_.hasStarted();
                this.trackingInterval_ = this.setInterval(this.trackLiveHandler_, UPDATE_REFRESH_INTERVAL);
                this.trackLive_();
                this.on(this.player_, [ "play", "pause" ], this.trackLiveHandler_);
                if (!this.timeupdateSeen_) {
                    this.one(this.player_, "play", this.handlePlay_);
                    this.one(this.player_, "timeupdate", this.handleFirstTimeupdate_);
                } else this.on(this.player_, "seeked", this.handleSeeked_);
            }
            handleFirstTimeupdate() {
                this.timeupdateSeen_ = true;
                this.on(this.player_, "seeked", this.handleSeeked_);
            }
            handleSeeked() {
                const timeDiff = Math.abs(this.liveCurrentTime() - this.player_.currentTime());
                this.seekedBehindLive_ = this.nextSeekedFromUser_ && timeDiff > 2;
                this.nextSeekedFromUser_ = false;
                this.trackLive_();
            }
            handlePlay() {
                this.one(this.player_, "timeupdate", this.seekToLiveEdge_);
            }
            reset_() {
                this.lastTime_ = -1;
                this.pastSeekEnd_ = 0;
                this.lastSeekEnd_ = -1;
                this.behindLiveEdge_ = true;
                this.timeupdateSeen_ = false;
                this.seekedBehindLive_ = false;
                this.nextSeekedFromUser_ = false;
                this.clearInterval(this.trackingInterval_);
                this.trackingInterval_ = null;
                this.off(this.player_, [ "play", "pause" ], this.trackLiveHandler_);
                this.off(this.player_, "seeked", this.handleSeeked_);
                this.off(this.player_, "play", this.handlePlay_);
                this.off(this.player_, "timeupdate", this.handleFirstTimeupdate_);
                this.off(this.player_, "timeupdate", this.seekToLiveEdge_);
            }
            nextSeekedFromUser() {
                this.nextSeekedFromUser_ = true;
            }
            stopTracking() {
                if (!this.isTracking()) return;
                this.reset_();
                this.trigger("liveedgechange");
            }
            seekableEnd() {
                const seekable = this.player_.seekable();
                const seekableEnds = [];
                let i = seekable ? seekable.length : 0;
                while (i--) seekableEnds.push(seekable.end(i));
                return seekableEnds.length ? seekableEnds.sort()[seekableEnds.length - 1] : 1 / 0;
            }
            seekableStart() {
                const seekable = this.player_.seekable();
                const seekableStarts = [];
                let i = seekable ? seekable.length : 0;
                while (i--) seekableStarts.push(seekable.start(i));
                return seekableStarts.length ? seekableStarts.sort()[0] : 0;
            }
            liveWindow() {
                const liveCurrentTime = this.liveCurrentTime();
                if (liveCurrentTime === 1 / 0) return 0;
                return liveCurrentTime - this.seekableStart();
            }
            isLive() {
                return this.isTracking();
            }
            atLiveEdge() {
                return !this.behindLiveEdge();
            }
            liveCurrentTime() {
                return this.pastSeekEnd() + this.seekableEnd();
            }
            pastSeekEnd() {
                const seekableEnd = this.seekableEnd();
                if (this.lastSeekEnd_ !== -1 && seekableEnd !== this.lastSeekEnd_) this.pastSeekEnd_ = 0;
                this.lastSeekEnd_ = seekableEnd;
                return this.pastSeekEnd_;
            }
            behindLiveEdge() {
                return this.behindLiveEdge_;
            }
            isTracking() {
                return typeof this.trackingInterval_ === "number";
            }
            seekToLiveEdge() {
                this.seekedBehindLive_ = false;
                if (this.atLiveEdge()) return;
                this.nextSeekedFromUser_ = false;
                this.player_.currentTime(this.liveCurrentTime());
            }
            dispose() {
                this.stopTracking();
                super.dispose();
            }
        }
        Component$1.registerComponent("LiveTracker", LiveTracker);
        class TitleBar extends Component$1 {
            constructor(player, options) {
                super(player, options);
                this.on("statechanged", (e => this.updateDom_()));
                this.updateDom_();
            }
            createEl() {
                this.els = {
                    title: createEl("div", {
                        className: "vjs-title-bar-title",
                        id: `vjs-title-bar-title-${newGUID()}`
                    }),
                    description: createEl("div", {
                        className: "vjs-title-bar-description",
                        id: `vjs-title-bar-description-${newGUID()}`
                    })
                };
                return createEl("div", {
                    className: "vjs-title-bar"
                }, {}, Object.values(this.els));
            }
            updateDom_() {
                const tech = this.player_.tech_;
                const techEl = tech && tech.el_;
                const techAriaAttrs = {
                    title: "aria-labelledby",
                    description: "aria-describedby"
                };
                [ "title", "description" ].forEach((k => {
                    const value = this.state[k];
                    const el = this.els[k];
                    const techAriaAttr = techAriaAttrs[k];
                    emptyEl(el);
                    if (value) textContent(el, value);
                    if (techEl) {
                        techEl.removeAttribute(techAriaAttr);
                        if (value) techEl.setAttribute(techAriaAttr, el.id);
                    }
                }));
                if (this.state.title || this.state.description) this.show(); else this.hide();
            }
            update(options) {
                this.setState(options);
            }
            dispose() {
                const tech = this.player_.tech_;
                const techEl = tech && tech.el_;
                if (techEl) {
                    techEl.removeAttribute("aria-labelledby");
                    techEl.removeAttribute("aria-describedby");
                }
                super.dispose();
                this.els = null;
            }
        }
        Component$1.registerComponent("TitleBar", TitleBar);
        const sourcesetLoad = tech => {
            const el = tech.el();
            if (el.hasAttribute("src")) {
                tech.triggerSourceset(el.src);
                return true;
            }
            const sources = tech.$$("source");
            const srcUrls = [];
            let src = "";
            if (!sources.length) return false;
            for (let i = 0; i < sources.length; i++) {
                const url = sources[i].src;
                if (url && srcUrls.indexOf(url) === -1) srcUrls.push(url);
            }
            if (!srcUrls.length) return false;
            if (srcUrls.length === 1) src = srcUrls[0];
            tech.triggerSourceset(src);
            return true;
        };
        const innerHTMLDescriptorPolyfill = Object.defineProperty({}, "innerHTML", {
            get() {
                return this.cloneNode(true).innerHTML;
            },
            set(v) {
                const dummy = document_default().createElement(this.nodeName.toLowerCase());
                dummy.innerHTML = v;
                const docFrag = document_default().createDocumentFragment();
                while (dummy.childNodes.length) docFrag.appendChild(dummy.childNodes[0]);
                this.innerText = "";
                window_default().Element.prototype.appendChild.call(this, docFrag);
                return this.innerHTML;
            }
        });
        const getDescriptor = (priority, prop) => {
            let descriptor = {};
            for (let i = 0; i < priority.length; i++) {
                descriptor = Object.getOwnPropertyDescriptor(priority[i], prop);
                if (descriptor && descriptor.set && descriptor.get) break;
            }
            descriptor.enumerable = true;
            descriptor.configurable = true;
            return descriptor;
        };
        const getInnerHTMLDescriptor = tech => getDescriptor([ tech.el(), window_default().HTMLMediaElement.prototype, window_default().Element.prototype, innerHTMLDescriptorPolyfill ], "innerHTML");
        const firstSourceWatch = function(tech) {
            const el = tech.el();
            if (el.resetSourceWatch_) return;
            const old = {};
            const innerDescriptor = getInnerHTMLDescriptor(tech);
            const appendWrapper = appendFn => (...args) => {
                const retval = appendFn.apply(el, args);
                sourcesetLoad(tech);
                return retval;
            };
            [ "append", "appendChild", "insertAdjacentHTML" ].forEach((k => {
                if (!el[k]) return;
                old[k] = el[k];
                el[k] = appendWrapper(old[k]);
            }));
            Object.defineProperty(el, "innerHTML", merge$1(innerDescriptor, {
                set: appendWrapper(innerDescriptor.set)
            }));
            el.resetSourceWatch_ = () => {
                el.resetSourceWatch_ = null;
                Object.keys(old).forEach((k => {
                    el[k] = old[k];
                }));
                Object.defineProperty(el, "innerHTML", innerDescriptor);
            };
            tech.one("sourceset", el.resetSourceWatch_);
        };
        const srcDescriptorPolyfill = Object.defineProperty({}, "src", {
            get() {
                if (this.hasAttribute("src")) return getAbsoluteURL(window_default().Element.prototype.getAttribute.call(this, "src"));
                return "";
            },
            set(v) {
                window_default().Element.prototype.setAttribute.call(this, "src", v);
                return v;
            }
        });
        const getSrcDescriptor = tech => getDescriptor([ tech.el(), window_default().HTMLMediaElement.prototype, srcDescriptorPolyfill ], "src");
        const setupSourceset = function(tech) {
            if (!tech.featuresSourceset) return;
            const el = tech.el();
            if (el.resetSourceset_) return;
            const srcDescriptor = getSrcDescriptor(tech);
            const oldSetAttribute = el.setAttribute;
            const oldLoad = el.load;
            Object.defineProperty(el, "src", merge$1(srcDescriptor, {
                set: v => {
                    const retval = srcDescriptor.set.call(el, v);
                    tech.triggerSourceset(el.src);
                    return retval;
                }
            }));
            el.setAttribute = (n, v) => {
                const retval = oldSetAttribute.call(el, n, v);
                if (/src/i.test(n)) tech.triggerSourceset(el.src);
                return retval;
            };
            el.load = () => {
                const retval = oldLoad.call(el);
                if (!sourcesetLoad(tech)) {
                    tech.triggerSourceset("");
                    firstSourceWatch(tech);
                }
                return retval;
            };
            if (el.currentSrc) tech.triggerSourceset(el.currentSrc); else if (!sourcesetLoad(tech)) firstSourceWatch(tech);
            el.resetSourceset_ = () => {
                el.resetSourceset_ = null;
                el.load = oldLoad;
                el.setAttribute = oldSetAttribute;
                Object.defineProperty(el, "src", srcDescriptor);
                if (el.resetSourceWatch_) el.resetSourceWatch_();
            };
        };
        class Html5 extends Tech {
            constructor(options, ready) {
                super(options, ready);
                const source = options.source;
                let crossoriginTracks = false;
                this.featuresVideoFrameCallback = this.featuresVideoFrameCallback && this.el_.tagName === "VIDEO";
                if (source && (this.el_.currentSrc !== source.src || options.tag && options.tag.initNetworkState_ === 3)) this.setSource(source); else this.handleLateInit_(this.el_);
                if (options.enableSourceset) this.setupSourcesetHandling_();
                this.isScrubbing_ = false;
                if (this.el_.hasChildNodes()) {
                    const nodes = this.el_.childNodes;
                    let nodesLength = nodes.length;
                    const removeNodes = [];
                    while (nodesLength--) {
                        const node = nodes[nodesLength];
                        const nodeName = node.nodeName.toLowerCase();
                        if (nodeName === "track") if (!this.featuresNativeTextTracks) removeNodes.push(node); else {
                            this.remoteTextTrackEls().addTrackElement_(node);
                            this.remoteTextTracks().addTrack(node.track);
                            this.textTracks().addTrack(node.track);
                            if (!crossoriginTracks && !this.el_.hasAttribute("crossorigin") && isCrossOrigin(node.src)) crossoriginTracks = true;
                        }
                    }
                    for (let i = 0; i < removeNodes.length; i++) this.el_.removeChild(removeNodes[i]);
                }
                this.proxyNativeTracks_();
                if (this.featuresNativeTextTracks && crossoriginTracks) log$1.warn("Text Tracks are being loaded from another origin but the crossorigin attribute isn't used.\n" + "This may prevent text tracks from loading.");
                this.restoreMetadataTracksInIOSNativePlayer_();
                if ((TOUCH_ENABLED || IS_IPHONE) && options.nativeControlsForTouch === true) this.setControls(true);
                this.proxyWebkitFullscreen_();
                this.triggerReady();
            }
            dispose() {
                if (this.el_ && this.el_.resetSourceset_) this.el_.resetSourceset_();
                Html5.disposeMediaElement(this.el_);
                this.options_ = null;
                super.dispose();
            }
            setupSourcesetHandling_() {
                setupSourceset(this);
            }
            restoreMetadataTracksInIOSNativePlayer_() {
                const textTracks = this.textTracks();
                let metadataTracksPreFullscreenState;
                const takeMetadataTrackSnapshot = () => {
                    metadataTracksPreFullscreenState = [];
                    for (let i = 0; i < textTracks.length; i++) {
                        const track = textTracks[i];
                        if (track.kind === "metadata") metadataTracksPreFullscreenState.push({
                            track,
                            storedMode: track.mode
                        });
                    }
                };
                takeMetadataTrackSnapshot();
                textTracks.addEventListener("change", takeMetadataTrackSnapshot);
                this.on("dispose", (() => textTracks.removeEventListener("change", takeMetadataTrackSnapshot)));
                const restoreTrackMode = () => {
                    for (let i = 0; i < metadataTracksPreFullscreenState.length; i++) {
                        const storedTrack = metadataTracksPreFullscreenState[i];
                        if (storedTrack.track.mode === "disabled" && storedTrack.track.mode !== storedTrack.storedMode) storedTrack.track.mode = storedTrack.storedMode;
                    }
                    textTracks.removeEventListener("change", restoreTrackMode);
                };
                this.on("webkitbeginfullscreen", (() => {
                    textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
                    textTracks.removeEventListener("change", restoreTrackMode);
                    textTracks.addEventListener("change", restoreTrackMode);
                }));
                this.on("webkitendfullscreen", (() => {
                    textTracks.removeEventListener("change", takeMetadataTrackSnapshot);
                    textTracks.addEventListener("change", takeMetadataTrackSnapshot);
                    textTracks.removeEventListener("change", restoreTrackMode);
                }));
            }
            overrideNative_(type, override) {
                if (override !== this[`featuresNative${type}Tracks`]) return;
                const lowerCaseType = type.toLowerCase();
                if (this[`${lowerCaseType}TracksListeners_`]) Object.keys(this[`${lowerCaseType}TracksListeners_`]).forEach((eventName => {
                    const elTracks = this.el()[`${lowerCaseType}Tracks`];
                    elTracks.removeEventListener(eventName, this[`${lowerCaseType}TracksListeners_`][eventName]);
                }));
                this[`featuresNative${type}Tracks`] = !override;
                this[`${lowerCaseType}TracksListeners_`] = null;
                this.proxyNativeTracksForType_(lowerCaseType);
            }
            overrideNativeAudioTracks(override) {
                this.overrideNative_("Audio", override);
            }
            overrideNativeVideoTracks(override) {
                this.overrideNative_("Video", override);
            }
            proxyNativeTracksForType_(name) {
                const props = NORMAL[name];
                const elTracks = this.el()[props.getterName];
                const techTracks = this[props.getterName]();
                if (!this[`featuresNative${props.capitalName}Tracks`] || !elTracks || !elTracks.addEventListener) return;
                const listeners = {
                    change: e => {
                        const event = {
                            type: "change",
                            target: techTracks,
                            currentTarget: techTracks,
                            srcElement: techTracks
                        };
                        techTracks.trigger(event);
                        if (name === "text") this[REMOTE.remoteText.getterName]().trigger(event);
                    },
                    addtrack(e) {
                        techTracks.addTrack(e.track);
                    },
                    removetrack(e) {
                        techTracks.removeTrack(e.track);
                    }
                };
                const removeOldTracks = function() {
                    const removeTracks = [];
                    for (let i = 0; i < techTracks.length; i++) {
                        let found = false;
                        for (let j = 0; j < elTracks.length; j++) if (elTracks[j] === techTracks[i]) {
                            found = true;
                            break;
                        }
                        if (!found) removeTracks.push(techTracks[i]);
                    }
                    while (removeTracks.length) techTracks.removeTrack(removeTracks.shift());
                };
                this[props.getterName + "Listeners_"] = listeners;
                Object.keys(listeners).forEach((eventName => {
                    const listener = listeners[eventName];
                    elTracks.addEventListener(eventName, listener);
                    this.on("dispose", (e => elTracks.removeEventListener(eventName, listener)));
                }));
                this.on("loadstart", removeOldTracks);
                this.on("dispose", (e => this.off("loadstart", removeOldTracks)));
            }
            proxyNativeTracks_() {
                NORMAL.names.forEach((name => {
                    this.proxyNativeTracksForType_(name);
                }));
            }
            createEl() {
                let el = this.options_.tag;
                if (!el || !(this.options_.playerElIngest || this.movingMediaElementInDOM)) {
                    if (el) {
                        const clone = el.cloneNode(true);
                        if (el.parentNode) el.parentNode.insertBefore(clone, el);
                        Html5.disposeMediaElement(el);
                        el = clone;
                    } else {
                        el = document_default().createElement("video");
                        const tagAttributes = this.options_.tag && getAttributes(this.options_.tag);
                        const attributes = merge$1({}, tagAttributes);
                        if (!TOUCH_ENABLED || this.options_.nativeControlsForTouch !== true) delete attributes.controls;
                        setAttributes(el, Object.assign(attributes, {
                            id: this.options_.techId,
                            class: "vjs-tech"
                        }));
                    }
                    el.playerId = this.options_.playerId;
                }
                if (typeof this.options_.preload !== "undefined") setAttribute(el, "preload", this.options_.preload);
                if (this.options_.disablePictureInPicture !== void 0) el.disablePictureInPicture = this.options_.disablePictureInPicture;
                const settingsAttrs = [ "loop", "muted", "playsinline", "autoplay" ];
                for (let i = 0; i < settingsAttrs.length; i++) {
                    const attr = settingsAttrs[i];
                    const value = this.options_[attr];
                    if (typeof value !== "undefined") {
                        if (value) setAttribute(el, attr, attr); else removeAttribute(el, attr);
                        el[attr] = value;
                    }
                }
                return el;
            }
            handleLateInit_(el) {
                if (el.networkState === 0 || el.networkState === 3) return;
                if (el.readyState === 0) {
                    let loadstartFired = false;
                    const setLoadstartFired = function() {
                        loadstartFired = true;
                    };
                    this.on("loadstart", setLoadstartFired);
                    const triggerLoadstart = function() {
                        if (!loadstartFired) this.trigger("loadstart");
                    };
                    this.on("loadedmetadata", triggerLoadstart);
                    this.ready((function() {
                        this.off("loadstart", setLoadstartFired);
                        this.off("loadedmetadata", triggerLoadstart);
                        if (!loadstartFired) this.trigger("loadstart");
                    }));
                    return;
                }
                const eventsToTrigger = [ "loadstart" ];
                eventsToTrigger.push("loadedmetadata");
                if (el.readyState >= 2) eventsToTrigger.push("loadeddata");
                if (el.readyState >= 3) eventsToTrigger.push("canplay");
                if (el.readyState >= 4) eventsToTrigger.push("canplaythrough");
                this.ready((function() {
                    eventsToTrigger.forEach((function(type) {
                        this.trigger(type);
                    }), this);
                }));
            }
            setScrubbing(isScrubbing) {
                this.isScrubbing_ = isScrubbing;
            }
            scrubbing() {
                return this.isScrubbing_;
            }
            setCurrentTime(seconds) {
                try {
                    if (this.isScrubbing_ && this.el_.fastSeek && IS_ANY_SAFARI) this.el_.fastSeek(seconds); else this.el_.currentTime = seconds;
                } catch (e) {
                    log$1(e, "Video is not ready. (Video.js)");
                }
            }
            duration() {
                if (this.el_.duration === 1 / 0 && IS_ANDROID && IS_CHROME && this.el_.currentTime === 0) {
                    const checkProgress = () => {
                        if (this.el_.currentTime > 0) {
                            if (this.el_.duration === 1 / 0) this.trigger("durationchange");
                            this.off("timeupdate", checkProgress);
                        }
                    };
                    this.on("timeupdate", checkProgress);
                    return NaN;
                }
                return this.el_.duration || NaN;
            }
            width() {
                return this.el_.offsetWidth;
            }
            height() {
                return this.el_.offsetHeight;
            }
            proxyWebkitFullscreen_() {
                if (!("webkitDisplayingFullscreen" in this.el_)) return;
                const endFn = function() {
                    this.trigger("fullscreenchange", {
                        isFullscreen: false
                    });
                    if (this.el_.controls && !this.options_.nativeControlsForTouch && this.controls()) this.el_.controls = false;
                };
                const beginFn = function() {
                    if ("webkitPresentationMode" in this.el_ && this.el_.webkitPresentationMode !== "picture-in-picture") {
                        this.one("webkitendfullscreen", endFn);
                        this.trigger("fullscreenchange", {
                            isFullscreen: true,
                            nativeIOSFullscreen: true
                        });
                    }
                };
                this.on("webkitbeginfullscreen", beginFn);
                this.on("dispose", (() => {
                    this.off("webkitbeginfullscreen", beginFn);
                    this.off("webkitendfullscreen", endFn);
                }));
            }
            supportsFullScreen() {
                return typeof this.el_.webkitEnterFullScreen === "function";
            }
            enterFullScreen() {
                const video = this.el_;
                if (video.paused && video.networkState <= video.HAVE_METADATA) {
                    silencePromise(this.el_.play());
                    this.setTimeout((function() {
                        video.pause();
                        try {
                            video.webkitEnterFullScreen();
                        } catch (e) {
                            this.trigger("fullscreenerror", e);
                        }
                    }), 0);
                } else try {
                    video.webkitEnterFullScreen();
                } catch (e) {
                    this.trigger("fullscreenerror", e);
                }
            }
            exitFullScreen() {
                if (!this.el_.webkitDisplayingFullscreen) {
                    this.trigger("fullscreenerror", new Error("The video is not fullscreen"));
                    return;
                }
                this.el_.webkitExitFullScreen();
            }
            requestPictureInPicture() {
                return this.el_.requestPictureInPicture();
            }
            requestVideoFrameCallback(cb) {
                if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) return this.el_.requestVideoFrameCallback(cb);
                return super.requestVideoFrameCallback(cb);
            }
            cancelVideoFrameCallback(id) {
                if (this.featuresVideoFrameCallback && !this.el_.webkitKeys) this.el_.cancelVideoFrameCallback(id); else super.cancelVideoFrameCallback(id);
            }
            src(src) {
                if (src === void 0) return this.el_.src;
                this.setSrc(src);
            }
            reset() {
                Html5.resetMediaElement(this.el_);
            }
            currentSrc() {
                if (this.currentSource_) return this.currentSource_.src;
                return this.el_.currentSrc;
            }
            setControls(val) {
                this.el_.controls = !!val;
            }
            addTextTrack(kind, label, language) {
                if (!this.featuresNativeTextTracks) return super.addTextTrack(kind, label, language);
                return this.el_.addTextTrack(kind, label, language);
            }
            createRemoteTextTrack(options) {
                if (!this.featuresNativeTextTracks) return super.createRemoteTextTrack(options);
                const htmlTrackElement = document_default().createElement("track");
                if (options.kind) htmlTrackElement.kind = options.kind;
                if (options.label) htmlTrackElement.label = options.label;
                if (options.language || options.srclang) htmlTrackElement.srclang = options.language || options.srclang;
                if (options.default) htmlTrackElement.default = options.default;
                if (options.id) htmlTrackElement.id = options.id;
                if (options.src) htmlTrackElement.src = options.src;
                return htmlTrackElement;
            }
            addRemoteTextTrack(options, manualCleanup) {
                const htmlTrackElement = super.addRemoteTextTrack(options, manualCleanup);
                if (this.featuresNativeTextTracks) this.el().appendChild(htmlTrackElement);
                return htmlTrackElement;
            }
            removeRemoteTextTrack(track) {
                super.removeRemoteTextTrack(track);
                if (this.featuresNativeTextTracks) {
                    const tracks = this.$$("track");
                    let i = tracks.length;
                    while (i--) if (track === tracks[i] || track === tracks[i].track) this.el().removeChild(tracks[i]);
                }
            }
            getVideoPlaybackQuality() {
                if (typeof this.el().getVideoPlaybackQuality === "function") return this.el().getVideoPlaybackQuality();
                const videoPlaybackQuality = {};
                if (typeof this.el().webkitDroppedFrameCount !== "undefined" && typeof this.el().webkitDecodedFrameCount !== "undefined") {
                    videoPlaybackQuality.droppedVideoFrames = this.el().webkitDroppedFrameCount;
                    videoPlaybackQuality.totalVideoFrames = this.el().webkitDecodedFrameCount;
                }
                if (window_default().performance) videoPlaybackQuality.creationTime = window_default().performance.now();
                return videoPlaybackQuality;
            }
        }
        defineLazyProperty(Html5, "TEST_VID", (function() {
            if (!isReal()) return;
            const video = document_default().createElement("video");
            const track = document_default().createElement("track");
            track.kind = "captions";
            track.srclang = "en";
            track.label = "English";
            video.appendChild(track);
            return video;
        }));
        Html5.isSupported = function() {
            try {
                Html5.TEST_VID.volume = .5;
            } catch (e) {
                return false;
            }
            return !!(Html5.TEST_VID && Html5.TEST_VID.canPlayType);
        };
        Html5.canPlayType = function(type) {
            return Html5.TEST_VID.canPlayType(type);
        };
        Html5.canPlaySource = function(srcObj, options) {
            return Html5.canPlayType(srcObj.type);
        };
        Html5.canControlVolume = function() {
            try {
                const volume = Html5.TEST_VID.volume;
                Html5.TEST_VID.volume = volume / 2 + .1;
                const canControl = volume !== Html5.TEST_VID.volume;
                if (canControl && IS_IOS) {
                    window_default().setTimeout((() => {
                        if (Html5 && Html5.prototype) Html5.prototype.featuresVolumeControl = volume !== Html5.TEST_VID.volume;
                    }));
                    return false;
                }
                return canControl;
            } catch (e) {
                return false;
            }
        };
        Html5.canMuteVolume = function() {
            try {
                const muted = Html5.TEST_VID.muted;
                Html5.TEST_VID.muted = !muted;
                if (Html5.TEST_VID.muted) setAttribute(Html5.TEST_VID, "muted", "muted"); else removeAttribute(Html5.TEST_VID, "muted", "muted");
                return muted !== Html5.TEST_VID.muted;
            } catch (e) {
                return false;
            }
        };
        Html5.canControlPlaybackRate = function() {
            if (IS_ANDROID && IS_CHROME && CHROME_VERSION < 58) return false;
            try {
                const playbackRate = Html5.TEST_VID.playbackRate;
                Html5.TEST_VID.playbackRate = playbackRate / 2 + .1;
                return playbackRate !== Html5.TEST_VID.playbackRate;
            } catch (e) {
                return false;
            }
        };
        Html5.canOverrideAttributes = function() {
            try {
                const noop = () => {};
                Object.defineProperty(document_default().createElement("video"), "src", {
                    get: noop,
                    set: noop
                });
                Object.defineProperty(document_default().createElement("audio"), "src", {
                    get: noop,
                    set: noop
                });
                Object.defineProperty(document_default().createElement("video"), "innerHTML", {
                    get: noop,
                    set: noop
                });
                Object.defineProperty(document_default().createElement("audio"), "innerHTML", {
                    get: noop,
                    set: noop
                });
            } catch (e) {
                return false;
            }
            return true;
        };
        Html5.supportsNativeTextTracks = function() {
            return IS_ANY_SAFARI || IS_IOS && IS_CHROME;
        };
        Html5.supportsNativeVideoTracks = function() {
            return !!(Html5.TEST_VID && Html5.TEST_VID.videoTracks);
        };
        Html5.supportsNativeAudioTracks = function() {
            return !!(Html5.TEST_VID && Html5.TEST_VID.audioTracks);
        };
        Html5.Events = [ "loadstart", "suspend", "abort", "error", "emptied", "stalled", "loadedmetadata", "loadeddata", "canplay", "canplaythrough", "playing", "waiting", "seeking", "seeked", "ended", "durationchange", "timeupdate", "progress", "play", "pause", "ratechange", "resize", "volumechange" ];
        [ [ "featuresMuteControl", "canMuteVolume" ], [ "featuresPlaybackRate", "canControlPlaybackRate" ], [ "featuresSourceset", "canOverrideAttributes" ], [ "featuresNativeTextTracks", "supportsNativeTextTracks" ], [ "featuresNativeVideoTracks", "supportsNativeVideoTracks" ], [ "featuresNativeAudioTracks", "supportsNativeAudioTracks" ] ].forEach((function([key, fn]) {
            defineLazyProperty(Html5.prototype, key, (() => Html5[fn]()), true);
        }));
        Html5.prototype.featuresVolumeControl = Html5.canControlVolume();
        Html5.prototype.movingMediaElementInDOM = !IS_IOS;
        Html5.prototype.featuresFullscreenResize = true;
        Html5.prototype.featuresProgressEvents = true;
        Html5.prototype.featuresTimeupdateEvents = true;
        Html5.prototype.featuresVideoFrameCallback = !!(Html5.TEST_VID && Html5.TEST_VID.requestVideoFrameCallback);
        Html5.disposeMediaElement = function(el) {
            if (!el) return;
            if (el.parentNode) el.parentNode.removeChild(el);
            while (el.hasChildNodes()) el.removeChild(el.firstChild);
            el.removeAttribute("src");
            if (typeof el.load === "function") (function() {
                try {
                    el.load();
                } catch (e) {}
            })();
        };
        Html5.resetMediaElement = function(el) {
            if (!el) return;
            const sources = el.querySelectorAll("source");
            let i = sources.length;
            while (i--) el.removeChild(sources[i]);
            el.removeAttribute("src");
            if (typeof el.load === "function") (function() {
                try {
                    el.load();
                } catch (e) {}
            })();
        };
        [ "muted", "defaultMuted", "autoplay", "controls", "loop", "playsinline" ].forEach((function(prop) {
            Html5.prototype[prop] = function() {
                return this.el_[prop] || this.el_.hasAttribute(prop);
            };
        }));
        [ "muted", "defaultMuted", "autoplay", "loop", "playsinline" ].forEach((function(prop) {
            Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
                this.el_[prop] = v;
                if (v) this.el_.setAttribute(prop, prop); else this.el_.removeAttribute(prop);
            };
        }));
        [ "paused", "currentTime", "buffered", "volume", "poster", "preload", "error", "seeking", "seekable", "ended", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "played", "networkState", "readyState", "videoWidth", "videoHeight", "crossOrigin" ].forEach((function(prop) {
            Html5.prototype[prop] = function() {
                return this.el_[prop];
            };
        }));
        [ "volume", "src", "poster", "preload", "playbackRate", "defaultPlaybackRate", "disablePictureInPicture", "crossOrigin" ].forEach((function(prop) {
            Html5.prototype["set" + toTitleCase$1(prop)] = function(v) {
                this.el_[prop] = v;
            };
        }));
        [ "pause", "load", "play" ].forEach((function(prop) {
            Html5.prototype[prop] = function() {
                return this.el_[prop]();
            };
        }));
        Tech.withSourceHandlers(Html5);
        Html5.nativeSourceHandler = {};
        Html5.nativeSourceHandler.canPlayType = function(type) {
            try {
                return Html5.TEST_VID.canPlayType(type);
            } catch (e) {
                return "";
            }
        };
        Html5.nativeSourceHandler.canHandleSource = function(source, options) {
            if (source.type) return Html5.nativeSourceHandler.canPlayType(source.type); else if (source.src) {
                const ext = getFileExtension(source.src);
                return Html5.nativeSourceHandler.canPlayType(`video/${ext}`);
            }
            return "";
        };
        Html5.nativeSourceHandler.handleSource = function(source, tech, options) {
            tech.setSrc(source.src);
        };
        Html5.nativeSourceHandler.dispose = function() {};
        Html5.registerSourceHandler(Html5.nativeSourceHandler);
        Tech.registerTech("Html5", Html5);
        const TECH_EVENTS_RETRIGGER = [ "progress", "abort", "suspend", "emptied", "stalled", "loadedmetadata", "loadeddata", "timeupdate", "resize", "volumechange", "texttrackchange" ];
        const TECH_EVENTS_QUEUE = {
            canplay: "CanPlay",
            canplaythrough: "CanPlayThrough",
            playing: "Playing",
            seeked: "Seeked"
        };
        const BREAKPOINT_ORDER = [ "tiny", "xsmall", "small", "medium", "large", "xlarge", "huge" ];
        const BREAKPOINT_CLASSES = {};
        BREAKPOINT_ORDER.forEach((k => {
            const v = k.charAt(0) === "x" ? `x-${k.substring(1)}` : k;
            BREAKPOINT_CLASSES[k] = `vjs-layout-${v}`;
        }));
        const DEFAULT_BREAKPOINTS = {
            tiny: 210,
            xsmall: 320,
            small: 425,
            medium: 768,
            large: 1440,
            xlarge: 2560,
            huge: 1 / 0
        };
        class Player extends Component$1 {
            constructor(tag, options, ready) {
                tag.id = tag.id || options.id || `vjs_video_${newGUID()}`;
                options = Object.assign(Player.getTagSettings(tag), options);
                options.initChildren = false;
                options.createEl = false;
                options.evented = false;
                options.reportTouchActivity = false;
                if (!options.language) {
                    const closest = tag.closest("[lang]");
                    if (closest) options.language = closest.getAttribute("lang");
                }
                super(null, options, ready);
                this.boundDocumentFullscreenChange_ = e => this.documentFullscreenChange_(e);
                this.boundFullWindowOnEscKey_ = e => this.fullWindowOnEscKey(e);
                this.boundUpdateStyleEl_ = e => this.updateStyleEl_(e);
                this.boundApplyInitTime_ = e => this.applyInitTime_(e);
                this.boundUpdateCurrentBreakpoint_ = e => this.updateCurrentBreakpoint_(e);
                this.boundHandleTechClick_ = e => this.handleTechClick_(e);
                this.boundHandleTechDoubleClick_ = e => this.handleTechDoubleClick_(e);
                this.boundHandleTechTouchStart_ = e => this.handleTechTouchStart_(e);
                this.boundHandleTechTouchMove_ = e => this.handleTechTouchMove_(e);
                this.boundHandleTechTouchEnd_ = e => this.handleTechTouchEnd_(e);
                this.boundHandleTechTap_ = e => this.handleTechTap_(e);
                this.isFullscreen_ = false;
                this.log = createLogger(this.id_);
                this.fsApi_ = FullscreenApi;
                this.isPosterFromTech_ = false;
                this.queuedCallbacks_ = [];
                this.isReady_ = false;
                this.hasStarted_ = false;
                this.userActive_ = false;
                this.debugEnabled_ = false;
                this.audioOnlyMode_ = false;
                this.audioPosterMode_ = false;
                this.audioOnlyCache_ = {
                    playerHeight: null,
                    hiddenChildren: []
                };
                if (!this.options_ || !this.options_.techOrder || !this.options_.techOrder.length) throw new Error("No techOrder specified. Did you overwrite " + "videojs.options instead of just changing the " + "properties you want to override?");
                this.tag = tag;
                this.tagAttributes = tag && getAttributes(tag);
                this.language(this.options_.language);
                if (options.languages) {
                    const languagesToLower = {};
                    Object.getOwnPropertyNames(options.languages).forEach((function(name) {
                        languagesToLower[name.toLowerCase()] = options.languages[name];
                    }));
                    this.languages_ = languagesToLower;
                } else this.languages_ = Player.prototype.options_.languages;
                this.resetCache_();
                this.poster_ = options.poster || "";
                this.controls_ = !!options.controls;
                tag.controls = false;
                tag.removeAttribute("controls");
                this.changingSrc_ = false;
                this.playCallbacks_ = [];
                this.playTerminatedQueue_ = [];
                if (tag.hasAttribute("autoplay")) this.autoplay(true); else this.autoplay(this.options_.autoplay);
                if (options.plugins) Object.keys(options.plugins).forEach((name => {
                    if (typeof this[name] !== "function") throw new Error(`plugin "${name}" does not exist`);
                }));
                this.scrubbing_ = false;
                this.el_ = this.createEl();
                evented(this, {
                    eventBusKey: "el_"
                });
                if (this.fsApi_.requestFullscreen) {
                    on(document_default(), this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
                    this.on(this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
                }
                if (this.fluid_) this.on([ "playerreset", "resize" ], this.boundUpdateStyleEl_);
                const playerOptionsCopy = merge$1(this.options_);
                if (options.plugins) Object.keys(options.plugins).forEach((name => {
                    this[name](options.plugins[name]);
                }));
                if (options.debug) this.debug(true);
                this.options_.playerOptions = playerOptionsCopy;
                this.middleware_ = [];
                this.playbackRates(options.playbackRates);
                this.initChildren();
                this.isAudio(tag.nodeName.toLowerCase() === "audio");
                if (this.controls()) this.addClass("vjs-controls-enabled"); else this.addClass("vjs-controls-disabled");
                this.el_.setAttribute("role", "region");
                if (this.isAudio()) this.el_.setAttribute("aria-label", this.localize("Audio Player")); else this.el_.setAttribute("aria-label", this.localize("Video Player"));
                if (this.isAudio()) this.addClass("vjs-audio");
                if (TOUCH_ENABLED) this.addClass("vjs-touch-enabled");
                if (!IS_IOS) this.addClass("vjs-workinghover");
                Player.players[this.id_] = this;
                const majorVersion = version$6.split(".")[0];
                this.addClass(`vjs-v${majorVersion}`);
                this.userActive(true);
                this.reportUserActivity();
                this.one("play", (e => this.listenForUserActivity_(e)));
                this.on("keydown", (e => this.handleKeyDown(e)));
                this.on("languagechange", (e => this.handleLanguagechange(e)));
                this.breakpoints(this.options_.breakpoints);
                this.responsive(this.options_.responsive);
                this.on("ready", (() => {
                    this.audioPosterMode(this.options_.audioPosterMode);
                    this.audioOnlyMode(this.options_.audioOnlyMode);
                }));
            }
            dispose() {
                this.trigger("dispose");
                this.off("dispose");
                off(document_default(), this.fsApi_.fullscreenchange, this.boundDocumentFullscreenChange_);
                off(document_default(), "keydown", this.boundFullWindowOnEscKey_);
                if (this.styleEl_ && this.styleEl_.parentNode) {
                    this.styleEl_.parentNode.removeChild(this.styleEl_);
                    this.styleEl_ = null;
                }
                Player.players[this.id_] = null;
                if (this.tag && this.tag.player) this.tag.player = null;
                if (this.el_ && this.el_.player) this.el_.player = null;
                if (this.tech_) {
                    this.tech_.dispose();
                    this.isPosterFromTech_ = false;
                    this.poster_ = "";
                }
                if (this.playerElIngest_) this.playerElIngest_ = null;
                if (this.tag) this.tag = null;
                clearCacheForPlayer(this);
                ALL.names.forEach((name => {
                    const props = ALL[name];
                    const list = this[props.getterName]();
                    if (list && list.off) list.off();
                }));
                super.dispose({
                    restoreEl: this.options_.restoreEl
                });
            }
            createEl() {
                let tag = this.tag;
                let el;
                let playerElIngest = this.playerElIngest_ = tag.parentNode && tag.parentNode.hasAttribute && tag.parentNode.hasAttribute("data-vjs-player");
                const divEmbed = this.tag.tagName.toLowerCase() === "video-js";
                if (playerElIngest) el = this.el_ = tag.parentNode; else if (!divEmbed) el = this.el_ = super.createEl("div");
                const attrs = getAttributes(tag);
                if (divEmbed) {
                    el = this.el_ = tag;
                    tag = this.tag = document_default().createElement("video");
                    while (el.children.length) tag.appendChild(el.firstChild);
                    if (!hasClass(el, "video-js")) addClass(el, "video-js");
                    el.appendChild(tag);
                    playerElIngest = this.playerElIngest_ = el;
                    Object.keys(el).forEach((k => {
                        try {
                            tag[k] = el[k];
                        } catch (e) {}
                    }));
                }
                tag.setAttribute("tabindex", "-1");
                attrs.tabindex = "-1";
                if (IS_CHROME && IS_WINDOWS) {
                    tag.setAttribute("role", "application");
                    attrs.role = "application";
                }
                tag.removeAttribute("width");
                tag.removeAttribute("height");
                if ("width" in attrs) delete attrs.width;
                if ("height" in attrs) delete attrs.height;
                Object.getOwnPropertyNames(attrs).forEach((function(attr) {
                    if (!(divEmbed && attr === "class")) el.setAttribute(attr, attrs[attr]);
                    if (divEmbed) tag.setAttribute(attr, attrs[attr]);
                }));
                tag.playerId = tag.id;
                tag.id += "_html5_api";
                tag.className = "vjs-tech";
                tag.player = el.player = this;
                this.addClass("vjs-paused");
                if (window_default().VIDEOJS_NO_DYNAMIC_STYLE !== true) {
                    this.styleEl_ = createStyleElement("vjs-styles-dimensions");
                    const defaultsStyleEl = video_es_$(".vjs-styles-defaults");
                    const head = video_es_$("head");
                    head.insertBefore(this.styleEl_, defaultsStyleEl ? defaultsStyleEl.nextSibling : head.firstChild);
                }
                this.fill_ = false;
                this.fluid_ = false;
                this.width(this.options_.width);
                this.height(this.options_.height);
                this.fill(this.options_.fill);
                this.fluid(this.options_.fluid);
                this.aspectRatio(this.options_.aspectRatio);
                this.crossOrigin(this.options_.crossOrigin || this.options_.crossorigin);
                const links = tag.getElementsByTagName("a");
                for (let i = 0; i < links.length; i++) {
                    const linkEl = links.item(i);
                    addClass(linkEl, "vjs-hidden");
                    linkEl.setAttribute("hidden", "hidden");
                }
                tag.initNetworkState_ = tag.networkState;
                if (tag.parentNode && !playerElIngest) tag.parentNode.insertBefore(el, tag);
                prependTo(tag, el);
                this.children_.unshift(tag);
                this.el_.setAttribute("lang", this.language_);
                this.el_.setAttribute("translate", "no");
                this.el_ = el;
                return el;
            }
            crossOrigin(value) {
                if (typeof value === "undefined") return this.techGet_("crossOrigin");
                if (value !== null && value !== "anonymous" && value !== "use-credentials") {
                    log$1.warn(`crossOrigin must be null,  "anonymous" or "use-credentials", given "${value}"`);
                    return;
                }
                this.techCall_("setCrossOrigin", value);
                if (this.posterImage) this.posterImage.crossOrigin(value);
                return;
            }
            width(value) {
                return this.dimension("width", value);
            }
            height(value) {
                return this.dimension("height", value);
            }
            dimension(dimension, value) {
                const privDimension = dimension + "_";
                if (value === void 0) return this[privDimension] || 0;
                if (value === "" || value === "auto") {
                    this[privDimension] = void 0;
                    this.updateStyleEl_();
                    return;
                }
                const parsedVal = parseFloat(value);
                if (isNaN(parsedVal)) {
                    log$1.error(`Improper value "${value}" supplied for for ${dimension}`);
                    return;
                }
                this[privDimension] = parsedVal;
                this.updateStyleEl_();
            }
            fluid(bool) {
                if (bool === void 0) return !!this.fluid_;
                this.fluid_ = !!bool;
                if (isEvented(this)) this.off([ "playerreset", "resize" ], this.boundUpdateStyleEl_);
                if (bool) {
                    this.addClass("vjs-fluid");
                    this.fill(false);
                    addEventedCallback(this, (() => {
                        this.on([ "playerreset", "resize" ], this.boundUpdateStyleEl_);
                    }));
                } else this.removeClass("vjs-fluid");
                this.updateStyleEl_();
            }
            fill(bool) {
                if (bool === void 0) return !!this.fill_;
                this.fill_ = !!bool;
                if (bool) {
                    this.addClass("vjs-fill");
                    this.fluid(false);
                } else this.removeClass("vjs-fill");
            }
            aspectRatio(ratio) {
                if (ratio === void 0) return this.aspectRatio_;
                if (!/^\d+\:\d+$/.test(ratio)) throw new Error("Improper value supplied for aspect ratio. The format should be width:height, for example 16:9.");
                this.aspectRatio_ = ratio;
                this.fluid(true);
                this.updateStyleEl_();
            }
            updateStyleEl_() {
                if (window_default().VIDEOJS_NO_DYNAMIC_STYLE === true) {
                    const width = typeof this.width_ === "number" ? this.width_ : this.options_.width;
                    const height = typeof this.height_ === "number" ? this.height_ : this.options_.height;
                    const techEl = this.tech_ && this.tech_.el();
                    if (techEl) {
                        if (width >= 0) techEl.width = width;
                        if (height >= 0) techEl.height = height;
                    }
                    return;
                }
                let width;
                let height;
                let aspectRatio;
                let idClass;
                if (this.aspectRatio_ !== void 0 && this.aspectRatio_ !== "auto") aspectRatio = this.aspectRatio_; else if (this.videoWidth() > 0) aspectRatio = this.videoWidth() + ":" + this.videoHeight(); else aspectRatio = "16:9";
                const ratioParts = aspectRatio.split(":");
                const ratioMultiplier = ratioParts[1] / ratioParts[0];
                if (this.width_ !== void 0) width = this.width_; else if (this.height_ !== void 0) width = this.height_ / ratioMultiplier; else width = this.videoWidth() || 300;
                if (this.height_ !== void 0) height = this.height_; else height = width * ratioMultiplier;
                if (/^[^a-zA-Z]/.test(this.id())) idClass = "dimensions-" + this.id(); else idClass = this.id() + "-dimensions";
                this.addClass(idClass);
                setTextContent(this.styleEl_, `\n      .${idClass} {\n        width: ${width}px;\n        height: ${height}px;\n      }\n\n      .${idClass}.vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: ${ratioMultiplier * 100}%;\n      }\n    `);
            }
            loadTech_(techName, source) {
                if (this.tech_) this.unloadTech_();
                const titleTechName = toTitleCase$1(techName);
                const camelTechName = techName.charAt(0).toLowerCase() + techName.slice(1);
                if (titleTechName !== "Html5" && this.tag) {
                    Tech.getTech("Html5").disposeMediaElement(this.tag);
                    this.tag.player = null;
                    this.tag = null;
                }
                this.techName_ = titleTechName;
                this.isReady_ = false;
                let autoplay = this.autoplay();
                if (typeof this.autoplay() === "string" || this.autoplay() === true && this.options_.normalizeAutoplay) autoplay = false;
                const techOptions = {
                    source,
                    autoplay,
                    nativeControlsForTouch: this.options_.nativeControlsForTouch,
                    playerId: this.id(),
                    techId: `${this.id()}_${camelTechName}_api`,
                    playsinline: this.options_.playsinline,
                    preload: this.options_.preload,
                    loop: this.options_.loop,
                    disablePictureInPicture: this.options_.disablePictureInPicture,
                    muted: this.options_.muted,
                    poster: this.poster(),
                    language: this.language(),
                    playerElIngest: this.playerElIngest_ || false,
                    "vtt.js": this.options_["vtt.js"],
                    canOverridePoster: !!this.options_.techCanOverridePoster,
                    enableSourceset: this.options_.enableSourceset
                };
                ALL.names.forEach((name => {
                    const props = ALL[name];
                    techOptions[props.getterName] = this[props.privateName];
                }));
                Object.assign(techOptions, this.options_[titleTechName]);
                Object.assign(techOptions, this.options_[camelTechName]);
                Object.assign(techOptions, this.options_[techName.toLowerCase()]);
                if (this.tag) techOptions.tag = this.tag;
                if (source && source.src === this.cache_.src && this.cache_.currentTime > 0) techOptions.startTime = this.cache_.currentTime;
                const TechClass = Tech.getTech(techName);
                if (!TechClass) throw new Error(`No Tech named '${titleTechName}' exists! '${titleTechName}' should be registered using videojs.registerTech()'`);
                this.tech_ = new TechClass(techOptions);
                this.tech_.ready(bind_(this, this.handleTechReady_), true);
                textTrackConverter.jsonToTextTracks(this.textTracksJson_ || [], this.tech_);
                TECH_EVENTS_RETRIGGER.forEach((event => {
                    this.on(this.tech_, event, (e => this[`handleTech${toTitleCase$1(event)}_`](e)));
                }));
                Object.keys(TECH_EVENTS_QUEUE).forEach((event => {
                    this.on(this.tech_, event, (eventObj => {
                        if (this.tech_.playbackRate() === 0 && this.tech_.seeking()) {
                            this.queuedCallbacks_.push({
                                callback: this[`handleTech${TECH_EVENTS_QUEUE[event]}_`].bind(this),
                                event: eventObj
                            });
                            return;
                        }
                        this[`handleTech${TECH_EVENTS_QUEUE[event]}_`](eventObj);
                    }));
                }));
                this.on(this.tech_, "loadstart", (e => this.handleTechLoadStart_(e)));
                this.on(this.tech_, "sourceset", (e => this.handleTechSourceset_(e)));
                this.on(this.tech_, "waiting", (e => this.handleTechWaiting_(e)));
                this.on(this.tech_, "ended", (e => this.handleTechEnded_(e)));
                this.on(this.tech_, "seeking", (e => this.handleTechSeeking_(e)));
                this.on(this.tech_, "play", (e => this.handleTechPlay_(e)));
                this.on(this.tech_, "pause", (e => this.handleTechPause_(e)));
                this.on(this.tech_, "durationchange", (e => this.handleTechDurationChange_(e)));
                this.on(this.tech_, "fullscreenchange", ((e, data) => this.handleTechFullscreenChange_(e, data)));
                this.on(this.tech_, "fullscreenerror", ((e, err) => this.handleTechFullscreenError_(e, err)));
                this.on(this.tech_, "enterpictureinpicture", (e => this.handleTechEnterPictureInPicture_(e)));
                this.on(this.tech_, "leavepictureinpicture", (e => this.handleTechLeavePictureInPicture_(e)));
                this.on(this.tech_, "error", (e => this.handleTechError_(e)));
                this.on(this.tech_, "posterchange", (e => this.handleTechPosterChange_(e)));
                this.on(this.tech_, "textdata", (e => this.handleTechTextData_(e)));
                this.on(this.tech_, "ratechange", (e => this.handleTechRateChange_(e)));
                this.on(this.tech_, "loadedmetadata", this.boundUpdateStyleEl_);
                this.usingNativeControls(this.techGet_("controls"));
                if (this.controls() && !this.usingNativeControls()) this.addTechControlsListeners_();
                if (this.tech_.el().parentNode !== this.el() && (titleTechName !== "Html5" || !this.tag)) prependTo(this.tech_.el(), this.el());
                if (this.tag) {
                    this.tag.player = null;
                    this.tag = null;
                }
            }
            unloadTech_() {
                ALL.names.forEach((name => {
                    const props = ALL[name];
                    this[props.privateName] = this[props.getterName]();
                }));
                this.textTracksJson_ = textTrackConverter.textTracksToJson(this.tech_);
                this.isReady_ = false;
                this.tech_.dispose();
                this.tech_ = false;
                if (this.isPosterFromTech_) {
                    this.poster_ = "";
                    this.trigger("posterchange");
                }
                this.isPosterFromTech_ = false;
            }
            tech(safety) {
                if (safety === void 0) log$1.warn("Using the tech directly can be dangerous. I hope you know what you're doing.\n" + "See https://github.com/videojs/video.js/issues/2617 for more info.\n");
                return this.tech_;
            }
            addTechControlsListeners_() {
                this.removeTechControlsListeners_();
                this.on(this.tech_, "click", this.boundHandleTechClick_);
                this.on(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
                this.on(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
                this.on(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
                this.on(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
                this.on(this.tech_, "tap", this.boundHandleTechTap_);
            }
            removeTechControlsListeners_() {
                this.off(this.tech_, "tap", this.boundHandleTechTap_);
                this.off(this.tech_, "touchstart", this.boundHandleTechTouchStart_);
                this.off(this.tech_, "touchmove", this.boundHandleTechTouchMove_);
                this.off(this.tech_, "touchend", this.boundHandleTechTouchEnd_);
                this.off(this.tech_, "click", this.boundHandleTechClick_);
                this.off(this.tech_, "dblclick", this.boundHandleTechDoubleClick_);
            }
            handleTechReady_() {
                this.triggerReady();
                if (this.cache_.volume) this.techCall_("setVolume", this.cache_.volume);
                this.handleTechPosterChange_();
                this.handleTechDurationChange_();
            }
            handleTechLoadStart_() {
                this.removeClass("vjs-ended", "vjs-seeking");
                this.error(null);
                this.handleTechDurationChange_();
                if (!this.paused()) this.trigger("loadstart"); else {
                    this.hasStarted(false);
                    this.trigger("loadstart");
                }
                this.manualAutoplay_(this.autoplay() === true && this.options_.normalizeAutoplay ? "play" : this.autoplay());
            }
            manualAutoplay_(type) {
                if (!this.tech_ || typeof type !== "string") return;
                const resolveMuted = () => {
                    const previouslyMuted = this.muted();
                    this.muted(true);
                    const restoreMuted = () => {
                        this.muted(previouslyMuted);
                    };
                    this.playTerminatedQueue_.push(restoreMuted);
                    const mutedPromise = this.play();
                    if (!isPromise(mutedPromise)) return;
                    return mutedPromise.catch((err => {
                        restoreMuted();
                        throw new Error(`Rejection at manualAutoplay. Restoring muted value. ${err ? err : ""}`);
                    }));
                };
                let promise;
                if (type === "any" && !this.muted()) {
                    promise = this.play();
                    if (isPromise(promise)) promise = promise.catch(resolveMuted);
                } else if (type === "muted" && !this.muted()) promise = resolveMuted(); else promise = this.play();
                if (!isPromise(promise)) return;
                return promise.then((() => {
                    this.trigger({
                        type: "autoplay-success",
                        autoplay: type
                    });
                })).catch((() => {
                    this.trigger({
                        type: "autoplay-failure",
                        autoplay: type
                    });
                }));
            }
            updateSourceCaches_(srcObj = "") {
                let src = srcObj;
                let type = "";
                if (typeof src !== "string") {
                    src = srcObj.src;
                    type = srcObj.type;
                }
                this.cache_.source = this.cache_.source || {};
                this.cache_.sources = this.cache_.sources || [];
                if (src && !type) type = findMimetype(this, src);
                this.cache_.source = merge$1({}, srcObj, {
                    src,
                    type
                });
                const matchingSources = this.cache_.sources.filter((s => s.src && s.src === src));
                const sourceElSources = [];
                const sourceEls = this.$$("source");
                const matchingSourceEls = [];
                for (let i = 0; i < sourceEls.length; i++) {
                    const sourceObj = getAttributes(sourceEls[i]);
                    sourceElSources.push(sourceObj);
                    if (sourceObj.src && sourceObj.src === src) matchingSourceEls.push(sourceObj.src);
                }
                if (matchingSourceEls.length && !matchingSources.length) this.cache_.sources = sourceElSources; else if (!matchingSources.length) this.cache_.sources = [ this.cache_.source ];
                this.cache_.src = src;
            }
            handleTechSourceset_(event) {
                if (!this.changingSrc_) {
                    let updateSourceCaches = src => this.updateSourceCaches_(src);
                    const playerSrc = this.currentSource().src;
                    const eventSrc = event.src;
                    if (playerSrc && !/^blob:/.test(playerSrc) && /^blob:/.test(eventSrc)) if (!this.lastSource_ || this.lastSource_.tech !== eventSrc && this.lastSource_.player !== playerSrc) updateSourceCaches = () => {};
                    updateSourceCaches(eventSrc);
                    if (!event.src) this.tech_.any([ "sourceset", "loadstart" ], (e => {
                        if (e.type === "sourceset") return;
                        const techSrc = this.techGet("currentSrc");
                        this.lastSource_.tech = techSrc;
                        this.updateSourceCaches_(techSrc);
                    }));
                }
                this.lastSource_ = {
                    player: this.currentSource().src,
                    tech: event.src
                };
                this.trigger({
                    src: event.src,
                    type: "sourceset"
                });
            }
            hasStarted(request) {
                if (request === void 0) return this.hasStarted_;
                if (request === this.hasStarted_) return;
                this.hasStarted_ = request;
                if (this.hasStarted_) this.addClass("vjs-has-started"); else this.removeClass("vjs-has-started");
            }
            handleTechPlay_() {
                this.removeClass("vjs-ended", "vjs-paused");
                this.addClass("vjs-playing");
                this.hasStarted(true);
                this.trigger("play");
            }
            handleTechRateChange_() {
                if (this.tech_.playbackRate() > 0 && this.cache_.lastPlaybackRate === 0) {
                    this.queuedCallbacks_.forEach((queued => queued.callback(queued.event)));
                    this.queuedCallbacks_ = [];
                }
                this.cache_.lastPlaybackRate = this.tech_.playbackRate();
                this.trigger("ratechange");
            }
            handleTechWaiting_() {
                this.addClass("vjs-waiting");
                this.trigger("waiting");
                const timeWhenWaiting = this.currentTime();
                const timeUpdateListener = () => {
                    if (timeWhenWaiting !== this.currentTime()) {
                        this.removeClass("vjs-waiting");
                        this.off("timeupdate", timeUpdateListener);
                    }
                };
                this.on("timeupdate", timeUpdateListener);
            }
            handleTechCanPlay_() {
                this.removeClass("vjs-waiting");
                this.trigger("canplay");
            }
            handleTechCanPlayThrough_() {
                this.removeClass("vjs-waiting");
                this.trigger("canplaythrough");
            }
            handleTechPlaying_() {
                this.removeClass("vjs-waiting");
                this.trigger("playing");
            }
            handleTechSeeking_() {
                this.addClass("vjs-seeking");
                this.trigger("seeking");
            }
            handleTechSeeked_() {
                this.removeClass("vjs-seeking", "vjs-ended");
                this.trigger("seeked");
            }
            handleTechPause_() {
                this.removeClass("vjs-playing");
                this.addClass("vjs-paused");
                this.trigger("pause");
            }
            handleTechEnded_() {
                this.addClass("vjs-ended");
                this.removeClass("vjs-waiting");
                if (this.options_.loop) {
                    this.currentTime(0);
                    this.play();
                } else if (!this.paused()) this.pause();
                this.trigger("ended");
            }
            handleTechDurationChange_() {
                this.duration(this.techGet_("duration"));
            }
            handleTechClick_(event) {
                if (!this.controls_) return;
                if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.click === void 0 || this.options_.userActions.click !== false) if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.click === "function") this.options_.userActions.click.call(this, event); else if (this.paused()) silencePromise(this.play()); else this.pause();
            }
            handleTechDoubleClick_(event) {
                if (!this.controls_) return;
                const inAllowedEls = Array.prototype.some.call(this.$$(".vjs-control-bar, .vjs-modal-dialog"), (el => el.contains(event.target)));
                if (!inAllowedEls) if (this.options_ === void 0 || this.options_.userActions === void 0 || this.options_.userActions.doubleClick === void 0 || this.options_.userActions.doubleClick !== false) if (this.options_ !== void 0 && this.options_.userActions !== void 0 && typeof this.options_.userActions.doubleClick === "function") this.options_.userActions.doubleClick.call(this, event); else if (this.isFullscreen()) this.exitFullscreen(); else this.requestFullscreen();
            }
            handleTechTap_() {
                this.userActive(!this.userActive());
            }
            handleTechTouchStart_() {
                this.userWasActive = this.userActive();
            }
            handleTechTouchMove_() {
                if (this.userWasActive) this.reportUserActivity();
            }
            handleTechTouchEnd_(event) {
                if (event.cancelable) event.preventDefault();
            }
            toggleFullscreenClass_() {
                if (this.isFullscreen()) this.addClass("vjs-fullscreen"); else this.removeClass("vjs-fullscreen");
            }
            documentFullscreenChange_(e) {
                const targetPlayer = e.target.player;
                if (targetPlayer && targetPlayer !== this) return;
                const el = this.el();
                let isFs = document_default()[this.fsApi_.fullscreenElement] === el;
                if (!isFs && el.matches) isFs = el.matches(":" + this.fsApi_.fullscreen); else if (!isFs && el.msMatchesSelector) isFs = el.msMatchesSelector(":" + this.fsApi_.fullscreen);
                this.isFullscreen(isFs);
            }
            handleTechFullscreenChange_(event, data) {
                if (data) {
                    if (data.nativeIOSFullscreen) {
                        this.addClass("vjs-ios-native-fs");
                        this.tech_.one("webkitendfullscreen", (() => {
                            this.removeClass("vjs-ios-native-fs");
                        }));
                    }
                    this.isFullscreen(data.isFullscreen);
                }
            }
            handleTechFullscreenError_(event, err) {
                this.trigger("fullscreenerror", err);
            }
            togglePictureInPictureClass_() {
                if (this.isInPictureInPicture()) this.addClass("vjs-picture-in-picture"); else this.removeClass("vjs-picture-in-picture");
            }
            handleTechEnterPictureInPicture_(event) {
                this.isInPictureInPicture(true);
            }
            handleTechLeavePictureInPicture_(event) {
                this.isInPictureInPicture(false);
            }
            handleTechError_() {
                const error = this.tech_.error();
                this.error(error);
            }
            handleTechTextData_() {
                let data = null;
                if (arguments.length > 1) data = arguments[1];
                this.trigger("textdata", data);
            }
            getCache() {
                return this.cache_;
            }
            resetCache_() {
                this.cache_ = {
                    currentTime: 0,
                    initTime: 0,
                    inactivityTimeout: this.options_.inactivityTimeout,
                    duration: NaN,
                    lastVolume: 1,
                    lastPlaybackRate: this.defaultPlaybackRate(),
                    media: null,
                    src: "",
                    source: {},
                    sources: [],
                    playbackRates: [],
                    volume: 1
                };
            }
            techCall_(method, arg) {
                this.ready((function() {
                    if (method in allowedSetters) return set(this.middleware_, this.tech_, method, arg); else if (method in allowedMediators) return mediate(this.middleware_, this.tech_, method, arg);
                    try {
                        if (this.tech_) this.tech_[method](arg);
                    } catch (e) {
                        log$1(e);
                        throw e;
                    }
                }), true);
            }
            techGet_(method) {
                if (!this.tech_ || !this.tech_.isReady_) return;
                if (method in allowedGetters) return get(this.middleware_, this.tech_, method); else if (method in allowedMediators) return mediate(this.middleware_, this.tech_, method);
                try {
                    return this.tech_[method]();
                } catch (e) {
                    if (this.tech_[method] === void 0) {
                        log$1(`Video.js: ${method} method not defined for ${this.techName_} playback technology.`, e);
                        throw e;
                    }
                    if (e.name === "TypeError") {
                        log$1(`Video.js: ${method} unavailable on ${this.techName_} playback technology element.`, e);
                        this.tech_.isReady_ = false;
                        throw e;
                    }
                    log$1(e);
                    throw e;
                }
            }
            play() {
                return new Promise((resolve => {
                    this.play_(resolve);
                }));
            }
            play_(callback = silencePromise) {
                this.playCallbacks_.push(callback);
                const isSrcReady = Boolean(!this.changingSrc_ && (this.src() || this.currentSrc()));
                const isSafariOrIOS = Boolean(IS_ANY_SAFARI || IS_IOS);
                if (this.waitToPlay_) {
                    this.off([ "ready", "loadstart" ], this.waitToPlay_);
                    this.waitToPlay_ = null;
                }
                if (!this.isReady_ || !isSrcReady) {
                    this.waitToPlay_ = e => {
                        this.play_();
                    };
                    this.one([ "ready", "loadstart" ], this.waitToPlay_);
                    if (!isSrcReady && isSafariOrIOS) this.load();
                    return;
                }
                const val = this.techGet_("play");
                const isNativeReplay = isSafariOrIOS && this.hasClass("vjs-ended");
                if (isNativeReplay) this.resetProgressBar_();
                if (val === null) this.runPlayTerminatedQueue_(); else this.runPlayCallbacks_(val);
            }
            runPlayTerminatedQueue_() {
                const queue = this.playTerminatedQueue_.slice(0);
                this.playTerminatedQueue_ = [];
                queue.forEach((function(q) {
                    q();
                }));
            }
            runPlayCallbacks_(val) {
                const callbacks = this.playCallbacks_.slice(0);
                this.playCallbacks_ = [];
                this.playTerminatedQueue_ = [];
                callbacks.forEach((function(cb) {
                    cb(val);
                }));
            }
            pause() {
                this.techCall_("pause");
            }
            paused() {
                return this.techGet_("paused") === false ? false : true;
            }
            played() {
                return this.techGet_("played") || createTimeRanges$1(0, 0);
            }
            scrubbing(isScrubbing) {
                if (typeof isScrubbing === "undefined") return this.scrubbing_;
                this.scrubbing_ = !!isScrubbing;
                this.techCall_("setScrubbing", this.scrubbing_);
                if (isScrubbing) this.addClass("vjs-scrubbing"); else this.removeClass("vjs-scrubbing");
            }
            currentTime(seconds) {
                if (typeof seconds !== "undefined") {
                    if (seconds < 0) seconds = 0;
                    if (!this.isReady_ || this.changingSrc_ || !this.tech_ || !this.tech_.isReady_) {
                        this.cache_.initTime = seconds;
                        this.off("canplay", this.boundApplyInitTime_);
                        this.one("canplay", this.boundApplyInitTime_);
                        return;
                    }
                    this.techCall_("setCurrentTime", seconds);
                    this.cache_.initTime = 0;
                    return;
                }
                this.cache_.currentTime = this.techGet_("currentTime") || 0;
                return this.cache_.currentTime;
            }
            applyInitTime_() {
                this.currentTime(this.cache_.initTime);
            }
            duration(seconds) {
                if (seconds === void 0) return this.cache_.duration !== void 0 ? this.cache_.duration : NaN;
                seconds = parseFloat(seconds);
                if (seconds < 0) seconds = 1 / 0;
                if (seconds !== this.cache_.duration) {
                    this.cache_.duration = seconds;
                    if (seconds === 1 / 0) this.addClass("vjs-live"); else this.removeClass("vjs-live");
                    if (!isNaN(seconds)) this.trigger("durationchange");
                }
            }
            remainingTime() {
                return this.duration() - this.currentTime();
            }
            remainingTimeDisplay() {
                return Math.floor(this.duration()) - Math.floor(this.currentTime());
            }
            buffered() {
                let buffered = this.techGet_("buffered");
                if (!buffered || !buffered.length) buffered = createTimeRanges$1(0, 0);
                return buffered;
            }
            bufferedPercent() {
                return bufferedPercent(this.buffered(), this.duration());
            }
            bufferedEnd() {
                const buffered = this.buffered();
                const duration = this.duration();
                let end = buffered.end(buffered.length - 1);
                if (end > duration) end = duration;
                return end;
            }
            volume(percentAsDecimal) {
                let vol;
                if (percentAsDecimal !== void 0) {
                    vol = Math.max(0, Math.min(1, parseFloat(percentAsDecimal)));
                    this.cache_.volume = vol;
                    this.techCall_("setVolume", vol);
                    if (vol > 0) this.lastVolume_(vol);
                    return;
                }
                vol = parseFloat(this.techGet_("volume"));
                return isNaN(vol) ? 1 : vol;
            }
            muted(muted) {
                if (muted !== void 0) {
                    this.techCall_("setMuted", muted);
                    return;
                }
                return this.techGet_("muted") || false;
            }
            defaultMuted(defaultMuted) {
                if (defaultMuted !== void 0) return this.techCall_("setDefaultMuted", defaultMuted);
                return this.techGet_("defaultMuted") || false;
            }
            lastVolume_(percentAsDecimal) {
                if (percentAsDecimal !== void 0 && percentAsDecimal !== 0) {
                    this.cache_.lastVolume = percentAsDecimal;
                    return;
                }
                return this.cache_.lastVolume;
            }
            supportsFullScreen() {
                return this.techGet_("supportsFullScreen") || false;
            }
            isFullscreen(isFS) {
                if (isFS !== void 0) {
                    const oldValue = this.isFullscreen_;
                    this.isFullscreen_ = Boolean(isFS);
                    if (this.isFullscreen_ !== oldValue && this.fsApi_.prefixed) this.trigger("fullscreenchange");
                    this.toggleFullscreenClass_();
                    return;
                }
                return this.isFullscreen_;
            }
            requestFullscreen(fullscreenOptions) {
                if (this.isInPictureInPicture()) this.exitPictureInPicture();
                const self = this;
                return new Promise(((resolve, reject) => {
                    function offHandler() {
                        self.off("fullscreenerror", errorHandler);
                        self.off("fullscreenchange", changeHandler);
                    }
                    function changeHandler() {
                        offHandler();
                        resolve();
                    }
                    function errorHandler(e, err) {
                        offHandler();
                        reject(err);
                    }
                    self.one("fullscreenchange", changeHandler);
                    self.one("fullscreenerror", errorHandler);
                    const promise = self.requestFullscreenHelper_(fullscreenOptions);
                    if (promise) {
                        promise.then(offHandler, offHandler);
                        promise.then(resolve, reject);
                    }
                }));
            }
            requestFullscreenHelper_(fullscreenOptions) {
                let fsOptions;
                if (!this.fsApi_.prefixed) {
                    fsOptions = this.options_.fullscreen && this.options_.fullscreen.options || {};
                    if (fullscreenOptions !== void 0) fsOptions = fullscreenOptions;
                }
                if (this.fsApi_.requestFullscreen) {
                    const promise = this.el_[this.fsApi_.requestFullscreen](fsOptions);
                    if (promise) promise.then((() => this.isFullscreen(true)), (() => this.isFullscreen(false)));
                    return promise;
                } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) this.techCall_("enterFullScreen"); else this.enterFullWindow();
            }
            exitFullscreen() {
                const self = this;
                return new Promise(((resolve, reject) => {
                    function offHandler() {
                        self.off("fullscreenerror", errorHandler);
                        self.off("fullscreenchange", changeHandler);
                    }
                    function changeHandler() {
                        offHandler();
                        resolve();
                    }
                    function errorHandler(e, err) {
                        offHandler();
                        reject(err);
                    }
                    self.one("fullscreenchange", changeHandler);
                    self.one("fullscreenerror", errorHandler);
                    const promise = self.exitFullscreenHelper_();
                    if (promise) {
                        promise.then(offHandler, offHandler);
                        promise.then(resolve, reject);
                    }
                }));
            }
            exitFullscreenHelper_() {
                if (this.fsApi_.requestFullscreen) {
                    const promise = document_default()[this.fsApi_.exitFullscreen]();
                    if (promise) silencePromise(promise.then((() => this.isFullscreen(false))));
                    return promise;
                } else if (this.tech_.supportsFullScreen() && !this.options_.preferFullWindow === true) this.techCall_("exitFullScreen"); else this.exitFullWindow();
            }
            enterFullWindow() {
                this.isFullscreen(true);
                this.isFullWindow = true;
                this.docOrigOverflow = document_default().documentElement.style.overflow;
                on(document_default(), "keydown", this.boundFullWindowOnEscKey_);
                document_default().documentElement.style.overflow = "hidden";
                addClass(document_default().body, "vjs-full-window");
                this.trigger("enterFullWindow");
            }
            fullWindowOnEscKey(event) {
                if (keycode_default().isEventKey(event, "Esc")) if (this.isFullscreen() === true) if (!this.isFullWindow) this.exitFullscreen(); else this.exitFullWindow();
            }
            exitFullWindow() {
                this.isFullscreen(false);
                this.isFullWindow = false;
                off(document_default(), "keydown", this.boundFullWindowOnEscKey_);
                document_default().documentElement.style.overflow = this.docOrigOverflow;
                removeClass(document_default().body, "vjs-full-window");
                this.trigger("exitFullWindow");
            }
            disablePictureInPicture(value) {
                if (value === void 0) return this.techGet_("disablePictureInPicture");
                this.techCall_("setDisablePictureInPicture", value);
                this.options_.disablePictureInPicture = value;
                this.trigger("disablepictureinpicturechanged");
            }
            isInPictureInPicture(isPiP) {
                if (isPiP !== void 0) {
                    this.isInPictureInPicture_ = !!isPiP;
                    this.togglePictureInPictureClass_();
                    return;
                }
                return !!this.isInPictureInPicture_;
            }
            requestPictureInPicture() {
                if (this.options_.enableDocumentPictureInPicture && window_default().documentPictureInPicture) {
                    const pipContainer = document_default().createElement(this.el().tagName);
                    pipContainer.classList = this.el().classList;
                    pipContainer.classList.add("vjs-pip-container");
                    if (this.posterImage) pipContainer.appendChild(this.posterImage.el().cloneNode(true));
                    if (this.titleBar) pipContainer.appendChild(this.titleBar.el().cloneNode(true));
                    pipContainer.appendChild(createEl("p", {
                        className: "vjs-pip-text"
                    }, {}, this.localize("Playing in picture-in-picture")));
                    return window_default().documentPictureInPicture.requestWindow({
                        initialAspectRatio: this.videoWidth() / this.videoHeight(),
                        copyStyleSheets: true
                    }).then((pipWindow => {
                        this.el_.parentNode.insertBefore(pipContainer, this.el_);
                        pipWindow.document.body.append(this.el_);
                        pipWindow.document.body.classList.add("vjs-pip-window");
                        this.player_.isInPictureInPicture(true);
                        this.player_.trigger("enterpictureinpicture");
                        pipWindow.addEventListener("unload", (event => {
                            const pipVideo = event.target.querySelector(".video-js");
                            pipContainer.replaceWith(pipVideo);
                            this.player_.isInPictureInPicture(false);
                            this.player_.trigger("leavepictureinpicture");
                        }));
                        return pipWindow;
                    }));
                }
                if ("pictureInPictureEnabled" in document_default() && this.disablePictureInPicture() === false) return this.techGet_("requestPictureInPicture");
                return Promise.reject("No PiP mode is available");
            }
            exitPictureInPicture() {
                if (window_default().documentPictureInPicture && window_default().documentPictureInPicture.window) {
                    window_default().documentPictureInPicture.window.close();
                    return Promise.resolve();
                }
                if ("pictureInPictureEnabled" in document_default()) return document_default().exitPictureInPicture();
            }
            handleKeyDown(event) {
                const {userActions} = this.options_;
                if (!userActions || !userActions.hotkeys) return;
                const excludeElement = el => {
                    const tagName = el.tagName.toLowerCase();
                    if (el.isContentEditable) return true;
                    const allowedInputTypes = [ "button", "checkbox", "hidden", "radio", "reset", "submit" ];
                    if (tagName === "input") return allowedInputTypes.indexOf(el.type) === -1;
                    const excludedTags = [ "textarea" ];
                    return excludedTags.indexOf(tagName) !== -1;
                };
                if (excludeElement(this.el_.ownerDocument.activeElement)) return;
                if (typeof userActions.hotkeys === "function") userActions.hotkeys.call(this, event); else this.handleHotkeys(event);
            }
            handleHotkeys(event) {
                const hotkeys = this.options_.userActions ? this.options_.userActions.hotkeys : {};
                const {fullscreenKey = keydownEvent => keycode_default().isEventKey(keydownEvent, "f"), muteKey = keydownEvent => keycode_default().isEventKey(keydownEvent, "m"), playPauseKey = keydownEvent => keycode_default().isEventKey(keydownEvent, "k") || keycode_default().isEventKey(keydownEvent, "Space")} = hotkeys;
                if (fullscreenKey.call(this, event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    const FSToggle = Component$1.getComponent("FullscreenToggle");
                    if (document_default()[this.fsApi_.fullscreenEnabled] !== false) FSToggle.prototype.handleClick.call(this, event);
                } else if (muteKey.call(this, event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    const MuteToggle = Component$1.getComponent("MuteToggle");
                    MuteToggle.prototype.handleClick.call(this, event);
                } else if (playPauseKey.call(this, event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    const PlayToggle = Component$1.getComponent("PlayToggle");
                    PlayToggle.prototype.handleClick.call(this, event);
                }
            }
            canPlayType(type) {
                let can;
                for (let i = 0, j = this.options_.techOrder; i < j.length; i++) {
                    const techName = j[i];
                    let tech = Tech.getTech(techName);
                    if (!tech) tech = Component$1.getComponent(techName);
                    if (!tech) {
                        log$1.error(`The "${techName}" tech is undefined. Skipped browser support check for that tech.`);
                        continue;
                    }
                    if (tech.isSupported()) {
                        can = tech.canPlayType(type);
                        if (can) return can;
                    }
                }
                return "";
            }
            selectSource(sources) {
                const techs = this.options_.techOrder.map((techName => [ techName, Tech.getTech(techName) ])).filter((([techName, tech]) => {
                    if (tech) return tech.isSupported();
                    log$1.error(`The "${techName}" tech is undefined. Skipped browser support check for that tech.`);
                    return false;
                }));
                const findFirstPassingTechSourcePair = function(outerArray, innerArray, tester) {
                    let found;
                    outerArray.some((outerChoice => innerArray.some((innerChoice => {
                        found = tester(outerChoice, innerChoice);
                        if (found) return true;
                    }))));
                    return found;
                };
                let foundSourceAndTech;
                const flip = fn => (a, b) => fn(b, a);
                const finder = ([techName, tech], source) => {
                    if (tech.canPlaySource(source, this.options_[techName.toLowerCase()])) return {
                        source,
                        tech: techName
                    };
                };
                if (this.options_.sourceOrder) foundSourceAndTech = findFirstPassingTechSourcePair(sources, techs, flip(finder)); else foundSourceAndTech = findFirstPassingTechSourcePair(techs, sources, finder);
                return foundSourceAndTech || false;
            }
            handleSrc_(source, isRetry) {
                if (typeof source === "undefined") return this.cache_.src || "";
                if (this.resetRetryOnError_) this.resetRetryOnError_();
                const sources = filterSource(source);
                if (!sources.length) {
                    this.setTimeout((function() {
                        this.error({
                            code: 4,
                            message: this.options_.notSupportedMessage
                        });
                    }), 0);
                    return;
                }
                this.changingSrc_ = true;
                if (!isRetry) this.cache_.sources = sources;
                this.updateSourceCaches_(sources[0]);
                setSource(this, sources[0], ((middlewareSource, mws) => {
                    this.middleware_ = mws;
                    if (!isRetry) this.cache_.sources = sources;
                    this.updateSourceCaches_(middlewareSource);
                    const err = this.src_(middlewareSource);
                    if (err) {
                        if (sources.length > 1) return this.handleSrc_(sources.slice(1));
                        this.changingSrc_ = false;
                        this.setTimeout((function() {
                            this.error({
                                code: 4,
                                message: this.options_.notSupportedMessage
                            });
                        }), 0);
                        this.triggerReady();
                        return;
                    }
                    setTech(mws, this.tech_);
                }));
                if (sources.length > 1) {
                    const retry = () => {
                        this.error(null);
                        this.handleSrc_(sources.slice(1), true);
                    };
                    const stopListeningForErrors = () => {
                        this.off("error", retry);
                    };
                    this.one("error", retry);
                    this.one("playing", stopListeningForErrors);
                    this.resetRetryOnError_ = () => {
                        this.off("error", retry);
                        this.off("playing", stopListeningForErrors);
                    };
                }
            }
            src(source) {
                return this.handleSrc_(source, false);
            }
            src_(source) {
                const sourceTech = this.selectSource([ source ]);
                if (!sourceTech) return true;
                if (!titleCaseEquals(sourceTech.tech, this.techName_)) {
                    this.changingSrc_ = true;
                    this.loadTech_(sourceTech.tech, sourceTech.source);
                    this.tech_.ready((() => {
                        this.changingSrc_ = false;
                    }));
                    return false;
                }
                this.ready((function() {
                    if (this.tech_.constructor.prototype.hasOwnProperty("setSource")) this.techCall_("setSource", source); else this.techCall_("src", source.src);
                    this.changingSrc_ = false;
                }), true);
                return false;
            }
            load() {
                this.techCall_("load");
            }
            reset() {
                if (this.paused()) this.doReset_(); else {
                    const playPromise = this.play();
                    silencePromise(playPromise.then((() => this.doReset_())));
                }
            }
            doReset_() {
                if (this.tech_) this.tech_.clearTracks("text");
                this.resetCache_();
                this.poster("");
                this.loadTech_(this.options_.techOrder[0], null);
                this.techCall_("reset");
                this.resetControlBarUI_();
                if (isEvented(this)) this.trigger("playerreset");
            }
            resetControlBarUI_() {
                this.resetProgressBar_();
                this.resetPlaybackRate_();
                this.resetVolumeBar_();
            }
            resetProgressBar_() {
                this.currentTime(0);
                const {currentTimeDisplay, durationDisplay, progressControl, remainingTimeDisplay} = this.controlBar || {};
                const {seekBar} = progressControl || {};
                if (currentTimeDisplay) currentTimeDisplay.updateContent();
                if (durationDisplay) durationDisplay.updateContent();
                if (remainingTimeDisplay) remainingTimeDisplay.updateContent();
                if (seekBar) {
                    seekBar.update();
                    if (seekBar.loadProgressBar) seekBar.loadProgressBar.update();
                }
            }
            resetPlaybackRate_() {
                this.playbackRate(this.defaultPlaybackRate());
                this.handleTechRateChange_();
            }
            resetVolumeBar_() {
                this.volume(1);
                this.trigger("volumechange");
            }
            currentSources() {
                const source = this.currentSource();
                const sources = [];
                if (Object.keys(source).length !== 0) sources.push(source);
                return this.cache_.sources || sources;
            }
            currentSource() {
                return this.cache_.source || {};
            }
            currentSrc() {
                return this.currentSource() && this.currentSource().src || "";
            }
            currentType() {
                return this.currentSource() && this.currentSource().type || "";
            }
            preload(value) {
                if (value !== void 0) {
                    this.techCall_("setPreload", value);
                    this.options_.preload = value;
                    return;
                }
                return this.techGet_("preload");
            }
            autoplay(value) {
                if (value === void 0) return this.options_.autoplay || false;
                let techAutoplay;
                if (typeof value === "string" && /(any|play|muted)/.test(value) || value === true && this.options_.normalizeAutoplay) {
                    this.options_.autoplay = value;
                    this.manualAutoplay_(typeof value === "string" ? value : "play");
                    techAutoplay = false;
                } else if (!value) this.options_.autoplay = false; else this.options_.autoplay = true;
                techAutoplay = typeof techAutoplay === "undefined" ? this.options_.autoplay : techAutoplay;
                if (this.tech_) this.techCall_("setAutoplay", techAutoplay);
            }
            playsinline(value) {
                if (value !== void 0) {
                    this.techCall_("setPlaysinline", value);
                    this.options_.playsinline = value;
                    return this;
                }
                return this.techGet_("playsinline");
            }
            loop(value) {
                if (value !== void 0) {
                    this.techCall_("setLoop", value);
                    this.options_.loop = value;
                    return;
                }
                return this.techGet_("loop");
            }
            poster(src) {
                if (src === void 0) return this.poster_;
                if (!src) src = "";
                if (src === this.poster_) return;
                this.poster_ = src;
                this.techCall_("setPoster", src);
                this.isPosterFromTech_ = false;
                this.trigger("posterchange");
            }
            handleTechPosterChange_() {
                if ((!this.poster_ || this.options_.techCanOverridePoster) && this.tech_ && this.tech_.poster) {
                    const newPoster = this.tech_.poster() || "";
                    if (newPoster !== this.poster_) {
                        this.poster_ = newPoster;
                        this.isPosterFromTech_ = true;
                        this.trigger("posterchange");
                    }
                }
            }
            controls(bool) {
                if (bool === void 0) return !!this.controls_;
                bool = !!bool;
                if (this.controls_ === bool) return;
                this.controls_ = bool;
                if (this.usingNativeControls()) this.techCall_("setControls", bool);
                if (this.controls_) {
                    this.removeClass("vjs-controls-disabled");
                    this.addClass("vjs-controls-enabled");
                    this.trigger("controlsenabled");
                    if (!this.usingNativeControls()) this.addTechControlsListeners_();
                } else {
                    this.removeClass("vjs-controls-enabled");
                    this.addClass("vjs-controls-disabled");
                    this.trigger("controlsdisabled");
                    if (!this.usingNativeControls()) this.removeTechControlsListeners_();
                }
            }
            usingNativeControls(bool) {
                if (bool === void 0) return !!this.usingNativeControls_;
                bool = !!bool;
                if (this.usingNativeControls_ === bool) return;
                this.usingNativeControls_ = bool;
                if (this.usingNativeControls_) {
                    this.addClass("vjs-using-native-controls");
                    this.trigger("usingnativecontrols");
                } else {
                    this.removeClass("vjs-using-native-controls");
                    this.trigger("usingcustomcontrols");
                }
            }
            error(err) {
                if (err === void 0) return this.error_ || null;
                hooks("beforeerror").forEach((hookFunction => {
                    const newErr = hookFunction(this, err);
                    if (!(video_es_isObject(newErr) && !Array.isArray(newErr) || typeof newErr === "string" || typeof newErr === "number" || newErr === null)) {
                        this.log.error("please return a value that MediaError expects in beforeerror hooks");
                        return;
                    }
                    err = newErr;
                }));
                if (this.options_.suppressNotSupportedError && err && err.code === 4) {
                    const triggerSuppressedError = function() {
                        this.error(err);
                    };
                    this.options_.suppressNotSupportedError = false;
                    this.any([ "click", "touchstart" ], triggerSuppressedError);
                    this.one("loadstart", (function() {
                        this.off([ "click", "touchstart" ], triggerSuppressedError);
                    }));
                    return;
                }
                if (err === null) {
                    this.error_ = err;
                    this.removeClass("vjs-error");
                    if (this.errorDisplay) this.errorDisplay.close();
                    return;
                }
                this.error_ = new MediaError(err);
                this.addClass("vjs-error");
                log$1.error(`(CODE:${this.error_.code} ${MediaError.errorTypes[this.error_.code]})`, this.error_.message, this.error_);
                this.trigger("error");
                hooks("error").forEach((hookFunction => hookFunction(this, this.error_)));
                return;
            }
            reportUserActivity(event) {
                this.userActivity_ = true;
            }
            userActive(bool) {
                if (bool === void 0) return this.userActive_;
                bool = !!bool;
                if (bool === this.userActive_) return;
                this.userActive_ = bool;
                if (this.userActive_) {
                    this.userActivity_ = true;
                    this.removeClass("vjs-user-inactive");
                    this.addClass("vjs-user-active");
                    this.trigger("useractive");
                    return;
                }
                if (this.tech_) this.tech_.one("mousemove", (function(e) {
                    e.stopPropagation();
                    e.preventDefault();
                }));
                this.userActivity_ = false;
                this.removeClass("vjs-user-active");
                this.addClass("vjs-user-inactive");
                this.trigger("userinactive");
            }
            listenForUserActivity_() {
                let mouseInProgress;
                let lastMoveX;
                let lastMoveY;
                const handleActivity = bind_(this, this.reportUserActivity);
                const handleMouseMove = function(e) {
                    if (e.screenX !== lastMoveX || e.screenY !== lastMoveY) {
                        lastMoveX = e.screenX;
                        lastMoveY = e.screenY;
                        handleActivity();
                    }
                };
                const handleMouseDown = function() {
                    handleActivity();
                    this.clearInterval(mouseInProgress);
                    mouseInProgress = this.setInterval(handleActivity, 250);
                };
                const handleMouseUpAndMouseLeave = function(event) {
                    handleActivity();
                    this.clearInterval(mouseInProgress);
                };
                this.on("mousedown", handleMouseDown);
                this.on("mousemove", handleMouseMove);
                this.on("mouseup", handleMouseUpAndMouseLeave);
                this.on("mouseleave", handleMouseUpAndMouseLeave);
                const controlBar = this.getChild("controlBar");
                if (controlBar && !IS_IOS && !IS_ANDROID) {
                    controlBar.on("mouseenter", (function(event) {
                        if (this.player().options_.inactivityTimeout !== 0) this.player().cache_.inactivityTimeout = this.player().options_.inactivityTimeout;
                        this.player().options_.inactivityTimeout = 0;
                    }));
                    controlBar.on("mouseleave", (function(event) {
                        this.player().options_.inactivityTimeout = this.player().cache_.inactivityTimeout;
                    }));
                }
                this.on("keydown", handleActivity);
                this.on("keyup", handleActivity);
                let inactivityTimeout;
                this.setInterval((function() {
                    if (!this.userActivity_) return;
                    this.userActivity_ = false;
                    this.userActive(true);
                    this.clearTimeout(inactivityTimeout);
                    const timeout = this.options_.inactivityTimeout;
                    if (timeout <= 0) return;
                    inactivityTimeout = this.setTimeout((function() {
                        if (!this.userActivity_) this.userActive(false);
                    }), timeout);
                }), 250);
            }
            playbackRate(rate) {
                if (rate !== void 0) {
                    this.techCall_("setPlaybackRate", rate);
                    return;
                }
                if (this.tech_ && this.tech_.featuresPlaybackRate) return this.cache_.lastPlaybackRate || this.techGet_("playbackRate");
                return 1;
            }
            defaultPlaybackRate(rate) {
                if (rate !== void 0) return this.techCall_("setDefaultPlaybackRate", rate);
                if (this.tech_ && this.tech_.featuresPlaybackRate) return this.techGet_("defaultPlaybackRate");
                return 1;
            }
            isAudio(bool) {
                if (bool !== void 0) {
                    this.isAudio_ = !!bool;
                    return;
                }
                return !!this.isAudio_;
            }
            enableAudioOnlyUI_() {
                this.addClass("vjs-audio-only-mode");
                const playerChildren = this.children();
                const controlBar = this.getChild("ControlBar");
                const controlBarHeight = controlBar && controlBar.currentHeight();
                playerChildren.forEach((child => {
                    if (child === controlBar) return;
                    if (child.el_ && !child.hasClass("vjs-hidden")) {
                        child.hide();
                        this.audioOnlyCache_.hiddenChildren.push(child);
                    }
                }));
                this.audioOnlyCache_.playerHeight = this.currentHeight();
                this.height(controlBarHeight);
                this.trigger("audioonlymodechange");
            }
            disableAudioOnlyUI_() {
                this.removeClass("vjs-audio-only-mode");
                this.audioOnlyCache_.hiddenChildren.forEach((child => child.show()));
                this.height(this.audioOnlyCache_.playerHeight);
                this.trigger("audioonlymodechange");
            }
            audioOnlyMode(value) {
                if (typeof value !== "boolean" || value === this.audioOnlyMode_) return this.audioOnlyMode_;
                this.audioOnlyMode_ = value;
                if (value) {
                    const exitPromises = [];
                    if (this.isInPictureInPicture()) exitPromises.push(this.exitPictureInPicture());
                    if (this.isFullscreen()) exitPromises.push(this.exitFullscreen());
                    if (this.audioPosterMode()) exitPromises.push(this.audioPosterMode(false));
                    return Promise.all(exitPromises).then((() => this.enableAudioOnlyUI_()));
                }
                return Promise.resolve().then((() => this.disableAudioOnlyUI_()));
            }
            enablePosterModeUI_() {
                const tech = this.tech_ && this.tech_;
                tech.hide();
                this.addClass("vjs-audio-poster-mode");
                this.trigger("audiopostermodechange");
            }
            disablePosterModeUI_() {
                const tech = this.tech_ && this.tech_;
                tech.show();
                this.removeClass("vjs-audio-poster-mode");
                this.trigger("audiopostermodechange");
            }
            audioPosterMode(value) {
                if (typeof value !== "boolean" || value === this.audioPosterMode_) return this.audioPosterMode_;
                this.audioPosterMode_ = value;
                if (value) {
                    if (this.audioOnlyMode()) {
                        const audioOnlyModePromise = this.audioOnlyMode(false);
                        return audioOnlyModePromise.then((() => {
                            this.enablePosterModeUI_();
                        }));
                    }
                    return Promise.resolve().then((() => {
                        this.enablePosterModeUI_();
                    }));
                }
                return Promise.resolve().then((() => {
                    this.disablePosterModeUI_();
                }));
            }
            addTextTrack(kind, label, language) {
                if (this.tech_) return this.tech_.addTextTrack(kind, label, language);
            }
            addRemoteTextTrack(options, manualCleanup) {
                if (this.tech_) return this.tech_.addRemoteTextTrack(options, manualCleanup);
            }
            removeRemoteTextTrack(obj = {}) {
                let {track} = obj;
                if (!track) track = obj;
                if (this.tech_) return this.tech_.removeRemoteTextTrack(track);
            }
            getVideoPlaybackQuality() {
                return this.techGet_("getVideoPlaybackQuality");
            }
            videoWidth() {
                return this.tech_ && this.tech_.videoWidth && this.tech_.videoWidth() || 0;
            }
            videoHeight() {
                return this.tech_ && this.tech_.videoHeight && this.tech_.videoHeight() || 0;
            }
            language(code) {
                if (code === void 0) return this.language_;
                if (this.language_ !== String(code).toLowerCase()) {
                    this.language_ = String(code).toLowerCase();
                    if (isEvented(this)) this.trigger("languagechange");
                }
            }
            languages() {
                return merge$1(Player.prototype.options_.languages, this.languages_);
            }
            toJSON() {
                const options = merge$1(this.options_);
                const tracks = options.tracks;
                options.tracks = [];
                for (let i = 0; i < tracks.length; i++) {
                    let track = tracks[i];
                    track = merge$1(track);
                    track.player = void 0;
                    options.tracks[i] = track;
                }
                return options;
            }
            createModal(content, options) {
                options = options || {};
                options.content = content || "";
                const modal = new ModalDialog(this, options);
                this.addChild(modal);
                modal.on("dispose", (() => {
                    this.removeChild(modal);
                }));
                modal.open();
                return modal;
            }
            updateCurrentBreakpoint_() {
                if (!this.responsive()) return;
                const currentBreakpoint = this.currentBreakpoint();
                const currentWidth = this.currentWidth();
                for (let i = 0; i < BREAKPOINT_ORDER.length; i++) {
                    const candidateBreakpoint = BREAKPOINT_ORDER[i];
                    const maxWidth = this.breakpoints_[candidateBreakpoint];
                    if (currentWidth <= maxWidth) {
                        if (currentBreakpoint === candidateBreakpoint) return;
                        if (currentBreakpoint) this.removeClass(BREAKPOINT_CLASSES[currentBreakpoint]);
                        this.addClass(BREAKPOINT_CLASSES[candidateBreakpoint]);
                        this.breakpoint_ = candidateBreakpoint;
                        break;
                    }
                }
            }
            removeCurrentBreakpoint_() {
                const className = this.currentBreakpointClass();
                this.breakpoint_ = "";
                if (className) this.removeClass(className);
            }
            breakpoints(breakpoints) {
                if (breakpoints === void 0) return Object.assign(this.breakpoints_);
                this.breakpoint_ = "";
                this.breakpoints_ = Object.assign({}, DEFAULT_BREAKPOINTS, breakpoints);
                this.updateCurrentBreakpoint_();
                return Object.assign(this.breakpoints_);
            }
            responsive(value) {
                if (value === void 0) return this.responsive_;
                value = Boolean(value);
                const current = this.responsive_;
                if (value === current) return;
                this.responsive_ = value;
                if (value) {
                    this.on("playerresize", this.boundUpdateCurrentBreakpoint_);
                    this.updateCurrentBreakpoint_();
                } else {
                    this.off("playerresize", this.boundUpdateCurrentBreakpoint_);
                    this.removeCurrentBreakpoint_();
                }
                return value;
            }
            currentBreakpoint() {
                return this.breakpoint_;
            }
            currentBreakpointClass() {
                return BREAKPOINT_CLASSES[this.breakpoint_] || "";
            }
            loadMedia(media, ready) {
                if (!media || typeof media !== "object") return;
                this.reset();
                this.cache_.media = merge$1(media);
                const {artist, artwork, description, poster, src, textTracks, title} = this.cache_.media;
                if (!artwork && poster) this.cache_.media.artwork = [ {
                    src: poster,
                    type: getMimetype(poster)
                } ];
                if (src) this.src(src);
                if (poster) this.poster(poster);
                if (Array.isArray(textTracks)) textTracks.forEach((tt => this.addRemoteTextTrack(tt, false)));
                if (this.titleBar) this.titleBar.update({
                    title,
                    description: description || artist || ""
                });
                this.ready(ready);
            }
            getMedia() {
                if (!this.cache_.media) {
                    const poster = this.poster();
                    const src = this.currentSources();
                    const textTracks = Array.prototype.map.call(this.remoteTextTracks(), (tt => ({
                        kind: tt.kind,
                        label: tt.label,
                        language: tt.language,
                        src: tt.src
                    })));
                    const media = {
                        src,
                        textTracks
                    };
                    if (poster) {
                        media.poster = poster;
                        media.artwork = [ {
                            src: media.poster,
                            type: getMimetype(media.poster)
                        } ];
                    }
                    return media;
                }
                return merge$1(this.cache_.media);
            }
            static getTagSettings(tag) {
                const baseOptions = {
                    sources: [],
                    tracks: []
                };
                const tagOptions = getAttributes(tag);
                const dataSetup = tagOptions["data-setup"];
                if (hasClass(tag, "vjs-fill")) tagOptions.fill = true;
                if (hasClass(tag, "vjs-fluid")) tagOptions.fluid = true;
                if (dataSetup !== null) {
                    const [err, data] = tuple_default()(dataSetup || "{}");
                    if (err) log$1.error(err);
                    Object.assign(tagOptions, data);
                }
                Object.assign(baseOptions, tagOptions);
                if (tag.hasChildNodes()) {
                    const children = tag.childNodes;
                    for (let i = 0, j = children.length; i < j; i++) {
                        const child = children[i];
                        const childName = child.nodeName.toLowerCase();
                        if (childName === "source") baseOptions.sources.push(getAttributes(child)); else if (childName === "track") baseOptions.tracks.push(getAttributes(child));
                    }
                }
                return baseOptions;
            }
            debug(enabled) {
                if (enabled === void 0) return this.debugEnabled_;
                if (enabled) {
                    this.trigger("debugon");
                    this.previousLogLevel_ = this.log.level;
                    this.log.level("debug");
                    this.debugEnabled_ = true;
                } else {
                    this.trigger("debugoff");
                    this.log.level(this.previousLogLevel_);
                    this.previousLogLevel_ = void 0;
                    this.debugEnabled_ = false;
                }
            }
            playbackRates(newRates) {
                if (newRates === void 0) return this.cache_.playbackRates;
                if (!Array.isArray(newRates)) return;
                if (!newRates.every((rate => typeof rate === "number"))) return;
                this.cache_.playbackRates = newRates;
                this.trigger("playbackrateschange");
            }
        }
        ALL.names.forEach((function(name) {
            const props = ALL[name];
            Player.prototype[props.getterName] = function() {
                if (this.tech_) return this.tech_[props.getterName]();
                this[props.privateName] = this[props.privateName] || new props.ListClass;
                return this[props.privateName];
            };
        }));
        Player.prototype.crossorigin = Player.prototype.crossOrigin;
        Player.players = {};
        const video_es_navigator = window_default().navigator;
        Player.prototype.options_ = {
            techOrder: Tech.defaultTechOrder_,
            html5: {},
            enableSourceset: true,
            inactivityTimeout: 2e3,
            playbackRates: [],
            liveui: false,
            children: [ "mediaLoader", "posterImage", "titleBar", "textTrackDisplay", "loadingSpinner", "bigPlayButton", "liveTracker", "controlBar", "errorDisplay", "textTrackSettings", "resizeManager" ],
            language: video_es_navigator && (video_es_navigator.languages && video_es_navigator.languages[0] || video_es_navigator.userLanguage || video_es_navigator.language) || "en",
            languages: {},
            notSupportedMessage: "No compatible source was found for this media.",
            normalizeAutoplay: false,
            fullscreen: {
                options: {
                    navigationUI: "hide"
                }
            },
            breakpoints: {},
            responsive: false,
            audioOnlyMode: false,
            audioPosterMode: false
        };
        [ "ended", "seeking", "seekable", "networkState", "readyState" ].forEach((function(fn) {
            Player.prototype[fn] = function() {
                return this.techGet_(fn);
            };
        }));
        TECH_EVENTS_RETRIGGER.forEach((function(event) {
            Player.prototype[`handleTech${toTitleCase$1(event)}_`] = function() {
                return this.trigger(event);
            };
        }));
        Component$1.registerComponent("Player", Player);
        const BASE_PLUGIN_NAME = "plugin";
        const PLUGIN_CACHE_KEY = "activePlugins_";
        const pluginStorage = {};
        const pluginExists = name => pluginStorage.hasOwnProperty(name);
        const getPlugin = name => pluginExists(name) ? pluginStorage[name] : void 0;
        const markPluginAsActive = (player, name) => {
            player[PLUGIN_CACHE_KEY] = player[PLUGIN_CACHE_KEY] || {};
            player[PLUGIN_CACHE_KEY][name] = true;
        };
        const triggerSetupEvent = (player, hash, before) => {
            const eventName = (before ? "before" : "") + "pluginsetup";
            player.trigger(eventName, hash);
            player.trigger(eventName + ":" + hash.name, hash);
        };
        const createBasicPlugin = function(name, plugin) {
            const basicPluginWrapper = function() {
                triggerSetupEvent(this, {
                    name,
                    plugin,
                    instance: null
                }, true);
                const instance = plugin.apply(this, arguments);
                markPluginAsActive(this, name);
                triggerSetupEvent(this, {
                    name,
                    plugin,
                    instance
                });
                return instance;
            };
            Object.keys(plugin).forEach((function(prop) {
                basicPluginWrapper[prop] = plugin[prop];
            }));
            return basicPluginWrapper;
        };
        const createPluginFactory = (name, PluginSubClass) => {
            PluginSubClass.prototype.name = name;
            return function(...args) {
                triggerSetupEvent(this, {
                    name,
                    plugin: PluginSubClass,
                    instance: null
                }, true);
                const instance = new PluginSubClass(...[ this, ...args ]);
                this[name] = () => instance;
                triggerSetupEvent(this, instance.getEventHash());
                return instance;
            };
        };
        class Plugin {
            constructor(player) {
                if (this.constructor === Plugin) throw new Error("Plugin must be sub-classed; not directly instantiated.");
                this.player = player;
                if (!this.log) this.log = this.player.log.createLogger(this.name);
                evented(this);
                delete this.trigger;
                stateful(this, this.constructor.defaultState);
                markPluginAsActive(player, this.name);
                this.dispose = this.dispose.bind(this);
                player.on("dispose", this.dispose);
            }
            version() {
                return this.constructor.VERSION;
            }
            getEventHash(hash = {}) {
                hash.name = this.name;
                hash.plugin = this.constructor;
                hash.instance = this;
                return hash;
            }
            trigger(event, hash = {}) {
                return trigger(this.eventBusEl_, event, this.getEventHash(hash));
            }
            handleStateChanged(e) {}
            dispose() {
                const {name, player} = this;
                this.trigger("dispose");
                this.off();
                player.off("dispose", this.dispose);
                player[PLUGIN_CACHE_KEY][name] = false;
                this.player = this.state = null;
                player[name] = createPluginFactory(name, pluginStorage[name]);
            }
            static isBasic(plugin) {
                const p = typeof plugin === "string" ? getPlugin(plugin) : plugin;
                return typeof p === "function" && !Plugin.prototype.isPrototypeOf(p.prototype);
            }
            static registerPlugin(name, plugin) {
                if (typeof name !== "string") throw new Error(`Illegal plugin name, "${name}", must be a string, was ${typeof name}.`);
                if (pluginExists(name)) log$1.warn(`A plugin named "${name}" already exists. You may want to avoid re-registering plugins!`); else if (Player.prototype.hasOwnProperty(name)) throw new Error(`Illegal plugin name, "${name}", cannot share a name with an existing player method!`);
                if (typeof plugin !== "function") throw new Error(`Illegal plugin for "${name}", must be a function, was ${typeof plugin}.`);
                pluginStorage[name] = plugin;
                if (name !== BASE_PLUGIN_NAME) if (Plugin.isBasic(plugin)) Player.prototype[name] = createBasicPlugin(name, plugin); else Player.prototype[name] = createPluginFactory(name, plugin);
                return plugin;
            }
            static deregisterPlugin(name) {
                if (name === BASE_PLUGIN_NAME) throw new Error("Cannot de-register base plugin.");
                if (pluginExists(name)) {
                    delete pluginStorage[name];
                    delete Player.prototype[name];
                }
            }
            static getPlugins(names = Object.keys(pluginStorage)) {
                let result;
                names.forEach((name => {
                    const plugin = getPlugin(name);
                    if (plugin) {
                        result = result || {};
                        result[name] = plugin;
                    }
                }));
                return result;
            }
            static getPluginVersion(name) {
                const plugin = getPlugin(name);
                return plugin && plugin.VERSION || "";
            }
        }
        Plugin.getPlugin = getPlugin;
        Plugin.BASE_PLUGIN_NAME = BASE_PLUGIN_NAME;
        Plugin.registerPlugin(BASE_PLUGIN_NAME, Plugin);
        Player.prototype.usingPlugin = function(name) {
            return !!this[PLUGIN_CACHE_KEY] && this[PLUGIN_CACHE_KEY][name] === true;
        };
        Player.prototype.hasPlugin = function(name) {
            return !!pluginExists(name);
        };
        function deprecate(message, fn) {
            let warned = false;
            return function(...args) {
                if (!warned) log$1.warn(message);
                warned = true;
                return fn.apply(this, args);
            };
        }
        function deprecateForMajor(major, oldName, newName, fn) {
            return deprecate(`${oldName} is deprecated and will be removed in ${major}.0; please use ${newName} instead.`, fn);
        }
        const normalizeId = id => id.indexOf("#") === 0 ? id.slice(1) : id;
        function videojs(id, options, ready) {
            let player = videojs.getPlayer(id);
            if (player) {
                if (options) log$1.warn(`Player "${id}" is already initialised. Options will not be applied.`);
                if (ready) player.ready(ready);
                return player;
            }
            const el = typeof id === "string" ? video_es_$("#" + normalizeId(id)) : id;
            if (!isEl(el)) throw new TypeError("The element or ID supplied is not valid. (videojs)");
            if (!el.ownerDocument.defaultView || !el.ownerDocument.body.contains(el)) log$1.warn("The element supplied is not included in the DOM");
            options = options || {};
            if (options.restoreEl === true) options.restoreEl = (el.parentNode && el.parentNode.hasAttribute("data-vjs-player") ? el.parentNode : el).cloneNode(true);
            hooks("beforesetup").forEach((hookFunction => {
                const opts = hookFunction(el, merge$1(options));
                if (!video_es_isObject(opts) || Array.isArray(opts)) {
                    log$1.error("please return an object in beforesetup hooks");
                    return;
                }
                options = merge$1(options, opts);
            }));
            const PlayerComponent = Component$1.getComponent("Player");
            player = new PlayerComponent(el, options, ready);
            hooks("setup").forEach((hookFunction => hookFunction(player)));
            return player;
        }
        videojs.hooks_ = hooks_;
        videojs.hooks = hooks;
        videojs.hook = hook;
        videojs.hookOnce = hookOnce;
        videojs.removeHook = removeHook;
        if (window_default().VIDEOJS_NO_DYNAMIC_STYLE !== true && isReal()) {
            let style = video_es_$(".vjs-styles-defaults");
            if (!style) {
                style = createStyleElement("vjs-styles-defaults");
                const head = video_es_$("head");
                if (head) head.insertBefore(style, head.firstChild);
                setTextContent(style, `\n      .video-js {\n        width: 300px;\n        height: 150px;\n      }\n\n      .vjs-fluid:not(.vjs-audio-only-mode) {\n        padding-top: 56.25%\n      }\n    `);
            }
        }
        autoSetupTimeout(1, videojs);
        videojs.VERSION = version$6;
        videojs.options = Player.prototype.options_;
        videojs.getPlayers = () => Player.players;
        videojs.getPlayer = id => {
            const players = Player.players;
            let tag;
            if (typeof id === "string") {
                const nId = normalizeId(id);
                const player = players[nId];
                if (player) return player;
                tag = video_es_$("#" + nId);
            } else tag = id;
            if (isEl(tag)) {
                const {player, playerId} = tag;
                if (player || players[playerId]) return player || players[playerId];
            }
        };
        videojs.getAllPlayers = () => Object.keys(Player.players).map((k => Player.players[k])).filter(Boolean);
        videojs.players = Player.players;
        videojs.getComponent = Component$1.getComponent;
        videojs.registerComponent = (name, comp) => {
            if (Tech.isTech(comp)) log$1.warn(`The ${name} tech was registered as a component. It should instead be registered using videojs.registerTech(name, tech)`);
            Component$1.registerComponent.call(Component$1, name, comp);
        };
        videojs.getTech = Tech.getTech;
        videojs.registerTech = Tech.registerTech;
        videojs.use = use;
        Object.defineProperty(videojs, "middleware", {
            value: {},
            writeable: false,
            enumerable: true
        });
        Object.defineProperty(videojs.middleware, "TERMINATOR", {
            value: TERMINATOR,
            writeable: false,
            enumerable: true
        });
        videojs.browser = video_es_browser;
        videojs.obj = Obj;
        videojs.mergeOptions = deprecateForMajor(9, "videojs.mergeOptions", "videojs.obj.merge", merge$1);
        videojs.defineLazyProperty = deprecateForMajor(9, "videojs.defineLazyProperty", "videojs.obj.defineLazyProperty", defineLazyProperty);
        videojs.bind = deprecateForMajor(9, "videojs.bind", "native Function.prototype.bind", bind_);
        videojs.registerPlugin = Plugin.registerPlugin;
        videojs.deregisterPlugin = Plugin.deregisterPlugin;
        videojs.plugin = (name, plugin) => {
            log$1.warn("videojs.plugin() is deprecated; use videojs.registerPlugin() instead");
            return Plugin.registerPlugin(name, plugin);
        };
        videojs.getPlugins = Plugin.getPlugins;
        videojs.getPlugin = Plugin.getPlugin;
        videojs.getPluginVersion = Plugin.getPluginVersion;
        videojs.addLanguage = function(code, data) {
            code = ("" + code).toLowerCase();
            videojs.options.languages = merge$1(videojs.options.languages, {
                [code]: data
            });
            return videojs.options.languages[code];
        };
        videojs.log = log$1;
        videojs.createLogger = createLogger;
        videojs.time = Time;
        videojs.createTimeRange = deprecateForMajor(9, "videojs.createTimeRange", "videojs.time.createTimeRanges", createTimeRanges$1);
        videojs.createTimeRanges = deprecateForMajor(9, "videojs.createTimeRanges", "videojs.time.createTimeRanges", createTimeRanges$1);
        videojs.formatTime = deprecateForMajor(9, "videojs.formatTime", "videojs.time.formatTime", formatTime);
        videojs.setFormatTime = deprecateForMajor(9, "videojs.setFormatTime", "videojs.time.setFormatTime", setFormatTime);
        videojs.resetFormatTime = deprecateForMajor(9, "videojs.resetFormatTime", "videojs.time.resetFormatTime", resetFormatTime);
        videojs.parseUrl = deprecateForMajor(9, "videojs.parseUrl", "videojs.url.parseUrl", parseUrl);
        videojs.isCrossOrigin = deprecateForMajor(9, "videojs.isCrossOrigin", "videojs.url.isCrossOrigin", isCrossOrigin);
        videojs.EventTarget = EventTarget$2;
        videojs.any = any;
        videojs.on = on;
        videojs.one = one;
        videojs.off = off;
        videojs.trigger = trigger;
        videojs.xhr = lib_default();
        videojs.TextTrack = TextTrack;
        videojs.AudioTrack = AudioTrack;
        videojs.VideoTrack = VideoTrack;
        [ "isEl", "isTextNode", "createEl", "hasClass", "addClass", "removeClass", "toggleClass", "setAttributes", "getAttributes", "emptyEl", "appendContent", "insertContent" ].forEach((k => {
            videojs[k] = function() {
                log$1.warn(`videojs.${k}() is deprecated; use videojs.dom.${k}() instead`);
                return Dom[k].apply(null, arguments);
            };
        }));
        videojs.computedStyle = deprecateForMajor(9, "videojs.computedStyle", "videojs.dom.computedStyle", computedStyle);
        videojs.dom = Dom;
        videojs.fn = Fn;
        videojs.num = Num;
        videojs.str = Str;
        videojs.url = Url;
        /*! @name videojs-contrib-quality-levels @version 3.0.0 @license Apache-2.0 */        class QualityLevel {
            constructor(representation) {
                let level = this;
                level.id = representation.id;
                level.label = level.id;
                level.width = representation.width;
                level.height = representation.height;
                level.bitrate = representation.bandwidth;
                level.frameRate = representation.frameRate;
                level.enabled_ = representation.enabled;
                Object.defineProperty(level, "enabled", {
                    get() {
                        return level.enabled_();
                    },
                    set(enable) {
                        level.enabled_(enable);
                    }
                });
                return level;
            }
        }
        class QualityLevelList extends videojs.EventTarget {
            constructor() {
                super();
                let list = this;
                list.levels_ = [];
                list.selectedIndex_ = -1;
                Object.defineProperty(list, "selectedIndex", {
                    get() {
                        return list.selectedIndex_;
                    }
                });
                Object.defineProperty(list, "length", {
                    get() {
                        return list.levels_.length;
                    }
                });
                return list;
            }
            addQualityLevel(representation) {
                let qualityLevel = this.getQualityLevelById(representation.id);
                if (qualityLevel) return qualityLevel;
                const index = this.levels_.length;
                qualityLevel = new QualityLevel(representation);
                if (!("" + index in this)) Object.defineProperty(this, index, {
                    get() {
                        return this.levels_[index];
                    }
                });
                this.levels_.push(qualityLevel);
                this.trigger({
                    qualityLevel,
                    type: "addqualitylevel"
                });
                return qualityLevel;
            }
            removeQualityLevel(qualityLevel) {
                let removed = null;
                for (let i = 0, l = this.length; i < l; i++) if (this[i] === qualityLevel) {
                    removed = this.levels_.splice(i, 1)[0];
                    if (this.selectedIndex_ === i) this.selectedIndex_ = -1; else if (this.selectedIndex_ > i) this.selectedIndex_--;
                    break;
                }
                if (removed) this.trigger({
                    qualityLevel,
                    type: "removequalitylevel"
                });
                return removed;
            }
            getQualityLevelById(id) {
                for (let i = 0, l = this.length; i < l; i++) {
                    const level = this[i];
                    if (level.id === id) return level;
                }
                return null;
            }
            dispose() {
                this.selectedIndex_ = -1;
                this.levels_.length = 0;
            }
        }
        QualityLevelList.prototype.allowedEvents_ = {
            change: "change",
            addqualitylevel: "addqualitylevel",
            removequalitylevel: "removequalitylevel"
        };
        for (const event in QualityLevelList.prototype.allowedEvents_) QualityLevelList.prototype["on" + event] = null;
        var version$5 = "3.0.0";
        const registerPlugin = videojs.registerPlugin || videojs.plugin;
        const initPlugin$1 = function(player, options) {
            const originalPluginFn = player.qualityLevels;
            const qualityLevelList = new QualityLevelList;
            const disposeHandler = function() {
                qualityLevelList.dispose();
                player.qualityLevels = originalPluginFn;
                player.off("dispose", disposeHandler);
            };
            player.on("dispose", disposeHandler);
            player.qualityLevels = () => qualityLevelList;
            player.qualityLevels.VERSION = version$5;
            return qualityLevelList;
        };
        const qualityLevels = function(options) {
            return initPlugin$1(this, videojs.mergeOptions({}, options));
        };
        registerPlugin("qualityLevels", qualityLevels);
        qualityLevels.VERSION = version$5;
        /*! @name @videojs/http-streaming @version 3.0.2 @license Apache-2.0 */        const video_es_resolveUrl = resolve_url;
        const resolveManifestRedirect = (url, req) => {
            if (req && req.responseURL && url !== req.responseURL) return req.responseURL;
            return url;
        };
        const logger = source => {
            if (videojs.log.debug) return videojs.log.debug.bind(videojs, "VHS:", `${source} >`);
            return function() {};
        };
        function video_es_merge(...args) {
            const context = videojs.obj || videojs;
            const fn = context.merge || context.mergeOptions;
            return fn.apply(context, args);
        }
        function createTimeRanges(...args) {
            const context = videojs.time || videojs;
            const fn = context.createTimeRanges || context.createTimeRanges;
            return fn.apply(context, args);
        }
        const TIME_FUDGE_FACTOR = 1 / 30;
        const SAFE_TIME_DELTA = TIME_FUDGE_FACTOR * 3;
        const filterRanges = function(timeRanges, predicate) {
            const results = [];
            let i;
            if (timeRanges && timeRanges.length) for (i = 0; i < timeRanges.length; i++) if (predicate(timeRanges.start(i), timeRanges.end(i))) results.push([ timeRanges.start(i), timeRanges.end(i) ]);
            return createTimeRanges(results);
        };
        const findRange = function(buffered, time) {
            return filterRanges(buffered, (function(start, end) {
                return start - SAFE_TIME_DELTA <= time && end + SAFE_TIME_DELTA >= time;
            }));
        };
        const findNextRange = function(timeRanges, time) {
            return filterRanges(timeRanges, (function(start) {
                return start - TIME_FUDGE_FACTOR >= time;
            }));
        };
        const findGaps = function(buffered) {
            if (buffered.length < 2) return createTimeRanges();
            const ranges = [];
            for (let i = 1; i < buffered.length; i++) {
                const start = buffered.end(i - 1);
                const end = buffered.start(i);
                ranges.push([ start, end ]);
            }
            return createTimeRanges(ranges);
        };
        const bufferIntersection = function(bufferA, bufferB) {
            let start = null;
            let end = null;
            let arity = 0;
            const extents = [];
            const ranges = [];
            if (!bufferA || !bufferA.length || !bufferB || !bufferB.length) return createTimeRanges();
            let count = bufferA.length;
            while (count--) {
                extents.push({
                    time: bufferA.start(count),
                    type: "start"
                });
                extents.push({
                    time: bufferA.end(count),
                    type: "end"
                });
            }
            count = bufferB.length;
            while (count--) {
                extents.push({
                    time: bufferB.start(count),
                    type: "start"
                });
                extents.push({
                    time: bufferB.end(count),
                    type: "end"
                });
            }
            extents.sort((function(a, b) {
                return a.time - b.time;
            }));
            for (count = 0; count < extents.length; count++) {
                if (extents[count].type === "start") {
                    arity++;
                    if (arity === 2) start = extents[count].time;
                } else if (extents[count].type === "end") {
                    arity--;
                    if (arity === 1) end = extents[count].time;
                }
                if (start !== null && end !== null) {
                    ranges.push([ start, end ]);
                    start = null;
                    end = null;
                }
            }
            return createTimeRanges(ranges);
        };
        const printableRange = range => {
            const strArr = [];
            if (!range || !range.length) return "";
            for (let i = 0; i < range.length; i++) strArr.push(range.start(i) + " => " + range.end(i));
            return strArr.join(", ");
        };
        const timeUntilRebuffer = function(buffered, currentTime, playbackRate = 1) {
            const bufferedEnd = buffered.length ? buffered.end(buffered.length - 1) : 0;
            return (bufferedEnd - currentTime) / playbackRate;
        };
        const timeRangesToArray = timeRanges => {
            const timeRangesList = [];
            for (let i = 0; i < timeRanges.length; i++) timeRangesList.push({
                start: timeRanges.start(i),
                end: timeRanges.end(i)
            });
            return timeRangesList;
        };
        const isRangeDifferent = function(a, b) {
            if (a === b) return false;
            if (!a && b || !b && a) return true;
            if (a.length !== b.length) return true;
            for (let i = 0; i < a.length; i++) if (a.start(i) !== b.start(i) || a.end(i) !== b.end(i)) return true;
            return false;
        };
        const lastBufferedEnd = function(a) {
            if (!a || !a.length || !a.end) return;
            return a.end(a.length - 1);
        };
        const timeAheadOf = function(range, startTime) {
            let time = 0;
            if (!range || !range.length) return time;
            for (let i = 0; i < range.length; i++) {
                const start = range.start(i);
                const end = range.end(i);
                if (startTime > end) continue;
                if (startTime > start && startTime <= end) {
                    time += end - startTime;
                    continue;
                }
                time += end - start;
            }
            return time;
        };
        const segmentDurationWithParts = (playlist, segment) => {
            if (!segment.preload) return segment.duration;
            let result = 0;
            (segment.parts || []).forEach((function(p) {
                result += p.duration;
            }));
            (segment.preloadHints || []).forEach((function(p) {
                if (p.type === "PART") result += playlist.partTargetDuration;
            }));
            return result;
        };
        const getPartsAndSegments = playlist => (playlist.segments || []).reduce(((acc, segment, si) => {
            if (segment.parts) segment.parts.forEach((function(part, pi) {
                acc.push({
                    duration: part.duration,
                    segmentIndex: si,
                    partIndex: pi,
                    part,
                    segment
                });
            })); else acc.push({
                duration: segment.duration,
                segmentIndex: si,
                partIndex: null,
                segment,
                part: null
            });
            return acc;
        }), []);
        const getLastParts = media => {
            const lastSegment = media.segments && media.segments.length && media.segments[media.segments.length - 1];
            return lastSegment && lastSegment.parts || [];
        };
        const getKnownPartCount = ({preloadSegment}) => {
            if (!preloadSegment) return;
            const {parts, preloadHints} = preloadSegment;
            let partCount = (preloadHints || []).reduce(((count, hint) => count + (hint.type === "PART" ? 1 : 0)), 0);
            partCount += parts && parts.length ? parts.length : 0;
            return partCount;
        };
        const liveEdgeDelay = (main, media) => {
            if (media.endList) return 0;
            if (main && main.suggestedPresentationDelay) return main.suggestedPresentationDelay;
            const hasParts = getLastParts(media).length > 0;
            if (hasParts && media.serverControl && media.serverControl.partHoldBack) return media.serverControl.partHoldBack; else if (hasParts && media.partTargetDuration) return media.partTargetDuration * 3; else if (media.serverControl && media.serverControl.holdBack) return media.serverControl.holdBack; else if (media.targetDuration) return media.targetDuration * 3;
            return 0;
        };
        const backwardDuration = function(playlist, endSequence) {
            let result = 0;
            let i = endSequence - playlist.mediaSequence;
            let segment = playlist.segments[i];
            if (segment) {
                if (typeof segment.start !== "undefined") return {
                    result: segment.start,
                    precise: true
                };
                if (typeof segment.end !== "undefined") return {
                    result: segment.end - segment.duration,
                    precise: true
                };
            }
            while (i--) {
                segment = playlist.segments[i];
                if (typeof segment.end !== "undefined") return {
                    result: result + segment.end,
                    precise: true
                };
                result += segmentDurationWithParts(playlist, segment);
                if (typeof segment.start !== "undefined") return {
                    result: result + segment.start,
                    precise: true
                };
            }
            return {
                result,
                precise: false
            };
        };
        const forwardDuration = function(playlist, endSequence) {
            let result = 0;
            let segment;
            let i = endSequence - playlist.mediaSequence;
            for (;i < playlist.segments.length; i++) {
                segment = playlist.segments[i];
                if (typeof segment.start !== "undefined") return {
                    result: segment.start - result,
                    precise: true
                };
                result += segmentDurationWithParts(playlist, segment);
                if (typeof segment.end !== "undefined") return {
                    result: segment.end - result,
                    precise: true
                };
            }
            return {
                result: -1,
                precise: false
            };
        };
        const intervalDuration = function(playlist, endSequence, expired) {
            if (typeof endSequence === "undefined") endSequence = playlist.mediaSequence + playlist.segments.length;
            if (endSequence < playlist.mediaSequence) return 0;
            const backward = backwardDuration(playlist, endSequence);
            if (backward.precise) return backward.result;
            const forward = forwardDuration(playlist, endSequence);
            if (forward.precise) return forward.result;
            return backward.result + expired;
        };
        const duration = function(playlist, endSequence, expired) {
            if (!playlist) return 0;
            if (typeof expired !== "number") expired = 0;
            if (typeof endSequence === "undefined") {
                if (playlist.totalDuration) return playlist.totalDuration;
                if (!playlist.endList) return window_default()[1 / 0];
            }
            return intervalDuration(playlist, endSequence, expired);
        };
        const sumDurations = function({defaultDuration, durationList, startIndex, endIndex}) {
            let durations = 0;
            if (startIndex > endIndex) [startIndex, endIndex] = [ endIndex, startIndex ];
            if (startIndex < 0) {
                for (let i = startIndex; i < Math.min(0, endIndex); i++) durations += defaultDuration;
                startIndex = 0;
            }
            for (let i = startIndex; i < endIndex; i++) durations += durationList[i].duration;
            return durations;
        };
        const playlistEnd = function(playlist, expired, useSafeLiveEnd, liveEdgePadding) {
            if (!playlist || !playlist.segments) return null;
            if (playlist.endList) return duration(playlist);
            if (expired === null) return null;
            expired = expired || 0;
            let lastSegmentEndTime = intervalDuration(playlist, playlist.mediaSequence + playlist.segments.length, expired);
            if (useSafeLiveEnd) {
                liveEdgePadding = typeof liveEdgePadding === "number" ? liveEdgePadding : liveEdgeDelay(null, playlist);
                lastSegmentEndTime -= liveEdgePadding;
            }
            return Math.max(0, lastSegmentEndTime);
        };
        const seekable = function(playlist, expired, liveEdgePadding) {
            const useSafeLiveEnd = true;
            const seekableStart = expired || 0;
            const seekableEnd = playlistEnd(playlist, expired, useSafeLiveEnd, liveEdgePadding);
            if (seekableEnd === null) return createTimeRanges();
            return createTimeRanges(seekableStart, seekableEnd);
        };
        const getMediaInfoForTime = function({playlist, currentTime, startingSegmentIndex, startingPartIndex, startTime, exactManifestTimings}) {
            let time = currentTime - startTime;
            const partsAndSegments = getPartsAndSegments(playlist);
            let startIndex = 0;
            for (let i = 0; i < partsAndSegments.length; i++) {
                const partAndSegment = partsAndSegments[i];
                if (startingSegmentIndex !== partAndSegment.segmentIndex) continue;
                if (typeof startingPartIndex === "number" && typeof partAndSegment.partIndex === "number" && startingPartIndex !== partAndSegment.partIndex) continue;
                startIndex = i;
                break;
            }
            if (time < 0) {
                if (startIndex > 0) for (let i = startIndex - 1; i >= 0; i--) {
                    const partAndSegment = partsAndSegments[i];
                    time += partAndSegment.duration;
                    if (exactManifestTimings) {
                        if (time < 0) continue;
                    } else if (time + TIME_FUDGE_FACTOR <= 0) continue;
                    return {
                        partIndex: partAndSegment.partIndex,
                        segmentIndex: partAndSegment.segmentIndex,
                        startTime: startTime - sumDurations({
                            defaultDuration: playlist.targetDuration,
                            durationList: partsAndSegments,
                            startIndex,
                            endIndex: i
                        })
                    };
                }
                return {
                    partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
                    segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
                    startTime: currentTime
                };
            }
            if (startIndex < 0) {
                for (let i = startIndex; i < 0; i++) {
                    time -= playlist.targetDuration;
                    if (time < 0) return {
                        partIndex: partsAndSegments[0] && partsAndSegments[0].partIndex || null,
                        segmentIndex: partsAndSegments[0] && partsAndSegments[0].segmentIndex || 0,
                        startTime: currentTime
                    };
                }
                startIndex = 0;
            }
            for (let i = startIndex; i < partsAndSegments.length; i++) {
                const partAndSegment = partsAndSegments[i];
                time -= partAndSegment.duration;
                if (exactManifestTimings) {
                    if (time > 0) continue;
                } else if (time - TIME_FUDGE_FACTOR >= 0) continue;
                return {
                    partIndex: partAndSegment.partIndex,
                    segmentIndex: partAndSegment.segmentIndex,
                    startTime: startTime + sumDurations({
                        defaultDuration: playlist.targetDuration,
                        durationList: partsAndSegments,
                        startIndex,
                        endIndex: i
                    })
                };
            }
            return {
                segmentIndex: partsAndSegments[partsAndSegments.length - 1].segmentIndex,
                partIndex: partsAndSegments[partsAndSegments.length - 1].partIndex,
                startTime: currentTime
            };
        };
        const isExcluded = function(playlist) {
            return playlist.excludeUntil && playlist.excludeUntil > Date.now();
        };
        const isIncompatible = function(playlist) {
            return playlist.excludeUntil && playlist.excludeUntil === 1 / 0;
        };
        const isEnabled = function(playlist) {
            const excluded = isExcluded(playlist);
            return !playlist.disabled && !excluded;
        };
        const isDisabled = function(playlist) {
            return playlist.disabled;
        };
        const isAes = function(media) {
            for (let i = 0; i < media.segments.length; i++) if (media.segments[i].key) return true;
            return false;
        };
        const hasAttribute = function(attr, playlist) {
            return playlist.attributes && playlist.attributes[attr];
        };
        const estimateSegmentRequestTime = function(segmentDuration, bandwidth, playlist, bytesReceived = 0) {
            if (!hasAttribute("BANDWIDTH", playlist)) return NaN;
            const size = segmentDuration * playlist.attributes.BANDWIDTH;
            return (size - bytesReceived * 8) / bandwidth;
        };
        const isLowestEnabledRendition = (main, media) => {
            if (main.playlists.length === 1) return true;
            const currentBandwidth = media.attributes.BANDWIDTH || Number.MAX_VALUE;
            return main.playlists.filter((playlist => {
                if (!isEnabled(playlist)) return false;
                return (playlist.attributes.BANDWIDTH || 0) < currentBandwidth;
            })).length === 0;
        };
        const playlistMatch = (a, b) => {
            if (!a && !b || !a && b || a && !b) return false;
            if (a === b) return true;
            if (a.id && b.id && a.id === b.id) return true;
            if (a.resolvedUri && b.resolvedUri && a.resolvedUri === b.resolvedUri) return true;
            if (a.uri && b.uri && a.uri === b.uri) return true;
            return false;
        };
        const someAudioVariant = function(main, callback) {
            const AUDIO = main && main.mediaGroups && main.mediaGroups.AUDIO || {};
            let found = false;
            for (const groupName in AUDIO) {
                for (const label in AUDIO[groupName]) {
                    found = callback(AUDIO[groupName][label]);
                    if (found) break;
                }
                if (found) break;
            }
            return !!found;
        };
        const isAudioOnly = main => {
            if (!main || !main.playlists || !main.playlists.length) {
                const found = someAudioVariant(main, (variant => variant.playlists && variant.playlists.length || variant.uri));
                return found;
            }
            for (let i = 0; i < main.playlists.length; i++) {
                const playlist = main.playlists[i];
                const CODECS = playlist.attributes && playlist.attributes.CODECS;
                if (CODECS && CODECS.split(",").every((c => isAudioCodec(c)))) continue;
                const found = someAudioVariant(main, (variant => playlistMatch(playlist, variant)));
                if (found) continue;
                return false;
            }
            return true;
        };
        var Playlist = {
            liveEdgeDelay,
            duration,
            seekable,
            getMediaInfoForTime,
            isEnabled,
            isDisabled,
            isExcluded,
            isIncompatible,
            playlistEnd,
            isAes,
            hasAttribute,
            estimateSegmentRequestTime,
            isLowestEnabledRendition,
            isAudioOnly,
            playlistMatch,
            segmentDurationWithParts
        };
        const {log} = videojs;
        const createPlaylistID = (index, uri) => `${index}-${uri}`;
        const groupID = (type, group, label) => `placeholder-uri-${type}-${group}-${label}`;
        const parseManifest = ({onwarn, oninfo, manifestString, customTagParsers = [], customTagMappers = [], llhls}) => {
            const parser = new Parser;
            if (onwarn) parser.on("warn", onwarn);
            if (oninfo) parser.on("info", oninfo);
            customTagParsers.forEach((customParser => parser.addParser(customParser)));
            customTagMappers.forEach((mapper => parser.addTagMapper(mapper)));
            parser.push(manifestString);
            parser.end();
            const manifest = parser.manifest;
            if (!llhls) {
                [ "preloadSegment", "skip", "serverControl", "renditionReports", "partInf", "partTargetDuration" ].forEach((function(k) {
                    if (manifest.hasOwnProperty(k)) delete manifest[k];
                }));
                if (manifest.segments) manifest.segments.forEach((function(segment) {
                    [ "parts", "preloadHints" ].forEach((function(k) {
                        if (segment.hasOwnProperty(k)) delete segment[k];
                    }));
                }));
            }
            if (!manifest.targetDuration) {
                let targetDuration = 10;
                if (manifest.segments && manifest.segments.length) targetDuration = manifest.segments.reduce(((acc, s) => Math.max(acc, s.duration)), 0);
                if (onwarn) onwarn(`manifest has no targetDuration defaulting to ${targetDuration}`);
                manifest.targetDuration = targetDuration;
            }
            const parts = getLastParts(manifest);
            if (parts.length && !manifest.partTargetDuration) {
                const partTargetDuration = parts.reduce(((acc, p) => Math.max(acc, p.duration)), 0);
                if (onwarn) {
                    onwarn(`manifest has no partTargetDuration defaulting to ${partTargetDuration}`);
                    log.error("LL-HLS manifest has parts but lacks required #EXT-X-PART-INF:PART-TARGET value. See https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis-09#section-4.4.3.7. Playback is not guaranteed.");
                }
                manifest.partTargetDuration = partTargetDuration;
            }
            return manifest;
        };
        const video_es_forEachMediaGroup = (main, callback) => {
            if (!main.mediaGroups) return;
            [ "AUDIO", "SUBTITLES" ].forEach((mediaType => {
                if (!main.mediaGroups[mediaType]) return;
                for (const groupKey in main.mediaGroups[mediaType]) for (const labelKey in main.mediaGroups[mediaType][groupKey]) {
                    const mediaProperties = main.mediaGroups[mediaType][groupKey][labelKey];
                    callback(mediaProperties, mediaType, groupKey, labelKey);
                }
            }));
        };
        const setupMediaPlaylist = ({playlist, uri, id}) => {
            playlist.id = id;
            playlist.playlistErrors_ = 0;
            if (uri) playlist.uri = uri;
            playlist.attributes = playlist.attributes || {};
        };
        const setupMediaPlaylists = main => {
            let i = main.playlists.length;
            while (i--) {
                const playlist = main.playlists[i];
                setupMediaPlaylist({
                    playlist,
                    id: createPlaylistID(i, playlist.uri)
                });
                playlist.resolvedUri = video_es_resolveUrl(main.uri, playlist.uri);
                main.playlists[playlist.id] = playlist;
                main.playlists[playlist.uri] = playlist;
                if (!playlist.attributes.BANDWIDTH) log.warn("Invalid playlist STREAM-INF detected. Missing BANDWIDTH attribute.");
            }
        };
        const resolveMediaGroupUris = main => {
            video_es_forEachMediaGroup(main, (properties => {
                if (properties.uri) properties.resolvedUri = video_es_resolveUrl(main.uri, properties.uri);
            }));
        };
        const mainForMedia = (media, uri) => {
            const id = createPlaylistID(0, uri);
            const main = {
                mediaGroups: {
                    AUDIO: {},
                    VIDEO: {},
                    "CLOSED-CAPTIONS": {},
                    SUBTITLES: {}
                },
                uri: window_default().location.href,
                resolvedUri: window_default().location.href,
                playlists: [ {
                    uri,
                    id,
                    resolvedUri: uri,
                    attributes: {}
                } ]
            };
            main.playlists[id] = main.playlists[0];
            main.playlists[uri] = main.playlists[0];
            return main;
        };
        const addPropertiesToMain = (main, uri, createGroupID = groupID) => {
            main.uri = uri;
            for (let i = 0; i < main.playlists.length; i++) if (!main.playlists[i].uri) {
                const phonyUri = `placeholder-uri-${i}`;
                main.playlists[i].uri = phonyUri;
            }
            const audioOnlyMain = isAudioOnly(main);
            video_es_forEachMediaGroup(main, ((properties, mediaType, groupKey, labelKey) => {
                if (!properties.playlists || !properties.playlists.length) {
                    if (audioOnlyMain && mediaType === "AUDIO" && !properties.uri) for (let i = 0; i < main.playlists.length; i++) {
                        const p = main.playlists[i];
                        if (p.attributes && p.attributes.AUDIO && p.attributes.AUDIO === groupKey) return;
                    }
                    properties.playlists = [ _extends({}, properties) ];
                }
                properties.playlists.forEach((function(p, i) {
                    const groupId = createGroupID(mediaType, groupKey, labelKey, p);
                    const id = createPlaylistID(i, groupId);
                    if (p.uri) p.resolvedUri = p.resolvedUri || video_es_resolveUrl(main.uri, p.uri); else {
                        p.uri = i === 0 ? groupId : id;
                        p.resolvedUri = p.uri;
                    }
                    p.id = p.id || id;
                    p.attributes = p.attributes || {};
                    main.playlists[p.id] = p;
                    main.playlists[p.uri] = p;
                }));
            }));
            setupMediaPlaylists(main);
            resolveMediaGroupUris(main);
        };
        const {EventTarget: EventTarget$1} = videojs;
        const addLLHLSQueryDirectives = (uri, media) => {
            if (media.endList || !media.serverControl) return uri;
            const parameters = {};
            if (media.serverControl.canBlockReload) {
                const {preloadSegment} = media;
                let nextMSN = media.mediaSequence + media.segments.length;
                if (preloadSegment) {
                    const parts = preloadSegment.parts || [];
                    const nextPart = getKnownPartCount(media) - 1;
                    if (nextPart > -1 && nextPart !== parts.length - 1) parameters._HLS_part = nextPart;
                    if (nextPart > -1 || parts.length) nextMSN--;
                }
                parameters._HLS_msn = nextMSN;
            }
            if (media.serverControl && media.serverControl.canSkipUntil) parameters._HLS_skip = media.serverControl.canSkipDateranges ? "v2" : "YES";
            if (Object.keys(parameters).length) {
                const parsedUri = new (window_default().URL)(uri);
                [ "_HLS_skip", "_HLS_msn", "_HLS_part" ].forEach((function(name) {
                    if (!parameters.hasOwnProperty(name)) return;
                    parsedUri.searchParams.set(name, parameters[name]);
                }));
                uri = parsedUri.toString();
            }
            return uri;
        };
        const updateSegment = (a, b) => {
            if (!a) return b;
            const result = video_es_merge(a, b);
            if (a.preloadHints && !b.preloadHints) delete result.preloadHints;
            if (a.parts && !b.parts) delete result.parts; else if (a.parts && b.parts) for (let i = 0; i < b.parts.length; i++) if (a.parts && a.parts[i]) result.parts[i] = video_es_merge(a.parts[i], b.parts[i]);
            if (!a.skipped && b.skipped) result.skipped = false;
            if (a.preload && !b.preload) result.preload = false;
            return result;
        };
        const updateSegments = (original, update, offset) => {
            const oldSegments = original.slice();
            const newSegments = update.slice();
            offset = offset || 0;
            const result = [];
            let currentMap;
            for (let newIndex = 0; newIndex < newSegments.length; newIndex++) {
                const oldSegment = oldSegments[newIndex + offset];
                const newSegment = newSegments[newIndex];
                if (oldSegment) {
                    currentMap = oldSegment.map || currentMap;
                    result.push(updateSegment(oldSegment, newSegment));
                } else {
                    if (currentMap && !newSegment.map) newSegment.map = currentMap;
                    result.push(newSegment);
                }
            }
            return result;
        };
        const resolveSegmentUris = (segment, baseUri) => {
            if (!segment.resolvedUri && segment.uri) segment.resolvedUri = video_es_resolveUrl(baseUri, segment.uri);
            if (segment.key && !segment.key.resolvedUri) segment.key.resolvedUri = video_es_resolveUrl(baseUri, segment.key.uri);
            if (segment.map && !segment.map.resolvedUri) segment.map.resolvedUri = video_es_resolveUrl(baseUri, segment.map.uri);
            if (segment.map && segment.map.key && !segment.map.key.resolvedUri) segment.map.key.resolvedUri = video_es_resolveUrl(baseUri, segment.map.key.uri);
            if (segment.parts && segment.parts.length) segment.parts.forEach((p => {
                if (p.resolvedUri) return;
                p.resolvedUri = video_es_resolveUrl(baseUri, p.uri);
            }));
            if (segment.preloadHints && segment.preloadHints.length) segment.preloadHints.forEach((p => {
                if (p.resolvedUri) return;
                p.resolvedUri = video_es_resolveUrl(baseUri, p.uri);
            }));
        };
        const getAllSegments = function(media) {
            const segments = media.segments || [];
            const preloadSegment = media.preloadSegment;
            if (preloadSegment && preloadSegment.parts && preloadSegment.parts.length) {
                if (preloadSegment.preloadHints) for (let i = 0; i < preloadSegment.preloadHints.length; i++) if (preloadSegment.preloadHints[i].type === "MAP") return segments;
                preloadSegment.duration = media.targetDuration;
                preloadSegment.preload = true;
                segments.push(preloadSegment);
            }
            return segments;
        };
        const isPlaylistUnchanged = (a, b) => a === b || a.segments && b.segments && a.segments.length === b.segments.length && a.endList === b.endList && a.mediaSequence === b.mediaSequence && a.preloadSegment === b.preloadSegment;
        const updateMain$1 = (main, newMedia, unchangedCheck = isPlaylistUnchanged) => {
            const result = video_es_merge(main, {});
            const oldMedia = result.playlists[newMedia.id];
            if (!oldMedia) return null;
            if (unchangedCheck(oldMedia, newMedia)) return null;
            newMedia.segments = getAllSegments(newMedia);
            const mergedPlaylist = video_es_merge(oldMedia, newMedia);
            if (mergedPlaylist.preloadSegment && !newMedia.preloadSegment) delete mergedPlaylist.preloadSegment;
            if (oldMedia.segments) {
                if (newMedia.skip) {
                    newMedia.segments = newMedia.segments || [];
                    for (let i = 0; i < newMedia.skip.skippedSegments; i++) newMedia.segments.unshift({
                        skipped: true
                    });
                }
                mergedPlaylist.segments = updateSegments(oldMedia.segments, newMedia.segments, newMedia.mediaSequence - oldMedia.mediaSequence);
            }
            mergedPlaylist.segments.forEach((segment => {
                resolveSegmentUris(segment, mergedPlaylist.resolvedUri);
            }));
            for (let i = 0; i < result.playlists.length; i++) if (result.playlists[i].id === newMedia.id) result.playlists[i] = mergedPlaylist;
            result.playlists[newMedia.id] = mergedPlaylist;
            result.playlists[newMedia.uri] = mergedPlaylist;
            video_es_forEachMediaGroup(main, ((properties, mediaType, groupKey, labelKey) => {
                if (!properties.playlists) return;
                for (let i = 0; i < properties.playlists.length; i++) if (newMedia.id === properties.playlists[i].id) properties.playlists[i] = mergedPlaylist;
            }));
            return result;
        };
        const refreshDelay = (media, update) => {
            const segments = media.segments || [];
            const lastSegment = segments[segments.length - 1];
            const lastPart = lastSegment && lastSegment.parts && lastSegment.parts[lastSegment.parts.length - 1];
            const lastDuration = lastPart && lastPart.duration || lastSegment && lastSegment.duration;
            if (update && lastDuration) return lastDuration * 1e3;
            return (media.partTargetDuration || media.targetDuration || 10) * 500;
        };
        class PlaylistLoader extends EventTarget$1 {
            constructor(src, vhs, options = {}) {
                super();
                if (!src) throw new Error("A non-empty playlist URL or object is required");
                this.logger_ = logger("PlaylistLoader");
                const {withCredentials = false} = options;
                this.src = src;
                this.vhs_ = vhs;
                this.withCredentials = withCredentials;
                const vhsOptions = vhs.options_;
                this.customTagParsers = vhsOptions && vhsOptions.customTagParsers || [];
                this.customTagMappers = vhsOptions && vhsOptions.customTagMappers || [];
                this.llhls = vhsOptions && vhsOptions.llhls;
                this.state = "HAVE_NOTHING";
                this.handleMediaupdatetimeout_ = this.handleMediaupdatetimeout_.bind(this);
                this.on("mediaupdatetimeout", this.handleMediaupdatetimeout_);
            }
            handleMediaupdatetimeout_() {
                if (this.state !== "HAVE_METADATA") return;
                const media = this.media();
                let uri = video_es_resolveUrl(this.main.uri, media.uri);
                if (this.llhls) uri = addLLHLSQueryDirectives(uri, media);
                this.state = "HAVE_CURRENT_METADATA";
                this.request = this.vhs_.xhr({
                    uri,
                    withCredentials: this.withCredentials
                }, ((error, req) => {
                    if (!this.request) return;
                    if (error) return this.playlistRequestError(this.request, this.media(), "HAVE_METADATA");
                    this.haveMetadata({
                        playlistString: this.request.responseText,
                        url: this.media().uri,
                        id: this.media().id
                    });
                }));
            }
            playlistRequestError(xhr, playlist, startingState) {
                const {uri, id} = playlist;
                this.request = null;
                if (startingState) this.state = startingState;
                this.error = {
                    playlist: this.main.playlists[id],
                    status: xhr.status,
                    message: `HLS playlist request error at URL: ${uri}.`,
                    responseText: xhr.responseText,
                    code: xhr.status >= 500 ? 4 : 2
                };
                this.trigger("error");
            }
            parseManifest_({url, manifestString}) {
                return parseManifest({
                    onwarn: ({message}) => this.logger_(`m3u8-parser warn for ${url}: ${message}`),
                    oninfo: ({message}) => this.logger_(`m3u8-parser info for ${url}: ${message}`),
                    manifestString,
                    customTagParsers: this.customTagParsers,
                    customTagMappers: this.customTagMappers,
                    llhls: this.llhls
                });
            }
            haveMetadata({playlistString, playlistObject, url, id}) {
                this.request = null;
                this.state = "HAVE_METADATA";
                const playlist = playlistObject || this.parseManifest_({
                    url,
                    manifestString: playlistString
                });
                playlist.lastRequest = Date.now();
                setupMediaPlaylist({
                    playlist,
                    uri: url,
                    id
                });
                const update = updateMain$1(this.main, playlist);
                this.targetDuration = playlist.partTargetDuration || playlist.targetDuration;
                this.pendingMedia_ = null;
                if (update) {
                    this.main = update;
                    this.media_ = this.main.playlists[id];
                } else this.trigger("playlistunchanged");
                this.updateMediaUpdateTimeout_(refreshDelay(this.media(), !!update));
                this.trigger("loadedplaylist");
            }
            dispose() {
                this.trigger("dispose");
                this.stopRequest();
                window_default().clearTimeout(this.mediaUpdateTimeout);
                window_default().clearTimeout(this.finalRenditionTimeout);
                this.off();
            }
            stopRequest() {
                if (this.request) {
                    const oldRequest = this.request;
                    this.request = null;
                    oldRequest.onreadystatechange = null;
                    oldRequest.abort();
                }
            }
            media(playlist, shouldDelay) {
                if (!playlist) return this.media_;
                if (this.state === "HAVE_NOTHING") throw new Error("Cannot switch media playlist from " + this.state);
                if (typeof playlist === "string") {
                    if (!this.main.playlists[playlist]) throw new Error("Unknown playlist URI: " + playlist);
                    playlist = this.main.playlists[playlist];
                }
                window_default().clearTimeout(this.finalRenditionTimeout);
                if (shouldDelay) {
                    const delay = (playlist.partTargetDuration || playlist.targetDuration) / 2 * 1e3 || 5 * 1e3;
                    this.finalRenditionTimeout = window_default().setTimeout(this.media.bind(this, playlist, false), delay);
                    return;
                }
                const startingState = this.state;
                const mediaChange = !this.media_ || playlist.id !== this.media_.id;
                const mainPlaylistRef = this.main.playlists[playlist.id];
                if (mainPlaylistRef && mainPlaylistRef.endList || playlist.endList && playlist.segments.length) {
                    if (this.request) {
                        this.request.onreadystatechange = null;
                        this.request.abort();
                        this.request = null;
                    }
                    this.state = "HAVE_METADATA";
                    this.media_ = playlist;
                    if (mediaChange) {
                        this.trigger("mediachanging");
                        if (startingState === "HAVE_MAIN_MANIFEST") this.trigger("loadedmetadata"); else this.trigger("mediachange");
                    }
                    return;
                }
                this.updateMediaUpdateTimeout_(refreshDelay(playlist, true));
                if (!mediaChange) return;
                this.state = "SWITCHING_MEDIA";
                if (this.request) {
                    if (playlist.resolvedUri === this.request.url) return;
                    this.request.onreadystatechange = null;
                    this.request.abort();
                    this.request = null;
                }
                if (this.media_) this.trigger("mediachanging");
                this.pendingMedia_ = playlist;
                this.request = this.vhs_.xhr({
                    uri: playlist.resolvedUri,
                    withCredentials: this.withCredentials
                }, ((error, req) => {
                    if (!this.request) return;
                    playlist.lastRequest = Date.now();
                    playlist.resolvedUri = resolveManifestRedirect(playlist.resolvedUri, req);
                    if (error) return this.playlistRequestError(this.request, playlist, startingState);
                    this.haveMetadata({
                        playlistString: req.responseText,
                        url: playlist.uri,
                        id: playlist.id
                    });
                    if (startingState === "HAVE_MAIN_MANIFEST") this.trigger("loadedmetadata"); else this.trigger("mediachange");
                }));
            }
            pause() {
                if (this.mediaUpdateTimeout) {
                    window_default().clearTimeout(this.mediaUpdateTimeout);
                    this.mediaUpdateTimeout = null;
                }
                this.stopRequest();
                if (this.state === "HAVE_NOTHING") this.started = false;
                if (this.state === "SWITCHING_MEDIA") if (this.media_) this.state = "HAVE_METADATA"; else this.state = "HAVE_MAIN_MANIFEST"; else if (this.state === "HAVE_CURRENT_METADATA") this.state = "HAVE_METADATA";
            }
            load(shouldDelay) {
                if (this.mediaUpdateTimeout) {
                    window_default().clearTimeout(this.mediaUpdateTimeout);
                    this.mediaUpdateTimeout = null;
                }
                const media = this.media();
                if (shouldDelay) {
                    const delay = media ? (media.partTargetDuration || media.targetDuration) / 2 * 1e3 : 5 * 1e3;
                    this.mediaUpdateTimeout = window_default().setTimeout((() => {
                        this.mediaUpdateTimeout = null;
                        this.load();
                    }), delay);
                    return;
                }
                if (!this.started) {
                    this.start();
                    return;
                }
                if (media && !media.endList) this.trigger("mediaupdatetimeout"); else this.trigger("loadedplaylist");
            }
            updateMediaUpdateTimeout_(delay) {
                if (this.mediaUpdateTimeout) {
                    window_default().clearTimeout(this.mediaUpdateTimeout);
                    this.mediaUpdateTimeout = null;
                }
                if (!this.media() || this.media().endList) return;
                this.mediaUpdateTimeout = window_default().setTimeout((() => {
                    this.mediaUpdateTimeout = null;
                    this.trigger("mediaupdatetimeout");
                    this.updateMediaUpdateTimeout_(delay);
                }), delay);
            }
            start() {
                this.started = true;
                if (typeof this.src === "object") {
                    if (!this.src.uri) this.src.uri = window_default().location.href;
                    this.src.resolvedUri = this.src.uri;
                    setTimeout((() => {
                        this.setupInitialPlaylist(this.src);
                    }), 0);
                    return;
                }
                this.request = this.vhs_.xhr({
                    uri: this.src,
                    withCredentials: this.withCredentials
                }, ((error, req) => {
                    if (!this.request) return;
                    this.request = null;
                    if (error) {
                        this.error = {
                            status: req.status,
                            message: `HLS playlist request error at URL: ${this.src}.`,
                            responseText: req.responseText,
                            code: 2
                        };
                        if (this.state === "HAVE_NOTHING") this.started = false;
                        return this.trigger("error");
                    }
                    this.src = resolveManifestRedirect(this.src, req);
                    const manifest = this.parseManifest_({
                        manifestString: req.responseText,
                        url: this.src
                    });
                    this.setupInitialPlaylist(manifest);
                }));
            }
            srcUri() {
                return typeof this.src === "string" ? this.src : this.src.uri;
            }
            setupInitialPlaylist(manifest) {
                this.state = "HAVE_MAIN_MANIFEST";
                if (manifest.playlists) {
                    this.main = manifest;
                    addPropertiesToMain(this.main, this.srcUri());
                    manifest.playlists.forEach((playlist => {
                        playlist.segments = getAllSegments(playlist);
                        playlist.segments.forEach((segment => {
                            resolveSegmentUris(segment, playlist.resolvedUri);
                        }));
                    }));
                    this.trigger("loadedplaylist");
                    if (!this.request) this.media(this.main.playlists[0]);
                    return;
                }
                const uri = this.srcUri() || window_default().location.href;
                this.main = mainForMedia(manifest, uri);
                this.haveMetadata({
                    playlistObject: manifest,
                    url: uri,
                    id: this.main.playlists[0].id
                });
                this.trigger("loadedmetadata");
            }
        }
        const {xhr: videojsXHR} = videojs;
        const callbackWrapper = function(request, error, response, callback) {
            const reqResponse = request.responseType === "arraybuffer" ? request.response : request.responseText;
            if (!error && reqResponse) {
                request.responseTime = Date.now();
                request.roundTripTime = request.responseTime - request.requestTime;
                request.bytesReceived = reqResponse.byteLength || reqResponse.length;
                if (!request.bandwidth) request.bandwidth = Math.floor(request.bytesReceived / request.roundTripTime * 8 * 1e3);
            }
            if (response.headers) request.responseHeaders = response.headers;
            if (error && error.code === "ETIMEDOUT") request.timedout = true;
            if (!error && !request.aborted && response.statusCode !== 200 && response.statusCode !== 206 && response.statusCode !== 0) error = new Error("XHR Failed with a response of: " + (request && (reqResponse || request.responseText)));
            callback(error, request);
        };
        const xhrFactory = function() {
            const xhr = function XhrFunction(options, callback) {
                options = video_es_merge({
                    timeout: 45e3
                }, options);
                const beforeRequest = XhrFunction.beforeRequest || videojs.Vhs.xhr.beforeRequest;
                if (beforeRequest && typeof beforeRequest === "function") {
                    const newOptions = beforeRequest(options);
                    if (newOptions) options = newOptions;
                }
                const xhrMethod = videojs.Vhs.xhr.original === true ? videojsXHR : videojs.Vhs.xhr;
                const request = xhrMethod(options, (function(error, response) {
                    return callbackWrapper(request, error, response, callback);
                }));
                const originalAbort = request.abort;
                request.abort = function() {
                    request.aborted = true;
                    return originalAbort.apply(request, arguments);
                };
                request.uri = options.uri;
                request.requestTime = Date.now();
                return request;
            };
            xhr.original = true;
            return xhr;
        };
        const byterangeStr = function(byterange) {
            let byterangeEnd;
            const byterangeStart = byterange.offset;
            if (typeof byterange.offset === "bigint" || typeof byterange.length === "bigint") byterangeEnd = window_default().BigInt(byterange.offset) + window_default().BigInt(byterange.length) - window_default().BigInt(1); else byterangeEnd = byterange.offset + byterange.length - 1;
            return "bytes=" + byterangeStart + "-" + byterangeEnd;
        };
        const segmentXhrHeaders = function(segment) {
            const headers = {};
            if (segment.byterange) headers.Range = byterangeStr(segment.byterange);
            return headers;
        };
        const textRange = function(range, i) {
            return range.start(i) + "-" + range.end(i);
        };
        const formatHexString = function(e, i) {
            const value = e.toString(16);
            return "00".substring(0, 2 - value.length) + value + (i % 2 ? " " : "");
        };
        const formatAsciiString = function(e) {
            if (e >= 32 && e < 126) return String.fromCharCode(e);
            return ".";
        };
        const createTransferableMessage = function(message) {
            const transferable = {};
            Object.keys(message).forEach((key => {
                const value = message[key];
                if (isArrayBufferView(value)) transferable[key] = {
                    bytes: value.buffer,
                    byteOffset: value.byteOffset,
                    byteLength: value.byteLength
                }; else transferable[key] = value;
            }));
            return transferable;
        };
        const initSegmentId = function(initSegment) {
            const byterange = initSegment.byterange || {
                length: 1 / 0,
                offset: 0
            };
            return [ byterange.length, byterange.offset, initSegment.resolvedUri ].join(",");
        };
        const segmentKeyId = function(key) {
            return key.resolvedUri;
        };
        const hexDump = data => {
            const bytes = Array.prototype.slice.call(data);
            const step = 16;
            let result = "";
            let hex;
            let ascii;
            for (let j = 0; j < bytes.length / step; j++) {
                hex = bytes.slice(j * step, j * step + step).map(formatHexString).join("");
                ascii = bytes.slice(j * step, j * step + step).map(formatAsciiString).join("");
                result += hex + " " + ascii + "\n";
            }
            return result;
        };
        const tagDump = ({bytes}) => hexDump(bytes);
        const textRanges = ranges => {
            let result = "";
            let i;
            for (i = 0; i < ranges.length; i++) result += textRange(ranges, i) + " ";
            return result;
        };
        var utils = Object.freeze({
            __proto__: null,
            createTransferableMessage,
            initSegmentId,
            segmentKeyId,
            hexDump,
            tagDump,
            textRanges
        });
        const SEGMENT_END_FUDGE_PERCENT = .25;
        const playerTimeToProgramTime = (playerTime, segment) => {
            if (!segment.dateTimeObject) return null;
            const transmuxerPrependedSeconds = segment.videoTimingInfo.transmuxerPrependedSeconds;
            const transmuxedStart = segment.videoTimingInfo.transmuxedPresentationStart;
            const startOfSegment = transmuxedStart + transmuxerPrependedSeconds;
            const offsetFromSegmentStart = playerTime - startOfSegment;
            return new Date(segment.dateTimeObject.getTime() + offsetFromSegmentStart * 1e3);
        };
        const originalSegmentVideoDuration = videoTimingInfo => videoTimingInfo.transmuxedPresentationEnd - videoTimingInfo.transmuxedPresentationStart - videoTimingInfo.transmuxerPrependedSeconds;
        const findSegmentForProgramTime = (programTime, playlist) => {
            let dateTimeObject;
            try {
                dateTimeObject = new Date(programTime);
            } catch (e) {
                return null;
            }
            if (!playlist || !playlist.segments || playlist.segments.length === 0) return null;
            let segment = playlist.segments[0];
            if (dateTimeObject < segment.dateTimeObject) return null;
            for (let i = 0; i < playlist.segments.length - 1; i++) {
                segment = playlist.segments[i];
                const nextSegmentStart = playlist.segments[i + 1].dateTimeObject;
                if (dateTimeObject < nextSegmentStart) break;
            }
            const lastSegment = playlist.segments[playlist.segments.length - 1];
            const lastSegmentStart = lastSegment.dateTimeObject;
            const lastSegmentDuration = lastSegment.videoTimingInfo ? originalSegmentVideoDuration(lastSegment.videoTimingInfo) : lastSegment.duration + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT;
            const lastSegmentEnd = new Date(lastSegmentStart.getTime() + lastSegmentDuration * 1e3);
            if (dateTimeObject > lastSegmentEnd) return null;
            if (dateTimeObject > lastSegmentStart) segment = lastSegment;
            return {
                segment,
                estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : Playlist.duration(playlist, playlist.mediaSequence + playlist.segments.indexOf(segment)),
                type: segment.videoTimingInfo ? "accurate" : "estimate"
            };
        };
        const findSegmentForPlayerTime = (time, playlist) => {
            if (!playlist || !playlist.segments || playlist.segments.length === 0) return null;
            let segmentEnd = 0;
            let segment;
            for (let i = 0; i < playlist.segments.length; i++) {
                segment = playlist.segments[i];
                segmentEnd = segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationEnd : segmentEnd + segment.duration;
                if (time <= segmentEnd) break;
            }
            const lastSegment = playlist.segments[playlist.segments.length - 1];
            if (lastSegment.videoTimingInfo && lastSegment.videoTimingInfo.transmuxedPresentationEnd < time) return null;
            if (time > segmentEnd) {
                if (time > segmentEnd + lastSegment.duration * SEGMENT_END_FUDGE_PERCENT) return null;
                segment = lastSegment;
            }
            return {
                segment,
                estimatedStart: segment.videoTimingInfo ? segment.videoTimingInfo.transmuxedPresentationStart : segmentEnd - segment.duration,
                type: segment.videoTimingInfo ? "accurate" : "estimate"
            };
        };
        const getOffsetFromTimestamp = (comparisonTimeStamp, programTime) => {
            let segmentDateTime;
            let programDateTime;
            try {
                segmentDateTime = new Date(comparisonTimeStamp);
                programDateTime = new Date(programTime);
            } catch (e) {}
            const segmentTimeEpoch = segmentDateTime.getTime();
            const programTimeEpoch = programDateTime.getTime();
            return (programTimeEpoch - segmentTimeEpoch) / 1e3;
        };
        const verifyProgramDateTimeTags = playlist => {
            if (!playlist.segments || playlist.segments.length === 0) return false;
            for (let i = 0; i < playlist.segments.length; i++) {
                const segment = playlist.segments[i];
                if (!segment.dateTimeObject) return false;
            }
            return true;
        };
        const getProgramTime = ({playlist, time = void 0, callback}) => {
            if (!callback) throw new Error("getProgramTime: callback must be provided");
            if (!playlist || time === void 0) return callback({
                message: "getProgramTime: playlist and time must be provided"
            });
            const matchedSegment = findSegmentForPlayerTime(time, playlist);
            if (!matchedSegment) return callback({
                message: "valid programTime was not found"
            });
            if (matchedSegment.type === "estimate") return callback({
                message: "Accurate programTime could not be determined." + " Please seek to e.seekTime and try again",
                seekTime: matchedSegment.estimatedStart
            });
            const programTimeObject = {
                mediaSeconds: time
            };
            const programTime = playerTimeToProgramTime(time, matchedSegment.segment);
            if (programTime) programTimeObject.programDateTime = programTime.toISOString();
            return callback(null, programTimeObject);
        };
        const seekToProgramTime = ({programTime, playlist, retryCount = 2, seekTo, pauseAfterSeek = true, tech, callback}) => {
            if (!callback) throw new Error("seekToProgramTime: callback must be provided");
            if (typeof programTime === "undefined" || !playlist || !seekTo) return callback({
                message: "seekToProgramTime: programTime, seekTo and playlist must be provided"
            });
            if (!playlist.endList && !tech.hasStarted_) return callback({
                message: "player must be playing a live stream to start buffering"
            });
            if (!verifyProgramDateTimeTags(playlist)) return callback({
                message: "programDateTime tags must be provided in the manifest " + playlist.resolvedUri
            });
            const matchedSegment = findSegmentForProgramTime(programTime, playlist);
            if (!matchedSegment) return callback({
                message: `${programTime} was not found in the stream`
            });
            const segment = matchedSegment.segment;
            const mediaOffset = getOffsetFromTimestamp(segment.dateTimeObject, programTime);
            if (matchedSegment.type === "estimate") {
                if (retryCount === 0) return callback({
                    message: `${programTime} is not buffered yet. Try again`
                });
                seekTo(matchedSegment.estimatedStart + mediaOffset);
                tech.one("seeked", (() => {
                    seekToProgramTime({
                        programTime,
                        playlist,
                        retryCount: retryCount - 1,
                        seekTo,
                        pauseAfterSeek,
                        tech,
                        callback
                    });
                }));
                return;
            }
            const seekToTime = segment.start + mediaOffset;
            const seekedCallback = () => callback(null, tech.currentTime());
            tech.one("seeked", seekedCallback);
            if (pauseAfterSeek) tech.pause();
            seekTo(seekToTime);
        };
        const callbackOnCompleted = (request, cb) => {
            if (request.readyState === 4) return cb();
            return;
        };
        const containerRequest = (uri, xhr, cb) => {
            let bytes = [];
            let id3Offset;
            let finished = false;
            const endRequestAndCallback = function(err, req, type, _bytes) {
                req.abort();
                finished = true;
                return cb(err, req, type, _bytes);
            };
            const progressListener = function(error, request) {
                if (finished) return;
                if (error) return endRequestAndCallback(error, request, "", bytes);
                const newPart = request.responseText.substring(bytes && bytes.byteLength || 0, request.responseText.length);
                bytes = concatTypedArrays(bytes, stringToBytes(newPart, true));
                id3Offset = id3Offset || getId3Offset(bytes);
                if (bytes.length < 10 || id3Offset && bytes.length < id3Offset + 2) return callbackOnCompleted(request, (() => endRequestAndCallback(error, request, "", bytes)));
                const type = detectContainerForBytes(bytes);
                if (type === "ts" && bytes.length < 188) return callbackOnCompleted(request, (() => endRequestAndCallback(error, request, "", bytes)));
                if (!type && bytes.length < 376) return callbackOnCompleted(request, (() => endRequestAndCallback(error, request, "", bytes)));
                return endRequestAndCallback(null, request, type, bytes);
            };
            const options = {
                uri,
                beforeSend(request) {
                    request.overrideMimeType("text/plain; charset=x-user-defined");
                    request.addEventListener("progress", (function({total, loaded}) {
                        return callbackWrapper(request, null, {
                            statusCode: request.status
                        }, progressListener);
                    }));
                }
            };
            const request = xhr(options, (function(error, response) {
                return callbackWrapper(request, error, response, progressListener);
            }));
            return request;
        };
        const {EventTarget} = videojs;
        const dashPlaylistUnchanged = function(a, b) {
            if (!isPlaylistUnchanged(a, b)) return false;
            if (a.sidx && b.sidx && (a.sidx.offset !== b.sidx.offset || a.sidx.length !== b.sidx.length)) return false; else if (!a.sidx && b.sidx || a.sidx && !b.sidx) return false;
            if (a.segments && !b.segments || !a.segments && b.segments) return false;
            if (!a.segments && !b.segments) return true;
            for (let i = 0; i < a.segments.length; i++) {
                const aSegment = a.segments[i];
                const bSegment = b.segments[i];
                if (aSegment.uri !== bSegment.uri) return false;
                if (!aSegment.byterange && !bSegment.byterange) continue;
                const aByterange = aSegment.byterange;
                const bByterange = bSegment.byterange;
                if (aByterange && !bByterange || !aByterange && bByterange) return false;
                if (aByterange.offset !== bByterange.offset || aByterange.length !== bByterange.length) return false;
            }
            return true;
        };
        const dashGroupId = (type, group, label, playlist) => {
            const playlistId = playlist.attributes.NAME || label;
            return `placeholder-uri-${type}-${group}-${playlistId}`;
        };
        const parseMainXml = ({mainXml, srcUrl, clientOffset, sidxMapping, previousManifest}) => {
            const manifest = parse(mainXml, {
                manifestUri: srcUrl,
                clientOffset,
                sidxMapping,
                previousManifest
            });
            addPropertiesToMain(manifest, srcUrl, dashGroupId);
            return manifest;
        };
        const removeOldMediaGroupLabels = (update, newMain) => {
            video_es_forEachMediaGroup(update, ((properties, type, group, label) => {
                if (!(label in newMain.mediaGroups[type][group])) delete update.mediaGroups[type][group][label];
            }));
        };
        const updateMain = (oldMain, newMain, sidxMapping) => {
            let noChanges = true;
            let update = video_es_merge(oldMain, {
                duration: newMain.duration,
                minimumUpdatePeriod: newMain.minimumUpdatePeriod,
                timelineStarts: newMain.timelineStarts
            });
            for (let i = 0; i < newMain.playlists.length; i++) {
                const playlist = newMain.playlists[i];
                if (playlist.sidx) {
                    const sidxKey = generateSidxKey(playlist.sidx);
                    if (sidxMapping && sidxMapping[sidxKey] && sidxMapping[sidxKey].sidx) addSidxSegmentsToPlaylist$1(playlist, sidxMapping[sidxKey].sidx, playlist.sidx.resolvedUri);
                }
                const playlistUpdate = updateMain$1(update, playlist, dashPlaylistUnchanged);
                if (playlistUpdate) {
                    update = playlistUpdate;
                    noChanges = false;
                }
            }
            video_es_forEachMediaGroup(newMain, ((properties, type, group, label) => {
                if (properties.playlists && properties.playlists.length) {
                    const id = properties.playlists[0].id;
                    const playlistUpdate = updateMain$1(update, properties.playlists[0], dashPlaylistUnchanged);
                    if (playlistUpdate) {
                        update = playlistUpdate;
                        if (!(label in update.mediaGroups[type][group])) update.mediaGroups[type][group][label] = properties;
                        update.mediaGroups[type][group][label].playlists[0] = update.playlists[id];
                        noChanges = false;
                    }
                }
            }));
            removeOldMediaGroupLabels(update, newMain);
            if (newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) noChanges = false;
            if (noChanges) return null;
            return update;
        };
        const equivalentSidx = (a, b) => {
            const neitherMap = Boolean(!a.map && !b.map);
            const equivalentMap = neitherMap || Boolean(a.map && b.map && a.map.byterange.offset === b.map.byterange.offset && a.map.byterange.length === b.map.byterange.length);
            return equivalentMap && a.uri === b.uri && a.byterange.offset === b.byterange.offset && a.byterange.length === b.byterange.length;
        };
        const compareSidxEntry = (playlists, oldSidxMapping) => {
            const newSidxMapping = {};
            for (const id in playlists) {
                const playlist = playlists[id];
                const currentSidxInfo = playlist.sidx;
                if (currentSidxInfo) {
                    const key = generateSidxKey(currentSidxInfo);
                    if (!oldSidxMapping[key]) break;
                    const savedSidxInfo = oldSidxMapping[key].sidxInfo;
                    if (equivalentSidx(savedSidxInfo, currentSidxInfo)) newSidxMapping[key] = oldSidxMapping[key];
                }
            }
            return newSidxMapping;
        };
        const filterChangedSidxMappings = (main, oldSidxMapping) => {
            const videoSidx = compareSidxEntry(main.playlists, oldSidxMapping);
            let mediaGroupSidx = videoSidx;
            video_es_forEachMediaGroup(main, ((properties, mediaType, groupKey, labelKey) => {
                if (properties.playlists && properties.playlists.length) {
                    const playlists = properties.playlists;
                    mediaGroupSidx = video_es_merge(mediaGroupSidx, compareSidxEntry(playlists, oldSidxMapping));
                }
            }));
            return mediaGroupSidx;
        };
        class DashPlaylistLoader extends EventTarget {
            constructor(srcUrlOrPlaylist, vhs, options = {}, mainPlaylistLoader) {
                super();
                this.mainPlaylistLoader_ = mainPlaylistLoader || this;
                if (!mainPlaylistLoader) this.isMain_ = true;
                const {withCredentials = false} = options;
                this.vhs_ = vhs;
                this.withCredentials = withCredentials;
                if (!srcUrlOrPlaylist) throw new Error("A non-empty playlist URL or object is required");
                this.on("minimumUpdatePeriod", (() => {
                    this.refreshXml_();
                }));
                this.on("mediaupdatetimeout", (() => {
                    this.refreshMedia_(this.media().id);
                }));
                this.state = "HAVE_NOTHING";
                this.loadedPlaylists_ = {};
                this.logger_ = logger("DashPlaylistLoader");
                if (this.isMain_) {
                    this.mainPlaylistLoader_.srcUrl = srcUrlOrPlaylist;
                    this.mainPlaylistLoader_.sidxMapping_ = {};
                } else this.childPlaylist_ = srcUrlOrPlaylist;
            }
            requestErrored_(err, request, startingState) {
                if (!this.request) return true;
                this.request = null;
                if (err) {
                    this.error = typeof err === "object" && !(err instanceof Error) ? err : {
                        status: request.status,
                        message: "DASH request error at URL: " + request.uri,
                        response: request.response,
                        code: 2
                    };
                    if (startingState) this.state = startingState;
                    this.trigger("error");
                    return true;
                }
            }
            addSidxSegments_(playlist, startingState, cb) {
                const sidxKey = playlist.sidx && generateSidxKey(playlist.sidx);
                if (!playlist.sidx || !sidxKey || this.mainPlaylistLoader_.sidxMapping_[sidxKey]) {
                    this.mediaRequest_ = window_default().setTimeout((() => cb(false)), 0);
                    return;
                }
                const uri = resolveManifestRedirect(playlist.sidx.resolvedUri);
                const fin = (err, request) => {
                    if (this.requestErrored_(err, request, startingState)) return;
                    const sidxMapping = this.mainPlaylistLoader_.sidxMapping_;
                    let sidx;
                    try {
                        sidx = parse_sidx_default()(byte_helpers_toUint8(request.response).subarray(8));
                    } catch (e) {
                        this.requestErrored_(e, request, startingState);
                        return;
                    }
                    sidxMapping[sidxKey] = {
                        sidxInfo: playlist.sidx,
                        sidx
                    };
                    addSidxSegmentsToPlaylist$1(playlist, sidx, playlist.sidx.resolvedUri);
                    return cb(true);
                };
                this.request = containerRequest(uri, this.vhs_.xhr, ((err, request, container, bytes) => {
                    if (err) return fin(err, request);
                    if (!container || container !== "mp4") return fin({
                        status: request.status,
                        message: `Unsupported ${container || "unknown"} container type for sidx segment at URL: ${uri}`,
                        response: "",
                        playlist,
                        internal: true,
                        playlistExclusionDuration: 1 / 0,
                        code: 2
                    }, request);
                    const {offset, length} = playlist.sidx.byterange;
                    if (bytes.length >= length + offset) return fin(err, {
                        response: bytes.subarray(offset, offset + length),
                        status: request.status,
                        uri: request.uri
                    });
                    this.request = this.vhs_.xhr({
                        uri,
                        responseType: "arraybuffer",
                        headers: segmentXhrHeaders({
                            byterange: playlist.sidx.byterange
                        })
                    }, fin);
                }));
            }
            dispose() {
                this.trigger("dispose");
                this.stopRequest();
                this.loadedPlaylists_ = {};
                window_default().clearTimeout(this.minimumUpdatePeriodTimeout_);
                window_default().clearTimeout(this.mediaRequest_);
                window_default().clearTimeout(this.mediaUpdateTimeout);
                this.mediaUpdateTimeout = null;
                this.mediaRequest_ = null;
                this.minimumUpdatePeriodTimeout_ = null;
                if (this.mainPlaylistLoader_.createMupOnMedia_) {
                    this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_);
                    this.mainPlaylistLoader_.createMupOnMedia_ = null;
                }
                this.off();
            }
            hasPendingRequest() {
                return this.request || this.mediaRequest_;
            }
            stopRequest() {
                if (this.request) {
                    const oldRequest = this.request;
                    this.request = null;
                    oldRequest.onreadystatechange = null;
                    oldRequest.abort();
                }
            }
            media(playlist) {
                if (!playlist) return this.media_;
                if (this.state === "HAVE_NOTHING") throw new Error("Cannot switch media playlist from " + this.state);
                const startingState = this.state;
                if (typeof playlist === "string") {
                    if (!this.mainPlaylistLoader_.main.playlists[playlist]) throw new Error("Unknown playlist URI: " + playlist);
                    playlist = this.mainPlaylistLoader_.main.playlists[playlist];
                }
                const mediaChange = !this.media_ || playlist.id !== this.media_.id;
                if (mediaChange && this.loadedPlaylists_[playlist.id] && this.loadedPlaylists_[playlist.id].endList) {
                    this.state = "HAVE_METADATA";
                    this.media_ = playlist;
                    if (mediaChange) {
                        this.trigger("mediachanging");
                        this.trigger("mediachange");
                    }
                    return;
                }
                if (!mediaChange) return;
                if (this.media_) this.trigger("mediachanging");
                this.addSidxSegments_(playlist, startingState, (sidxChanged => {
                    this.haveMetadata({
                        startingState,
                        playlist
                    });
                }));
            }
            haveMetadata({startingState, playlist}) {
                this.state = "HAVE_METADATA";
                this.loadedPlaylists_[playlist.id] = playlist;
                this.mediaRequest_ = null;
                this.refreshMedia_(playlist.id);
                if (startingState === "HAVE_MAIN_MANIFEST") this.trigger("loadedmetadata"); else this.trigger("mediachange");
            }
            pause() {
                if (this.mainPlaylistLoader_.createMupOnMedia_) {
                    this.off("loadedmetadata", this.mainPlaylistLoader_.createMupOnMedia_);
                    this.mainPlaylistLoader_.createMupOnMedia_ = null;
                }
                this.stopRequest();
                window_default().clearTimeout(this.mediaUpdateTimeout);
                this.mediaUpdateTimeout = null;
                if (this.isMain_) {
                    window_default().clearTimeout(this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_);
                    this.mainPlaylistLoader_.minimumUpdatePeriodTimeout_ = null;
                }
                if (this.state === "HAVE_NOTHING") this.started = false;
            }
            load(isFinalRendition) {
                window_default().clearTimeout(this.mediaUpdateTimeout);
                this.mediaUpdateTimeout = null;
                const media = this.media();
                if (isFinalRendition) {
                    const delay = media ? media.targetDuration / 2 * 1e3 : 5 * 1e3;
                    this.mediaUpdateTimeout = window_default().setTimeout((() => this.load()), delay);
                    return;
                }
                if (!this.started) {
                    this.start();
                    return;
                }
                if (media && !media.endList) {
                    if (this.isMain_ && !this.minimumUpdatePeriodTimeout_) {
                        this.trigger("minimumUpdatePeriod");
                        this.updateMinimumUpdatePeriodTimeout_();
                    }
                    this.trigger("mediaupdatetimeout");
                } else this.trigger("loadedplaylist");
            }
            start() {
                this.started = true;
                if (!this.isMain_) {
                    this.mediaRequest_ = window_default().setTimeout((() => this.haveMain_()), 0);
                    return;
                }
                this.requestMain_(((req, mainChanged) => {
                    this.haveMain_();
                    if (!this.hasPendingRequest() && !this.media_) this.media(this.mainPlaylistLoader_.main.playlists[0]);
                }));
            }
            requestMain_(cb) {
                this.request = this.vhs_.xhr({
                    uri: this.mainPlaylistLoader_.srcUrl,
                    withCredentials: this.withCredentials
                }, ((error, req) => {
                    if (this.requestErrored_(error, req)) {
                        if (this.state === "HAVE_NOTHING") this.started = false;
                        return;
                    }
                    const mainChanged = req.responseText !== this.mainPlaylistLoader_.mainXml_;
                    this.mainPlaylistLoader_.mainXml_ = req.responseText;
                    if (req.responseHeaders && req.responseHeaders.date) this.mainLoaded_ = Date.parse(req.responseHeaders.date); else this.mainLoaded_ = Date.now();
                    this.mainPlaylistLoader_.srcUrl = resolveManifestRedirect(this.mainPlaylistLoader_.srcUrl, req);
                    if (mainChanged) {
                        this.handleMain_();
                        this.syncClientServerClock_((() => cb(req, mainChanged)));
                        return;
                    }
                    return cb(req, mainChanged);
                }));
            }
            syncClientServerClock_(done) {
                const utcTiming = parseUTCTiming(this.mainPlaylistLoader_.mainXml_);
                if (utcTiming === null) {
                    this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();
                    return done();
                }
                if (utcTiming.method === "DIRECT") {
                    this.mainPlaylistLoader_.clientOffset_ = utcTiming.value - Date.now();
                    return done();
                }
                this.request = this.vhs_.xhr({
                    uri: video_es_resolveUrl(this.mainPlaylistLoader_.srcUrl, utcTiming.value),
                    method: utcTiming.method,
                    withCredentials: this.withCredentials
                }, ((error, req) => {
                    if (!this.request) return;
                    if (error) {
                        this.mainPlaylistLoader_.clientOffset_ = this.mainLoaded_ - Date.now();
                        return done();
                    }
                    let serverTime;
                    if (utcTiming.method === "HEAD") if (!req.responseHeaders || !req.responseHeaders.date) serverTime = this.mainLoaded_; else serverTime = Date.parse(req.responseHeaders.date); else serverTime = Date.parse(req.responseText);
                    this.mainPlaylistLoader_.clientOffset_ = serverTime - Date.now();
                    done();
                }));
            }
            haveMain_() {
                this.state = "HAVE_MAIN_MANIFEST";
                if (this.isMain_) this.trigger("loadedplaylist"); else if (!this.media_) this.media(this.childPlaylist_);
            }
            handleMain_() {
                this.mediaRequest_ = null;
                const oldMain = this.mainPlaylistLoader_.main;
                let newMain = parseMainXml({
                    mainXml: this.mainPlaylistLoader_.mainXml_,
                    srcUrl: this.mainPlaylistLoader_.srcUrl,
                    clientOffset: this.mainPlaylistLoader_.clientOffset_,
                    sidxMapping: this.mainPlaylistLoader_.sidxMapping_,
                    previousManifest: oldMain
                });
                if (oldMain) newMain = updateMain(oldMain, newMain, this.mainPlaylistLoader_.sidxMapping_);
                this.mainPlaylistLoader_.main = newMain ? newMain : oldMain;
                const location = this.mainPlaylistLoader_.main.locations && this.mainPlaylistLoader_.main.locations[0];
                if (location && location !== this.mainPlaylistLoader_.srcUrl) this.mainPlaylistLoader_.srcUrl = location;
                if (!oldMain || newMain && newMain.minimumUpdatePeriod !== oldMain.minimumUpdatePeriod) this.updateMinimumUpdatePeriodTimeout_();
                return Boolean(newMain);
            }
            updateMinimumUpdatePeriodTimeout_() {
                const mpl = this.mainPlaylistLoader_;
                if (mpl.createMupOnMedia_) {
                    mpl.off("loadedmetadata", mpl.createMupOnMedia_);
                    mpl.createMupOnMedia_ = null;
                }
                if (mpl.minimumUpdatePeriodTimeout_) {
                    window_default().clearTimeout(mpl.minimumUpdatePeriodTimeout_);
                    mpl.minimumUpdatePeriodTimeout_ = null;
                }
                let mup = mpl.main && mpl.main.minimumUpdatePeriod;
                if (mup === 0) if (mpl.media()) mup = mpl.media().targetDuration * 1e3; else {
                    mpl.createMupOnMedia_ = mpl.updateMinimumUpdatePeriodTimeout_;
                    mpl.one("loadedmetadata", mpl.createMupOnMedia_);
                }
                if (typeof mup !== "number" || mup <= 0) {
                    if (mup < 0) this.logger_(`found invalid minimumUpdatePeriod of ${mup}, not setting a timeout`);
                    return;
                }
                this.createMUPTimeout_(mup);
            }
            createMUPTimeout_(mup) {
                const mpl = this.mainPlaylistLoader_;
                mpl.minimumUpdatePeriodTimeout_ = window_default().setTimeout((() => {
                    mpl.minimumUpdatePeriodTimeout_ = null;
                    mpl.trigger("minimumUpdatePeriod");
                    mpl.createMUPTimeout_(mup);
                }), mup);
            }
            refreshXml_() {
                this.requestMain_(((req, mainChanged) => {
                    if (!mainChanged) return;
                    if (this.media_) this.media_ = this.mainPlaylistLoader_.main.playlists[this.media_.id];
                    this.mainPlaylistLoader_.sidxMapping_ = filterChangedSidxMappings(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.sidxMapping_);
                    this.addSidxSegments_(this.media(), this.state, (sidxChanged => {
                        this.refreshMedia_(this.media().id);
                    }));
                }));
            }
            refreshMedia_(mediaID) {
                if (!mediaID) throw new Error("refreshMedia_ must take a media id");
                if (this.media_ && this.isMain_) this.handleMain_();
                const playlists = this.mainPlaylistLoader_.main.playlists;
                const mediaChanged = !this.media_ || this.media_ !== playlists[mediaID];
                if (mediaChanged) this.media_ = playlists[mediaID]; else this.trigger("playlistunchanged");
                if (!this.mediaUpdateTimeout) {
                    const createMediaUpdateTimeout = () => {
                        if (this.media().endList) return;
                        this.mediaUpdateTimeout = window_default().setTimeout((() => {
                            this.trigger("mediaupdatetimeout");
                            createMediaUpdateTimeout();
                        }), refreshDelay(this.media(), Boolean(mediaChanged)));
                    };
                    createMediaUpdateTimeout();
                }
                this.trigger("loadedplaylist");
            }
        }
        var Config = {
            GOAL_BUFFER_LENGTH: 30,
            MAX_GOAL_BUFFER_LENGTH: 60,
            BACK_BUFFER_LENGTH: 30,
            GOAL_BUFFER_LENGTH_RATE: 1,
            INITIAL_BANDWIDTH: 4194304,
            BANDWIDTH_VARIANCE: 1.2,
            BUFFER_LOW_WATER_LINE: 0,
            MAX_BUFFER_LOW_WATER_LINE: 30,
            EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE: 16,
            BUFFER_LOW_WATER_LINE_RATE: 1,
            BUFFER_HIGH_WATER_LINE: 30
        };
        const stringToArrayBuffer = string => {
            const view = new Uint8Array(new ArrayBuffer(string.length));
            for (let i = 0; i < string.length; i++) view[i] = string.charCodeAt(i);
            return view.buffer;
        };
        const browserWorkerPolyFill = function(workerObj) {
            workerObj.on = workerObj.addEventListener;
            workerObj.off = workerObj.removeEventListener;
            return workerObj;
        };
        const createObjectURL = function(str) {
            try {
                return URL.createObjectURL(new Blob([ str ], {
                    type: "application/javascript"
                }));
            } catch (e) {
                const blob = new BlobBuilder;
                blob.append(str);
                return URL.createObjectURL(blob.getBlob());
            }
        };
        const factory = function(code) {
            return function() {
                const objectUrl = createObjectURL(code);
                const worker = browserWorkerPolyFill(new Worker(objectUrl));
                worker.objURL = objectUrl;
                const terminate = worker.terminate;
                worker.on = worker.addEventListener;
                worker.off = worker.removeEventListener;
                worker.terminate = function() {
                    URL.revokeObjectURL(objectUrl);
                    return terminate.call(this);
                };
                return worker;
            };
        };
        const transform = function(code) {
            return `var browserWorkerPolyFill = ${browserWorkerPolyFill.toString()};\n` + "browserWorkerPolyFill(self);\n" + code;
        };
        const getWorkerString = function(fn) {
            return fn.toString().replace(/^function.+?{/, "").slice(0, -1);
        };
        const workerCode$1 = transform(getWorkerString((function() {
            var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : {};
            var Stream$8 = function() {
                this.init = function() {
                    var listeners = {};
                    this.on = function(type, listener) {
                        if (!listeners[type]) listeners[type] = [];
                        listeners[type] = listeners[type].concat(listener);
                    };
                    this.off = function(type, listener) {
                        var index;
                        if (!listeners[type]) return false;
                        index = listeners[type].indexOf(listener);
                        listeners[type] = listeners[type].slice();
                        listeners[type].splice(index, 1);
                        return index > -1;
                    };
                    this.trigger = function(type) {
                        var callbacks, i, length, args;
                        callbacks = listeners[type];
                        if (!callbacks) return;
                        if (arguments.length === 2) {
                            length = callbacks.length;
                            for (i = 0; i < length; ++i) callbacks[i].call(this, arguments[1]);
                        } else {
                            args = [];
                            i = arguments.length;
                            for (i = 1; i < arguments.length; ++i) args.push(arguments[i]);
                            length = callbacks.length;
                            for (i = 0; i < length; ++i) callbacks[i].apply(this, args);
                        }
                    };
                    this.dispose = function() {
                        listeners = {};
                    };
                };
            };
            Stream$8.prototype.pipe = function(destination) {
                this.on("data", (function(data) {
                    destination.push(data);
                }));
                this.on("done", (function(flushSource) {
                    destination.flush(flushSource);
                }));
                this.on("partialdone", (function(flushSource) {
                    destination.partialFlush(flushSource);
                }));
                this.on("endedtimeline", (function(flushSource) {
                    destination.endTimeline(flushSource);
                }));
                this.on("reset", (function(flushSource) {
                    destination.reset(flushSource);
                }));
                return destination;
            };
            Stream$8.prototype.push = function(data) {
                this.trigger("data", data);
            };
            Stream$8.prototype.flush = function(flushSource) {
                this.trigger("done", flushSource);
            };
            Stream$8.prototype.partialFlush = function(flushSource) {
                this.trigger("partialdone", flushSource);
            };
            Stream$8.prototype.endTimeline = function(flushSource) {
                this.trigger("endedtimeline", flushSource);
            };
            Stream$8.prototype.reset = function(flushSource) {
                this.trigger("reset", flushSource);
            };
            var stream = Stream$8;
            var MAX_UINT32$1 = Math.pow(2, 32);
            var getUint64$3 = function(uint8) {
                var dv = new DataView(uint8.buffer, uint8.byteOffset, uint8.byteLength);
                var value;
                if (dv.getBigUint64) {
                    value = dv.getBigUint64(0);
                    if (value < Number.MAX_SAFE_INTEGER) return Number(value);
                    return value;
                }
                return dv.getUint32(0) * MAX_UINT32$1 + dv.getUint32(4);
            };
            var numbers = {
                getUint64: getUint64$3,
                MAX_UINT32: MAX_UINT32$1
            };
            var MAX_UINT32 = numbers.MAX_UINT32;
            var box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd, trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex, trun$1, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR, AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;
            (function() {
                var i;
                types = {
                    avc1: [],
                    avcC: [],
                    btrt: [],
                    dinf: [],
                    dref: [],
                    esds: [],
                    ftyp: [],
                    hdlr: [],
                    mdat: [],
                    mdhd: [],
                    mdia: [],
                    mfhd: [],
                    minf: [],
                    moof: [],
                    moov: [],
                    mp4a: [],
                    mvex: [],
                    mvhd: [],
                    pasp: [],
                    sdtp: [],
                    smhd: [],
                    stbl: [],
                    stco: [],
                    stsc: [],
                    stsd: [],
                    stsz: [],
                    stts: [],
                    styp: [],
                    tfdt: [],
                    tfhd: [],
                    traf: [],
                    trak: [],
                    trun: [],
                    trex: [],
                    tkhd: [],
                    vmhd: []
                };
                if (typeof Uint8Array === "undefined") return;
                for (i in types) if (types.hasOwnProperty(i)) types[i] = [ i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3) ];
                MAJOR_BRAND = new Uint8Array([ "i".charCodeAt(0), "s".charCodeAt(0), "o".charCodeAt(0), "m".charCodeAt(0) ]);
                AVC1_BRAND = new Uint8Array([ "a".charCodeAt(0), "v".charCodeAt(0), "c".charCodeAt(0), "1".charCodeAt(0) ]);
                MINOR_VERSION = new Uint8Array([ 0, 0, 0, 1 ]);
                VIDEO_HDLR = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0 ]);
                AUDIO_HDLR = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0 ]);
                HDLR_TYPES = {
                    video: VIDEO_HDLR,
                    audio: AUDIO_HDLR
                };
                DREF = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1 ]);
                SMHD = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0 ]);
                STCO = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0 ]);
                STSC = STCO;
                STSZ = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]);
                STTS = STCO;
                VMHD = new Uint8Array([ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0 ]);
            })();
            box = function(type) {
                var i, result, view, payload = [], size = 0;
                for (i = 1; i < arguments.length; i++) payload.push(arguments[i]);
                i = payload.length;
                while (i--) size += payload[i].byteLength;
                result = new Uint8Array(size + 8);
                view = new DataView(result.buffer, result.byteOffset, result.byteLength);
                view.setUint32(0, result.byteLength);
                result.set(type, 4);
                for (i = 0, size = 8; i < payload.length; i++) {
                    result.set(payload[i], size);
                    size += payload[i].byteLength;
                }
                return result;
            };
            dinf = function() {
                return box(types.dinf, box(types.dref, DREF));
            };
            esds = function(track) {
                return box(types.esds, new Uint8Array([ 0, 0, 0, 0, 3, 25, 0, 0, 0, 4, 17, 64, 21, 0, 6, 0, 0, 0, 218, 192, 0, 0, 218, 192, 5, 2, track.audioobjecttype << 3 | track.samplingfrequencyindex >>> 1, track.samplingfrequencyindex << 7 | track.channelcount << 3, 6, 1, 2 ]));
            };
            ftyp = function() {
                return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);
            };
            hdlr = function(type) {
                return box(types.hdlr, HDLR_TYPES[type]);
            };
            mdat = function(data) {
                return box(types.mdat, data);
            };
            mdhd = function(track) {
                var result = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 95, 144, track.duration >>> 24 & 255, track.duration >>> 16 & 255, track.duration >>> 8 & 255, track.duration & 255, 85, 196, 0, 0 ]);
                if (track.samplerate) {
                    result[12] = track.samplerate >>> 24 & 255;
                    result[13] = track.samplerate >>> 16 & 255;
                    result[14] = track.samplerate >>> 8 & 255;
                    result[15] = track.samplerate & 255;
                }
                return box(types.mdhd, result);
            };
            mdia = function(track) {
                return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));
            };
            mfhd = function(sequenceNumber) {
                return box(types.mfhd, new Uint8Array([ 0, 0, 0, 0, (sequenceNumber & 4278190080) >> 24, (sequenceNumber & 16711680) >> 16, (sequenceNumber & 65280) >> 8, sequenceNumber & 255 ]));
            };
            minf = function(track) {
                return box(types.minf, track.type === "video" ? box(types.vmhd, VMHD) : box(types.smhd, SMHD), dinf(), stbl(track));
            };
            moof = function(sequenceNumber, tracks) {
                var trackFragments = [], i = tracks.length;
                while (i--) trackFragments[i] = traf(tracks[i]);
                return box.apply(null, [ types.moof, mfhd(sequenceNumber) ].concat(trackFragments));
            };
            moov = function(tracks) {
                var i = tracks.length, boxes = [];
                while (i--) boxes[i] = trak(tracks[i]);
                return box.apply(null, [ types.moov, mvhd(4294967295) ].concat(boxes).concat(mvex(tracks)));
            };
            mvex = function(tracks) {
                var i = tracks.length, boxes = [];
                while (i--) boxes[i] = trex(tracks[i]);
                return box.apply(null, [ types.mvex ].concat(boxes));
            };
            mvhd = function(duration) {
                var bytes = new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 0, 1, 95, 144, (duration & 4278190080) >> 24, (duration & 16711680) >> 16, (duration & 65280) >> 8, duration & 255, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255 ]);
                return box(types.mvhd, bytes);
            };
            sdtp = function(track) {
                var flags, i, samples = track.samples || [], bytes = new Uint8Array(4 + samples.length);
                for (i = 0; i < samples.length; i++) {
                    flags = samples[i].flags;
                    bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;
                }
                return box(types.sdtp, bytes);
            };
            stbl = function(track) {
                return box(types.stbl, stsd(track), box(types.stts, STTS), box(types.stsc, STSC), box(types.stsz, STSZ), box(types.stco, STCO));
            };
            (function() {
                var videoSample, audioSample;
                stsd = function(track) {
                    return box(types.stsd, new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 1 ]), track.type === "video" ? videoSample(track) : audioSample(track));
                };
                videoSample = function(track) {
                    var i, avc1Box, sps = track.sps || [], pps = track.pps || [], sequenceParameterSets = [], pictureParameterSets = [];
                    for (i = 0; i < sps.length; i++) {
                        sequenceParameterSets.push((sps[i].byteLength & 65280) >>> 8);
                        sequenceParameterSets.push(sps[i].byteLength & 255);
                        sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i]));
                    }
                    for (i = 0; i < pps.length; i++) {
                        pictureParameterSets.push((pps[i].byteLength & 65280) >>> 8);
                        pictureParameterSets.push(pps[i].byteLength & 255);
                        pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));
                    }
                    avc1Box = [ types.avc1, new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, (track.width & 65280) >> 8, track.width & 255, (track.height & 65280) >> 8, track.height & 255, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 19, 118, 105, 100, 101, 111, 106, 115, 45, 99, 111, 110, 116, 114, 105, 98, 45, 104, 108, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17 ]), box(types.avcC, new Uint8Array([ 1, track.profileIdc, track.profileCompatibility, track.levelIdc, 255 ].concat([ sps.length ], sequenceParameterSets, [ pps.length ], pictureParameterSets))), box(types.btrt, new Uint8Array([ 0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192 ])) ];
                    if (track.sarRatio) {
                        var hSpacing = track.sarRatio[0], vSpacing = track.sarRatio[1];
                        avc1Box.push(box(types.pasp, new Uint8Array([ (hSpacing & 4278190080) >> 24, (hSpacing & 16711680) >> 16, (hSpacing & 65280) >> 8, hSpacing & 255, (vSpacing & 4278190080) >> 24, (vSpacing & 16711680) >> 16, (vSpacing & 65280) >> 8, vSpacing & 255 ])));
                    }
                    return box.apply(null, avc1Box);
                };
                audioSample = function(track) {
                    return box(types.mp4a, new Uint8Array([ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, (track.channelcount & 65280) >> 8, track.channelcount & 255, (track.samplesize & 65280) >> 8, track.samplesize & 255, 0, 0, 0, 0, (track.samplerate & 65280) >> 8, track.samplerate & 255, 0, 0 ]), esds(track));
                };
            })();
            tkhd = function(track) {
                var result = new Uint8Array([ 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, (track.id & 4278190080) >> 24, (track.id & 16711680) >> 16, (track.id & 65280) >> 8, track.id & 255, 0, 0, 0, 0, (track.duration & 4278190080) >> 24, (track.duration & 16711680) >> 16, (track.duration & 65280) >> 8, track.duration & 255, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, (track.width & 65280) >> 8, track.width & 255, 0, 0, (track.height & 65280) >> 8, track.height & 255, 0, 0 ]);
                return box(types.tkhd, result);
            };
            traf = function(track) {
                var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable, dataOffset, upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;
                trackFragmentHeader = box(types.tfhd, new Uint8Array([ 0, 0, 0, 58, (track.id & 4278190080) >> 24, (track.id & 16711680) >> 16, (track.id & 65280) >> 8, track.id & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]));
                upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / MAX_UINT32);
                lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % MAX_UINT32);
                trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([ 1, 0, 0, 0, upperWordBaseMediaDecodeTime >>> 24 & 255, upperWordBaseMediaDecodeTime >>> 16 & 255, upperWordBaseMediaDecodeTime >>> 8 & 255, upperWordBaseMediaDecodeTime & 255, lowerWordBaseMediaDecodeTime >>> 24 & 255, lowerWordBaseMediaDecodeTime >>> 16 & 255, lowerWordBaseMediaDecodeTime >>> 8 & 255, lowerWordBaseMediaDecodeTime & 255 ]));
                dataOffset = 32 + 20 + 8 + 16 + 8 + 8;
                if (track.type === "audio") {
                    trackFragmentRun = trun$1(track, dataOffset);
                    return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun);
                }
                sampleDependencyTable = sdtp(track);
                trackFragmentRun = trun$1(track, sampleDependencyTable.length + dataOffset);
                return box(types.traf, trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun, sampleDependencyTable);
            };
            trak = function(track) {
                track.duration = track.duration || 4294967295;
                return box(types.trak, tkhd(track), mdia(track));
            };
            trex = function(track) {
                var result = new Uint8Array([ 0, 0, 0, 0, (track.id & 4278190080) >> 24, (track.id & 16711680) >> 16, (track.id & 65280) >> 8, track.id & 255, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1 ]);
                if (track.type !== "video") result[result.length - 1] = 0;
                return box(types.trex, result);
            };
            (function() {
                var audioTrun, videoTrun, trunHeader;
                trunHeader = function(samples, offset) {
                    var durationPresent = 0, sizePresent = 0, flagsPresent = 0, compositionTimeOffset = 0;
                    if (samples.length) {
                        if (samples[0].duration !== void 0) durationPresent = 1;
                        if (samples[0].size !== void 0) sizePresent = 2;
                        if (samples[0].flags !== void 0) flagsPresent = 4;
                        if (samples[0].compositionTimeOffset !== void 0) compositionTimeOffset = 8;
                    }
                    return [ 0, 0, durationPresent | sizePresent | flagsPresent | compositionTimeOffset, 1, (samples.length & 4278190080) >>> 24, (samples.length & 16711680) >>> 16, (samples.length & 65280) >>> 8, samples.length & 255, (offset & 4278190080) >>> 24, (offset & 16711680) >>> 16, (offset & 65280) >>> 8, offset & 255 ];
                };
                videoTrun = function(track, offset) {
                    var bytesOffest, bytes, header, samples, sample, i;
                    samples = track.samples || [];
                    offset += 8 + 12 + 16 * samples.length;
                    header = trunHeader(samples, offset);
                    bytes = new Uint8Array(header.length + samples.length * 16);
                    bytes.set(header);
                    bytesOffest = header.length;
                    for (i = 0; i < samples.length; i++) {
                        sample = samples[i];
                        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
                        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
                        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
                        bytes[bytesOffest++] = sample.duration & 255;
                        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
                        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
                        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
                        bytes[bytesOffest++] = sample.size & 255;
                        bytes[bytesOffest++] = sample.flags.isLeading << 2 | sample.flags.dependsOn;
                        bytes[bytesOffest++] = sample.flags.isDependedOn << 6 | sample.flags.hasRedundancy << 4 | sample.flags.paddingValue << 1 | sample.flags.isNonSyncSample;
                        bytes[bytesOffest++] = sample.flags.degradationPriority & 240 << 8;
                        bytes[bytesOffest++] = sample.flags.degradationPriority & 15;
                        bytes[bytesOffest++] = (sample.compositionTimeOffset & 4278190080) >>> 24;
                        bytes[bytesOffest++] = (sample.compositionTimeOffset & 16711680) >>> 16;
                        bytes[bytesOffest++] = (sample.compositionTimeOffset & 65280) >>> 8;
                        bytes[bytesOffest++] = sample.compositionTimeOffset & 255;
                    }
                    return box(types.trun, bytes);
                };
                audioTrun = function(track, offset) {
                    var bytes, bytesOffest, header, samples, sample, i;
                    samples = track.samples || [];
                    offset += 8 + 12 + 8 * samples.length;
                    header = trunHeader(samples, offset);
                    bytes = new Uint8Array(header.length + samples.length * 8);
                    bytes.set(header);
                    bytesOffest = header.length;
                    for (i = 0; i < samples.length; i++) {
                        sample = samples[i];
                        bytes[bytesOffest++] = (sample.duration & 4278190080) >>> 24;
                        bytes[bytesOffest++] = (sample.duration & 16711680) >>> 16;
                        bytes[bytesOffest++] = (sample.duration & 65280) >>> 8;
                        bytes[bytesOffest++] = sample.duration & 255;
                        bytes[bytesOffest++] = (sample.size & 4278190080) >>> 24;
                        bytes[bytesOffest++] = (sample.size & 16711680) >>> 16;
                        bytes[bytesOffest++] = (sample.size & 65280) >>> 8;
                        bytes[bytesOffest++] = sample.size & 255;
                    }
                    return box(types.trun, bytes);
                };
                trun$1 = function(track, offset) {
                    if (track.type === "audio") return audioTrun(track, offset);
                    return videoTrun(track, offset);
                };
            })();
            var mp4Generator = {
                ftyp,
                mdat,
                moof,
                moov,
                initSegment: function(tracks) {
                    var result, fileType = ftyp(), movie = moov(tracks);
                    result = new Uint8Array(fileType.byteLength + movie.byteLength);
                    result.set(fileType);
                    result.set(movie, fileType.byteLength);
                    return result;
                }
            };
            var groupNalsIntoFrames = function(nalUnits) {
                var i, currentNal, currentFrame = [], frames = [];
                frames.byteLength = 0;
                frames.nalCount = 0;
                frames.duration = 0;
                currentFrame.byteLength = 0;
                for (i = 0; i < nalUnits.length; i++) {
                    currentNal = nalUnits[i];
                    if (currentNal.nalUnitType === "access_unit_delimiter_rbsp") {
                        if (currentFrame.length) {
                            currentFrame.duration = currentNal.dts - currentFrame.dts;
                            frames.byteLength += currentFrame.byteLength;
                            frames.nalCount += currentFrame.length;
                            frames.duration += currentFrame.duration;
                            frames.push(currentFrame);
                        }
                        currentFrame = [ currentNal ];
                        currentFrame.byteLength = currentNal.data.byteLength;
                        currentFrame.pts = currentNal.pts;
                        currentFrame.dts = currentNal.dts;
                    } else {
                        if (currentNal.nalUnitType === "slice_layer_without_partitioning_rbsp_idr") currentFrame.keyFrame = true;
                        currentFrame.duration = currentNal.dts - currentFrame.dts;
                        currentFrame.byteLength += currentNal.data.byteLength;
                        currentFrame.push(currentNal);
                    }
                }
                if (frames.length && (!currentFrame.duration || currentFrame.duration <= 0)) currentFrame.duration = frames[frames.length - 1].duration;
                frames.byteLength += currentFrame.byteLength;
                frames.nalCount += currentFrame.length;
                frames.duration += currentFrame.duration;
                frames.push(currentFrame);
                return frames;
            };
            var groupFramesIntoGops = function(frames) {
                var i, currentFrame, currentGop = [], gops = [];
                currentGop.byteLength = 0;
                currentGop.nalCount = 0;
                currentGop.duration = 0;
                currentGop.pts = frames[0].pts;
                currentGop.dts = frames[0].dts;
                gops.byteLength = 0;
                gops.nalCount = 0;
                gops.duration = 0;
                gops.pts = frames[0].pts;
                gops.dts = frames[0].dts;
                for (i = 0; i < frames.length; i++) {
                    currentFrame = frames[i];
                    if (currentFrame.keyFrame) {
                        if (currentGop.length) {
                            gops.push(currentGop);
                            gops.byteLength += currentGop.byteLength;
                            gops.nalCount += currentGop.nalCount;
                            gops.duration += currentGop.duration;
                        }
                        currentGop = [ currentFrame ];
                        currentGop.nalCount = currentFrame.length;
                        currentGop.byteLength = currentFrame.byteLength;
                        currentGop.pts = currentFrame.pts;
                        currentGop.dts = currentFrame.dts;
                        currentGop.duration = currentFrame.duration;
                    } else {
                        currentGop.duration += currentFrame.duration;
                        currentGop.nalCount += currentFrame.length;
                        currentGop.byteLength += currentFrame.byteLength;
                        currentGop.push(currentFrame);
                    }
                }
                if (gops.length && currentGop.duration <= 0) currentGop.duration = gops[gops.length - 1].duration;
                gops.byteLength += currentGop.byteLength;
                gops.nalCount += currentGop.nalCount;
                gops.duration += currentGop.duration;
                gops.push(currentGop);
                return gops;
            };
            var extendFirstKeyFrame = function(gops) {
                var currentGop;
                if (!gops[0][0].keyFrame && gops.length > 1) {
                    currentGop = gops.shift();
                    gops.byteLength -= currentGop.byteLength;
                    gops.nalCount -= currentGop.nalCount;
                    gops[0][0].dts = currentGop.dts;
                    gops[0][0].pts = currentGop.pts;
                    gops[0][0].duration += currentGop.duration;
                }
                return gops;
            };
            var createDefaultSample = function() {
                return {
                    size: 0,
                    flags: {
                        isLeading: 0,
                        dependsOn: 1,
                        isDependedOn: 0,
                        hasRedundancy: 0,
                        degradationPriority: 0,
                        isNonSyncSample: 1
                    }
                };
            };
            var sampleForFrame = function(frame, dataOffset) {
                var sample = createDefaultSample();
                sample.dataOffset = dataOffset;
                sample.compositionTimeOffset = frame.pts - frame.dts;
                sample.duration = frame.duration;
                sample.size = 4 * frame.length;
                sample.size += frame.byteLength;
                if (frame.keyFrame) {
                    sample.flags.dependsOn = 2;
                    sample.flags.isNonSyncSample = 0;
                }
                return sample;
            };
            var generateSampleTable$1 = function(gops, baseDataOffset) {
                var h, i, sample, currentGop, currentFrame, dataOffset = baseDataOffset || 0, samples = [];
                for (h = 0; h < gops.length; h++) {
                    currentGop = gops[h];
                    for (i = 0; i < currentGop.length; i++) {
                        currentFrame = currentGop[i];
                        sample = sampleForFrame(currentFrame, dataOffset);
                        dataOffset += sample.size;
                        samples.push(sample);
                    }
                }
                return samples;
            };
            var concatenateNalData = function(gops) {
                var h, i, j, currentGop, currentFrame, currentNal, dataOffset = 0, nalsByteLength = gops.byteLength, numberOfNals = gops.nalCount, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
                for (h = 0; h < gops.length; h++) {
                    currentGop = gops[h];
                    for (i = 0; i < currentGop.length; i++) {
                        currentFrame = currentGop[i];
                        for (j = 0; j < currentFrame.length; j++) {
                            currentNal = currentFrame[j];
                            view.setUint32(dataOffset, currentNal.data.byteLength);
                            dataOffset += 4;
                            data.set(currentNal.data, dataOffset);
                            dataOffset += currentNal.data.byteLength;
                        }
                    }
                }
                return data;
            };
            var generateSampleTableForFrame = function(frame, baseDataOffset) {
                var sample, dataOffset = baseDataOffset || 0, samples = [];
                sample = sampleForFrame(frame, dataOffset);
                samples.push(sample);
                return samples;
            };
            var concatenateNalDataForFrame = function(frame) {
                var i, currentNal, dataOffset = 0, nalsByteLength = frame.byteLength, numberOfNals = frame.length, totalByteLength = nalsByteLength + 4 * numberOfNals, data = new Uint8Array(totalByteLength), view = new DataView(data.buffer);
                for (i = 0; i < frame.length; i++) {
                    currentNal = frame[i];
                    view.setUint32(dataOffset, currentNal.data.byteLength);
                    dataOffset += 4;
                    data.set(currentNal.data, dataOffset);
                    dataOffset += currentNal.data.byteLength;
                }
                return data;
            };
            var frameUtils$1 = {
                groupNalsIntoFrames,
                groupFramesIntoGops,
                extendFirstKeyFrame,
                generateSampleTable: generateSampleTable$1,
                concatenateNalData,
                generateSampleTableForFrame,
                concatenateNalDataForFrame
            };
            var highPrefix = [ 33, 16, 5, 32, 164, 27 ];
            var lowPrefix = [ 33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252 ];
            var zeroFill = function(count) {
                var a = [];
                while (count--) a.push(0);
                return a;
            };
            var makeTable = function(metaTable) {
                return Object.keys(metaTable).reduce((function(obj, key) {
                    obj[key] = new Uint8Array(metaTable[key].reduce((function(arr, part) {
                        return arr.concat(part);
                    }), []));
                    return obj;
                }), {});
            };
            var silence;
            var silence_1 = function() {
                if (!silence) {
                    var coneOfSilence = {
                        96e3: [ highPrefix, [ 227, 64 ], zeroFill(154), [ 56 ] ],
                        88200: [ highPrefix, [ 231 ], zeroFill(170), [ 56 ] ],
                        64e3: [ highPrefix, [ 248, 192 ], zeroFill(240), [ 56 ] ],
                        48e3: [ highPrefix, [ 255, 192 ], zeroFill(268), [ 55, 148, 128 ], zeroFill(54), [ 112 ] ],
                        44100: [ highPrefix, [ 255, 192 ], zeroFill(268), [ 55, 163, 128 ], zeroFill(84), [ 112 ] ],
                        32e3: [ highPrefix, [ 255, 192 ], zeroFill(268), [ 55, 234 ], zeroFill(226), [ 112 ] ],
                        24e3: [ highPrefix, [ 255, 192 ], zeroFill(268), [ 55, 255, 128 ], zeroFill(268), [ 111, 112 ], zeroFill(126), [ 224 ] ],
                        16e3: [ highPrefix, [ 255, 192 ], zeroFill(268), [ 55, 255, 128 ], zeroFill(268), [ 111, 255 ], zeroFill(269), [ 223, 108 ], zeroFill(195), [ 1, 192 ] ],
                        12e3: [ lowPrefix, zeroFill(268), [ 3, 127, 248 ], zeroFill(268), [ 6, 255, 240 ], zeroFill(268), [ 13, 255, 224 ], zeroFill(268), [ 27, 253, 128 ], zeroFill(259), [ 56 ] ],
                        11025: [ lowPrefix, zeroFill(268), [ 3, 127, 248 ], zeroFill(268), [ 6, 255, 240 ], zeroFill(268), [ 13, 255, 224 ], zeroFill(268), [ 27, 255, 192 ], zeroFill(268), [ 55, 175, 128 ], zeroFill(108), [ 112 ] ],
                        8e3: [ lowPrefix, zeroFill(268), [ 3, 121, 16 ], zeroFill(47), [ 7 ] ]
                    };
                    silence = makeTable(coneOfSilence);
                }
                return silence;
            };
            var secondsToVideoTs, secondsToAudioTs, videoTsToSeconds, audioTsToSeconds, audioTsToVideoTs, videoTsToAudioTs, metadataTsToSeconds, ONE_SECOND_IN_TS$4 = 9e4;
            secondsToVideoTs = function(seconds) {
                return seconds * ONE_SECOND_IN_TS$4;
            };
            secondsToAudioTs = function(seconds, sampleRate) {
                return seconds * sampleRate;
            };
            videoTsToSeconds = function(timestamp) {
                return timestamp / ONE_SECOND_IN_TS$4;
            };
            audioTsToSeconds = function(timestamp, sampleRate) {
                return timestamp / sampleRate;
            };
            audioTsToVideoTs = function(timestamp, sampleRate) {
                return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));
            };
            videoTsToAudioTs = function(timestamp, sampleRate) {
                return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);
            };
            metadataTsToSeconds = function(timestamp, timelineStartPts, keepOriginalTimestamps) {
                return videoTsToSeconds(keepOriginalTimestamps ? timestamp : timestamp - timelineStartPts);
            };
            var clock$2 = {
                ONE_SECOND_IN_TS: ONE_SECOND_IN_TS$4,
                secondsToVideoTs,
                secondsToAudioTs,
                videoTsToSeconds,
                audioTsToSeconds,
                audioTsToVideoTs,
                videoTsToAudioTs,
                metadataTsToSeconds
            };
            var coneOfSilence = silence_1;
            var clock$1 = clock$2;
            var sumFrameByteLengths = function(array) {
                var i, currentObj, sum = 0;
                for (i = 0; i < array.length; i++) {
                    currentObj = array[i];
                    sum += currentObj.data.byteLength;
                }
                return sum;
            };
            var prefixWithSilence = function(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime) {
                var baseMediaDecodeTimeTs, silentFrame, i, firstFrame, frameDuration = 0, audioGapDuration = 0, audioFillFrameCount = 0, audioFillDuration = 0;
                if (!frames.length) return;
                baseMediaDecodeTimeTs = clock$1.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);
                frameDuration = Math.ceil(clock$1.ONE_SECOND_IN_TS / (track.samplerate / 1024));
                if (audioAppendStartTs && videoBaseMediaDecodeTime) {
                    audioGapDuration = baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);
                    audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);
                    audioFillDuration = audioFillFrameCount * frameDuration;
                }
                if (audioFillFrameCount < 1 || audioFillDuration > clock$1.ONE_SECOND_IN_TS / 2) return;
                silentFrame = coneOfSilence()[track.samplerate];
                if (!silentFrame) silentFrame = frames[0].data;
                for (i = 0; i < audioFillFrameCount; i++) {
                    firstFrame = frames[0];
                    frames.splice(0, 0, {
                        data: silentFrame,
                        dts: firstFrame.dts - frameDuration,
                        pts: firstFrame.pts - frameDuration
                    });
                }
                track.baseMediaDecodeTime -= Math.floor(clock$1.videoTsToAudioTs(audioFillDuration, track.samplerate));
                return audioFillDuration;
            };
            var trimAdtsFramesByEarliestDts = function(adtsFrames, track, earliestAllowedDts) {
                if (track.minSegmentDts >= earliestAllowedDts) return adtsFrames;
                track.minSegmentDts = 1 / 0;
                return adtsFrames.filter((function(currentFrame) {
                    if (currentFrame.dts >= earliestAllowedDts) {
                        track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);
                        track.minSegmentPts = track.minSegmentDts;
                        return true;
                    }
                    return false;
                }));
            };
            var generateSampleTable = function(frames) {
                var i, currentFrame, samples = [];
                for (i = 0; i < frames.length; i++) {
                    currentFrame = frames[i];
                    samples.push({
                        size: currentFrame.data.byteLength,
                        duration: 1024
                    });
                }
                return samples;
            };
            var concatenateFrameData = function(frames) {
                var i, currentFrame, dataOffset = 0, data = new Uint8Array(sumFrameByteLengths(frames));
                for (i = 0; i < frames.length; i++) {
                    currentFrame = frames[i];
                    data.set(currentFrame.data, dataOffset);
                    dataOffset += currentFrame.data.byteLength;
                }
                return data;
            };
            var audioFrameUtils$1 = {
                prefixWithSilence,
                trimAdtsFramesByEarliestDts,
                generateSampleTable,
                concatenateFrameData
            };
            var ONE_SECOND_IN_TS$3 = clock$2.ONE_SECOND_IN_TS;
            var collectDtsInfo = function(track, data) {
                if (typeof data.pts === "number") {
                    if (track.timelineStartInfo.pts === void 0) track.timelineStartInfo.pts = data.pts;
                    if (track.minSegmentPts === void 0) track.minSegmentPts = data.pts; else track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);
                    if (track.maxSegmentPts === void 0) track.maxSegmentPts = data.pts; else track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);
                }
                if (typeof data.dts === "number") {
                    if (track.timelineStartInfo.dts === void 0) track.timelineStartInfo.dts = data.dts;
                    if (track.minSegmentDts === void 0) track.minSegmentDts = data.dts; else track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);
                    if (track.maxSegmentDts === void 0) track.maxSegmentDts = data.dts; else track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);
                }
            };
            var clearDtsInfo = function(track) {
                delete track.minSegmentDts;
                delete track.maxSegmentDts;
                delete track.minSegmentPts;
                delete track.maxSegmentPts;
            };
            var calculateTrackBaseMediaDecodeTime = function(track, keepOriginalTimestamps) {
                var baseMediaDecodeTime, scale, minSegmentDts = track.minSegmentDts;
                if (!keepOriginalTimestamps) minSegmentDts -= track.timelineStartInfo.dts;
                baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;
                baseMediaDecodeTime += minSegmentDts;
                baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);
                if (track.type === "audio") {
                    scale = track.samplerate / ONE_SECOND_IN_TS$3;
                    baseMediaDecodeTime *= scale;
                    baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);
                }
                return baseMediaDecodeTime;
            };
            var trackDecodeInfo$1 = {
                clearDtsInfo,
                calculateTrackBaseMediaDecodeTime,
                collectDtsInfo
            };
            var USER_DATA_REGISTERED_ITU_T_T35 = 4, RBSP_TRAILING_BITS = 128;
            var parseSei = function(bytes) {
                var i = 0, result = {
                    payloadType: -1,
                    payloadSize: 0
                }, payloadType = 0, payloadSize = 0;
                while (i < bytes.byteLength) {
                    if (bytes[i] === RBSP_TRAILING_BITS) break;
                    while (bytes[i] === 255) {
                        payloadType += 255;
                        i++;
                    }
                    payloadType += bytes[i++];
                    while (bytes[i] === 255) {
                        payloadSize += 255;
                        i++;
                    }
                    payloadSize += bytes[i++];
                    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {
                        var userIdentifier = String.fromCharCode(bytes[i + 3], bytes[i + 4], bytes[i + 5], bytes[i + 6]);
                        if (userIdentifier === "GA94") {
                            result.payloadType = payloadType;
                            result.payloadSize = payloadSize;
                            result.payload = bytes.subarray(i, i + payloadSize);
                            break;
                        } else result.payload = void 0;
                    }
                    i += payloadSize;
                    payloadType = 0;
                    payloadSize = 0;
                }
                return result;
            };
            var parseUserData = function(sei) {
                if (sei.payload[0] !== 181) return null;
                if ((sei.payload[1] << 8 | sei.payload[2]) !== 49) return null;
                if (String.fromCharCode(sei.payload[3], sei.payload[4], sei.payload[5], sei.payload[6]) !== "GA94") return null;
                if (sei.payload[7] !== 3) return null;
                return sei.payload.subarray(8, sei.payload.length - 1);
            };
            var parseCaptionPackets = function(pts, userData) {
                var i, count, offset, data, results = [];
                if (!(userData[0] & 64)) return results;
                count = userData[0] & 31;
                for (i = 0; i < count; i++) {
                    offset = i * 3;
                    data = {
                        type: userData[offset + 2] & 3,
                        pts
                    };
                    if (userData[offset + 2] & 4) {
                        data.ccData = userData[offset + 3] << 8 | userData[offset + 4];
                        results.push(data);
                    }
                }
                return results;
            };
            var discardEmulationPreventionBytes$1 = function(data) {
                var newLength, newData, length = data.byteLength, emulationPreventionBytesPositions = [], i = 1;
                while (i < length - 2) if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
                    emulationPreventionBytesPositions.push(i + 2);
                    i += 2;
                } else i++;
                if (emulationPreventionBytesPositions.length === 0) return data;
                newLength = length - emulationPreventionBytesPositions.length;
                newData = new Uint8Array(newLength);
                var sourceIndex = 0;
                for (i = 0; i < newLength; sourceIndex++, i++) {
                    if (sourceIndex === emulationPreventionBytesPositions[0]) {
                        sourceIndex++;
                        emulationPreventionBytesPositions.shift();
                    }
                    newData[i] = data[sourceIndex];
                }
                return newData;
            };
            var captionPacketParser = {
                parseSei,
                parseUserData,
                parseCaptionPackets,
                discardEmulationPreventionBytes: discardEmulationPreventionBytes$1,
                USER_DATA_REGISTERED_ITU_T_T35
            };
            var Stream$7 = stream;
            var cea708Parser = captionPacketParser;
            var CaptionStream$2 = function(options) {
                options = options || {};
                CaptionStream$2.prototype.init.call(this);
                this.parse708captions_ = typeof options.parse708captions === "boolean" ? options.parse708captions : true;
                this.captionPackets_ = [];
                this.ccStreams_ = [ new Cea608Stream(0, 0), new Cea608Stream(0, 1), new Cea608Stream(1, 0), new Cea608Stream(1, 1) ];
                if (this.parse708captions_) this.cc708Stream_ = new Cea708Stream({
                    captionServices: options.captionServices
                });
                this.reset();
                this.ccStreams_.forEach((function(cc) {
                    cc.on("data", this.trigger.bind(this, "data"));
                    cc.on("partialdone", this.trigger.bind(this, "partialdone"));
                    cc.on("done", this.trigger.bind(this, "done"));
                }), this);
                if (this.parse708captions_) {
                    this.cc708Stream_.on("data", this.trigger.bind(this, "data"));
                    this.cc708Stream_.on("partialdone", this.trigger.bind(this, "partialdone"));
                    this.cc708Stream_.on("done", this.trigger.bind(this, "done"));
                }
            };
            CaptionStream$2.prototype = new Stream$7;
            CaptionStream$2.prototype.push = function(event) {
                var sei, userData, newCaptionPackets;
                if (event.nalUnitType !== "sei_rbsp") return;
                sei = cea708Parser.parseSei(event.escapedRBSP);
                if (!sei.payload) return;
                if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) return;
                userData = cea708Parser.parseUserData(sei);
                if (!userData) return;
                if (event.dts < this.latestDts_) {
                    this.ignoreNextEqualDts_ = true;
                    return;
                } else if (event.dts === this.latestDts_ && this.ignoreNextEqualDts_) {
                    this.numSameDts_--;
                    if (!this.numSameDts_) this.ignoreNextEqualDts_ = false;
                    return;
                }
                newCaptionPackets = cea708Parser.parseCaptionPackets(event.pts, userData);
                this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);
                if (this.latestDts_ !== event.dts) this.numSameDts_ = 0;
                this.numSameDts_++;
                this.latestDts_ = event.dts;
            };
            CaptionStream$2.prototype.flushCCStreams = function(flushType) {
                this.ccStreams_.forEach((function(cc) {
                    return flushType === "flush" ? cc.flush() : cc.partialFlush();
                }), this);
            };
            CaptionStream$2.prototype.flushStream = function(flushType) {
                if (!this.captionPackets_.length) {
                    this.flushCCStreams(flushType);
                    return;
                }
                this.captionPackets_.forEach((function(elem, idx) {
                    elem.presortIndex = idx;
                }));
                this.captionPackets_.sort((function(a, b) {
                    if (a.pts === b.pts) return a.presortIndex - b.presortIndex;
                    return a.pts - b.pts;
                }));
                this.captionPackets_.forEach((function(packet) {
                    if (packet.type < 2) this.dispatchCea608Packet(packet); else this.dispatchCea708Packet(packet);
                }), this);
                this.captionPackets_.length = 0;
                this.flushCCStreams(flushType);
            };
            CaptionStream$2.prototype.flush = function() {
                return this.flushStream("flush");
            };
            CaptionStream$2.prototype.partialFlush = function() {
                return this.flushStream("partialFlush");
            };
            CaptionStream$2.prototype.reset = function() {
                this.latestDts_ = null;
                this.ignoreNextEqualDts_ = false;
                this.numSameDts_ = 0;
                this.activeCea608Channel_ = [ null, null ];
                this.ccStreams_.forEach((function(ccStream) {
                    ccStream.reset();
                }));
            };
            CaptionStream$2.prototype.dispatchCea608Packet = function(packet) {
                if (this.setsTextOrXDSActive(packet)) this.activeCea608Channel_[packet.type] = null; else if (this.setsChannel1Active(packet)) this.activeCea608Channel_[packet.type] = 0; else if (this.setsChannel2Active(packet)) this.activeCea608Channel_[packet.type] = 1;
                if (this.activeCea608Channel_[packet.type] === null) return;
                this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);
            };
            CaptionStream$2.prototype.setsChannel1Active = function(packet) {
                return (packet.ccData & 30720) === 4096;
            };
            CaptionStream$2.prototype.setsChannel2Active = function(packet) {
                return (packet.ccData & 30720) === 6144;
            };
            CaptionStream$2.prototype.setsTextOrXDSActive = function(packet) {
                return (packet.ccData & 28928) === 256 || (packet.ccData & 30974) === 4138 || (packet.ccData & 30974) === 6186;
            };
            CaptionStream$2.prototype.dispatchCea708Packet = function(packet) {
                if (this.parse708captions_) this.cc708Stream_.push(packet);
            };
            var CHARACTER_TRANSLATION_708 = {
                127: 9834,
                4128: 32,
                4129: 160,
                4133: 8230,
                4138: 352,
                4140: 338,
                4144: 9608,
                4145: 8216,
                4146: 8217,
                4147: 8220,
                4148: 8221,
                4149: 8226,
                4153: 8482,
                4154: 353,
                4156: 339,
                4157: 8480,
                4159: 376,
                4214: 8539,
                4215: 8540,
                4216: 8541,
                4217: 8542,
                4218: 9168,
                4219: 9124,
                4220: 9123,
                4221: 9135,
                4222: 9126,
                4223: 9121,
                4256: 12600
            };
            var get708CharFromCode = function(code) {
                var newCode = CHARACTER_TRANSLATION_708[code] || code;
                if (code & 4096 && code === newCode) return "";
                return String.fromCharCode(newCode);
            };
            var within708TextBlock = function(b) {
                return 32 <= b && b <= 127 || 160 <= b && b <= 255;
            };
            var Cea708Window = function(windowNum) {
                this.windowNum = windowNum;
                this.reset();
            };
            Cea708Window.prototype.reset = function() {
                this.clearText();
                this.pendingNewLine = false;
                this.winAttr = {};
                this.penAttr = {};
                this.penLoc = {};
                this.penColor = {};
                this.visible = 0;
                this.rowLock = 0;
                this.columnLock = 0;
                this.priority = 0;
                this.relativePositioning = 0;
                this.anchorVertical = 0;
                this.anchorHorizontal = 0;
                this.anchorPoint = 0;
                this.rowCount = 1;
                this.virtualRowCount = this.rowCount + 1;
                this.columnCount = 41;
                this.windowStyle = 0;
                this.penStyle = 0;
            };
            Cea708Window.prototype.getText = function() {
                return this.rows.join("\n");
            };
            Cea708Window.prototype.clearText = function() {
                this.rows = [ "" ];
                this.rowIdx = 0;
            };
            Cea708Window.prototype.newLine = function(pts) {
                if (this.rows.length >= this.virtualRowCount && typeof this.beforeRowOverflow === "function") this.beforeRowOverflow(pts);
                if (this.rows.length > 0) {
                    this.rows.push("");
                    this.rowIdx++;
                }
                while (this.rows.length > this.virtualRowCount) {
                    this.rows.shift();
                    this.rowIdx--;
                }
            };
            Cea708Window.prototype.isEmpty = function() {
                if (this.rows.length === 0) return true; else if (this.rows.length === 1) return this.rows[0] === "";
                return false;
            };
            Cea708Window.prototype.addText = function(text) {
                this.rows[this.rowIdx] += text;
            };
            Cea708Window.prototype.backspace = function() {
                if (!this.isEmpty()) {
                    var row = this.rows[this.rowIdx];
                    this.rows[this.rowIdx] = row.substr(0, row.length - 1);
                }
            };
            var Cea708Service = function(serviceNum, encoding, stream) {
                this.serviceNum = serviceNum;
                this.text = "";
                this.currentWindow = new Cea708Window(-1);
                this.windows = [];
                this.stream = stream;
                if (typeof encoding === "string") this.createTextDecoder(encoding);
            };
            Cea708Service.prototype.init = function(pts, beforeRowOverflow) {
                this.startPts = pts;
                for (var win = 0; win < 8; win++) {
                    this.windows[win] = new Cea708Window(win);
                    if (typeof beforeRowOverflow === "function") this.windows[win].beforeRowOverflow = beforeRowOverflow;
                }
            };
            Cea708Service.prototype.setCurrentWindow = function(windowNum) {
                this.currentWindow = this.windows[windowNum];
            };
            Cea708Service.prototype.createTextDecoder = function(encoding) {
                if (typeof TextDecoder === "undefined") this.stream.trigger("log", {
                    level: "warn",
                    message: "The `encoding` option is unsupported without TextDecoder support"
                }); else try {
                    this.textDecoder_ = new TextDecoder(encoding);
                } catch (error) {
                    this.stream.trigger("log", {
                        level: "warn",
                        message: "TextDecoder could not be created with " + encoding + " encoding. " + error
                    });
                }
            };
            var Cea708Stream = function(options) {
                options = options || {};
                Cea708Stream.prototype.init.call(this);
                var self = this;
                var captionServices = options.captionServices || {};
                var captionServiceEncodings = {};
                var serviceProps;
                Object.keys(captionServices).forEach((serviceName => {
                    serviceProps = captionServices[serviceName];
                    if (/^SERVICE/.test(serviceName)) captionServiceEncodings[serviceName] = serviceProps.encoding;
                }));
                this.serviceEncodings = captionServiceEncodings;
                this.current708Packet = null;
                this.services = {};
                this.push = function(packet) {
                    if (packet.type === 3) {
                        self.new708Packet();
                        self.add708Bytes(packet);
                    } else {
                        if (self.current708Packet === null) self.new708Packet();
                        self.add708Bytes(packet);
                    }
                };
            };
            Cea708Stream.prototype = new Stream$7;
            Cea708Stream.prototype.new708Packet = function() {
                if (this.current708Packet !== null) this.push708Packet();
                this.current708Packet = {
                    data: [],
                    ptsVals: []
                };
            };
            Cea708Stream.prototype.add708Bytes = function(packet) {
                var data = packet.ccData;
                var byte0 = data >>> 8;
                var byte1 = data & 255;
                this.current708Packet.ptsVals.push(packet.pts);
                this.current708Packet.data.push(byte0);
                this.current708Packet.data.push(byte1);
            };
            Cea708Stream.prototype.push708Packet = function() {
                var packet708 = this.current708Packet;
                var packetData = packet708.data;
                var serviceNum = null;
                var blockSize = null;
                var i = 0;
                var b = packetData[i++];
                packet708.seq = b >> 6;
                packet708.sizeCode = b & 63;
                for (;i < packetData.length; i++) {
                    b = packetData[i++];
                    serviceNum = b >> 5;
                    blockSize = b & 31;
                    if (serviceNum === 7 && blockSize > 0) {
                        b = packetData[i++];
                        serviceNum = b;
                    }
                    this.pushServiceBlock(serviceNum, i, blockSize);
                    if (blockSize > 0) i += blockSize - 1;
                }
            };
            Cea708Stream.prototype.pushServiceBlock = function(serviceNum, start, size) {
                var b;
                var i = start;
                var packetData = this.current708Packet.data;
                var service = this.services[serviceNum];
                if (!service) service = this.initService(serviceNum, i);
                for (;i < start + size && i < packetData.length; i++) {
                    b = packetData[i];
                    if (within708TextBlock(b)) i = this.handleText(i, service); else if (b === 24) i = this.multiByteCharacter(i, service); else if (b === 16) i = this.extendedCommands(i, service); else if (128 <= b && b <= 135) i = this.setCurrentWindow(i, service); else if (152 <= b && b <= 159) i = this.defineWindow(i, service); else if (b === 136) i = this.clearWindows(i, service); else if (b === 140) i = this.deleteWindows(i, service); else if (b === 137) i = this.displayWindows(i, service); else if (b === 138) i = this.hideWindows(i, service); else if (b === 139) i = this.toggleWindows(i, service); else if (b === 151) i = this.setWindowAttributes(i, service); else if (b === 144) i = this.setPenAttributes(i, service); else if (b === 145) i = this.setPenColor(i, service); else if (b === 146) i = this.setPenLocation(i, service); else if (b === 143) service = this.reset(i, service); else if (b === 8) service.currentWindow.backspace(); else if (b === 12) service.currentWindow.clearText(); else if (b === 13) service.currentWindow.pendingNewLine = true; else if (b === 14) service.currentWindow.clearText(); else if (b === 141) i++;
                }
            };
            Cea708Stream.prototype.extendedCommands = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                if (within708TextBlock(b)) i = this.handleText(i, service, {
                    isExtended: true
                });
                return i;
            };
            Cea708Stream.prototype.getPts = function(byteIndex) {
                return this.current708Packet.ptsVals[Math.floor(byteIndex / 2)];
            };
            Cea708Stream.prototype.initService = function(serviceNum, i) {
                var serviceName = "SERVICE" + serviceNum;
                var self = this;
                var encoding;
                if (serviceName in this.serviceEncodings) encoding = this.serviceEncodings[serviceName];
                this.services[serviceNum] = new Cea708Service(serviceNum, encoding, self);
                this.services[serviceNum].init(this.getPts(i), (function(pts) {
                    self.flushDisplayed(pts, self.services[serviceNum]);
                }));
                return this.services[serviceNum];
            };
            Cea708Stream.prototype.handleText = function(i, service, options) {
                var isExtended = options && options.isExtended;
                var isMultiByte = options && options.isMultiByte;
                var packetData = this.current708Packet.data;
                var extended = isExtended ? 4096 : 0;
                var currentByte = packetData[i];
                var nextByte = packetData[i + 1];
                var win = service.currentWindow;
                var char;
                var charCodeArray;
                if (service.textDecoder_ && !isExtended) {
                    if (isMultiByte) {
                        charCodeArray = [ currentByte, nextByte ];
                        i++;
                    } else charCodeArray = [ currentByte ];
                    char = service.textDecoder_.decode(new Uint8Array(charCodeArray));
                } else char = get708CharFromCode(extended | currentByte);
                if (win.pendingNewLine && !win.isEmpty()) win.newLine(this.getPts(i));
                win.pendingNewLine = false;
                win.addText(char);
                return i;
            };
            Cea708Stream.prototype.multiByteCharacter = function(i, service) {
                var packetData = this.current708Packet.data;
                var firstByte = packetData[i + 1];
                var secondByte = packetData[i + 2];
                if (within708TextBlock(firstByte) && within708TextBlock(secondByte)) i = this.handleText(++i, service, {
                    isMultiByte: true
                });
                return i;
            };
            Cea708Stream.prototype.setCurrentWindow = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var windowNum = b & 7;
                service.setCurrentWindow(windowNum);
                return i;
            };
            Cea708Stream.prototype.defineWindow = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var windowNum = b & 7;
                service.setCurrentWindow(windowNum);
                var win = service.currentWindow;
                b = packetData[++i];
                win.visible = (b & 32) >> 5;
                win.rowLock = (b & 16) >> 4;
                win.columnLock = (b & 8) >> 3;
                win.priority = b & 7;
                b = packetData[++i];
                win.relativePositioning = (b & 128) >> 7;
                win.anchorVertical = b & 127;
                b = packetData[++i];
                win.anchorHorizontal = b;
                b = packetData[++i];
                win.anchorPoint = (b & 240) >> 4;
                win.rowCount = b & 15;
                b = packetData[++i];
                win.columnCount = b & 63;
                b = packetData[++i];
                win.windowStyle = (b & 56) >> 3;
                win.penStyle = b & 7;
                win.virtualRowCount = win.rowCount + 1;
                return i;
            };
            Cea708Stream.prototype.setWindowAttributes = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var winAttr = service.currentWindow.winAttr;
                b = packetData[++i];
                winAttr.fillOpacity = (b & 192) >> 6;
                winAttr.fillRed = (b & 48) >> 4;
                winAttr.fillGreen = (b & 12) >> 2;
                winAttr.fillBlue = b & 3;
                b = packetData[++i];
                winAttr.borderType = (b & 192) >> 6;
                winAttr.borderRed = (b & 48) >> 4;
                winAttr.borderGreen = (b & 12) >> 2;
                winAttr.borderBlue = b & 3;
                b = packetData[++i];
                winAttr.borderType += (b & 128) >> 5;
                winAttr.wordWrap = (b & 64) >> 6;
                winAttr.printDirection = (b & 48) >> 4;
                winAttr.scrollDirection = (b & 12) >> 2;
                winAttr.justify = b & 3;
                b = packetData[++i];
                winAttr.effectSpeed = (b & 240) >> 4;
                winAttr.effectDirection = (b & 12) >> 2;
                winAttr.displayEffect = b & 3;
                return i;
            };
            Cea708Stream.prototype.flushDisplayed = function(pts, service) {
                var displayedText = [];
                for (var winId = 0; winId < 8; winId++) if (service.windows[winId].visible && !service.windows[winId].isEmpty()) displayedText.push(service.windows[winId].getText());
                service.endPts = pts;
                service.text = displayedText.join("\n\n");
                this.pushCaption(service);
                service.startPts = pts;
            };
            Cea708Stream.prototype.pushCaption = function(service) {
                if (service.text !== "") {
                    this.trigger("data", {
                        startPts: service.startPts,
                        endPts: service.endPts,
                        text: service.text,
                        stream: "cc708_" + service.serviceNum
                    });
                    service.text = "";
                    service.startPts = service.endPts;
                }
            };
            Cea708Stream.prototype.displayWindows = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                for (var winId = 0; winId < 8; winId++) if (b & 1 << winId) service.windows[winId].visible = 1;
                return i;
            };
            Cea708Stream.prototype.hideWindows = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                for (var winId = 0; winId < 8; winId++) if (b & 1 << winId) service.windows[winId].visible = 0;
                return i;
            };
            Cea708Stream.prototype.toggleWindows = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                for (var winId = 0; winId < 8; winId++) if (b & 1 << winId) service.windows[winId].visible ^= 1;
                return i;
            };
            Cea708Stream.prototype.clearWindows = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                for (var winId = 0; winId < 8; winId++) if (b & 1 << winId) service.windows[winId].clearText();
                return i;
            };
            Cea708Stream.prototype.deleteWindows = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[++i];
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                for (var winId = 0; winId < 8; winId++) if (b & 1 << winId) service.windows[winId].reset();
                return i;
            };
            Cea708Stream.prototype.setPenAttributes = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var penAttr = service.currentWindow.penAttr;
                b = packetData[++i];
                penAttr.textTag = (b & 240) >> 4;
                penAttr.offset = (b & 12) >> 2;
                penAttr.penSize = b & 3;
                b = packetData[++i];
                penAttr.italics = (b & 128) >> 7;
                penAttr.underline = (b & 64) >> 6;
                penAttr.edgeType = (b & 56) >> 3;
                penAttr.fontStyle = b & 7;
                return i;
            };
            Cea708Stream.prototype.setPenColor = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var penColor = service.currentWindow.penColor;
                b = packetData[++i];
                penColor.fgOpacity = (b & 192) >> 6;
                penColor.fgRed = (b & 48) >> 4;
                penColor.fgGreen = (b & 12) >> 2;
                penColor.fgBlue = b & 3;
                b = packetData[++i];
                penColor.bgOpacity = (b & 192) >> 6;
                penColor.bgRed = (b & 48) >> 4;
                penColor.bgGreen = (b & 12) >> 2;
                penColor.bgBlue = b & 3;
                b = packetData[++i];
                penColor.edgeRed = (b & 48) >> 4;
                penColor.edgeGreen = (b & 12) >> 2;
                penColor.edgeBlue = b & 3;
                return i;
            };
            Cea708Stream.prototype.setPenLocation = function(i, service) {
                var packetData = this.current708Packet.data;
                var b = packetData[i];
                var penLoc = service.currentWindow.penLoc;
                service.currentWindow.pendingNewLine = true;
                b = packetData[++i];
                penLoc.row = b & 15;
                b = packetData[++i];
                penLoc.column = b & 63;
                return i;
            };
            Cea708Stream.prototype.reset = function(i, service) {
                var pts = this.getPts(i);
                this.flushDisplayed(pts, service);
                return this.initService(service.serviceNum, i);
            };
            var CHARACTER_TRANSLATION = {
                42: 225,
                92: 233,
                94: 237,
                95: 243,
                96: 250,
                123: 231,
                124: 247,
                125: 209,
                126: 241,
                127: 9608,
                304: 174,
                305: 176,
                306: 189,
                307: 191,
                308: 8482,
                309: 162,
                310: 163,
                311: 9834,
                312: 224,
                313: 160,
                314: 232,
                315: 226,
                316: 234,
                317: 238,
                318: 244,
                319: 251,
                544: 193,
                545: 201,
                546: 211,
                547: 218,
                548: 220,
                549: 252,
                550: 8216,
                551: 161,
                552: 42,
                553: 39,
                554: 8212,
                555: 169,
                556: 8480,
                557: 8226,
                558: 8220,
                559: 8221,
                560: 192,
                561: 194,
                562: 199,
                563: 200,
                564: 202,
                565: 203,
                566: 235,
                567: 206,
                568: 207,
                569: 239,
                570: 212,
                571: 217,
                572: 249,
                573: 219,
                574: 171,
                575: 187,
                800: 195,
                801: 227,
                802: 205,
                803: 204,
                804: 236,
                805: 210,
                806: 242,
                807: 213,
                808: 245,
                809: 123,
                810: 125,
                811: 92,
                812: 94,
                813: 95,
                814: 124,
                815: 126,
                816: 196,
                817: 228,
                818: 214,
                819: 246,
                820: 223,
                821: 165,
                822: 164,
                823: 9474,
                824: 197,
                825: 229,
                826: 216,
                827: 248,
                828: 9484,
                829: 9488,
                830: 9492,
                831: 9496
            };
            var getCharFromCode = function(code) {
                if (code === null) return "";
                code = CHARACTER_TRANSLATION[code] || code;
                return String.fromCharCode(code);
            };
            var BOTTOM_ROW = 14;
            var ROWS = [ 4352, 4384, 4608, 4640, 5376, 5408, 5632, 5664, 5888, 5920, 4096, 4864, 4896, 5120, 5152 ];
            var createDisplayBuffer = function() {
                var result = [], i = BOTTOM_ROW + 1;
                while (i--) result.push("");
                return result;
            };
            var Cea608Stream = function(field, dataChannel) {
                Cea608Stream.prototype.init.call(this);
                this.field_ = field || 0;
                this.dataChannel_ = dataChannel || 0;
                this.name_ = "CC" + ((this.field_ << 1 | this.dataChannel_) + 1);
                this.setConstants();
                this.reset();
                this.push = function(packet) {
                    var data, swap, char0, char1, text;
                    data = packet.ccData & 32639;
                    if (data === this.lastControlCode_) {
                        this.lastControlCode_ = null;
                        return;
                    }
                    if ((data & 61440) === 4096) this.lastControlCode_ = data; else if (data !== this.PADDING_) this.lastControlCode_ = null;
                    char0 = data >>> 8;
                    char1 = data & 255;
                    if (data === this.PADDING_) return; else if (data === this.RESUME_CAPTION_LOADING_) this.mode_ = "popOn"; else if (data === this.END_OF_CAPTION_) {
                        this.mode_ = "popOn";
                        this.clearFormatting(packet.pts);
                        this.flushDisplayed(packet.pts);
                        swap = this.displayed_;
                        this.displayed_ = this.nonDisplayed_;
                        this.nonDisplayed_ = swap;
                        this.startPts_ = packet.pts;
                    } else if (data === this.ROLL_UP_2_ROWS_) {
                        this.rollUpRows_ = 2;
                        this.setRollUp(packet.pts);
                    } else if (data === this.ROLL_UP_3_ROWS_) {
                        this.rollUpRows_ = 3;
                        this.setRollUp(packet.pts);
                    } else if (data === this.ROLL_UP_4_ROWS_) {
                        this.rollUpRows_ = 4;
                        this.setRollUp(packet.pts);
                    } else if (data === this.CARRIAGE_RETURN_) {
                        this.clearFormatting(packet.pts);
                        this.flushDisplayed(packet.pts);
                        this.shiftRowsUp_();
                        this.startPts_ = packet.pts;
                    } else if (data === this.BACKSPACE_) if (this.mode_ === "popOn") this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1); else this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1); else if (data === this.ERASE_DISPLAYED_MEMORY_) {
                        this.flushDisplayed(packet.pts);
                        this.displayed_ = createDisplayBuffer();
                    } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) this.nonDisplayed_ = createDisplayBuffer(); else if (data === this.RESUME_DIRECT_CAPTIONING_) {
                        if (this.mode_ !== "paintOn") {
                            this.flushDisplayed(packet.pts);
                            this.displayed_ = createDisplayBuffer();
                        }
                        this.mode_ = "paintOn";
                        this.startPts_ = packet.pts;
                    } else if (this.isSpecialCharacter(char0, char1)) {
                        char0 = (char0 & 3) << 8;
                        text = getCharFromCode(char0 | char1);
                        this[this.mode_](packet.pts, text);
                        this.column_++;
                    } else if (this.isExtCharacter(char0, char1)) {
                        if (this.mode_ === "popOn") this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1); else this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);
                        char0 = (char0 & 3) << 8;
                        text = getCharFromCode(char0 | char1);
                        this[this.mode_](packet.pts, text);
                        this.column_++;
                    } else if (this.isMidRowCode(char0, char1)) {
                        this.clearFormatting(packet.pts);
                        this[this.mode_](packet.pts, " ");
                        this.column_++;
                        if ((char1 & 14) === 14) this.addFormatting(packet.pts, [ "i" ]);
                        if ((char1 & 1) === 1) this.addFormatting(packet.pts, [ "u" ]);
                    } else if (this.isOffsetControlCode(char0, char1)) this.column_ += char1 & 3; else if (this.isPAC(char0, char1)) {
                        var row = ROWS.indexOf(data & 7968);
                        if (this.mode_ === "rollUp") {
                            if (row - this.rollUpRows_ + 1 < 0) row = this.rollUpRows_ - 1;
                            this.setRollUp(packet.pts, row);
                        }
                        if (row !== this.row_) {
                            this.clearFormatting(packet.pts);
                            this.row_ = row;
                        }
                        if (char1 & 1 && this.formatting_.indexOf("u") === -1) this.addFormatting(packet.pts, [ "u" ]);
                        if ((data & 16) === 16) this.column_ = ((data & 14) >> 1) * 4;
                        if (this.isColorPAC(char1)) if ((char1 & 14) === 14) this.addFormatting(packet.pts, [ "i" ]);
                    } else if (this.isNormalChar(char0)) {
                        if (char1 === 0) char1 = null;
                        text = getCharFromCode(char0);
                        text += getCharFromCode(char1);
                        this[this.mode_](packet.pts, text);
                        this.column_ += text.length;
                    }
                };
            };
            Cea608Stream.prototype = new Stream$7;
            Cea608Stream.prototype.flushDisplayed = function(pts) {
                var content = this.displayed_.map((function(row, index) {
                    try {
                        return row.trim();
                    } catch (e) {
                        this.trigger("log", {
                            level: "warn",
                            message: "Skipping a malformed 608 caption at index " + index + "."
                        });
                        return "";
                    }
                }), this).join("\n").replace(/^\n+|\n+$/g, "");
                if (content.length) this.trigger("data", {
                    startPts: this.startPts_,
                    endPts: pts,
                    text: content,
                    stream: this.name_
                });
            };
            Cea608Stream.prototype.reset = function() {
                this.mode_ = "popOn";
                this.topRow_ = 0;
                this.startPts_ = 0;
                this.displayed_ = createDisplayBuffer();
                this.nonDisplayed_ = createDisplayBuffer();
                this.lastControlCode_ = null;
                this.column_ = 0;
                this.row_ = BOTTOM_ROW;
                this.rollUpRows_ = 2;
                this.formatting_ = [];
            };
            Cea608Stream.prototype.setConstants = function() {
                if (this.dataChannel_ === 0) {
                    this.BASE_ = 16;
                    this.EXT_ = 17;
                    this.CONTROL_ = (20 | this.field_) << 8;
                    this.OFFSET_ = 23;
                } else if (this.dataChannel_ === 1) {
                    this.BASE_ = 24;
                    this.EXT_ = 25;
                    this.CONTROL_ = (28 | this.field_) << 8;
                    this.OFFSET_ = 31;
                }
                this.PADDING_ = 0;
                this.RESUME_CAPTION_LOADING_ = this.CONTROL_ | 32;
                this.END_OF_CAPTION_ = this.CONTROL_ | 47;
                this.ROLL_UP_2_ROWS_ = this.CONTROL_ | 37;
                this.ROLL_UP_3_ROWS_ = this.CONTROL_ | 38;
                this.ROLL_UP_4_ROWS_ = this.CONTROL_ | 39;
                this.CARRIAGE_RETURN_ = this.CONTROL_ | 45;
                this.RESUME_DIRECT_CAPTIONING_ = this.CONTROL_ | 41;
                this.BACKSPACE_ = this.CONTROL_ | 33;
                this.ERASE_DISPLAYED_MEMORY_ = this.CONTROL_ | 44;
                this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 46;
            };
            Cea608Stream.prototype.isSpecialCharacter = function(char0, char1) {
                return char0 === this.EXT_ && char1 >= 48 && char1 <= 63;
            };
            Cea608Stream.prototype.isExtCharacter = function(char0, char1) {
                return (char0 === this.EXT_ + 1 || char0 === this.EXT_ + 2) && char1 >= 32 && char1 <= 63;
            };
            Cea608Stream.prototype.isMidRowCode = function(char0, char1) {
                return char0 === this.EXT_ && char1 >= 32 && char1 <= 47;
            };
            Cea608Stream.prototype.isOffsetControlCode = function(char0, char1) {
                return char0 === this.OFFSET_ && char1 >= 33 && char1 <= 35;
            };
            Cea608Stream.prototype.isPAC = function(char0, char1) {
                return char0 >= this.BASE_ && char0 < this.BASE_ + 8 && char1 >= 64 && char1 <= 127;
            };
            Cea608Stream.prototype.isColorPAC = function(char1) {
                return char1 >= 64 && char1 <= 79 || char1 >= 96 && char1 <= 127;
            };
            Cea608Stream.prototype.isNormalChar = function(char) {
                return char >= 32 && char <= 127;
            };
            Cea608Stream.prototype.setRollUp = function(pts, newBaseRow) {
                if (this.mode_ !== "rollUp") {
                    this.row_ = BOTTOM_ROW;
                    this.mode_ = "rollUp";
                    this.flushDisplayed(pts);
                    this.nonDisplayed_ = createDisplayBuffer();
                    this.displayed_ = createDisplayBuffer();
                }
                if (newBaseRow !== void 0 && newBaseRow !== this.row_) for (var i = 0; i < this.rollUpRows_; i++) {
                    this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];
                    this.displayed_[this.row_ - i] = "";
                }
                if (newBaseRow === void 0) newBaseRow = this.row_;
                this.topRow_ = newBaseRow - this.rollUpRows_ + 1;
            };
            Cea608Stream.prototype.addFormatting = function(pts, format) {
                this.formatting_ = this.formatting_.concat(format);
                var text = format.reduce((function(text, format) {
                    return text + "<" + format + ">";
                }), "");
                this[this.mode_](pts, text);
            };
            Cea608Stream.prototype.clearFormatting = function(pts) {
                if (!this.formatting_.length) return;
                var text = this.formatting_.reverse().reduce((function(text, format) {
                    return text + "</" + format + ">";
                }), "");
                this.formatting_ = [];
                this[this.mode_](pts, text);
            };
            Cea608Stream.prototype.popOn = function(pts, text) {
                var baseRow = this.nonDisplayed_[this.row_];
                baseRow += text;
                this.nonDisplayed_[this.row_] = baseRow;
            };
            Cea608Stream.prototype.rollUp = function(pts, text) {
                var baseRow = this.displayed_[this.row_];
                baseRow += text;
                this.displayed_[this.row_] = baseRow;
            };
            Cea608Stream.prototype.shiftRowsUp_ = function() {
                var i;
                for (i = 0; i < this.topRow_; i++) this.displayed_[i] = "";
                for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) this.displayed_[i] = "";
                for (i = this.topRow_; i < this.row_; i++) this.displayed_[i] = this.displayed_[i + 1];
                this.displayed_[this.row_] = "";
            };
            Cea608Stream.prototype.paintOn = function(pts, text) {
                var baseRow = this.displayed_[this.row_];
                baseRow += text;
                this.displayed_[this.row_] = baseRow;
            };
            var captionStream = {
                CaptionStream: CaptionStream$2,
                Cea608Stream,
                Cea708Stream
            };
            var streamTypes = {
                H264_STREAM_TYPE: 27,
                ADTS_STREAM_TYPE: 15,
                METADATA_STREAM_TYPE: 21
            };
            var Stream$6 = stream;
            var MAX_TS = 8589934592;
            var RO_THRESH = 4294967296;
            var TYPE_SHARED = "shared";
            var handleRollover$1 = function(value, reference) {
                var direction = 1;
                if (value > reference) direction = -1;
                while (Math.abs(reference - value) > RO_THRESH) value += direction * MAX_TS;
                return value;
            };
            var TimestampRolloverStream$1 = function(type) {
                var lastDTS, referenceDTS;
                TimestampRolloverStream$1.prototype.init.call(this);
                this.type_ = type || TYPE_SHARED;
                this.push = function(data) {
                    if (this.type_ !== TYPE_SHARED && data.type !== this.type_) return;
                    if (referenceDTS === void 0) referenceDTS = data.dts;
                    data.dts = handleRollover$1(data.dts, referenceDTS);
                    data.pts = handleRollover$1(data.pts, referenceDTS);
                    lastDTS = data.dts;
                    this.trigger("data", data);
                };
                this.flush = function() {
                    referenceDTS = lastDTS;
                    this.trigger("done");
                };
                this.endTimeline = function() {
                    this.flush();
                    this.trigger("endedtimeline");
                };
                this.discontinuity = function() {
                    referenceDTS = void 0;
                    lastDTS = void 0;
                };
                this.reset = function() {
                    this.discontinuity();
                    this.trigger("reset");
                };
            };
            TimestampRolloverStream$1.prototype = new Stream$6;
            var timestampRolloverStream = {
                TimestampRolloverStream: TimestampRolloverStream$1,
                handleRollover: handleRollover$1
            };
            var typedArrayIndexOf$1 = (typedArray, element, fromIndex) => {
                if (!typedArray) return -1;
                var currentIndex = fromIndex;
                for (;currentIndex < typedArray.length; currentIndex++) if (typedArray[currentIndex] === element) return currentIndex;
                return -1;
            };
            var typedArray = {
                typedArrayIndexOf: typedArrayIndexOf$1
            };
            var typedArrayIndexOf = typedArray.typedArrayIndexOf, textEncodingDescriptionByte = {
                Iso88591: 0,
                Utf16: 1,
                Utf16be: 2,
                Utf8: 3
            }, percentEncode$1 = function(bytes, start, end) {
                var i, result = "";
                for (i = start; i < end; i++) result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
                return result;
            }, parseUtf8 = function(bytes, start, end) {
                return decodeURIComponent(percentEncode$1(bytes, start, end));
            }, parseIso88591$1 = function(bytes, start, end) {
                return unescape(percentEncode$1(bytes, start, end));
            }, parseSyncSafeInteger$1 = function(data) {
                return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
            }, frameParsers = {
                APIC: function(frame) {
                    var mimeTypeEndIndex, descriptionEndIndex, i = 1, LINK_MIME_TYPE = "--\x3e";
                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) return;
                    mimeTypeEndIndex = typedArrayIndexOf(frame.data, 0, i);
                    if (mimeTypeEndIndex < 0) return;
                    frame.mimeType = parseIso88591$1(frame.data, i, mimeTypeEndIndex);
                    i = mimeTypeEndIndex + 1;
                    frame.pictureType = frame.data[i];
                    i++;
                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, i);
                    if (descriptionEndIndex < 0) return;
                    frame.description = parseUtf8(frame.data, i, descriptionEndIndex);
                    i = descriptionEndIndex + 1;
                    if (frame.mimeType === LINK_MIME_TYPE) frame.url = parseIso88591$1(frame.data, i, frame.data.length); else frame.pictureData = frame.data.subarray(i, frame.data.length);
                },
                "T*": function(frame) {
                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) return;
                    frame.value = parseUtf8(frame.data, 1, frame.data.length).replace(/\0*$/, "");
                    frame.values = frame.value.split("\0");
                },
                TXXX: function(frame) {
                    var descriptionEndIndex;
                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) return;
                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);
                    if (descriptionEndIndex === -1) return;
                    frame.description = parseUtf8(frame.data, 1, descriptionEndIndex);
                    frame.value = parseUtf8(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\0*$/, "");
                    frame.data = frame.value;
                },
                "W*": function(frame) {
                    frame.url = parseIso88591$1(frame.data, 0, frame.data.length).replace(/\0.*$/, "");
                },
                WXXX: function(frame) {
                    var descriptionEndIndex;
                    if (frame.data[0] !== textEncodingDescriptionByte.Utf8) return;
                    descriptionEndIndex = typedArrayIndexOf(frame.data, 0, 1);
                    if (descriptionEndIndex === -1) return;
                    frame.description = parseUtf8(frame.data, 1, descriptionEndIndex);
                    frame.url = parseIso88591$1(frame.data, descriptionEndIndex + 1, frame.data.length).replace(/\0.*$/, "");
                },
                PRIV: function(frame) {
                    var i;
                    for (i = 0; i < frame.data.length; i++) if (frame.data[i] === 0) {
                        frame.owner = parseIso88591$1(frame.data, 0, i);
                        break;
                    }
                    frame.privateData = frame.data.subarray(i + 1);
                    frame.data = frame.privateData;
                }
            };
            var parseId3Frames$1 = function(data) {
                var frameSize, frameHeader, frameStart = 10, tagSize = 0, frames = [];
                if (data.length < 10 || data[0] !== "I".charCodeAt(0) || data[1] !== "D".charCodeAt(0) || data[2] !== "3".charCodeAt(0)) return;
                tagSize = parseSyncSafeInteger$1(data.subarray(6, 10));
                tagSize += 10;
                var hasExtendedHeader = data[5] & 64;
                if (hasExtendedHeader) {
                    frameStart += 4;
                    frameStart += parseSyncSafeInteger$1(data.subarray(10, 14));
                    tagSize -= parseSyncSafeInteger$1(data.subarray(16, 20));
                }
                do {
                    frameSize = parseSyncSafeInteger$1(data.subarray(frameStart + 4, frameStart + 8));
                    if (frameSize < 1) break;
                    frameHeader = String.fromCharCode(data[frameStart], data[frameStart + 1], data[frameStart + 2], data[frameStart + 3]);
                    var frame = {
                        id: frameHeader,
                        data: data.subarray(frameStart + 10, frameStart + frameSize + 10)
                    };
                    frame.key = frame.id;
                    if (frameParsers[frame.id]) frameParsers[frame.id](frame); else if (frame.id[0] === "T") frameParsers["T*"](frame); else if (frame.id[0] === "W") frameParsers["W*"](frame);
                    frames.push(frame);
                    frameStart += 10;
                    frameStart += frameSize;
                } while (frameStart < tagSize);
                return frames;
            };
            var parseId3 = {
                parseId3Frames: parseId3Frames$1,
                parseSyncSafeInteger: parseSyncSafeInteger$1,
                frameParsers
            };
            var MetadataStream, Stream$5 = stream, StreamTypes$3 = streamTypes, id3 = parseId3;
            MetadataStream = function(options) {
                var i, settings = {
                    descriptor: options && options.descriptor
                }, tagSize = 0, buffer = [], bufferSize = 0;
                MetadataStream.prototype.init.call(this);
                this.dispatchType = StreamTypes$3.METADATA_STREAM_TYPE.toString(16);
                if (settings.descriptor) for (i = 0; i < settings.descriptor.length; i++) this.dispatchType += ("00" + settings.descriptor[i].toString(16)).slice(-2);
                this.push = function(chunk) {
                    var tag, frameStart, frameSize, frame, i, frameHeader;
                    if (chunk.type !== "timed-metadata") return;
                    if (chunk.dataAlignmentIndicator) {
                        bufferSize = 0;
                        buffer.length = 0;
                    }
                    if (buffer.length === 0 && (chunk.data.length < 10 || chunk.data[0] !== "I".charCodeAt(0) || chunk.data[1] !== "D".charCodeAt(0) || chunk.data[2] !== "3".charCodeAt(0))) {
                        this.trigger("log", {
                            level: "warn",
                            message: "Skipping unrecognized metadata packet"
                        });
                        return;
                    }
                    buffer.push(chunk);
                    bufferSize += chunk.data.byteLength;
                    if (buffer.length === 1) {
                        tagSize = id3.parseSyncSafeInteger(chunk.data.subarray(6, 10));
                        tagSize += 10;
                    }
                    if (bufferSize < tagSize) return;
                    tag = {
                        data: new Uint8Array(tagSize),
                        frames: [],
                        pts: buffer[0].pts,
                        dts: buffer[0].dts
                    };
                    for (i = 0; i < tagSize; ) {
                        tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);
                        i += buffer[0].data.byteLength;
                        bufferSize -= buffer[0].data.byteLength;
                        buffer.shift();
                    }
                    frameStart = 10;
                    if (tag.data[5] & 64) {
                        frameStart += 4;
                        frameStart += id3.parseSyncSafeInteger(tag.data.subarray(10, 14));
                        tagSize -= id3.parseSyncSafeInteger(tag.data.subarray(16, 20));
                    }
                    do {
                        frameSize = id3.parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));
                        if (frameSize < 1) {
                            this.trigger("log", {
                                level: "warn",
                                message: "Malformed ID3 frame encountered. Skipping remaining metadata parsing."
                            });
                            break;
                        }
                        frameHeader = String.fromCharCode(tag.data[frameStart], tag.data[frameStart + 1], tag.data[frameStart + 2], tag.data[frameStart + 3]);
                        frame = {
                            id: frameHeader,
                            data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)
                        };
                        frame.key = frame.id;
                        if (id3.frameParsers[frame.id]) id3.frameParsers[frame.id](frame); else if (frame.id[0] === "T") id3.frameParsers["T*"](frame); else if (frame.id[0] === "W") id3.frameParsers["W*"](frame);
                        if (frame.owner === "com.apple.streaming.transportStreamTimestamp") {
                            var d = frame.data, size = (d[3] & 1) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
                            size *= 4;
                            size += d[7] & 3;
                            frame.timeStamp = size;
                            if (tag.pts === void 0 && tag.dts === void 0) {
                                tag.pts = frame.timeStamp;
                                tag.dts = frame.timeStamp;
                            }
                            this.trigger("timestamp", frame);
                        }
                        tag.frames.push(frame);
                        frameStart += 10;
                        frameStart += frameSize;
                    } while (frameStart < tagSize);
                    this.trigger("data", tag);
                };
            };
            MetadataStream.prototype = new Stream$5;
            var metadataStream = MetadataStream;
            var Stream$4 = stream, CaptionStream$1 = captionStream, StreamTypes$2 = streamTypes, TimestampRolloverStream = timestampRolloverStream.TimestampRolloverStream;
            var TransportPacketStream, TransportParseStream, ElementaryStream;
            var MP2T_PACKET_LENGTH$1 = 188, SYNC_BYTE$1 = 71;
            TransportPacketStream = function() {
                var buffer = new Uint8Array(MP2T_PACKET_LENGTH$1), bytesInBuffer = 0;
                TransportPacketStream.prototype.init.call(this);
                this.push = function(bytes) {
                    var everything, startIndex = 0, endIndex = MP2T_PACKET_LENGTH$1;
                    if (bytesInBuffer) {
                        everything = new Uint8Array(bytes.byteLength + bytesInBuffer);
                        everything.set(buffer.subarray(0, bytesInBuffer));
                        everything.set(bytes, bytesInBuffer);
                        bytesInBuffer = 0;
                    } else everything = bytes;
                    while (endIndex < everything.byteLength) {
                        if (everything[startIndex] === SYNC_BYTE$1 && everything[endIndex] === SYNC_BYTE$1) {
                            this.trigger("data", everything.subarray(startIndex, endIndex));
                            startIndex += MP2T_PACKET_LENGTH$1;
                            endIndex += MP2T_PACKET_LENGTH$1;
                            continue;
                        }
                        startIndex++;
                        endIndex++;
                    }
                    if (startIndex < everything.byteLength) {
                        buffer.set(everything.subarray(startIndex), 0);
                        bytesInBuffer = everything.byteLength - startIndex;
                    }
                };
                this.flush = function() {
                    if (bytesInBuffer === MP2T_PACKET_LENGTH$1 && buffer[0] === SYNC_BYTE$1) {
                        this.trigger("data", buffer);
                        bytesInBuffer = 0;
                    }
                    this.trigger("done");
                };
                this.endTimeline = function() {
                    this.flush();
                    this.trigger("endedtimeline");
                };
                this.reset = function() {
                    bytesInBuffer = 0;
                    this.trigger("reset");
                };
            };
            TransportPacketStream.prototype = new Stream$4;
            TransportParseStream = function() {
                var parsePsi, parsePat, parsePmt, self;
                TransportParseStream.prototype.init.call(this);
                self = this;
                this.packetsWaitingForPmt = [];
                this.programMapTable = void 0;
                parsePsi = function(payload, psi) {
                    var offset = 0;
                    if (psi.payloadUnitStartIndicator) offset += payload[offset] + 1;
                    if (psi.type === "pat") parsePat(payload.subarray(offset), psi); else parsePmt(payload.subarray(offset), psi);
                };
                parsePat = function(payload, pat) {
                    pat.section_number = payload[7];
                    pat.last_section_number = payload[8];
                    self.pmtPid = (payload[10] & 31) << 8 | payload[11];
                    pat.pmtPid = self.pmtPid;
                };
                parsePmt = function(payload, pmt) {
                    var sectionLength, tableEnd, programInfoLength, offset;
                    if (!(payload[5] & 1)) return;
                    self.programMapTable = {
                        video: null,
                        audio: null,
                        "timed-metadata": {}
                    };
                    sectionLength = (payload[1] & 15) << 8 | payload[2];
                    tableEnd = 3 + sectionLength - 4;
                    programInfoLength = (payload[10] & 15) << 8 | payload[11];
                    offset = 12 + programInfoLength;
                    while (offset < tableEnd) {
                        var streamType = payload[offset];
                        var pid = (payload[offset + 1] & 31) << 8 | payload[offset + 2];
                        if (streamType === StreamTypes$2.H264_STREAM_TYPE && self.programMapTable.video === null) self.programMapTable.video = pid; else if (streamType === StreamTypes$2.ADTS_STREAM_TYPE && self.programMapTable.audio === null) self.programMapTable.audio = pid; else if (streamType === StreamTypes$2.METADATA_STREAM_TYPE) self.programMapTable["timed-metadata"][pid] = streamType;
                        offset += ((payload[offset + 3] & 15) << 8 | payload[offset + 4]) + 5;
                    }
                    pmt.programMapTable = self.programMapTable;
                };
                this.push = function(packet) {
                    var result = {}, offset = 4;
                    result.payloadUnitStartIndicator = !!(packet[1] & 64);
                    result.pid = packet[1] & 31;
                    result.pid <<= 8;
                    result.pid |= packet[2];
                    if ((packet[3] & 48) >>> 4 > 1) offset += packet[offset] + 1;
                    if (result.pid === 0) {
                        result.type = "pat";
                        parsePsi(packet.subarray(offset), result);
                        this.trigger("data", result);
                    } else if (result.pid === this.pmtPid) {
                        result.type = "pmt";
                        parsePsi(packet.subarray(offset), result);
                        this.trigger("data", result);
                        while (this.packetsWaitingForPmt.length) this.processPes_.apply(this, this.packetsWaitingForPmt.shift());
                    } else if (this.programMapTable === void 0) this.packetsWaitingForPmt.push([ packet, offset, result ]); else this.processPes_(packet, offset, result);
                };
                this.processPes_ = function(packet, offset, result) {
                    if (result.pid === this.programMapTable.video) result.streamType = StreamTypes$2.H264_STREAM_TYPE; else if (result.pid === this.programMapTable.audio) result.streamType = StreamTypes$2.ADTS_STREAM_TYPE; else result.streamType = this.programMapTable["timed-metadata"][result.pid];
                    result.type = "pes";
                    result.data = packet.subarray(offset);
                    this.trigger("data", result);
                };
            };
            TransportParseStream.prototype = new Stream$4;
            TransportParseStream.STREAM_TYPES = {
                h264: 27,
                adts: 15
            };
            ElementaryStream = function() {
                var programMapTable, self = this, segmentHadPmt = false, video = {
                    data: [],
                    size: 0
                }, audio = {
                    data: [],
                    size: 0
                }, timedMetadata = {
                    data: [],
                    size: 0
                }, parsePes = function(payload, pes) {
                    var ptsDtsFlags;
                    const startPrefix = payload[0] << 16 | payload[1] << 8 | payload[2];
                    pes.data = new Uint8Array;
                    if (startPrefix !== 1) return;
                    pes.packetLength = 6 + (payload[4] << 8 | payload[5]);
                    pes.dataAlignmentIndicator = (payload[6] & 4) !== 0;
                    ptsDtsFlags = payload[7];
                    if (ptsDtsFlags & 192) {
                        pes.pts = (payload[9] & 14) << 27 | (payload[10] & 255) << 20 | (payload[11] & 254) << 12 | (payload[12] & 255) << 5 | (payload[13] & 254) >>> 3;
                        pes.pts *= 4;
                        pes.pts += (payload[13] & 6) >>> 1;
                        pes.dts = pes.pts;
                        if (ptsDtsFlags & 64) {
                            pes.dts = (payload[14] & 14) << 27 | (payload[15] & 255) << 20 | (payload[16] & 254) << 12 | (payload[17] & 255) << 5 | (payload[18] & 254) >>> 3;
                            pes.dts *= 4;
                            pes.dts += (payload[18] & 6) >>> 1;
                        }
                    }
                    pes.data = payload.subarray(9 + payload[8]);
                }, flushStream = function(stream, type, forceFlush) {
                    var fragment, packetData = new Uint8Array(stream.size), event = {
                        type
                    }, i = 0, offset = 0, packetFlushable = false;
                    if (!stream.data.length || stream.size < 9) return;
                    event.trackId = stream.data[0].pid;
                    for (i = 0; i < stream.data.length; i++) {
                        fragment = stream.data[i];
                        packetData.set(fragment.data, offset);
                        offset += fragment.data.byteLength;
                    }
                    parsePes(packetData, event);
                    packetFlushable = type === "video" || event.packetLength <= stream.size;
                    if (forceFlush || packetFlushable) {
                        stream.size = 0;
                        stream.data.length = 0;
                    }
                    if (packetFlushable) self.trigger("data", event);
                };
                ElementaryStream.prototype.init.call(this);
                this.push = function(data) {
                    ({
                        pat: function() {},
                        pes: function() {
                            var stream, streamType;
                            switch (data.streamType) {
                              case StreamTypes$2.H264_STREAM_TYPE:
                                stream = video;
                                streamType = "video";
                                break;

                              case StreamTypes$2.ADTS_STREAM_TYPE:
                                stream = audio;
                                streamType = "audio";
                                break;

                              case StreamTypes$2.METADATA_STREAM_TYPE:
                                stream = timedMetadata;
                                streamType = "timed-metadata";
                                break;

                              default:
                                return;
                            }
                            if (data.payloadUnitStartIndicator) flushStream(stream, streamType, true);
                            stream.data.push(data);
                            stream.size += data.data.byteLength;
                        },
                        pmt: function() {
                            var event = {
                                type: "metadata",
                                tracks: []
                            };
                            programMapTable = data.programMapTable;
                            if (programMapTable.video !== null) event.tracks.push({
                                timelineStartInfo: {
                                    baseMediaDecodeTime: 0
                                },
                                id: +programMapTable.video,
                                codec: "avc",
                                type: "video"
                            });
                            if (programMapTable.audio !== null) event.tracks.push({
                                timelineStartInfo: {
                                    baseMediaDecodeTime: 0
                                },
                                id: +programMapTable.audio,
                                codec: "adts",
                                type: "audio"
                            });
                            segmentHadPmt = true;
                            self.trigger("data", event);
                        }
                    })[data.type]();
                };
                this.reset = function() {
                    video.size = 0;
                    video.data.length = 0;
                    audio.size = 0;
                    audio.data.length = 0;
                    this.trigger("reset");
                };
                this.flushStreams_ = function() {
                    flushStream(video, "video");
                    flushStream(audio, "audio");
                    flushStream(timedMetadata, "timed-metadata");
                };
                this.flush = function() {
                    if (!segmentHadPmt && programMapTable) {
                        var pmt = {
                            type: "metadata",
                            tracks: []
                        };
                        if (programMapTable.video !== null) pmt.tracks.push({
                            timelineStartInfo: {
                                baseMediaDecodeTime: 0
                            },
                            id: +programMapTable.video,
                            codec: "avc",
                            type: "video"
                        });
                        if (programMapTable.audio !== null) pmt.tracks.push({
                            timelineStartInfo: {
                                baseMediaDecodeTime: 0
                            },
                            id: +programMapTable.audio,
                            codec: "adts",
                            type: "audio"
                        });
                        self.trigger("data", pmt);
                    }
                    segmentHadPmt = false;
                    this.flushStreams_();
                    this.trigger("done");
                };
            };
            ElementaryStream.prototype = new Stream$4;
            var m2ts$1 = {
                PAT_PID: 0,
                MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH$1,
                TransportPacketStream,
                TransportParseStream,
                ElementaryStream,
                TimestampRolloverStream,
                CaptionStream: CaptionStream$1.CaptionStream,
                Cea608Stream: CaptionStream$1.Cea608Stream,
                Cea708Stream: CaptionStream$1.Cea708Stream,
                MetadataStream: metadataStream
            };
            for (var type in StreamTypes$2) if (StreamTypes$2.hasOwnProperty(type)) m2ts$1[type] = StreamTypes$2[type];
            var m2ts_1 = m2ts$1;
            var Stream$3 = stream;
            var ONE_SECOND_IN_TS$2 = clock$2.ONE_SECOND_IN_TS;
            var AdtsStream$1;
            var ADTS_SAMPLING_FREQUENCIES$1 = [ 96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350 ];
            AdtsStream$1 = function(handlePartialSegments) {
                var buffer, frameNum = 0;
                AdtsStream$1.prototype.init.call(this);
                this.skipWarn_ = function(start, end) {
                    this.trigger("log", {
                        level: "warn",
                        message: `adts skiping bytes ${start} to ${end} in frame ${frameNum} outside syncword`
                    });
                };
                this.push = function(packet) {
                    var frameLength, protectionSkipBytes, oldBuffer, sampleCount, adtsFrameDuration, i = 0;
                    if (!handlePartialSegments) frameNum = 0;
                    if (packet.type !== "audio") return;
                    if (buffer && buffer.length) {
                        oldBuffer = buffer;
                        buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);
                        buffer.set(oldBuffer);
                        buffer.set(packet.data, oldBuffer.byteLength);
                    } else buffer = packet.data;
                    var skip;
                    while (i + 7 < buffer.length) {
                        if (buffer[i] !== 255 || (buffer[i + 1] & 246) !== 240) {
                            if (typeof skip !== "number") skip = i;
                            i++;
                            continue;
                        }
                        if (typeof skip === "number") {
                            this.skipWarn_(skip, i);
                            skip = null;
                        }
                        protectionSkipBytes = (~buffer[i + 1] & 1) * 2;
                        frameLength = (buffer[i + 3] & 3) << 11 | buffer[i + 4] << 3 | (buffer[i + 5] & 224) >> 5;
                        sampleCount = ((buffer[i + 6] & 3) + 1) * 1024;
                        adtsFrameDuration = sampleCount * ONE_SECOND_IN_TS$2 / ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2];
                        if (buffer.byteLength - i < frameLength) break;
                        this.trigger("data", {
                            pts: packet.pts + frameNum * adtsFrameDuration,
                            dts: packet.dts + frameNum * adtsFrameDuration,
                            sampleCount,
                            audioobjecttype: (buffer[i + 2] >>> 6 & 3) + 1,
                            channelcount: (buffer[i + 2] & 1) << 2 | (buffer[i + 3] & 192) >>> 6,
                            samplerate: ADTS_SAMPLING_FREQUENCIES$1[(buffer[i + 2] & 60) >>> 2],
                            samplingfrequencyindex: (buffer[i + 2] & 60) >>> 2,
                            samplesize: 16,
                            data: buffer.subarray(i + 7 + protectionSkipBytes, i + frameLength)
                        });
                        frameNum++;
                        i += frameLength;
                    }
                    if (typeof skip === "number") {
                        this.skipWarn_(skip, i);
                        skip = null;
                    }
                    buffer = buffer.subarray(i);
                };
                this.flush = function() {
                    frameNum = 0;
                    this.trigger("done");
                };
                this.reset = function() {
                    buffer = void 0;
                    this.trigger("reset");
                };
                this.endTimeline = function() {
                    buffer = void 0;
                    this.trigger("endedtimeline");
                };
            };
            AdtsStream$1.prototype = new Stream$3;
            var adts = AdtsStream$1;
            var ExpGolomb$1;
            ExpGolomb$1 = function(workingData) {
                var workingBytesAvailable = workingData.byteLength, workingWord = 0, workingBitsAvailable = 0;
                this.length = function() {
                    return 8 * workingBytesAvailable;
                };
                this.bitsAvailable = function() {
                    return 8 * workingBytesAvailable + workingBitsAvailable;
                };
                this.loadWord = function() {
                    var position = workingData.byteLength - workingBytesAvailable, workingBytes = new Uint8Array(4), availableBytes = Math.min(4, workingBytesAvailable);
                    if (availableBytes === 0) throw new Error("no bytes available");
                    workingBytes.set(workingData.subarray(position, position + availableBytes));
                    workingWord = new DataView(workingBytes.buffer).getUint32(0);
                    workingBitsAvailable = availableBytes * 8;
                    workingBytesAvailable -= availableBytes;
                };
                this.skipBits = function(count) {
                    var skipBytes;
                    if (workingBitsAvailable > count) {
                        workingWord <<= count;
                        workingBitsAvailable -= count;
                    } else {
                        count -= workingBitsAvailable;
                        skipBytes = Math.floor(count / 8);
                        count -= skipBytes * 8;
                        workingBytesAvailable -= skipBytes;
                        this.loadWord();
                        workingWord <<= count;
                        workingBitsAvailable -= count;
                    }
                };
                this.readBits = function(size) {
                    var bits = Math.min(workingBitsAvailable, size), valu = workingWord >>> 32 - bits;
                    workingBitsAvailable -= bits;
                    if (workingBitsAvailable > 0) workingWord <<= bits; else if (workingBytesAvailable > 0) this.loadWord();
                    bits = size - bits;
                    if (bits > 0) return valu << bits | this.readBits(bits);
                    return valu;
                };
                this.skipLeadingZeros = function() {
                    var leadingZeroCount;
                    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) if ((workingWord & 2147483648 >>> leadingZeroCount) !== 0) {
                        workingWord <<= leadingZeroCount;
                        workingBitsAvailable -= leadingZeroCount;
                        return leadingZeroCount;
                    }
                    this.loadWord();
                    return leadingZeroCount + this.skipLeadingZeros();
                };
                this.skipUnsignedExpGolomb = function() {
                    this.skipBits(1 + this.skipLeadingZeros());
                };
                this.skipExpGolomb = function() {
                    this.skipBits(1 + this.skipLeadingZeros());
                };
                this.readUnsignedExpGolomb = function() {
                    var clz = this.skipLeadingZeros();
                    return this.readBits(clz + 1) - 1;
                };
                this.readExpGolomb = function() {
                    var valu = this.readUnsignedExpGolomb();
                    if (1 & valu) return 1 + valu >>> 1;
                    return -1 * (valu >>> 1);
                };
                this.readBoolean = function() {
                    return this.readBits(1) === 1;
                };
                this.readUnsignedByte = function() {
                    return this.readBits(8);
                };
                this.loadWord();
            };
            var expGolomb = ExpGolomb$1;
            var Stream$2 = stream;
            var ExpGolomb = expGolomb;
            var H264Stream$1, NalByteStream;
            var PROFILES_WITH_OPTIONAL_SPS_DATA;
            NalByteStream = function() {
                var i, buffer, syncPoint = 0;
                NalByteStream.prototype.init.call(this);
                this.push = function(data) {
                    var swapBuffer;
                    if (!buffer) buffer = data.data; else {
                        swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);
                        swapBuffer.set(buffer);
                        swapBuffer.set(data.data, buffer.byteLength);
                        buffer = swapBuffer;
                    }
                    var len = buffer.byteLength;
                    for (;syncPoint < len - 3; syncPoint++) if (buffer[syncPoint + 2] === 1) {
                        i = syncPoint + 5;
                        break;
                    }
                    while (i < len) switch (buffer[i]) {
                      case 0:
                        if (buffer[i - 1] !== 0) {
                            i += 2;
                            break;
                        } else if (buffer[i - 2] !== 0) {
                            i++;
                            break;
                        }
                        if (syncPoint + 3 !== i - 2) this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
                        do {
                            i++;
                        } while (buffer[i] !== 1 && i < len);
                        syncPoint = i - 2;
                        i += 3;
                        break;

                      case 1:
                        if (buffer[i - 1] !== 0 || buffer[i - 2] !== 0) {
                            i += 3;
                            break;
                        }
                        this.trigger("data", buffer.subarray(syncPoint + 3, i - 2));
                        syncPoint = i - 2;
                        i += 3;
                        break;

                      default:
                        i += 3;
                        break;
                    }
                    buffer = buffer.subarray(syncPoint);
                    i -= syncPoint;
                    syncPoint = 0;
                };
                this.reset = function() {
                    buffer = null;
                    syncPoint = 0;
                    this.trigger("reset");
                };
                this.flush = function() {
                    if (buffer && buffer.byteLength > 3) this.trigger("data", buffer.subarray(syncPoint + 3));
                    buffer = null;
                    syncPoint = 0;
                    this.trigger("done");
                };
                this.endTimeline = function() {
                    this.flush();
                    this.trigger("endedtimeline");
                };
            };
            NalByteStream.prototype = new Stream$2;
            PROFILES_WITH_OPTIONAL_SPS_DATA = {
                100: true,
                110: true,
                122: true,
                244: true,
                44: true,
                83: true,
                86: true,
                118: true,
                128: true,
                138: true,
                139: true,
                134: true
            };
            H264Stream$1 = function() {
                var self, trackId, currentPts, currentDts, discardEmulationPreventionBytes, readSequenceParameterSet, skipScalingList, nalByteStream = new NalByteStream;
                H264Stream$1.prototype.init.call(this);
                self = this;
                this.push = function(packet) {
                    if (packet.type !== "video") return;
                    trackId = packet.trackId;
                    currentPts = packet.pts;
                    currentDts = packet.dts;
                    nalByteStream.push(packet);
                };
                nalByteStream.on("data", (function(data) {
                    var event = {
                        trackId,
                        pts: currentPts,
                        dts: currentDts,
                        data,
                        nalUnitTypeCode: data[0] & 31
                    };
                    switch (event.nalUnitTypeCode) {
                      case 5:
                        event.nalUnitType = "slice_layer_without_partitioning_rbsp_idr";
                        break;

                      case 6:
                        event.nalUnitType = "sei_rbsp";
                        event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));
                        break;

                      case 7:
                        event.nalUnitType = "seq_parameter_set_rbsp";
                        event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));
                        event.config = readSequenceParameterSet(event.escapedRBSP);
                        break;

                      case 8:
                        event.nalUnitType = "pic_parameter_set_rbsp";
                        break;

                      case 9:
                        event.nalUnitType = "access_unit_delimiter_rbsp";
                        break;
                    }
                    self.trigger("data", event);
                }));
                nalByteStream.on("done", (function() {
                    self.trigger("done");
                }));
                nalByteStream.on("partialdone", (function() {
                    self.trigger("partialdone");
                }));
                nalByteStream.on("reset", (function() {
                    self.trigger("reset");
                }));
                nalByteStream.on("endedtimeline", (function() {
                    self.trigger("endedtimeline");
                }));
                this.flush = function() {
                    nalByteStream.flush();
                };
                this.partialFlush = function() {
                    nalByteStream.partialFlush();
                };
                this.reset = function() {
                    nalByteStream.reset();
                };
                this.endTimeline = function() {
                    nalByteStream.endTimeline();
                };
                skipScalingList = function(count, expGolombDecoder) {
                    var j, deltaScale, lastScale = 8, nextScale = 8;
                    for (j = 0; j < count; j++) {
                        if (nextScale !== 0) {
                            deltaScale = expGolombDecoder.readExpGolomb();
                            nextScale = (lastScale + deltaScale + 256) % 256;
                        }
                        lastScale = nextScale === 0 ? lastScale : nextScale;
                    }
                };
                discardEmulationPreventionBytes = function(data) {
                    var newLength, newData, length = data.byteLength, emulationPreventionBytesPositions = [], i = 1;
                    while (i < length - 2) if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 3) {
                        emulationPreventionBytesPositions.push(i + 2);
                        i += 2;
                    } else i++;
                    if (emulationPreventionBytesPositions.length === 0) return data;
                    newLength = length - emulationPreventionBytesPositions.length;
                    newData = new Uint8Array(newLength);
                    var sourceIndex = 0;
                    for (i = 0; i < newLength; sourceIndex++, i++) {
                        if (sourceIndex === emulationPreventionBytesPositions[0]) {
                            sourceIndex++;
                            emulationPreventionBytesPositions.shift();
                        }
                        newData[i] = data[sourceIndex];
                    }
                    return newData;
                };
                readSequenceParameterSet = function(data) {
                    var expGolombDecoder, profileIdc, levelIdc, profileCompatibility, chromaFormatIdc, picOrderCntType, numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1, picHeightInMapUnitsMinus1, frameMbsOnlyFlag, scalingListCount, aspectRatioIdc, i, frameCropLeftOffset = 0, frameCropRightOffset = 0, frameCropTopOffset = 0, frameCropBottomOffset = 0, sarRatio = [ 1, 1 ];
                    expGolombDecoder = new ExpGolomb(data);
                    profileIdc = expGolombDecoder.readUnsignedByte();
                    profileCompatibility = expGolombDecoder.readUnsignedByte();
                    levelIdc = expGolombDecoder.readUnsignedByte();
                    expGolombDecoder.skipUnsignedExpGolomb();
                    if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {
                        chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();
                        if (chromaFormatIdc === 3) expGolombDecoder.skipBits(1);
                        expGolombDecoder.skipUnsignedExpGolomb();
                        expGolombDecoder.skipUnsignedExpGolomb();
                        expGolombDecoder.skipBits(1);
                        if (expGolombDecoder.readBoolean()) {
                            scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;
                            for (i = 0; i < scalingListCount; i++) if (expGolombDecoder.readBoolean()) if (i < 6) skipScalingList(16, expGolombDecoder); else skipScalingList(64, expGolombDecoder);
                        }
                    }
                    expGolombDecoder.skipUnsignedExpGolomb();
                    picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();
                    if (picOrderCntType === 0) expGolombDecoder.readUnsignedExpGolomb(); else if (picOrderCntType === 1) {
                        expGolombDecoder.skipBits(1);
                        expGolombDecoder.skipExpGolomb();
                        expGolombDecoder.skipExpGolomb();
                        numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();
                        for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) expGolombDecoder.skipExpGolomb();
                    }
                    expGolombDecoder.skipUnsignedExpGolomb();
                    expGolombDecoder.skipBits(1);
                    picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
                    picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();
                    frameMbsOnlyFlag = expGolombDecoder.readBits(1);
                    if (frameMbsOnlyFlag === 0) expGolombDecoder.skipBits(1);
                    expGolombDecoder.skipBits(1);
                    if (expGolombDecoder.readBoolean()) {
                        frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();
                        frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();
                        frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();
                        frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();
                    }
                    if (expGolombDecoder.readBoolean()) if (expGolombDecoder.readBoolean()) {
                        aspectRatioIdc = expGolombDecoder.readUnsignedByte();
                        switch (aspectRatioIdc) {
                          case 1:
                            sarRatio = [ 1, 1 ];
                            break;

                          case 2:
                            sarRatio = [ 12, 11 ];
                            break;

                          case 3:
                            sarRatio = [ 10, 11 ];
                            break;

                          case 4:
                            sarRatio = [ 16, 11 ];
                            break;

                          case 5:
                            sarRatio = [ 40, 33 ];
                            break;

                          case 6:
                            sarRatio = [ 24, 11 ];
                            break;

                          case 7:
                            sarRatio = [ 20, 11 ];
                            break;

                          case 8:
                            sarRatio = [ 32, 11 ];
                            break;

                          case 9:
                            sarRatio = [ 80, 33 ];
                            break;

                          case 10:
                            sarRatio = [ 18, 11 ];
                            break;

                          case 11:
                            sarRatio = [ 15, 11 ];
                            break;

                          case 12:
                            sarRatio = [ 64, 33 ];
                            break;

                          case 13:
                            sarRatio = [ 160, 99 ];
                            break;

                          case 14:
                            sarRatio = [ 4, 3 ];
                            break;

                          case 15:
                            sarRatio = [ 3, 2 ];
                            break;

                          case 16:
                            sarRatio = [ 2, 1 ];
                            break;

                          case 255:
                            sarRatio = [ expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte(), expGolombDecoder.readUnsignedByte() << 8 | expGolombDecoder.readUnsignedByte() ];
                            break;
                        }
                        if (sarRatio) sarRatio[0] / sarRatio[1];
                    }
                    return {
                        profileIdc,
                        levelIdc,
                        profileCompatibility,
                        width: (picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2,
                        height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - frameCropTopOffset * 2 - frameCropBottomOffset * 2,
                        sarRatio
                    };
                };
            };
            H264Stream$1.prototype = new Stream$2;
            var h264 = {
                H264Stream: H264Stream$1,
                NalByteStream
            };
            var ADTS_SAMPLING_FREQUENCIES = [ 96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350 ];
            var parseId3TagSize = function(header, byteIndex) {
                var returnSize = header[byteIndex + 6] << 21 | header[byteIndex + 7] << 14 | header[byteIndex + 8] << 7 | header[byteIndex + 9], flags = header[byteIndex + 5], footerPresent = (flags & 16) >> 4;
                returnSize = returnSize >= 0 ? returnSize : 0;
                if (footerPresent) return returnSize + 20;
                return returnSize + 10;
            };
            var getId3Offset = function(data, offset) {
                if (data.length - offset < 10 || data[offset] !== "I".charCodeAt(0) || data[offset + 1] !== "D".charCodeAt(0) || data[offset + 2] !== "3".charCodeAt(0)) return offset;
                offset += parseId3TagSize(data, offset);
                return getId3Offset(data, offset);
            };
            var isLikelyAacData$1 = function(data) {
                var offset = getId3Offset(data, 0);
                return data.length >= offset + 2 && (data[offset] & 255) === 255 && (data[offset + 1] & 240) === 240 && (data[offset + 1] & 22) === 16;
            };
            var parseSyncSafeInteger = function(data) {
                return data[0] << 21 | data[1] << 14 | data[2] << 7 | data[3];
            };
            var percentEncode = function(bytes, start, end) {
                var i, result = "";
                for (i = start; i < end; i++) result += "%" + ("00" + bytes[i].toString(16)).slice(-2);
                return result;
            };
            var parseIso88591 = function(bytes, start, end) {
                return unescape(percentEncode(bytes, start, end));
            };
            var parseAdtsSize = function(header, byteIndex) {
                var lowThree = (header[byteIndex + 5] & 224) >> 5, middle = header[byteIndex + 4] << 3, highTwo = header[byteIndex + 3] & 3 << 11;
                return highTwo | middle | lowThree;
            };
            var parseType$4 = function(header, byteIndex) {
                if (header[byteIndex] === "I".charCodeAt(0) && header[byteIndex + 1] === "D".charCodeAt(0) && header[byteIndex + 2] === "3".charCodeAt(0)) return "timed-metadata"; else if (header[byteIndex] & 255 === 255 && (header[byteIndex + 1] & 240) === 240) return "audio";
                return null;
            };
            var parseSampleRate = function(packet) {
                var i = 0;
                while (i + 5 < packet.length) {
                    if (packet[i] !== 255 || (packet[i + 1] & 246) !== 240) {
                        i++;
                        continue;
                    }
                    return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 60) >>> 2];
                }
                return null;
            };
            var parseAacTimestamp = function(packet) {
                var frameStart, frameSize, frame, frameHeader;
                frameStart = 10;
                if (packet[5] & 64) {
                    frameStart += 4;
                    frameStart += parseSyncSafeInteger(packet.subarray(10, 14));
                }
                do {
                    frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));
                    if (frameSize < 1) return null;
                    frameHeader = String.fromCharCode(packet[frameStart], packet[frameStart + 1], packet[frameStart + 2], packet[frameStart + 3]);
                    if (frameHeader === "PRIV") {
                        frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);
                        for (var i = 0; i < frame.byteLength; i++) if (frame[i] === 0) {
                            var owner = parseIso88591(frame, 0, i);
                            if (owner === "com.apple.streaming.transportStreamTimestamp") {
                                var d = frame.subarray(i + 1);
                                var size = (d[3] & 1) << 30 | d[4] << 22 | d[5] << 14 | d[6] << 6 | d[7] >>> 2;
                                size *= 4;
                                size += d[7] & 3;
                                return size;
                            }
                            break;
                        }
                    }
                    frameStart += 10;
                    frameStart += frameSize;
                } while (frameStart < packet.byteLength);
                return null;
            };
            var utils = {
                isLikelyAacData: isLikelyAacData$1,
                parseId3TagSize,
                parseAdtsSize,
                parseType: parseType$4,
                parseSampleRate,
                parseAacTimestamp
            };
            var Stream$1 = stream;
            var aacUtils = utils;
            var AacStream$1;
            AacStream$1 = function() {
                var everything = new Uint8Array, timeStamp = 0;
                AacStream$1.prototype.init.call(this);
                this.setTimestamp = function(timestamp) {
                    timeStamp = timestamp;
                };
                this.push = function(bytes) {
                    var bytesLeft, chunk, packet, tempLength, frameSize = 0, byteIndex = 0;
                    if (everything.length) {
                        tempLength = everything.length;
                        everything = new Uint8Array(bytes.byteLength + tempLength);
                        everything.set(everything.subarray(0, tempLength));
                        everything.set(bytes, tempLength);
                    } else everything = bytes;
                    while (everything.length - byteIndex >= 3) {
                        if (everything[byteIndex] === "I".charCodeAt(0) && everything[byteIndex + 1] === "D".charCodeAt(0) && everything[byteIndex + 2] === "3".charCodeAt(0)) {
                            if (everything.length - byteIndex < 10) break;
                            frameSize = aacUtils.parseId3TagSize(everything, byteIndex);
                            if (byteIndex + frameSize > everything.length) break;
                            chunk = {
                                type: "timed-metadata",
                                data: everything.subarray(byteIndex, byteIndex + frameSize)
                            };
                            this.trigger("data", chunk);
                            byteIndex += frameSize;
                            continue;
                        } else if ((everything[byteIndex] & 255) === 255 && (everything[byteIndex + 1] & 240) === 240) {
                            if (everything.length - byteIndex < 7) break;
                            frameSize = aacUtils.parseAdtsSize(everything, byteIndex);
                            if (byteIndex + frameSize > everything.length) break;
                            packet = {
                                type: "audio",
                                data: everything.subarray(byteIndex, byteIndex + frameSize),
                                pts: timeStamp,
                                dts: timeStamp
                            };
                            this.trigger("data", packet);
                            byteIndex += frameSize;
                            continue;
                        }
                        byteIndex++;
                    }
                    bytesLeft = everything.length - byteIndex;
                    if (bytesLeft > 0) everything = everything.subarray(byteIndex); else everything = new Uint8Array;
                };
                this.reset = function() {
                    everything = new Uint8Array;
                    this.trigger("reset");
                };
                this.endTimeline = function() {
                    everything = new Uint8Array;
                    this.trigger("endedtimeline");
                };
            };
            AacStream$1.prototype = new Stream$1;
            var aac = AacStream$1;
            var AUDIO_PROPERTIES$1 = [ "audioobjecttype", "channelcount", "samplerate", "samplingfrequencyindex", "samplesize" ];
            var audioProperties = AUDIO_PROPERTIES$1;
            var VIDEO_PROPERTIES$1 = [ "width", "height", "profileIdc", "levelIdc", "profileCompatibility", "sarRatio" ];
            var videoProperties = VIDEO_PROPERTIES$1;
            var Stream = stream;
            var mp4 = mp4Generator;
            var frameUtils = frameUtils$1;
            var audioFrameUtils = audioFrameUtils$1;
            var trackDecodeInfo = trackDecodeInfo$1;
            var m2ts = m2ts_1;
            var clock = clock$2;
            var AdtsStream = adts;
            var H264Stream = h264.H264Stream;
            var AacStream = aac;
            var isLikelyAacData = utils.isLikelyAacData;
            var ONE_SECOND_IN_TS$1 = clock$2.ONE_SECOND_IN_TS;
            var AUDIO_PROPERTIES = audioProperties;
            var VIDEO_PROPERTIES = videoProperties;
            var VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;
            var retriggerForStream = function(key, event) {
                event.stream = key;
                this.trigger("log", event);
            };
            var addPipelineLogRetriggers = function(transmuxer, pipeline) {
                var keys = Object.keys(pipeline);
                for (var i = 0; i < keys.length; i++) {
                    var key = keys[i];
                    if (key === "headOfPipeline" || !pipeline[key].on) continue;
                    pipeline[key].on("log", retriggerForStream.bind(transmuxer, key));
                }
            };
            var arrayEquals = function(a, b) {
                var i;
                if (a.length !== b.length) return false;
                for (i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;
                return true;
            };
            var generateSegmentTimingInfo = function(baseMediaDecodeTime, startDts, startPts, endDts, endPts, prependedContentDuration) {
                var ptsOffsetFromDts = startPts - startDts, decodeDuration = endDts - startDts, presentationDuration = endPts - startPts;
                return {
                    start: {
                        dts: baseMediaDecodeTime,
                        pts: baseMediaDecodeTime + ptsOffsetFromDts
                    },
                    end: {
                        dts: baseMediaDecodeTime + decodeDuration,
                        pts: baseMediaDecodeTime + presentationDuration
                    },
                    prependedContentDuration,
                    baseMediaDecodeTime
                };
            };
            AudioSegmentStream = function(track, options) {
                var sequenceNumber, adtsFrames = [], earliestAllowedDts = 0, audioAppendStartTs = 0, videoBaseMediaDecodeTime = 1 / 0;
                options = options || {};
                sequenceNumber = options.firstSequenceNumber || 0;
                AudioSegmentStream.prototype.init.call(this);
                this.push = function(data) {
                    trackDecodeInfo.collectDtsInfo(track, data);
                    if (track) AUDIO_PROPERTIES.forEach((function(prop) {
                        track[prop] = data[prop];
                    }));
                    adtsFrames.push(data);
                };
                this.setEarliestDts = function(earliestDts) {
                    earliestAllowedDts = earliestDts;
                };
                this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {
                    videoBaseMediaDecodeTime = baseMediaDecodeTime;
                };
                this.setAudioAppendStart = function(timestamp) {
                    audioAppendStartTs = timestamp;
                };
                this.flush = function() {
                    var frames, moof, mdat, boxes, frameDuration, segmentDuration, videoClockCyclesOfSilencePrefixed;
                    if (adtsFrames.length === 0) {
                        this.trigger("done", "AudioSegmentStream");
                        return;
                    }
                    frames = audioFrameUtils.trimAdtsFramesByEarliestDts(adtsFrames, track, earliestAllowedDts);
                    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
                    videoClockCyclesOfSilencePrefixed = audioFrameUtils.prefixWithSilence(track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);
                    track.samples = audioFrameUtils.generateSampleTable(frames);
                    mdat = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));
                    adtsFrames = [];
                    moof = mp4.moof(sequenceNumber, [ track ]);
                    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);
                    sequenceNumber++;
                    boxes.set(moof);
                    boxes.set(mdat, moof.byteLength);
                    trackDecodeInfo.clearDtsInfo(track);
                    frameDuration = Math.ceil(ONE_SECOND_IN_TS$1 * 1024 / track.samplerate);
                    if (frames.length) {
                        segmentDuration = frames.length * frameDuration;
                        this.trigger("segmentTimingInfo", generateSegmentTimingInfo(clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate), frames[0].dts, frames[0].pts, frames[0].dts + segmentDuration, frames[0].pts + segmentDuration, videoClockCyclesOfSilencePrefixed || 0));
                        this.trigger("timingInfo", {
                            start: frames[0].pts,
                            end: frames[0].pts + segmentDuration
                        });
                    }
                    this.trigger("data", {
                        track,
                        boxes
                    });
                    this.trigger("done", "AudioSegmentStream");
                };
                this.reset = function() {
                    trackDecodeInfo.clearDtsInfo(track);
                    adtsFrames = [];
                    this.trigger("reset");
                };
            };
            AudioSegmentStream.prototype = new Stream;
            VideoSegmentStream = function(track, options) {
                var sequenceNumber, config, pps, nalUnits = [], gopsToAlignWith = [];
                options = options || {};
                sequenceNumber = options.firstSequenceNumber || 0;
                VideoSegmentStream.prototype.init.call(this);
                delete track.minPTS;
                this.gopCache_ = [];
                this.push = function(nalUnit) {
                    trackDecodeInfo.collectDtsInfo(track, nalUnit);
                    if (nalUnit.nalUnitType === "seq_parameter_set_rbsp" && !config) {
                        config = nalUnit.config;
                        track.sps = [ nalUnit.data ];
                        VIDEO_PROPERTIES.forEach((function(prop) {
                            track[prop] = config[prop];
                        }), this);
                    }
                    if (nalUnit.nalUnitType === "pic_parameter_set_rbsp" && !pps) {
                        pps = nalUnit.data;
                        track.pps = [ nalUnit.data ];
                    }
                    nalUnits.push(nalUnit);
                };
                this.flush = function() {
                    var frames, gopForFusion, gops, moof, mdat, boxes, firstGop, lastGop, prependedContentDuration = 0;
                    while (nalUnits.length) {
                        if (nalUnits[0].nalUnitType === "access_unit_delimiter_rbsp") break;
                        nalUnits.shift();
                    }
                    if (nalUnits.length === 0) {
                        this.resetStream_();
                        this.trigger("done", "VideoSegmentStream");
                        return;
                    }
                    frames = frameUtils.groupNalsIntoFrames(nalUnits);
                    gops = frameUtils.groupFramesIntoGops(frames);
                    if (!gops[0][0].keyFrame) {
                        gopForFusion = this.getGopForFusion_(nalUnits[0], track);
                        if (gopForFusion) {
                            prependedContentDuration = gopForFusion.duration;
                            gops.unshift(gopForFusion);
                            gops.byteLength += gopForFusion.byteLength;
                            gops.nalCount += gopForFusion.nalCount;
                            gops.pts = gopForFusion.pts;
                            gops.dts = gopForFusion.dts;
                            gops.duration += gopForFusion.duration;
                        } else gops = frameUtils.extendFirstKeyFrame(gops);
                    }
                    if (gopsToAlignWith.length) {
                        var alignedGops;
                        if (options.alignGopsAtEnd) alignedGops = this.alignGopsAtEnd_(gops); else alignedGops = this.alignGopsAtStart_(gops);
                        if (!alignedGops) {
                            this.gopCache_.unshift({
                                gop: gops.pop(),
                                pps: track.pps,
                                sps: track.sps
                            });
                            this.gopCache_.length = Math.min(6, this.gopCache_.length);
                            nalUnits = [];
                            this.resetStream_();
                            this.trigger("done", "VideoSegmentStream");
                            return;
                        }
                        trackDecodeInfo.clearDtsInfo(track);
                        gops = alignedGops;
                    }
                    trackDecodeInfo.collectDtsInfo(track, gops);
                    track.samples = frameUtils.generateSampleTable(gops);
                    mdat = mp4.mdat(frameUtils.concatenateNalData(gops));
                    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(track, options.keepOriginalTimestamps);
                    this.trigger("processedGopsInfo", gops.map((function(gop) {
                        return {
                            pts: gop.pts,
                            dts: gop.dts,
                            byteLength: gop.byteLength
                        };
                    })));
                    firstGop = gops[0];
                    lastGop = gops[gops.length - 1];
                    this.trigger("segmentTimingInfo", generateSegmentTimingInfo(track.baseMediaDecodeTime, firstGop.dts, firstGop.pts, lastGop.dts + lastGop.duration, lastGop.pts + lastGop.duration, prependedContentDuration));
                    this.trigger("timingInfo", {
                        start: gops[0].pts,
                        end: gops[gops.length - 1].pts + gops[gops.length - 1].duration
                    });
                    this.gopCache_.unshift({
                        gop: gops.pop(),
                        pps: track.pps,
                        sps: track.sps
                    });
                    this.gopCache_.length = Math.min(6, this.gopCache_.length);
                    nalUnits = [];
                    this.trigger("baseMediaDecodeTime", track.baseMediaDecodeTime);
                    this.trigger("timelineStartInfo", track.timelineStartInfo);
                    moof = mp4.moof(sequenceNumber, [ track ]);
                    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);
                    sequenceNumber++;
                    boxes.set(moof);
                    boxes.set(mdat, moof.byteLength);
                    this.trigger("data", {
                        track,
                        boxes
                    });
                    this.resetStream_();
                    this.trigger("done", "VideoSegmentStream");
                };
                this.reset = function() {
                    this.resetStream_();
                    nalUnits = [];
                    this.gopCache_.length = 0;
                    gopsToAlignWith.length = 0;
                    this.trigger("reset");
                };
                this.resetStream_ = function() {
                    trackDecodeInfo.clearDtsInfo(track);
                    config = void 0;
                    pps = void 0;
                };
                this.getGopForFusion_ = function(nalUnit) {
                    var dtsDistance, nearestGopObj, currentGop, currentGopObj, i, halfSecond = 45e3, allowableOverlap = 1e4, nearestDistance = 1 / 0;
                    for (i = 0; i < this.gopCache_.length; i++) {
                        currentGopObj = this.gopCache_[i];
                        currentGop = currentGopObj.gop;
                        if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) || !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) continue;
                        if (currentGop.dts < track.timelineStartInfo.dts) continue;
                        dtsDistance = nalUnit.dts - currentGop.dts - currentGop.duration;
                        if (dtsDistance >= -allowableOverlap && dtsDistance <= halfSecond) if (!nearestGopObj || nearestDistance > dtsDistance) {
                            nearestGopObj = currentGopObj;
                            nearestDistance = dtsDistance;
                        }
                    }
                    if (nearestGopObj) return nearestGopObj.gop;
                    return null;
                };
                this.alignGopsAtStart_ = function(gops) {
                    var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;
                    byteLength = gops.byteLength;
                    nalCount = gops.nalCount;
                    duration = gops.duration;
                    alignIndex = gopIndex = 0;
                    while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {
                        align = gopsToAlignWith[alignIndex];
                        gop = gops[gopIndex];
                        if (align.pts === gop.pts) break;
                        if (gop.pts > align.pts) {
                            alignIndex++;
                            continue;
                        }
                        gopIndex++;
                        byteLength -= gop.byteLength;
                        nalCount -= gop.nalCount;
                        duration -= gop.duration;
                    }
                    if (gopIndex === 0) return gops;
                    if (gopIndex === gops.length) return null;
                    alignedGops = gops.slice(gopIndex);
                    alignedGops.byteLength = byteLength;
                    alignedGops.duration = duration;
                    alignedGops.nalCount = nalCount;
                    alignedGops.pts = alignedGops[0].pts;
                    alignedGops.dts = alignedGops[0].dts;
                    return alignedGops;
                };
                this.alignGopsAtEnd_ = function(gops) {
                    var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;
                    alignIndex = gopsToAlignWith.length - 1;
                    gopIndex = gops.length - 1;
                    alignEndIndex = null;
                    matchFound = false;
                    while (alignIndex >= 0 && gopIndex >= 0) {
                        align = gopsToAlignWith[alignIndex];
                        gop = gops[gopIndex];
                        if (align.pts === gop.pts) {
                            matchFound = true;
                            break;
                        }
                        if (align.pts > gop.pts) {
                            alignIndex--;
                            continue;
                        }
                        if (alignIndex === gopsToAlignWith.length - 1) alignEndIndex = gopIndex;
                        gopIndex--;
                    }
                    if (!matchFound && alignEndIndex === null) return null;
                    var trimIndex;
                    if (matchFound) trimIndex = gopIndex; else trimIndex = alignEndIndex;
                    if (trimIndex === 0) return gops;
                    var alignedGops = gops.slice(trimIndex);
                    var metadata = alignedGops.reduce((function(total, gop) {
                        total.byteLength += gop.byteLength;
                        total.duration += gop.duration;
                        total.nalCount += gop.nalCount;
                        return total;
                    }), {
                        byteLength: 0,
                        duration: 0,
                        nalCount: 0
                    });
                    alignedGops.byteLength = metadata.byteLength;
                    alignedGops.duration = metadata.duration;
                    alignedGops.nalCount = metadata.nalCount;
                    alignedGops.pts = alignedGops[0].pts;
                    alignedGops.dts = alignedGops[0].dts;
                    return alignedGops;
                };
                this.alignGopsWith = function(newGopsToAlignWith) {
                    gopsToAlignWith = newGopsToAlignWith;
                };
            };
            VideoSegmentStream.prototype = new Stream;
            CoalesceStream = function(options, metadataStream) {
                this.numberOfTracks = 0;
                this.metadataStream = metadataStream;
                options = options || {};
                if (typeof options.remux !== "undefined") this.remuxTracks = !!options.remux; else this.remuxTracks = true;
                if (typeof options.keepOriginalTimestamps === "boolean") this.keepOriginalTimestamps = options.keepOriginalTimestamps; else this.keepOriginalTimestamps = false;
                this.pendingTracks = [];
                this.videoTrack = null;
                this.pendingBoxes = [];
                this.pendingCaptions = [];
                this.pendingMetadata = [];
                this.pendingBytes = 0;
                this.emittedTracks = 0;
                CoalesceStream.prototype.init.call(this);
                this.push = function(output) {
                    if (output.text) return this.pendingCaptions.push(output);
                    if (output.frames) return this.pendingMetadata.push(output);
                    this.pendingTracks.push(output.track);
                    this.pendingBytes += output.boxes.byteLength;
                    if (output.track.type === "video") {
                        this.videoTrack = output.track;
                        this.pendingBoxes.push(output.boxes);
                    }
                    if (output.track.type === "audio") {
                        this.audioTrack = output.track;
                        this.pendingBoxes.unshift(output.boxes);
                    }
                };
            };
            CoalesceStream.prototype = new Stream;
            CoalesceStream.prototype.flush = function(flushSource) {
                var caption, id3, initSegment, i, offset = 0, event = {
                    captions: [],
                    captionStreams: {},
                    metadata: [],
                    info: {}
                }, timelineStartPts = 0;
                if (this.pendingTracks.length < this.numberOfTracks) if (flushSource !== "VideoSegmentStream" && flushSource !== "AudioSegmentStream") return; else if (this.remuxTracks) return; else if (this.pendingTracks.length === 0) {
                    this.emittedTracks++;
                    if (this.emittedTracks >= this.numberOfTracks) {
                        this.trigger("done");
                        this.emittedTracks = 0;
                    }
                    return;
                }
                if (this.videoTrack) {
                    timelineStartPts = this.videoTrack.timelineStartInfo.pts;
                    VIDEO_PROPERTIES.forEach((function(prop) {
                        event.info[prop] = this.videoTrack[prop];
                    }), this);
                } else if (this.audioTrack) {
                    timelineStartPts = this.audioTrack.timelineStartInfo.pts;
                    AUDIO_PROPERTIES.forEach((function(prop) {
                        event.info[prop] = this.audioTrack[prop];
                    }), this);
                }
                if (this.videoTrack || this.audioTrack) {
                    if (this.pendingTracks.length === 1) event.type = this.pendingTracks[0].type; else event.type = "combined";
                    this.emittedTracks += this.pendingTracks.length;
                    initSegment = mp4.initSegment(this.pendingTracks);
                    event.initSegment = new Uint8Array(initSegment.byteLength);
                    event.initSegment.set(initSegment);
                    event.data = new Uint8Array(this.pendingBytes);
                    for (i = 0; i < this.pendingBoxes.length; i++) {
                        event.data.set(this.pendingBoxes[i], offset);
                        offset += this.pendingBoxes[i].byteLength;
                    }
                    for (i = 0; i < this.pendingCaptions.length; i++) {
                        caption = this.pendingCaptions[i];
                        caption.startTime = clock.metadataTsToSeconds(caption.startPts, timelineStartPts, this.keepOriginalTimestamps);
                        caption.endTime = clock.metadataTsToSeconds(caption.endPts, timelineStartPts, this.keepOriginalTimestamps);
                        event.captionStreams[caption.stream] = true;
                        event.captions.push(caption);
                    }
                    for (i = 0; i < this.pendingMetadata.length; i++) {
                        id3 = this.pendingMetadata[i];
                        id3.cueTime = clock.metadataTsToSeconds(id3.pts, timelineStartPts, this.keepOriginalTimestamps);
                        event.metadata.push(id3);
                    }
                    event.metadata.dispatchType = this.metadataStream.dispatchType;
                    this.pendingTracks.length = 0;
                    this.videoTrack = null;
                    this.pendingBoxes.length = 0;
                    this.pendingCaptions.length = 0;
                    this.pendingBytes = 0;
                    this.pendingMetadata.length = 0;
                    this.trigger("data", event);
                    for (i = 0; i < event.captions.length; i++) {
                        caption = event.captions[i];
                        this.trigger("caption", caption);
                    }
                    for (i = 0; i < event.metadata.length; i++) {
                        id3 = event.metadata[i];
                        this.trigger("id3Frame", id3);
                    }
                }
                if (this.emittedTracks >= this.numberOfTracks) {
                    this.trigger("done");
                    this.emittedTracks = 0;
                }
            };
            CoalesceStream.prototype.setRemux = function(val) {
                this.remuxTracks = val;
            };
            Transmuxer = function(options) {
                var videoTrack, audioTrack, self = this, hasFlushed = true;
                Transmuxer.prototype.init.call(this);
                options = options || {};
                this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;
                this.transmuxPipeline_ = {};
                this.setupAacPipeline = function() {
                    var pipeline = {};
                    this.transmuxPipeline_ = pipeline;
                    pipeline.type = "aac";
                    pipeline.metadataStream = new m2ts.MetadataStream;
                    pipeline.aacStream = new AacStream;
                    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream("audio");
                    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream("timed-metadata");
                    pipeline.adtsStream = new AdtsStream;
                    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);
                    pipeline.headOfPipeline = pipeline.aacStream;
                    pipeline.aacStream.pipe(pipeline.audioTimestampRolloverStream).pipe(pipeline.adtsStream);
                    pipeline.aacStream.pipe(pipeline.timedMetadataTimestampRolloverStream).pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
                    pipeline.metadataStream.on("timestamp", (function(frame) {
                        pipeline.aacStream.setTimestamp(frame.timeStamp);
                    }));
                    pipeline.aacStream.on("data", (function(data) {
                        if (data.type !== "timed-metadata" && data.type !== "audio" || pipeline.audioSegmentStream) return;
                        audioTrack = audioTrack || {
                            timelineStartInfo: {
                                baseMediaDecodeTime: self.baseMediaDecodeTime
                            },
                            codec: "adts",
                            type: "audio"
                        };
                        pipeline.coalesceStream.numberOfTracks++;
                        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);
                        pipeline.audioSegmentStream.on("log", self.getLogTrigger_("audioSegmentStream"));
                        pipeline.audioSegmentStream.on("timingInfo", self.trigger.bind(self, "audioTimingInfo"));
                        pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
                        self.trigger("trackinfo", {
                            hasAudio: !!audioTrack,
                            hasVideo: !!videoTrack
                        });
                    }));
                    pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
                    pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
                    addPipelineLogRetriggers(this, pipeline);
                };
                this.setupTsPipeline = function() {
                    var pipeline = {};
                    this.transmuxPipeline_ = pipeline;
                    pipeline.type = "ts";
                    pipeline.metadataStream = new m2ts.MetadataStream;
                    pipeline.packetStream = new m2ts.TransportPacketStream;
                    pipeline.parseStream = new m2ts.TransportParseStream;
                    pipeline.elementaryStream = new m2ts.ElementaryStream;
                    pipeline.timestampRolloverStream = new m2ts.TimestampRolloverStream;
                    pipeline.adtsStream = new AdtsStream;
                    pipeline.h264Stream = new H264Stream;
                    pipeline.captionStream = new m2ts.CaptionStream(options);
                    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);
                    pipeline.headOfPipeline = pipeline.packetStream;
                    pipeline.packetStream.pipe(pipeline.parseStream).pipe(pipeline.elementaryStream).pipe(pipeline.timestampRolloverStream);
                    pipeline.timestampRolloverStream.pipe(pipeline.h264Stream);
                    pipeline.timestampRolloverStream.pipe(pipeline.adtsStream);
                    pipeline.timestampRolloverStream.pipe(pipeline.metadataStream).pipe(pipeline.coalesceStream);
                    pipeline.h264Stream.pipe(pipeline.captionStream).pipe(pipeline.coalesceStream);
                    pipeline.elementaryStream.on("data", (function(data) {
                        var i;
                        if (data.type === "metadata") {
                            i = data.tracks.length;
                            while (i--) if (!videoTrack && data.tracks[i].type === "video") {
                                videoTrack = data.tracks[i];
                                videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;
                            } else if (!audioTrack && data.tracks[i].type === "audio") {
                                audioTrack = data.tracks[i];
                                audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;
                            }
                            if (videoTrack && !pipeline.videoSegmentStream) {
                                pipeline.coalesceStream.numberOfTracks++;
                                pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);
                                pipeline.videoSegmentStream.on("log", self.getLogTrigger_("videoSegmentStream"));
                                pipeline.videoSegmentStream.on("timelineStartInfo", (function(timelineStartInfo) {
                                    if (audioTrack && !options.keepOriginalTimestamps) {
                                        audioTrack.timelineStartInfo = timelineStartInfo;
                                        pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts - self.baseMediaDecodeTime);
                                    }
                                }));
                                pipeline.videoSegmentStream.on("processedGopsInfo", self.trigger.bind(self, "gopInfo"));
                                pipeline.videoSegmentStream.on("segmentTimingInfo", self.trigger.bind(self, "videoSegmentTimingInfo"));
                                pipeline.videoSegmentStream.on("baseMediaDecodeTime", (function(baseMediaDecodeTime) {
                                    if (audioTrack) pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);
                                }));
                                pipeline.videoSegmentStream.on("timingInfo", self.trigger.bind(self, "videoTimingInfo"));
                                pipeline.h264Stream.pipe(pipeline.videoSegmentStream).pipe(pipeline.coalesceStream);
                            }
                            if (audioTrack && !pipeline.audioSegmentStream) {
                                pipeline.coalesceStream.numberOfTracks++;
                                pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);
                                pipeline.audioSegmentStream.on("log", self.getLogTrigger_("audioSegmentStream"));
                                pipeline.audioSegmentStream.on("timingInfo", self.trigger.bind(self, "audioTimingInfo"));
                                pipeline.audioSegmentStream.on("segmentTimingInfo", self.trigger.bind(self, "audioSegmentTimingInfo"));
                                pipeline.adtsStream.pipe(pipeline.audioSegmentStream).pipe(pipeline.coalesceStream);
                            }
                            self.trigger("trackinfo", {
                                hasAudio: !!audioTrack,
                                hasVideo: !!videoTrack
                            });
                        }
                    }));
                    pipeline.coalesceStream.on("data", this.trigger.bind(this, "data"));
                    pipeline.coalesceStream.on("id3Frame", (function(id3Frame) {
                        id3Frame.dispatchType = pipeline.metadataStream.dispatchType;
                        self.trigger("id3Frame", id3Frame);
                    }));
                    pipeline.coalesceStream.on("caption", this.trigger.bind(this, "caption"));
                    pipeline.coalesceStream.on("done", this.trigger.bind(this, "done"));
                    addPipelineLogRetriggers(this, pipeline);
                };
                this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {
                    var pipeline = this.transmuxPipeline_;
                    if (!options.keepOriginalTimestamps) this.baseMediaDecodeTime = baseMediaDecodeTime;
                    if (audioTrack) {
                        audioTrack.timelineStartInfo.dts = void 0;
                        audioTrack.timelineStartInfo.pts = void 0;
                        trackDecodeInfo.clearDtsInfo(audioTrack);
                        if (pipeline.audioTimestampRolloverStream) pipeline.audioTimestampRolloverStream.discontinuity();
                    }
                    if (videoTrack) {
                        if (pipeline.videoSegmentStream) pipeline.videoSegmentStream.gopCache_ = [];
                        videoTrack.timelineStartInfo.dts = void 0;
                        videoTrack.timelineStartInfo.pts = void 0;
                        trackDecodeInfo.clearDtsInfo(videoTrack);
                        pipeline.captionStream.reset();
                    }
                    if (pipeline.timestampRolloverStream) pipeline.timestampRolloverStream.discontinuity();
                };
                this.setAudioAppendStart = function(timestamp) {
                    if (audioTrack) this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);
                };
                this.setRemux = function(val) {
                    var pipeline = this.transmuxPipeline_;
                    options.remux = val;
                    if (pipeline && pipeline.coalesceStream) pipeline.coalesceStream.setRemux(val);
                };
                this.alignGopsWith = function(gopsToAlignWith) {
                    if (videoTrack && this.transmuxPipeline_.videoSegmentStream) this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);
                };
                this.getLogTrigger_ = function(key) {
                    var self = this;
                    return function(event) {
                        event.stream = key;
                        self.trigger("log", event);
                    };
                };
                this.push = function(data) {
                    if (hasFlushed) {
                        var isAac = isLikelyAacData(data);
                        if (isAac && this.transmuxPipeline_.type !== "aac") this.setupAacPipeline(); else if (!isAac && this.transmuxPipeline_.type !== "ts") this.setupTsPipeline();
                        hasFlushed = false;
                    }
                    this.transmuxPipeline_.headOfPipeline.push(data);
                };
                this.flush = function() {
                    hasFlushed = true;
                    this.transmuxPipeline_.headOfPipeline.flush();
                };
                this.endTimeline = function() {
                    this.transmuxPipeline_.headOfPipeline.endTimeline();
                };
                this.reset = function() {
                    if (this.transmuxPipeline_.headOfPipeline) this.transmuxPipeline_.headOfPipeline.reset();
                };
                this.resetCaptions = function() {
                    if (this.transmuxPipeline_.captionStream) this.transmuxPipeline_.captionStream.reset();
                };
            };
            Transmuxer.prototype = new Stream;
            var transmuxer = {
                Transmuxer,
                VideoSegmentStream,
                AudioSegmentStream,
                AUDIO_PROPERTIES,
                VIDEO_PROPERTIES,
                generateSegmentTimingInfo
            };
            var toUnsigned$3 = function(value) {
                return value >>> 0;
            };
            var toHexString$1 = function(value) {
                return ("00" + value.toString(16)).slice(-2);
            };
            var bin = {
                toUnsigned: toUnsigned$3,
                toHexString: toHexString$1
            };
            var parseType$3 = function(buffer) {
                var result = "";
                result += String.fromCharCode(buffer[0]);
                result += String.fromCharCode(buffer[1]);
                result += String.fromCharCode(buffer[2]);
                result += String.fromCharCode(buffer[3]);
                return result;
            };
            var parseType_1 = parseType$3;
            var toUnsigned$2 = bin.toUnsigned;
            var parseType$2 = parseType_1;
            var findBox$2 = function(data, path) {
                var i, size, type, end, subresults, results = [];
                if (!path.length) return null;
                for (i = 0; i < data.byteLength; ) {
                    size = toUnsigned$2(data[i] << 24 | data[i + 1] << 16 | data[i + 2] << 8 | data[i + 3]);
                    type = parseType$2(data.subarray(i + 4, i + 8));
                    end = size > 1 ? i + size : data.byteLength;
                    if (type === path[0]) if (path.length === 1) results.push(data.subarray(i + 8, end)); else {
                        subresults = findBox$2(data.subarray(i + 8, end), path.slice(1));
                        if (subresults.length) results = results.concat(subresults);
                    }
                    i = end;
                }
                return results;
            };
            var findBox_1 = findBox$2;
            var toUnsigned$1 = bin.toUnsigned;
            var getUint64$2 = numbers.getUint64;
            var tfdt = function(data) {
                var result = {
                    version: data[0],
                    flags: new Uint8Array(data.subarray(1, 4))
                };
                if (result.version === 1) result.baseMediaDecodeTime = getUint64$2(data.subarray(4)); else result.baseMediaDecodeTime = toUnsigned$1(data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]);
                return result;
            };
            var parseTfdt$2 = tfdt;
            var parseSampleFlags$1 = function(flags) {
                return {
                    isLeading: (flags[0] & 12) >>> 2,
                    dependsOn: flags[0] & 3,
                    isDependedOn: (flags[1] & 192) >>> 6,
                    hasRedundancy: (flags[1] & 48) >>> 4,
                    paddingValue: (flags[1] & 14) >>> 1,
                    isNonSyncSample: flags[1] & 1,
                    degradationPriority: flags[2] << 8 | flags[3]
                };
            };
            var parseSampleFlags_1 = parseSampleFlags$1;
            var parseSampleFlags = parseSampleFlags_1;
            var trun = function(data) {
                var sample, result = {
                    version: data[0],
                    flags: new Uint8Array(data.subarray(1, 4)),
                    samples: []
                }, view = new DataView(data.buffer, data.byteOffset, data.byteLength), dataOffsetPresent = result.flags[2] & 1, firstSampleFlagsPresent = result.flags[2] & 4, sampleDurationPresent = result.flags[1] & 1, sampleSizePresent = result.flags[1] & 2, sampleFlagsPresent = result.flags[1] & 4, sampleCompositionTimeOffsetPresent = result.flags[1] & 8, sampleCount = view.getUint32(4), offset = 8;
                if (dataOffsetPresent) {
                    result.dataOffset = view.getInt32(offset);
                    offset += 4;
                }
                if (firstSampleFlagsPresent && sampleCount) {
                    sample = {
                        flags: parseSampleFlags(data.subarray(offset, offset + 4))
                    };
                    offset += 4;
                    if (sampleDurationPresent) {
                        sample.duration = view.getUint32(offset);
                        offset += 4;
                    }
                    if (sampleSizePresent) {
                        sample.size = view.getUint32(offset);
                        offset += 4;
                    }
                    if (sampleCompositionTimeOffsetPresent) {
                        if (result.version === 1) sample.compositionTimeOffset = view.getInt32(offset); else sample.compositionTimeOffset = view.getUint32(offset);
                        offset += 4;
                    }
                    result.samples.push(sample);
                    sampleCount--;
                }
                while (sampleCount--) {
                    sample = {};
                    if (sampleDurationPresent) {
                        sample.duration = view.getUint32(offset);
                        offset += 4;
                    }
                    if (sampleSizePresent) {
                        sample.size = view.getUint32(offset);
                        offset += 4;
                    }
                    if (sampleFlagsPresent) {
                        sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));
                        offset += 4;
                    }
                    if (sampleCompositionTimeOffsetPresent) {
                        if (result.version === 1) sample.compositionTimeOffset = view.getInt32(offset); else sample.compositionTimeOffset = view.getUint32(offset);
                        offset += 4;
                    }
                    result.samples.push(sample);
                }
                return result;
            };
            var parseTrun$2 = trun;
            var tfhd = function(data) {
                var i, view = new DataView(data.buffer, data.byteOffset, data.byteLength), result = {
                    version: data[0],
                    flags: new Uint8Array(data.subarray(1, 4)),
                    trackId: view.getUint32(4)
                }, baseDataOffsetPresent = result.flags[2] & 1, sampleDescriptionIndexPresent = result.flags[2] & 2, defaultSampleDurationPresent = result.flags[2] & 8, defaultSampleSizePresent = result.flags[2] & 16, defaultSampleFlagsPresent = result.flags[2] & 32, durationIsEmpty = result.flags[0] & 65536, defaultBaseIsMoof = result.flags[0] & 131072;
                i = 8;
                if (baseDataOffsetPresent) {
                    i += 4;
                    result.baseDataOffset = view.getUint32(12);
                    i += 4;
                }
                if (sampleDescriptionIndexPresent) {
                    result.sampleDescriptionIndex = view.getUint32(i);
                    i += 4;
                }
                if (defaultSampleDurationPresent) {
                    result.defaultSampleDuration = view.getUint32(i);
                    i += 4;
                }
                if (defaultSampleSizePresent) {
                    result.defaultSampleSize = view.getUint32(i);
                    i += 4;
                }
                if (defaultSampleFlagsPresent) result.defaultSampleFlags = view.getUint32(i);
                if (durationIsEmpty) result.durationIsEmpty = true;
                if (!baseDataOffsetPresent && defaultBaseIsMoof) result.baseDataOffsetIsMoof = true;
                return result;
            };
            var parseTfhd$2 = tfhd;
            var win;
            if (typeof window !== "undefined") win = window; else if (typeof commonjsGlobal !== "undefined") win = commonjsGlobal; else if (typeof self !== "undefined") win = self; else win = {};
            var window_1 = win;
            var discardEmulationPreventionBytes = captionPacketParser.discardEmulationPreventionBytes;
            var CaptionStream = captionStream.CaptionStream;
            var findBox$1 = findBox_1;
            var parseTfdt$1 = parseTfdt$2;
            var parseTrun$1 = parseTrun$2;
            var parseTfhd$1 = parseTfhd$2;
            var window$2 = window_1;
            var mapToSample = function(offset, samples) {
                var approximateOffset = offset;
                for (var i = 0; i < samples.length; i++) {
                    var sample = samples[i];
                    if (approximateOffset < sample.size) return sample;
                    approximateOffset -= sample.size;
                }
                return null;
            };
            var findSeiNals = function(avcStream, samples, trackId) {
                var seiNal, i, length, lastMatchedSample, avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength), result = {
                    logs: [],
                    seiNals: []
                };
                for (i = 0; i + 4 < avcStream.length; i += length) {
                    length = avcView.getUint32(i);
                    i += 4;
                    if (length <= 0) continue;
                    switch (avcStream[i] & 31) {
                      case 6:
                        var data = avcStream.subarray(i + 1, i + 1 + length);
                        var matchingSample = mapToSample(i, samples);
                        seiNal = {
                            nalUnitType: "sei_rbsp",
                            size: length,
                            data,
                            escapedRBSP: discardEmulationPreventionBytes(data),
                            trackId
                        };
                        if (matchingSample) {
                            seiNal.pts = matchingSample.pts;
                            seiNal.dts = matchingSample.dts;
                            lastMatchedSample = matchingSample;
                        } else if (lastMatchedSample) {
                            seiNal.pts = lastMatchedSample.pts;
                            seiNal.dts = lastMatchedSample.dts;
                        } else {
                            result.logs.push({
                                level: "warn",
                                message: "We've encountered a nal unit without data at " + i + " for trackId " + trackId + ". See mux.js#223."
                            });
                            break;
                        }
                        result.seiNals.push(seiNal);
                        break;
                    }
                }
                return result;
            };
            var parseSamples = function(truns, baseMediaDecodeTime, tfhd) {
                var currentDts = baseMediaDecodeTime;
                var defaultSampleDuration = tfhd.defaultSampleDuration || 0;
                var defaultSampleSize = tfhd.defaultSampleSize || 0;
                var trackId = tfhd.trackId;
                var allSamples = [];
                truns.forEach((function(trun) {
                    var trackRun = parseTrun$1(trun);
                    var samples = trackRun.samples;
                    samples.forEach((function(sample) {
                        if (sample.duration === void 0) sample.duration = defaultSampleDuration;
                        if (sample.size === void 0) sample.size = defaultSampleSize;
                        sample.trackId = trackId;
                        sample.dts = currentDts;
                        if (sample.compositionTimeOffset === void 0) sample.compositionTimeOffset = 0;
                        if (typeof currentDts === "bigint") {
                            sample.pts = currentDts + window$2.BigInt(sample.compositionTimeOffset);
                            currentDts += window$2.BigInt(sample.duration);
                        } else {
                            sample.pts = currentDts + sample.compositionTimeOffset;
                            currentDts += sample.duration;
                        }
                    }));
                    allSamples = allSamples.concat(samples);
                }));
                return allSamples;
            };
            var parseCaptionNals = function(segment, videoTrackId) {
                var trafs = findBox$1(segment, [ "moof", "traf" ]);
                var mdats = findBox$1(segment, [ "mdat" ]);
                var captionNals = {};
                var mdatTrafPairs = [];
                mdats.forEach((function(mdat, index) {
                    var matchingTraf = trafs[index];
                    mdatTrafPairs.push({
                        mdat,
                        traf: matchingTraf
                    });
                }));
                mdatTrafPairs.forEach((function(pair) {
                    var mdat = pair.mdat;
                    var traf = pair.traf;
                    var tfhd = findBox$1(traf, [ "tfhd" ]);
                    var headerInfo = parseTfhd$1(tfhd[0]);
                    var trackId = headerInfo.trackId;
                    var tfdt = findBox$1(traf, [ "tfdt" ]);
                    var baseMediaDecodeTime = tfdt.length > 0 ? parseTfdt$1(tfdt[0]).baseMediaDecodeTime : 0;
                    var truns = findBox$1(traf, [ "trun" ]);
                    var samples;
                    var result;
                    if (videoTrackId === trackId && truns.length > 0) {
                        samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);
                        result = findSeiNals(mdat, samples, trackId);
                        if (!captionNals[trackId]) captionNals[trackId] = {
                            seiNals: [],
                            logs: []
                        };
                        captionNals[trackId].seiNals = captionNals[trackId].seiNals.concat(result.seiNals);
                        captionNals[trackId].logs = captionNals[trackId].logs.concat(result.logs);
                    }
                }));
                return captionNals;
            };
            var parseEmbeddedCaptions = function(segment, trackId, timescale) {
                var captionNals;
                if (trackId === null) return null;
                captionNals = parseCaptionNals(segment, trackId);
                var trackNals = captionNals[trackId] || {};
                return {
                    seiNals: trackNals.seiNals,
                    logs: trackNals.logs,
                    timescale
                };
            };
            var CaptionParser = function() {
                var isInitialized = false;
                var captionStream;
                var segmentCache;
                var trackId;
                var timescale;
                var parsedCaptions;
                var parsingPartial;
                this.isInitialized = function() {
                    return isInitialized;
                };
                this.init = function(options) {
                    captionStream = new CaptionStream;
                    isInitialized = true;
                    parsingPartial = options ? options.isPartial : false;
                    captionStream.on("data", (function(event) {
                        event.startTime = event.startPts / timescale;
                        event.endTime = event.endPts / timescale;
                        parsedCaptions.captions.push(event);
                        parsedCaptions.captionStreams[event.stream] = true;
                    }));
                    captionStream.on("log", (function(log) {
                        parsedCaptions.logs.push(log);
                    }));
                };
                this.isNewInit = function(videoTrackIds, timescales) {
                    if (videoTrackIds && videoTrackIds.length === 0 || timescales && typeof timescales === "object" && Object.keys(timescales).length === 0) return false;
                    return trackId !== videoTrackIds[0] || timescale !== timescales[trackId];
                };
                this.parse = function(segment, videoTrackIds, timescales) {
                    var parsedData;
                    if (!this.isInitialized()) return null; else if (!videoTrackIds || !timescales) return null; else if (this.isNewInit(videoTrackIds, timescales)) {
                        trackId = videoTrackIds[0];
                        timescale = timescales[trackId];
                    } else if (trackId === null || !timescale) {
                        segmentCache.push(segment);
                        return null;
                    }
                    while (segmentCache.length > 0) {
                        var cachedSegment = segmentCache.shift();
                        this.parse(cachedSegment, videoTrackIds, timescales);
                    }
                    parsedData = parseEmbeddedCaptions(segment, trackId, timescale);
                    if (parsedData && parsedData.logs) parsedCaptions.logs = parsedCaptions.logs.concat(parsedData.logs);
                    if (parsedData === null || !parsedData.seiNals) {
                        if (parsedCaptions.logs.length) return {
                            logs: parsedCaptions.logs,
                            captions: [],
                            captionStreams: []
                        };
                        return null;
                    }
                    this.pushNals(parsedData.seiNals);
                    this.flushStream();
                    return parsedCaptions;
                };
                this.pushNals = function(nals) {
                    if (!this.isInitialized() || !nals || nals.length === 0) return null;
                    nals.forEach((function(nal) {
                        captionStream.push(nal);
                    }));
                };
                this.flushStream = function() {
                    if (!this.isInitialized()) return null;
                    if (!parsingPartial) captionStream.flush(); else captionStream.partialFlush();
                };
                this.clearParsedCaptions = function() {
                    parsedCaptions.captions = [];
                    parsedCaptions.captionStreams = {};
                    parsedCaptions.logs = [];
                };
                this.resetCaptionStream = function() {
                    if (!this.isInitialized()) return null;
                    captionStream.reset();
                };
                this.clearAllCaptions = function() {
                    this.clearParsedCaptions();
                    this.resetCaptionStream();
                };
                this.reset = function() {
                    segmentCache = [];
                    trackId = null;
                    timescale = null;
                    if (!parsedCaptions) parsedCaptions = {
                        captions: [],
                        captionStreams: {},
                        logs: []
                    }; else this.clearParsedCaptions();
                    this.resetCaptionStream();
                };
                this.reset();
            };
            var captionParser = CaptionParser;
            var uint8ToCString$1 = function(data) {
                var index = 0;
                var curChar = String.fromCharCode(data[index]);
                var retString = "";
                while (curChar !== "\0") {
                    retString += curChar;
                    index++;
                    curChar = String.fromCharCode(data[index]);
                }
                retString += curChar;
                return retString;
            };
            var string = {
                uint8ToCString: uint8ToCString$1
            };
            var uint8ToCString = string.uint8ToCString;
            var getUint64$1 = numbers.getUint64;
            var parseEmsgBox = function(boxData) {
                var offset = 4;
                var version = boxData[0];
                var scheme_id_uri, value, timescale, presentation_time, presentation_time_delta, event_duration, id, message_data;
                if (version === 0) {
                    scheme_id_uri = uint8ToCString(boxData.subarray(offset));
                    offset += scheme_id_uri.length;
                    value = uint8ToCString(boxData.subarray(offset));
                    offset += value.length;
                    var dv = new DataView(boxData.buffer);
                    timescale = dv.getUint32(offset);
                    offset += 4;
                    presentation_time_delta = dv.getUint32(offset);
                    offset += 4;
                    event_duration = dv.getUint32(offset);
                    offset += 4;
                    id = dv.getUint32(offset);
                    offset += 4;
                } else if (version === 1) {
                    dv = new DataView(boxData.buffer);
                    timescale = dv.getUint32(offset);
                    offset += 4;
                    presentation_time = getUint64$1(boxData.subarray(offset));
                    offset += 8;
                    event_duration = dv.getUint32(offset);
                    offset += 4;
                    id = dv.getUint32(offset);
                    offset += 4;
                    scheme_id_uri = uint8ToCString(boxData.subarray(offset));
                    offset += scheme_id_uri.length;
                    value = uint8ToCString(boxData.subarray(offset));
                    offset += value.length;
                }
                message_data = new Uint8Array(boxData.subarray(offset, boxData.byteLength));
                var emsgBox = {
                    scheme_id_uri,
                    value,
                    timescale: timescale ? timescale : 1,
                    presentation_time,
                    presentation_time_delta,
                    event_duration,
                    id,
                    message_data
                };
                return isValidEmsgBox(version, emsgBox) ? emsgBox : void 0;
            };
            var scaleTime = function(presentationTime, timescale, timeDelta, offset) {
                return presentationTime || presentationTime === 0 ? presentationTime / timescale : offset + timeDelta / timescale;
            };
            var isValidEmsgBox = function(version, emsg) {
                var hasScheme = emsg.scheme_id_uri !== "\0";
                var isValidV0Box = version === 0 && isDefined(emsg.presentation_time_delta) && hasScheme;
                var isValidV1Box = version === 1 && isDefined(emsg.presentation_time) && hasScheme;
                return !(version > 1) && isValidV0Box || isValidV1Box;
            };
            var isDefined = function(data) {
                return data !== void 0 || data !== null;
            };
            var emsg$1 = {
                parseEmsgBox,
                scaleTime
            };
            var toUnsigned = bin.toUnsigned;
            var toHexString = bin.toHexString;
            var findBox = findBox_1;
            var parseType$1 = parseType_1;
            var emsg = emsg$1;
            var parseTfhd = parseTfhd$2;
            var parseTrun = parseTrun$2;
            var parseTfdt = parseTfdt$2;
            var getUint64 = numbers.getUint64;
            var timescale, startTime, compositionStartTime, getVideoTrackIds, getTracks, getTimescaleFromMediaHeader, getEmsgID3;
            var window$1 = window_1;
            var parseId3Frames = parseId3.parseId3Frames;
            timescale = function(init) {
                var result = {}, traks = findBox(init, [ "moov", "trak" ]);
                return traks.reduce((function(result, trak) {
                    var tkhd, version, index, id, mdhd;
                    tkhd = findBox(trak, [ "tkhd" ])[0];
                    if (!tkhd) return null;
                    version = tkhd[0];
                    index = version === 0 ? 12 : 20;
                    id = toUnsigned(tkhd[index] << 24 | tkhd[index + 1] << 16 | tkhd[index + 2] << 8 | tkhd[index + 3]);
                    mdhd = findBox(trak, [ "mdia", "mdhd" ])[0];
                    if (!mdhd) return null;
                    version = mdhd[0];
                    index = version === 0 ? 12 : 20;
                    result[id] = toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);
                    return result;
                }), result);
            };
            startTime = function(timescale, fragment) {
                var trafs;
                trafs = findBox(fragment, [ "moof", "traf" ]);
                var lowestTime = trafs.reduce((function(acc, traf) {
                    var tfhd = findBox(traf, [ "tfhd" ])[0];
                    var id = toUnsigned(tfhd[4] << 24 | tfhd[5] << 16 | tfhd[6] << 8 | tfhd[7]);
                    var scale = timescale[id] || 9e4;
                    var tfdt = findBox(traf, [ "tfdt" ])[0];
                    var dv = new DataView(tfdt.buffer, tfdt.byteOffset, tfdt.byteLength);
                    var baseTime;
                    if (tfdt[0] === 1) baseTime = getUint64(tfdt.subarray(4, 12)); else baseTime = dv.getUint32(4);
                    let seconds;
                    if (typeof baseTime === "bigint") seconds = baseTime / window$1.BigInt(scale); else if (typeof baseTime === "number" && !isNaN(baseTime)) seconds = baseTime / scale;
                    if (seconds < Number.MAX_SAFE_INTEGER) seconds = Number(seconds);
                    if (seconds < acc) acc = seconds;
                    return acc;
                }), 1 / 0);
                return typeof lowestTime === "bigint" || isFinite(lowestTime) ? lowestTime : 0;
            };
            compositionStartTime = function(timescales, fragment) {
                var trafBoxes = findBox(fragment, [ "moof", "traf" ]);
                var baseMediaDecodeTime = 0;
                var compositionTimeOffset = 0;
                var trackId;
                if (trafBoxes && trafBoxes.length) {
                    var tfhd = findBox(trafBoxes[0], [ "tfhd" ])[0];
                    var trun = findBox(trafBoxes[0], [ "trun" ])[0];
                    var tfdt = findBox(trafBoxes[0], [ "tfdt" ])[0];
                    if (tfhd) {
                        var parsedTfhd = parseTfhd(tfhd);
                        trackId = parsedTfhd.trackId;
                    }
                    if (tfdt) {
                        var parsedTfdt = parseTfdt(tfdt);
                        baseMediaDecodeTime = parsedTfdt.baseMediaDecodeTime;
                    }
                    if (trun) {
                        var parsedTrun = parseTrun(trun);
                        if (parsedTrun.samples && parsedTrun.samples.length) compositionTimeOffset = parsedTrun.samples[0].compositionTimeOffset || 0;
                    }
                }
                var timescale = timescales[trackId] || 9e4;
                if (typeof baseMediaDecodeTime === "bigint") {
                    compositionTimeOffset = window$1.BigInt(compositionTimeOffset);
                    timescale = window$1.BigInt(timescale);
                }
                var result = (baseMediaDecodeTime + compositionTimeOffset) / timescale;
                if (typeof result === "bigint" && result < Number.MAX_SAFE_INTEGER) result = Number(result);
                return result;
            };
            getVideoTrackIds = function(init) {
                var traks = findBox(init, [ "moov", "trak" ]);
                var videoTrackIds = [];
                traks.forEach((function(trak) {
                    var hdlrs = findBox(trak, [ "mdia", "hdlr" ]);
                    var tkhds = findBox(trak, [ "tkhd" ]);
                    hdlrs.forEach((function(hdlr, index) {
                        var handlerType = parseType$1(hdlr.subarray(8, 12));
                        var tkhd = tkhds[index];
                        var view;
                        var version;
                        var trackId;
                        if (handlerType === "vide") {
                            view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);
                            version = view.getUint8(0);
                            trackId = version === 0 ? view.getUint32(12) : view.getUint32(20);
                            videoTrackIds.push(trackId);
                        }
                    }));
                }));
                return videoTrackIds;
            };
            getTimescaleFromMediaHeader = function(mdhd) {
                var version = mdhd[0];
                var index = version === 0 ? 12 : 20;
                return toUnsigned(mdhd[index] << 24 | mdhd[index + 1] << 16 | mdhd[index + 2] << 8 | mdhd[index + 3]);
            };
            getTracks = function(init) {
                var traks = findBox(init, [ "moov", "trak" ]);
                var tracks = [];
                traks.forEach((function(trak) {
                    var track = {};
                    var tkhd = findBox(trak, [ "tkhd" ])[0];
                    var view, tkhdVersion;
                    if (tkhd) {
                        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);
                        tkhdVersion = view.getUint8(0);
                        track.id = tkhdVersion === 0 ? view.getUint32(12) : view.getUint32(20);
                    }
                    var hdlr = findBox(trak, [ "mdia", "hdlr" ])[0];
                    if (hdlr) {
                        var type = parseType$1(hdlr.subarray(8, 12));
                        if (type === "vide") track.type = "video"; else if (type === "soun") track.type = "audio"; else track.type = type;
                    }
                    var stsd = findBox(trak, [ "mdia", "minf", "stbl", "stsd" ])[0];
                    if (stsd) {
                        var sampleDescriptions = stsd.subarray(8);
                        track.codec = parseType$1(sampleDescriptions.subarray(4, 8));
                        var codecBox = findBox(sampleDescriptions, [ track.codec ])[0];
                        var codecConfig, codecConfigType;
                        if (codecBox) if (/^[asm]vc[1-9]$/i.test(track.codec)) {
                            codecConfig = codecBox.subarray(78);
                            codecConfigType = parseType$1(codecConfig.subarray(4, 8));
                            if (codecConfigType === "avcC" && codecConfig.length > 11) {
                                track.codec += ".";
                                track.codec += toHexString(codecConfig[9]);
                                track.codec += toHexString(codecConfig[10]);
                                track.codec += toHexString(codecConfig[11]);
                            } else track.codec = "avc1.4d400d";
                        } else if (/^mp4[a,v]$/i.test(track.codec)) {
                            codecConfig = codecBox.subarray(28);
                            codecConfigType = parseType$1(codecConfig.subarray(4, 8));
                            if (codecConfigType === "esds" && codecConfig.length > 20 && codecConfig[19] !== 0) {
                                track.codec += "." + toHexString(codecConfig[19]);
                                track.codec += "." + toHexString(codecConfig[20] >>> 2 & 63).replace(/^0/, "");
                            } else track.codec = "mp4a.40.2";
                        } else track.codec = track.codec.toLowerCase();
                    }
                    var mdhd = findBox(trak, [ "mdia", "mdhd" ])[0];
                    if (mdhd) track.timescale = getTimescaleFromMediaHeader(mdhd);
                    tracks.push(track);
                }));
                return tracks;
            };
            getEmsgID3 = function(segmentData, offset = 0) {
                var emsgBoxes = findBox(segmentData, [ "emsg" ]);
                return emsgBoxes.map((data => {
                    var parsedBox = emsg.parseEmsgBox(new Uint8Array(data));
                    var parsedId3Frames = parseId3Frames(parsedBox.message_data);
                    return {
                        cueTime: emsg.scaleTime(parsedBox.presentation_time, parsedBox.timescale, parsedBox.presentation_time_delta, offset),
                        duration: emsg.scaleTime(parsedBox.event_duration, parsedBox.timescale),
                        frames: parsedId3Frames
                    };
                }));
            };
            var probe$2 = {
                findBox,
                parseType: parseType$1,
                timescale,
                startTime,
                compositionStartTime,
                videoTrackIds: getVideoTrackIds,
                tracks: getTracks,
                getTimescaleFromMediaHeader,
                getEmsgID3
            };
            var StreamTypes$1 = streamTypes;
            var parsePid = function(packet) {
                var pid = packet[1] & 31;
                pid <<= 8;
                pid |= packet[2];
                return pid;
            };
            var parsePayloadUnitStartIndicator = function(packet) {
                return !!(packet[1] & 64);
            };
            var parseAdaptionField = function(packet) {
                var offset = 0;
                if ((packet[3] & 48) >>> 4 > 1) offset += packet[4] + 1;
                return offset;
            };
            var parseType = function(packet, pmtPid) {
                var pid = parsePid(packet);
                if (pid === 0) return "pat"; else if (pid === pmtPid) return "pmt"; else if (pmtPid) return "pes";
                return null;
            };
            var parsePat = function(packet) {
                var pusi = parsePayloadUnitStartIndicator(packet);
                var offset = 4 + parseAdaptionField(packet);
                if (pusi) offset += packet[offset] + 1;
                return (packet[offset + 10] & 31) << 8 | packet[offset + 11];
            };
            var parsePmt = function(packet) {
                var programMapTable = {};
                var pusi = parsePayloadUnitStartIndicator(packet);
                var payloadOffset = 4 + parseAdaptionField(packet);
                if (pusi) payloadOffset += packet[payloadOffset] + 1;
                if (!(packet[payloadOffset + 5] & 1)) return;
                var sectionLength, tableEnd, programInfoLength;
                sectionLength = (packet[payloadOffset + 1] & 15) << 8 | packet[payloadOffset + 2];
                tableEnd = 3 + sectionLength - 4;
                programInfoLength = (packet[payloadOffset + 10] & 15) << 8 | packet[payloadOffset + 11];
                var offset = 12 + programInfoLength;
                while (offset < tableEnd) {
                    var i = payloadOffset + offset;
                    programMapTable[(packet[i + 1] & 31) << 8 | packet[i + 2]] = packet[i];
                    offset += ((packet[i + 3] & 15) << 8 | packet[i + 4]) + 5;
                }
                return programMapTable;
            };
            var parsePesType = function(packet, programMapTable) {
                var pid = parsePid(packet);
                var type = programMapTable[pid];
                switch (type) {
                  case StreamTypes$1.H264_STREAM_TYPE:
                    return "video";

                  case StreamTypes$1.ADTS_STREAM_TYPE:
                    return "audio";

                  case StreamTypes$1.METADATA_STREAM_TYPE:
                    return "timed-metadata";

                  default:
                    return null;
                }
            };
            var parsePesTime = function(packet) {
                var pusi = parsePayloadUnitStartIndicator(packet);
                if (!pusi) return null;
                var offset = 4 + parseAdaptionField(packet);
                if (offset >= packet.byteLength) return null;
                var pes = null;
                var ptsDtsFlags;
                ptsDtsFlags = packet[offset + 7];
                if (ptsDtsFlags & 192) {
                    pes = {};
                    pes.pts = (packet[offset + 9] & 14) << 27 | (packet[offset + 10] & 255) << 20 | (packet[offset + 11] & 254) << 12 | (packet[offset + 12] & 255) << 5 | (packet[offset + 13] & 254) >>> 3;
                    pes.pts *= 4;
                    pes.pts += (packet[offset + 13] & 6) >>> 1;
                    pes.dts = pes.pts;
                    if (ptsDtsFlags & 64) {
                        pes.dts = (packet[offset + 14] & 14) << 27 | (packet[offset + 15] & 255) << 20 | (packet[offset + 16] & 254) << 12 | (packet[offset + 17] & 255) << 5 | (packet[offset + 18] & 254) >>> 3;
                        pes.dts *= 4;
                        pes.dts += (packet[offset + 18] & 6) >>> 1;
                    }
                }
                return pes;
            };
            var parseNalUnitType = function(type) {
                switch (type) {
                  case 5:
                    return "slice_layer_without_partitioning_rbsp_idr";

                  case 6:
                    return "sei_rbsp";

                  case 7:
                    return "seq_parameter_set_rbsp";

                  case 8:
                    return "pic_parameter_set_rbsp";

                  case 9:
                    return "access_unit_delimiter_rbsp";

                  default:
                    return null;
                }
            };
            var videoPacketContainsKeyFrame = function(packet) {
                var offset = 4 + parseAdaptionField(packet);
                var frameBuffer = packet.subarray(offset);
                var frameI = 0;
                var frameSyncPoint = 0;
                var foundKeyFrame = false;
                var nalType;
                for (;frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) if (frameBuffer[frameSyncPoint + 2] === 1) {
                    frameI = frameSyncPoint + 5;
                    break;
                }
                while (frameI < frameBuffer.byteLength) switch (frameBuffer[frameI]) {
                  case 0:
                    if (frameBuffer[frameI - 1] !== 0) {
                        frameI += 2;
                        break;
                    } else if (frameBuffer[frameI - 2] !== 0) {
                        frameI++;
                        break;
                    }
                    if (frameSyncPoint + 3 !== frameI - 2) {
                        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
                        if (nalType === "slice_layer_without_partitioning_rbsp_idr") foundKeyFrame = true;
                    }
                    do {
                        frameI++;
                    } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);
                    frameSyncPoint = frameI - 2;
                    frameI += 3;
                    break;

                  case 1:
                    if (frameBuffer[frameI - 1] !== 0 || frameBuffer[frameI - 2] !== 0) {
                        frameI += 3;
                        break;
                    }
                    nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
                    if (nalType === "slice_layer_without_partitioning_rbsp_idr") foundKeyFrame = true;
                    frameSyncPoint = frameI - 2;
                    frameI += 3;
                    break;

                  default:
                    frameI += 3;
                    break;
                }
                frameBuffer = frameBuffer.subarray(frameSyncPoint);
                frameI -= frameSyncPoint;
                frameSyncPoint = 0;
                if (frameBuffer && frameBuffer.byteLength > 3) {
                    nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 31);
                    if (nalType === "slice_layer_without_partitioning_rbsp_idr") foundKeyFrame = true;
                }
                return foundKeyFrame;
            };
            var probe$1 = {
                parseType,
                parsePat,
                parsePmt,
                parsePayloadUnitStartIndicator,
                parsePesType,
                parsePesTime,
                videoPacketContainsKeyFrame
            };
            var StreamTypes = streamTypes;
            var handleRollover = timestampRolloverStream.handleRollover;
            var probe = {};
            probe.ts = probe$1;
            probe.aac = utils;
            var ONE_SECOND_IN_TS = clock$2.ONE_SECOND_IN_TS;
            var MP2T_PACKET_LENGTH = 188, SYNC_BYTE = 71;
            var parsePsi_ = function(bytes, pmt) {
                var packet, type, startIndex = 0, endIndex = MP2T_PACKET_LENGTH;
                while (endIndex < bytes.byteLength) {
                    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
                        packet = bytes.subarray(startIndex, endIndex);
                        type = probe.ts.parseType(packet, pmt.pid);
                        switch (type) {
                          case "pat":
                            pmt.pid = probe.ts.parsePat(packet);
                            break;

                          case "pmt":
                            var table = probe.ts.parsePmt(packet);
                            pmt.table = pmt.table || {};
                            Object.keys(table).forEach((function(key) {
                                pmt.table[key] = table[key];
                            }));
                            break;
                        }
                        startIndex += MP2T_PACKET_LENGTH;
                        endIndex += MP2T_PACKET_LENGTH;
                        continue;
                    }
                    startIndex++;
                    endIndex++;
                }
            };
            var parseAudioPes_ = function(bytes, pmt, result) {
                var packet, type, pesType, pusi, parsed, startIndex = 0, endIndex = MP2T_PACKET_LENGTH;
                var endLoop = false;
                while (endIndex <= bytes.byteLength) {
                    if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
                        packet = bytes.subarray(startIndex, endIndex);
                        type = probe.ts.parseType(packet, pmt.pid);
                        switch (type) {
                          case "pes":
                            pesType = probe.ts.parsePesType(packet, pmt.table);
                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                            if (pesType === "audio" && pusi) {
                                parsed = probe.ts.parsePesTime(packet);
                                if (parsed) {
                                    parsed.type = "audio";
                                    result.audio.push(parsed);
                                    endLoop = true;
                                }
                            }
                            break;
                        }
                        if (endLoop) break;
                        startIndex += MP2T_PACKET_LENGTH;
                        endIndex += MP2T_PACKET_LENGTH;
                        continue;
                    }
                    startIndex++;
                    endIndex++;
                }
                endIndex = bytes.byteLength;
                startIndex = endIndex - MP2T_PACKET_LENGTH;
                endLoop = false;
                while (startIndex >= 0) {
                    if (bytes[startIndex] === SYNC_BYTE && (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {
                        packet = bytes.subarray(startIndex, endIndex);
                        type = probe.ts.parseType(packet, pmt.pid);
                        switch (type) {
                          case "pes":
                            pesType = probe.ts.parsePesType(packet, pmt.table);
                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                            if (pesType === "audio" && pusi) {
                                parsed = probe.ts.parsePesTime(packet);
                                if (parsed) {
                                    parsed.type = "audio";
                                    result.audio.push(parsed);
                                    endLoop = true;
                                }
                            }
                            break;
                        }
                        if (endLoop) break;
                        startIndex -= MP2T_PACKET_LENGTH;
                        endIndex -= MP2T_PACKET_LENGTH;
                        continue;
                    }
                    startIndex--;
                    endIndex--;
                }
            };
            var parseVideoPes_ = function(bytes, pmt, result) {
                var packet, type, pesType, pusi, parsed, frame, i, pes, startIndex = 0, endIndex = MP2T_PACKET_LENGTH;
                var endLoop = false;
                var currentFrame = {
                    data: [],
                    size: 0
                };
                while (endIndex < bytes.byteLength) {
                    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
                        packet = bytes.subarray(startIndex, endIndex);
                        type = probe.ts.parseType(packet, pmt.pid);
                        switch (type) {
                          case "pes":
                            pesType = probe.ts.parsePesType(packet, pmt.table);
                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                            if (pesType === "video") {
                                if (pusi && !endLoop) {
                                    parsed = probe.ts.parsePesTime(packet);
                                    if (parsed) {
                                        parsed.type = "video";
                                        result.video.push(parsed);
                                        endLoop = true;
                                    }
                                }
                                if (!result.firstKeyFrame) {
                                    if (pusi) if (currentFrame.size !== 0) {
                                        frame = new Uint8Array(currentFrame.size);
                                        i = 0;
                                        while (currentFrame.data.length) {
                                            pes = currentFrame.data.shift();
                                            frame.set(pes, i);
                                            i += pes.byteLength;
                                        }
                                        if (probe.ts.videoPacketContainsKeyFrame(frame)) {
                                            var firstKeyFrame = probe.ts.parsePesTime(frame);
                                            if (firstKeyFrame) {
                                                result.firstKeyFrame = firstKeyFrame;
                                                result.firstKeyFrame.type = "video";
                                            } else console.warn("Failed to extract PTS/DTS from PES at first keyframe. " + "This could be an unusual TS segment, or else mux.js did not " + "parse your TS segment correctly. If you know your TS " + "segments do contain PTS/DTS on keyframes please file a bug " + "report! You can try ffprobe to double check for yourself.");
                                        }
                                        currentFrame.size = 0;
                                    }
                                    currentFrame.data.push(packet);
                                    currentFrame.size += packet.byteLength;
                                }
                            }
                            break;
                        }
                        if (endLoop && result.firstKeyFrame) break;
                        startIndex += MP2T_PACKET_LENGTH;
                        endIndex += MP2T_PACKET_LENGTH;
                        continue;
                    }
                    startIndex++;
                    endIndex++;
                }
                endIndex = bytes.byteLength;
                startIndex = endIndex - MP2T_PACKET_LENGTH;
                endLoop = false;
                while (startIndex >= 0) {
                    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {
                        packet = bytes.subarray(startIndex, endIndex);
                        type = probe.ts.parseType(packet, pmt.pid);
                        switch (type) {
                          case "pes":
                            pesType = probe.ts.parsePesType(packet, pmt.table);
                            pusi = probe.ts.parsePayloadUnitStartIndicator(packet);
                            if (pesType === "video" && pusi) {
                                parsed = probe.ts.parsePesTime(packet);
                                if (parsed) {
                                    parsed.type = "video";
                                    result.video.push(parsed);
                                    endLoop = true;
                                }
                            }
                            break;
                        }
                        if (endLoop) break;
                        startIndex -= MP2T_PACKET_LENGTH;
                        endIndex -= MP2T_PACKET_LENGTH;
                        continue;
                    }
                    startIndex--;
                    endIndex--;
                }
            };
            var adjustTimestamp_ = function(segmentInfo, baseTimestamp) {
                if (segmentInfo.audio && segmentInfo.audio.length) {
                    var audioBaseTimestamp = baseTimestamp;
                    if (typeof audioBaseTimestamp === "undefined" || isNaN(audioBaseTimestamp)) audioBaseTimestamp = segmentInfo.audio[0].dts;
                    segmentInfo.audio.forEach((function(info) {
                        info.dts = handleRollover(info.dts, audioBaseTimestamp);
                        info.pts = handleRollover(info.pts, audioBaseTimestamp);
                        info.dtsTime = info.dts / ONE_SECOND_IN_TS;
                        info.ptsTime = info.pts / ONE_SECOND_IN_TS;
                    }));
                }
                if (segmentInfo.video && segmentInfo.video.length) {
                    var videoBaseTimestamp = baseTimestamp;
                    if (typeof videoBaseTimestamp === "undefined" || isNaN(videoBaseTimestamp)) videoBaseTimestamp = segmentInfo.video[0].dts;
                    segmentInfo.video.forEach((function(info) {
                        info.dts = handleRollover(info.dts, videoBaseTimestamp);
                        info.pts = handleRollover(info.pts, videoBaseTimestamp);
                        info.dtsTime = info.dts / ONE_SECOND_IN_TS;
                        info.ptsTime = info.pts / ONE_SECOND_IN_TS;
                    }));
                    if (segmentInfo.firstKeyFrame) {
                        var frame = segmentInfo.firstKeyFrame;
                        frame.dts = handleRollover(frame.dts, videoBaseTimestamp);
                        frame.pts = handleRollover(frame.pts, videoBaseTimestamp);
                        frame.dtsTime = frame.dts / ONE_SECOND_IN_TS;
                        frame.ptsTime = frame.pts / ONE_SECOND_IN_TS;
                    }
                }
            };
            var inspectAac_ = function(bytes) {
                var packet, endLoop = false, audioCount = 0, sampleRate = null, timestamp = null, frameSize = 0, byteIndex = 0;
                while (bytes.length - byteIndex >= 3) {
                    var type = probe.aac.parseType(bytes, byteIndex);
                    switch (type) {
                      case "timed-metadata":
                        if (bytes.length - byteIndex < 10) {
                            endLoop = true;
                            break;
                        }
                        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);
                        if (frameSize > bytes.length) {
                            endLoop = true;
                            break;
                        }
                        if (timestamp === null) {
                            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
                            timestamp = probe.aac.parseAacTimestamp(packet);
                        }
                        byteIndex += frameSize;
                        break;

                      case "audio":
                        if (bytes.length - byteIndex < 7) {
                            endLoop = true;
                            break;
                        }
                        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);
                        if (frameSize > bytes.length) {
                            endLoop = true;
                            break;
                        }
                        if (sampleRate === null) {
                            packet = bytes.subarray(byteIndex, byteIndex + frameSize);
                            sampleRate = probe.aac.parseSampleRate(packet);
                        }
                        audioCount++;
                        byteIndex += frameSize;
                        break;

                      default:
                        byteIndex++;
                        break;
                    }
                    if (endLoop) return null;
                }
                if (sampleRate === null || timestamp === null) return null;
                var audioTimescale = ONE_SECOND_IN_TS / sampleRate;
                var result = {
                    audio: [ {
                        type: "audio",
                        dts: timestamp,
                        pts: timestamp
                    }, {
                        type: "audio",
                        dts: timestamp + audioCount * 1024 * audioTimescale,
                        pts: timestamp + audioCount * 1024 * audioTimescale
                    } ]
                };
                return result;
            };
            var inspectTs_ = function(bytes) {
                var pmt = {
                    pid: null,
                    table: null
                };
                var result = {};
                parsePsi_(bytes, pmt);
                for (var pid in pmt.table) if (pmt.table.hasOwnProperty(pid)) {
                    var type = pmt.table[pid];
                    switch (type) {
                      case StreamTypes.H264_STREAM_TYPE:
                        result.video = [];
                        parseVideoPes_(bytes, pmt, result);
                        if (result.video.length === 0) delete result.video;
                        break;

                      case StreamTypes.ADTS_STREAM_TYPE:
                        result.audio = [];
                        parseAudioPes_(bytes, pmt, result);
                        if (result.audio.length === 0) delete result.audio;
                        break;
                    }
                }
                return result;
            };
            var inspect = function(bytes, baseTimestamp) {
                var isAacData = probe.aac.isLikelyAacData(bytes);
                var result;
                if (isAacData) result = inspectAac_(bytes); else result = inspectTs_(bytes);
                if (!result || !result.audio && !result.video) return null;
                adjustTimestamp_(result, baseTimestamp);
                return result;
            };
            var tsInspector = {
                inspect,
                parseAudioPes_
            };
            const wireTransmuxerEvents = function(self, transmuxer) {
                transmuxer.on("data", (function(segment) {
                    const initArray = segment.initSegment;
                    segment.initSegment = {
                        data: initArray.buffer,
                        byteOffset: initArray.byteOffset,
                        byteLength: initArray.byteLength
                    };
                    const typedArray = segment.data;
                    segment.data = typedArray.buffer;
                    self.postMessage({
                        action: "data",
                        segment,
                        byteOffset: typedArray.byteOffset,
                        byteLength: typedArray.byteLength
                    }, [ segment.data ]);
                }));
                transmuxer.on("done", (function(data) {
                    self.postMessage({
                        action: "done"
                    });
                }));
                transmuxer.on("gopInfo", (function(gopInfo) {
                    self.postMessage({
                        action: "gopInfo",
                        gopInfo
                    });
                }));
                transmuxer.on("videoSegmentTimingInfo", (function(timingInfo) {
                    const videoSegmentTimingInfo = {
                        start: {
                            decode: clock$2.videoTsToSeconds(timingInfo.start.dts),
                            presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)
                        },
                        end: {
                            decode: clock$2.videoTsToSeconds(timingInfo.end.dts),
                            presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)
                        },
                        baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
                    };
                    if (timingInfo.prependedContentDuration) videoSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);
                    self.postMessage({
                        action: "videoSegmentTimingInfo",
                        videoSegmentTimingInfo
                    });
                }));
                transmuxer.on("audioSegmentTimingInfo", (function(timingInfo) {
                    const audioSegmentTimingInfo = {
                        start: {
                            decode: clock$2.videoTsToSeconds(timingInfo.start.dts),
                            presentation: clock$2.videoTsToSeconds(timingInfo.start.pts)
                        },
                        end: {
                            decode: clock$2.videoTsToSeconds(timingInfo.end.dts),
                            presentation: clock$2.videoTsToSeconds(timingInfo.end.pts)
                        },
                        baseMediaDecodeTime: clock$2.videoTsToSeconds(timingInfo.baseMediaDecodeTime)
                    };
                    if (timingInfo.prependedContentDuration) audioSegmentTimingInfo.prependedContentDuration = clock$2.videoTsToSeconds(timingInfo.prependedContentDuration);
                    self.postMessage({
                        action: "audioSegmentTimingInfo",
                        audioSegmentTimingInfo
                    });
                }));
                transmuxer.on("id3Frame", (function(id3Frame) {
                    self.postMessage({
                        action: "id3Frame",
                        id3Frame
                    });
                }));
                transmuxer.on("caption", (function(caption) {
                    self.postMessage({
                        action: "caption",
                        caption
                    });
                }));
                transmuxer.on("trackinfo", (function(trackInfo) {
                    self.postMessage({
                        action: "trackinfo",
                        trackInfo
                    });
                }));
                transmuxer.on("audioTimingInfo", (function(audioTimingInfo) {
                    self.postMessage({
                        action: "audioTimingInfo",
                        audioTimingInfo: {
                            start: clock$2.videoTsToSeconds(audioTimingInfo.start),
                            end: clock$2.videoTsToSeconds(audioTimingInfo.end)
                        }
                    });
                }));
                transmuxer.on("videoTimingInfo", (function(videoTimingInfo) {
                    self.postMessage({
                        action: "videoTimingInfo",
                        videoTimingInfo: {
                            start: clock$2.videoTsToSeconds(videoTimingInfo.start),
                            end: clock$2.videoTsToSeconds(videoTimingInfo.end)
                        }
                    });
                }));
                transmuxer.on("log", (function(log) {
                    self.postMessage({
                        action: "log",
                        log
                    });
                }));
            };
            class MessageHandlers {
                constructor(self, options) {
                    this.options = options || {};
                    this.self = self;
                    this.init();
                }
                init() {
                    if (this.transmuxer) this.transmuxer.dispose();
                    this.transmuxer = new transmuxer.Transmuxer(this.options);
                    wireTransmuxerEvents(this.self, this.transmuxer);
                }
                pushMp4Captions(data) {
                    if (!this.captionParser) {
                        this.captionParser = new captionParser;
                        this.captionParser.init();
                    }
                    const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
                    const parsed = this.captionParser.parse(segment, data.trackIds, data.timescales);
                    this.self.postMessage({
                        action: "mp4Captions",
                        captions: parsed && parsed.captions || [],
                        logs: parsed && parsed.logs || [],
                        data: segment.buffer
                    }, [ segment.buffer ]);
                }
                probeMp4StartTime({timescales, data}) {
                    const startTime = probe$2.startTime(timescales, data);
                    this.self.postMessage({
                        action: "probeMp4StartTime",
                        startTime,
                        data
                    }, [ data.buffer ]);
                }
                probeMp4Tracks({data}) {
                    const tracks = probe$2.tracks(data);
                    this.self.postMessage({
                        action: "probeMp4Tracks",
                        tracks,
                        data
                    }, [ data.buffer ]);
                }
                probeTs({data, baseStartTime}) {
                    const tsStartTime = typeof baseStartTime === "number" && !isNaN(baseStartTime) ? baseStartTime * clock$2.ONE_SECOND_IN_TS : void 0;
                    const timeInfo = tsInspector.inspect(data, tsStartTime);
                    let result = null;
                    if (timeInfo) {
                        result = {
                            hasVideo: timeInfo.video && timeInfo.video.length === 2 || false,
                            hasAudio: timeInfo.audio && timeInfo.audio.length === 2 || false
                        };
                        if (result.hasVideo) result.videoStart = timeInfo.video[0].ptsTime;
                        if (result.hasAudio) result.audioStart = timeInfo.audio[0].ptsTime;
                    }
                    this.self.postMessage({
                        action: "probeTs",
                        result,
                        data
                    }, [ data.buffer ]);
                }
                clearAllMp4Captions() {
                    if (this.captionParser) this.captionParser.clearAllCaptions();
                }
                clearParsedMp4Captions() {
                    if (this.captionParser) this.captionParser.clearParsedCaptions();
                }
                push(data) {
                    const segment = new Uint8Array(data.data, data.byteOffset, data.byteLength);
                    this.transmuxer.push(segment);
                }
                reset() {
                    this.transmuxer.reset();
                }
                setTimestampOffset(data) {
                    const timestampOffset = data.timestampOffset || 0;
                    this.transmuxer.setBaseMediaDecodeTime(Math.round(clock$2.secondsToVideoTs(timestampOffset)));
                }
                setAudioAppendStart(data) {
                    this.transmuxer.setAudioAppendStart(Math.ceil(clock$2.secondsToVideoTs(data.appendStart)));
                }
                setRemux(data) {
                    this.transmuxer.setRemux(data.remux);
                }
                flush(data) {
                    this.transmuxer.flush();
                    self.postMessage({
                        action: "done",
                        type: "transmuxed"
                    });
                }
                endTimeline() {
                    this.transmuxer.endTimeline();
                    self.postMessage({
                        action: "endedtimeline",
                        type: "transmuxed"
                    });
                }
                alignGopsWith(data) {
                    this.transmuxer.alignGopsWith(data.gopsToAlignWith.slice());
                }
            }
            self.onmessage = function(event) {
                if (event.data.action === "init" && event.data.options) {
                    this.messageHandlers = new MessageHandlers(self, event.data.options);
                    return;
                }
                if (!this.messageHandlers) this.messageHandlers = new MessageHandlers(self);
                if (event.data && event.data.action && event.data.action !== "init") if (this.messageHandlers[event.data.action]) this.messageHandlers[event.data.action](event.data);
            };
        })));
        var TransmuxWorker = factory(workerCode$1);
        const handleData_ = (event, transmuxedData, callback) => {
            const {type, initSegment, captions, captionStreams, metadata, videoFrameDtsTime, videoFramePtsTime} = event.data.segment;
            transmuxedData.buffer.push({
                captions,
                captionStreams,
                metadata
            });
            const boxes = event.data.segment.boxes || {
                data: event.data.segment.data
            };
            const result = {
                type,
                data: new Uint8Array(boxes.data, boxes.data.byteOffset, boxes.data.byteLength),
                initSegment: new Uint8Array(initSegment.data, initSegment.byteOffset, initSegment.byteLength)
            };
            if (typeof videoFrameDtsTime !== "undefined") result.videoFrameDtsTime = videoFrameDtsTime;
            if (typeof videoFramePtsTime !== "undefined") result.videoFramePtsTime = videoFramePtsTime;
            callback(result);
        };
        const handleDone_ = ({transmuxedData, callback}) => {
            transmuxedData.buffer = [];
            callback(transmuxedData);
        };
        const handleGopInfo_ = (event, transmuxedData) => {
            transmuxedData.gopInfo = event.data.gopInfo;
        };
        const processTransmux = options => {
            const {transmuxer, bytes, audioAppendStart, gopsToAlignWith, remux, onData, onTrackInfo, onAudioTimingInfo, onVideoTimingInfo, onVideoSegmentTimingInfo, onAudioSegmentTimingInfo, onId3, onCaptions, onDone, onEndedTimeline, onTransmuxerLog, isEndOfTimeline} = options;
            const transmuxedData = {
                buffer: []
            };
            let waitForEndedTimelineEvent = isEndOfTimeline;
            const handleMessage = event => {
                if (transmuxer.currentTransmux !== options) return;
                if (event.data.action === "data") handleData_(event, transmuxedData, onData);
                if (event.data.action === "trackinfo") onTrackInfo(event.data.trackInfo);
                if (event.data.action === "gopInfo") handleGopInfo_(event, transmuxedData);
                if (event.data.action === "audioTimingInfo") onAudioTimingInfo(event.data.audioTimingInfo);
                if (event.data.action === "videoTimingInfo") onVideoTimingInfo(event.data.videoTimingInfo);
                if (event.data.action === "videoSegmentTimingInfo") onVideoSegmentTimingInfo(event.data.videoSegmentTimingInfo);
                if (event.data.action === "audioSegmentTimingInfo") onAudioSegmentTimingInfo(event.data.audioSegmentTimingInfo);
                if (event.data.action === "id3Frame") onId3([ event.data.id3Frame ], event.data.id3Frame.dispatchType);
                if (event.data.action === "caption") onCaptions(event.data.caption);
                if (event.data.action === "endedtimeline") {
                    waitForEndedTimelineEvent = false;
                    onEndedTimeline();
                }
                if (event.data.action === "log") onTransmuxerLog(event.data.log);
                if (event.data.type !== "transmuxed") return;
                if (waitForEndedTimelineEvent) return;
                transmuxer.onmessage = null;
                handleDone_({
                    transmuxedData,
                    callback: onDone
                });
                dequeue(transmuxer);
            };
            transmuxer.onmessage = handleMessage;
            if (audioAppendStart) transmuxer.postMessage({
                action: "setAudioAppendStart",
                appendStart: audioAppendStart
            });
            if (Array.isArray(gopsToAlignWith)) transmuxer.postMessage({
                action: "alignGopsWith",
                gopsToAlignWith
            });
            if (typeof remux !== "undefined") transmuxer.postMessage({
                action: "setRemux",
                remux
            });
            if (bytes.byteLength) {
                const buffer = bytes instanceof ArrayBuffer ? bytes : bytes.buffer;
                const byteOffset = bytes instanceof ArrayBuffer ? 0 : bytes.byteOffset;
                transmuxer.postMessage({
                    action: "push",
                    data: buffer,
                    byteOffset,
                    byteLength: bytes.byteLength
                }, [ buffer ]);
            }
            if (isEndOfTimeline) transmuxer.postMessage({
                action: "endTimeline"
            });
            transmuxer.postMessage({
                action: "flush"
            });
        };
        const dequeue = transmuxer => {
            transmuxer.currentTransmux = null;
            if (transmuxer.transmuxQueue.length) {
                transmuxer.currentTransmux = transmuxer.transmuxQueue.shift();
                if (typeof transmuxer.currentTransmux === "function") transmuxer.currentTransmux(); else processTransmux(transmuxer.currentTransmux);
            }
        };
        const processAction = (transmuxer, action) => {
            transmuxer.postMessage({
                action
            });
            dequeue(transmuxer);
        };
        const enqueueAction = (action, transmuxer) => {
            if (!transmuxer.currentTransmux) {
                transmuxer.currentTransmux = action;
                processAction(transmuxer, action);
                return;
            }
            transmuxer.transmuxQueue.push(processAction.bind(null, transmuxer, action));
        };
        const video_es_reset = transmuxer => {
            enqueueAction("reset", transmuxer);
        };
        const endTimeline = transmuxer => {
            enqueueAction("endTimeline", transmuxer);
        };
        const transmux = options => {
            if (!options.transmuxer.currentTransmux) {
                options.transmuxer.currentTransmux = options;
                processTransmux(options);
                return;
            }
            options.transmuxer.transmuxQueue.push(options);
        };
        const createTransmuxer = options => {
            const transmuxer = new TransmuxWorker;
            transmuxer.currentTransmux = null;
            transmuxer.transmuxQueue = [];
            const term = transmuxer.terminate;
            transmuxer.terminate = () => {
                transmuxer.currentTransmux = null;
                transmuxer.transmuxQueue.length = 0;
                return term.call(transmuxer);
            };
            transmuxer.postMessage({
                action: "init",
                options
            });
            return transmuxer;
        };
        var segmentTransmuxer = {
            reset: video_es_reset,
            endTimeline,
            transmux,
            createTransmuxer
        };
        const workerCallback = function(options) {
            const transmuxer = options.transmuxer;
            const endAction = options.endAction || options.action;
            const callback = options.callback;
            const message = _extends({}, options, {
                endAction: null,
                transmuxer: null,
                callback: null
            });
            const listenForEndEvent = event => {
                if (event.data.action !== endAction) return;
                transmuxer.removeEventListener("message", listenForEndEvent);
                if (event.data.data) {
                    event.data.data = new Uint8Array(event.data.data, options.byteOffset || 0, options.byteLength || event.data.data.byteLength);
                    if (options.data) options.data = event.data.data;
                }
                callback(event.data);
            };
            transmuxer.addEventListener("message", listenForEndEvent);
            if (options.data) {
                const isArrayBuffer = options.data instanceof ArrayBuffer;
                message.byteOffset = isArrayBuffer ? 0 : options.data.byteOffset;
                message.byteLength = options.data.byteLength;
                const transfers = [ isArrayBuffer ? options.data : options.data.buffer ];
                transmuxer.postMessage(message, transfers);
            } else transmuxer.postMessage(message);
        };
        const REQUEST_ERRORS = {
            FAILURE: 2,
            TIMEOUT: -101,
            ABORTED: -102
        };
        const abortAll = activeXhrs => {
            activeXhrs.forEach((xhr => {
                xhr.abort();
            }));
        };
        const getRequestStats = request => ({
            bandwidth: request.bandwidth,
            bytesReceived: request.bytesReceived || 0,
            roundTripTime: request.roundTripTime || 0
        });
        const getProgressStats = progressEvent => {
            const request = progressEvent.target;
            const roundTripTime = Date.now() - request.requestTime;
            const stats = {
                bandwidth: 1 / 0,
                bytesReceived: 0,
                roundTripTime: roundTripTime || 0
            };
            stats.bytesReceived = progressEvent.loaded;
            stats.bandwidth = Math.floor(stats.bytesReceived / stats.roundTripTime * 8 * 1e3);
            return stats;
        };
        const handleErrors = (error, request) => {
            if (request.timedout) return {
                status: request.status,
                message: "HLS request timed-out at URL: " + request.uri,
                code: REQUEST_ERRORS.TIMEOUT,
                xhr: request
            };
            if (request.aborted) return {
                status: request.status,
                message: "HLS request aborted at URL: " + request.uri,
                code: REQUEST_ERRORS.ABORTED,
                xhr: request
            };
            if (error) return {
                status: request.status,
                message: "HLS request errored at URL: " + request.uri,
                code: REQUEST_ERRORS.FAILURE,
                xhr: request
            };
            if (request.responseType === "arraybuffer" && request.response.byteLength === 0) return {
                status: request.status,
                message: "Empty HLS response at URL: " + request.uri,
                code: REQUEST_ERRORS.FAILURE,
                xhr: request
            };
            return null;
        };
        const handleKeyResponse = (segment, objects, finishProcessingFn) => (error, request) => {
            const response = request.response;
            const errorObj = handleErrors(error, request);
            if (errorObj) return finishProcessingFn(errorObj, segment);
            if (response.byteLength !== 16) return finishProcessingFn({
                status: request.status,
                message: "Invalid HLS key at URL: " + request.uri,
                code: REQUEST_ERRORS.FAILURE,
                xhr: request
            }, segment);
            const view = new DataView(response);
            const bytes = new Uint32Array([ view.getUint32(0), view.getUint32(4), view.getUint32(8), view.getUint32(12) ]);
            for (let i = 0; i < objects.length; i++) objects[i].bytes = bytes;
            return finishProcessingFn(null, segment);
        };
        const parseInitSegment = (segment, callback) => {
            const type = detectContainerForBytes(segment.map.bytes);
            if (type !== "mp4") {
                const uri = segment.map.resolvedUri || segment.map.uri;
                return callback({
                    internal: true,
                    message: `Found unsupported ${type || "unknown"} container for initialization segment at URL: ${uri}`,
                    code: REQUEST_ERRORS.FAILURE
                });
            }
            workerCallback({
                action: "probeMp4Tracks",
                data: segment.map.bytes,
                transmuxer: segment.transmuxer,
                callback: ({tracks, data}) => {
                    segment.map.bytes = data;
                    tracks.forEach((function(track) {
                        segment.map.tracks = segment.map.tracks || {};
                        if (segment.map.tracks[track.type]) return;
                        segment.map.tracks[track.type] = track;
                        if (typeof track.id === "number" && track.timescale) {
                            segment.map.timescales = segment.map.timescales || {};
                            segment.map.timescales[track.id] = track.timescale;
                        }
                    }));
                    return callback(null);
                }
            });
        };
        const handleInitSegmentResponse = ({segment, finishProcessingFn}) => (error, request) => {
            const errorObj = handleErrors(error, request);
            if (errorObj) return finishProcessingFn(errorObj, segment);
            const bytes = new Uint8Array(request.response);
            if (segment.map.key) {
                segment.map.encryptedBytes = bytes;
                return finishProcessingFn(null, segment);
            }
            segment.map.bytes = bytes;
            parseInitSegment(segment, (function(parseError) {
                if (parseError) {
                    parseError.xhr = request;
                    parseError.status = request.status;
                    return finishProcessingFn(parseError, segment);
                }
                finishProcessingFn(null, segment);
            }));
        };
        const handleSegmentResponse = ({segment, finishProcessingFn, responseType}) => (error, request) => {
            const errorObj = handleErrors(error, request);
            if (errorObj) return finishProcessingFn(errorObj, segment);
            const newBytes = responseType === "arraybuffer" || !request.responseText ? request.response : stringToArrayBuffer(request.responseText.substring(segment.lastReachedChar || 0));
            segment.stats = getRequestStats(request);
            if (segment.key) segment.encryptedBytes = new Uint8Array(newBytes); else segment.bytes = new Uint8Array(newBytes);
            return finishProcessingFn(null, segment);
        };
        const transmuxAndNotify = ({segment, bytes, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn, doneFn, onTransmuxerLog}) => {
            const fmp4Tracks = segment.map && segment.map.tracks || {};
            const isMuxed = Boolean(fmp4Tracks.audio && fmp4Tracks.video);
            let audioStartFn = timingInfoFn.bind(null, segment, "audio", "start");
            const audioEndFn = timingInfoFn.bind(null, segment, "audio", "end");
            let videoStartFn = timingInfoFn.bind(null, segment, "video", "start");
            const videoEndFn = timingInfoFn.bind(null, segment, "video", "end");
            const finish = () => transmux({
                bytes,
                transmuxer: segment.transmuxer,
                audioAppendStart: segment.audioAppendStart,
                gopsToAlignWith: segment.gopsToAlignWith,
                remux: isMuxed,
                onData: result => {
                    result.type = result.type === "combined" ? "video" : result.type;
                    dataFn(segment, result);
                },
                onTrackInfo: trackInfo => {
                    if (trackInfoFn) {
                        if (isMuxed) trackInfo.isMuxed = true;
                        trackInfoFn(segment, trackInfo);
                    }
                },
                onAudioTimingInfo: audioTimingInfo => {
                    if (audioStartFn && typeof audioTimingInfo.start !== "undefined") {
                        audioStartFn(audioTimingInfo.start);
                        audioStartFn = null;
                    }
                    if (audioEndFn && typeof audioTimingInfo.end !== "undefined") audioEndFn(audioTimingInfo.end);
                },
                onVideoTimingInfo: videoTimingInfo => {
                    if (videoStartFn && typeof videoTimingInfo.start !== "undefined") {
                        videoStartFn(videoTimingInfo.start);
                        videoStartFn = null;
                    }
                    if (videoEndFn && typeof videoTimingInfo.end !== "undefined") videoEndFn(videoTimingInfo.end);
                },
                onVideoSegmentTimingInfo: videoSegmentTimingInfo => {
                    videoSegmentTimingInfoFn(videoSegmentTimingInfo);
                },
                onAudioSegmentTimingInfo: audioSegmentTimingInfo => {
                    audioSegmentTimingInfoFn(audioSegmentTimingInfo);
                },
                onId3: (id3Frames, dispatchType) => {
                    id3Fn(segment, id3Frames, dispatchType);
                },
                onCaptions: captions => {
                    captionsFn(segment, [ captions ]);
                },
                isEndOfTimeline,
                onEndedTimeline: () => {
                    endedTimelineFn();
                },
                onTransmuxerLog,
                onDone: result => {
                    if (!doneFn) return;
                    result.type = result.type === "combined" ? "video" : result.type;
                    doneFn(null, segment, result);
                }
            });
            workerCallback({
                action: "probeTs",
                transmuxer: segment.transmuxer,
                data: bytes,
                baseStartTime: segment.baseStartTime,
                callback: data => {
                    segment.bytes = bytes = data.data;
                    const probeResult = data.result;
                    if (probeResult) {
                        trackInfoFn(segment, {
                            hasAudio: probeResult.hasAudio,
                            hasVideo: probeResult.hasVideo,
                            isMuxed
                        });
                        trackInfoFn = null;
                        if (probeResult.hasAudio && !isMuxed) audioStartFn(probeResult.audioStart);
                        if (probeResult.hasVideo) videoStartFn(probeResult.videoStart);
                        audioStartFn = null;
                        videoStartFn = null;
                    }
                    finish();
                }
            });
        };
        const handleSegmentBytes = ({segment, bytes, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn, doneFn, onTransmuxerLog}) => {
            let bytesAsUint8Array = new Uint8Array(bytes);
            if (isLikelyFmp4MediaSegment(bytesAsUint8Array)) {
                segment.isFmp4 = true;
                const {tracks} = segment.map;
                const trackInfo = {
                    isFmp4: true,
                    hasVideo: !!tracks.video,
                    hasAudio: !!tracks.audio
                };
                if (tracks.audio && tracks.audio.codec && tracks.audio.codec !== "enca") trackInfo.audioCodec = tracks.audio.codec;
                if (tracks.video && tracks.video.codec && tracks.video.codec !== "encv") trackInfo.videoCodec = tracks.video.codec;
                if (tracks.video && tracks.audio) trackInfo.isMuxed = true;
                trackInfoFn(segment, trackInfo);
                const finishLoading = captions => {
                    dataFn(segment, {
                        data: bytesAsUint8Array,
                        type: trackInfo.hasAudio && !trackInfo.isMuxed ? "audio" : "video"
                    });
                    if (captions && captions.length) captionsFn(segment, captions);
                    doneFn(null, segment, {});
                };
                workerCallback({
                    action: "probeMp4StartTime",
                    timescales: segment.map.timescales,
                    data: bytesAsUint8Array,
                    transmuxer: segment.transmuxer,
                    callback: ({data, startTime}) => {
                        bytes = data.buffer;
                        segment.bytes = bytesAsUint8Array = data;
                        if (trackInfo.hasAudio && !trackInfo.isMuxed) timingInfoFn(segment, "audio", "start", startTime);
                        if (trackInfo.hasVideo) timingInfoFn(segment, "video", "start", startTime);
                        if (!tracks.video || !data.byteLength || !segment.transmuxer) {
                            finishLoading();
                            return;
                        }
                        workerCallback({
                            action: "pushMp4Captions",
                            endAction: "mp4Captions",
                            transmuxer: segment.transmuxer,
                            data: bytesAsUint8Array,
                            timescales: segment.map.timescales,
                            trackIds: [ tracks.video.id ],
                            callback: message => {
                                bytes = message.data.buffer;
                                segment.bytes = bytesAsUint8Array = message.data;
                                message.logs.forEach((function(log) {
                                    onTransmuxerLog(video_es_merge(log, {
                                        stream: "mp4CaptionParser"
                                    }));
                                }));
                                finishLoading(message.captions);
                            }
                        });
                    }
                });
                return;
            }
            if (!segment.transmuxer) {
                doneFn(null, segment, {});
                return;
            }
            if (typeof segment.container === "undefined") segment.container = detectContainerForBytes(bytesAsUint8Array);
            if (segment.container !== "ts" && segment.container !== "aac") {
                trackInfoFn(segment, {
                    hasAudio: false,
                    hasVideo: false
                });
                doneFn(null, segment, {});
                return;
            }
            transmuxAndNotify({
                segment,
                bytes,
                trackInfoFn,
                timingInfoFn,
                videoSegmentTimingInfoFn,
                audioSegmentTimingInfoFn,
                id3Fn,
                captionsFn,
                isEndOfTimeline,
                endedTimelineFn,
                dataFn,
                doneFn,
                onTransmuxerLog
            });
        };
        const decrypt = function({id, key, encryptedBytes, decryptionWorker}, callback) {
            const decryptionHandler = event => {
                if (event.data.source === id) {
                    decryptionWorker.removeEventListener("message", decryptionHandler);
                    const decrypted = event.data.decrypted;
                    callback(new Uint8Array(decrypted.bytes, decrypted.byteOffset, decrypted.byteLength));
                }
            };
            decryptionWorker.addEventListener("message", decryptionHandler);
            let keyBytes;
            if (key.bytes.slice) keyBytes = key.bytes.slice(); else keyBytes = new Uint32Array(Array.prototype.slice.call(key.bytes));
            decryptionWorker.postMessage(createTransferableMessage({
                source: id,
                encrypted: encryptedBytes,
                key: keyBytes,
                iv: key.iv
            }), [ encryptedBytes.buffer, keyBytes.buffer ]);
        };
        const decryptSegment = ({decryptionWorker, segment, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn, doneFn, onTransmuxerLog}) => {
            decrypt({
                id: segment.requestId,
                key: segment.key,
                encryptedBytes: segment.encryptedBytes,
                decryptionWorker
            }, (decryptedBytes => {
                segment.bytes = decryptedBytes;
                handleSegmentBytes({
                    segment,
                    bytes: segment.bytes,
                    trackInfoFn,
                    timingInfoFn,
                    videoSegmentTimingInfoFn,
                    audioSegmentTimingInfoFn,
                    id3Fn,
                    captionsFn,
                    isEndOfTimeline,
                    endedTimelineFn,
                    dataFn,
                    doneFn,
                    onTransmuxerLog
                });
            }));
        };
        const waitForCompletion = ({activeXhrs, decryptionWorker, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn, doneFn, onTransmuxerLog}) => {
            let count = 0;
            let didError = false;
            return (error, segment) => {
                if (didError) return;
                if (error) {
                    didError = true;
                    abortAll(activeXhrs);
                    return doneFn(error, segment);
                }
                count += 1;
                if (count === activeXhrs.length) {
                    const segmentFinish = function() {
                        if (segment.encryptedBytes) return decryptSegment({
                            decryptionWorker,
                            segment,
                            trackInfoFn,
                            timingInfoFn,
                            videoSegmentTimingInfoFn,
                            audioSegmentTimingInfoFn,
                            id3Fn,
                            captionsFn,
                            isEndOfTimeline,
                            endedTimelineFn,
                            dataFn,
                            doneFn,
                            onTransmuxerLog
                        });
                        handleSegmentBytes({
                            segment,
                            bytes: segment.bytes,
                            trackInfoFn,
                            timingInfoFn,
                            videoSegmentTimingInfoFn,
                            audioSegmentTimingInfoFn,
                            id3Fn,
                            captionsFn,
                            isEndOfTimeline,
                            endedTimelineFn,
                            dataFn,
                            doneFn,
                            onTransmuxerLog
                        });
                    };
                    segment.endOfAllRequests = Date.now();
                    if (segment.map && segment.map.encryptedBytes && !segment.map.bytes) return decrypt({
                        decryptionWorker,
                        id: segment.requestId + "-init",
                        encryptedBytes: segment.map.encryptedBytes,
                        key: segment.map.key
                    }, (decryptedBytes => {
                        segment.map.bytes = decryptedBytes;
                        parseInitSegment(segment, (parseError => {
                            if (parseError) {
                                abortAll(activeXhrs);
                                return doneFn(parseError, segment);
                            }
                            segmentFinish();
                        }));
                    }));
                    segmentFinish();
                }
            };
        };
        const handleLoadEnd = ({loadendState, abortFn}) => event => {
            const request = event.target;
            if (request.aborted && abortFn && !loadendState.calledAbortFn) {
                abortFn();
                loadendState.calledAbortFn = true;
            }
        };
        const handleProgress = ({segment, progressFn, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn}) => event => {
            const request = event.target;
            if (request.aborted) return;
            segment.stats = video_es_merge(segment.stats, getProgressStats(event));
            if (!segment.stats.firstBytesReceivedAt && segment.stats.bytesReceived) segment.stats.firstBytesReceivedAt = Date.now();
            return progressFn(event, segment);
        };
        const mediaSegmentRequest = ({xhr, xhrOptions, decryptionWorker, segment, abortFn, progressFn, trackInfoFn, timingInfoFn, videoSegmentTimingInfoFn, audioSegmentTimingInfoFn, id3Fn, captionsFn, isEndOfTimeline, endedTimelineFn, dataFn, doneFn, onTransmuxerLog}) => {
            const activeXhrs = [];
            const finishProcessingFn = waitForCompletion({
                activeXhrs,
                decryptionWorker,
                trackInfoFn,
                timingInfoFn,
                videoSegmentTimingInfoFn,
                audioSegmentTimingInfoFn,
                id3Fn,
                captionsFn,
                isEndOfTimeline,
                endedTimelineFn,
                dataFn,
                doneFn,
                onTransmuxerLog
            });
            if (segment.key && !segment.key.bytes) {
                const objects = [ segment.key ];
                if (segment.map && !segment.map.bytes && segment.map.key && segment.map.key.resolvedUri === segment.key.resolvedUri) objects.push(segment.map.key);
                const keyRequestOptions = video_es_merge(xhrOptions, {
                    uri: segment.key.resolvedUri,
                    responseType: "arraybuffer"
                });
                const keyRequestCallback = handleKeyResponse(segment, objects, finishProcessingFn);
                const keyXhr = xhr(keyRequestOptions, keyRequestCallback);
                activeXhrs.push(keyXhr);
            }
            if (segment.map && !segment.map.bytes) {
                const differentMapKey = segment.map.key && (!segment.key || segment.key.resolvedUri !== segment.map.key.resolvedUri);
                if (differentMapKey) {
                    const mapKeyRequestOptions = video_es_merge(xhrOptions, {
                        uri: segment.map.key.resolvedUri,
                        responseType: "arraybuffer"
                    });
                    const mapKeyRequestCallback = handleKeyResponse(segment, [ segment.map.key ], finishProcessingFn);
                    const mapKeyXhr = xhr(mapKeyRequestOptions, mapKeyRequestCallback);
                    activeXhrs.push(mapKeyXhr);
                }
                const initSegmentOptions = video_es_merge(xhrOptions, {
                    uri: segment.map.resolvedUri,
                    responseType: "arraybuffer",
                    headers: segmentXhrHeaders(segment.map)
                });
                const initSegmentRequestCallback = handleInitSegmentResponse({
                    segment,
                    finishProcessingFn
                });
                const initSegmentXhr = xhr(initSegmentOptions, initSegmentRequestCallback);
                activeXhrs.push(initSegmentXhr);
            }
            const segmentRequestOptions = video_es_merge(xhrOptions, {
                uri: segment.part && segment.part.resolvedUri || segment.resolvedUri,
                responseType: "arraybuffer",
                headers: segmentXhrHeaders(segment)
            });
            const segmentRequestCallback = handleSegmentResponse({
                segment,
                finishProcessingFn,
                responseType: segmentRequestOptions.responseType
            });
            const segmentXhr = xhr(segmentRequestOptions, segmentRequestCallback);
            segmentXhr.addEventListener("progress", handleProgress({
                segment,
                progressFn,
                trackInfoFn,
                timingInfoFn,
                videoSegmentTimingInfoFn,
                audioSegmentTimingInfoFn,
                id3Fn,
                captionsFn,
                isEndOfTimeline,
                endedTimelineFn,
                dataFn
            }));
            activeXhrs.push(segmentXhr);
            const loadendState = {};
            activeXhrs.forEach((activeXhr => {
                activeXhr.addEventListener("loadend", handleLoadEnd({
                    loadendState,
                    abortFn
                }));
            }));
            return () => abortAll(activeXhrs);
        };
        const logFn$1 = logger("CodecUtils");
        const getCodecs = function(media) {
            const mediaAttributes = media.attributes || {};
            if (mediaAttributes.CODECS) return parseCodecs(mediaAttributes.CODECS);
        };
        const isMaat = (main, media) => {
            const mediaAttributes = media.attributes || {};
            return main && main.mediaGroups && main.mediaGroups.AUDIO && mediaAttributes.AUDIO && main.mediaGroups.AUDIO[mediaAttributes.AUDIO];
        };
        const isMuxed = (main, media) => {
            if (!isMaat(main, media)) return true;
            const mediaAttributes = media.attributes || {};
            const audioGroup = main.mediaGroups.AUDIO[mediaAttributes.AUDIO];
            for (const groupId in audioGroup) if (!audioGroup[groupId].uri && !audioGroup[groupId].playlists) return true;
            return false;
        };
        const unwrapCodecList = function(codecList) {
            const codecs = {};
            codecList.forEach((({mediaType, type, details}) => {
                codecs[mediaType] = codecs[mediaType] || [];
                codecs[mediaType].push(translateLegacyCodec(`${type}${details}`));
            }));
            Object.keys(codecs).forEach((function(mediaType) {
                if (codecs[mediaType].length > 1) {
                    logFn$1(`multiple ${mediaType} codecs found as attributes: ${codecs[mediaType].join(", ")}. Setting playlist codecs to null so that we wait for mux.js to probe segments for real codecs.`);
                    codecs[mediaType] = null;
                    return;
                }
                codecs[mediaType] = codecs[mediaType][0];
            }));
            return codecs;
        };
        const codecCount = function(codecObj) {
            let count = 0;
            if (codecObj.audio) count++;
            if (codecObj.video) count++;
            return count;
        };
        const codecsForPlaylist = function(main, media) {
            const mediaAttributes = media.attributes || {};
            const codecInfo = unwrapCodecList(getCodecs(media) || []);
            if (isMaat(main, media) && !codecInfo.audio) if (!isMuxed(main, media)) {
                const defaultCodecs = unwrapCodecList(codecsFromDefault(main, mediaAttributes.AUDIO) || []);
                if (defaultCodecs.audio) codecInfo.audio = defaultCodecs.audio;
            }
            return codecInfo;
        };
        const logFn = logger("PlaylistSelector");
        const representationToString = function(representation) {
            if (!representation || !representation.playlist) return;
            const playlist = representation.playlist;
            return JSON.stringify({
                id: playlist.id,
                bandwidth: representation.bandwidth,
                width: representation.width,
                height: representation.height,
                codecs: playlist.attributes && playlist.attributes.CODECS || ""
            });
        };
        const safeGetComputedStyle = function(el, property) {
            if (!el) return "";
            const result = window_default().getComputedStyle(el);
            if (!result) return "";
            return result[property];
        };
        const stableSort = function(array, sortFn) {
            const newArray = array.slice();
            array.sort((function(left, right) {
                const cmp = sortFn(left, right);
                if (cmp === 0) return newArray.indexOf(left) - newArray.indexOf(right);
                return cmp;
            }));
        };
        const comparePlaylistBandwidth = function(left, right) {
            let leftBandwidth;
            let rightBandwidth;
            if (left.attributes.BANDWIDTH) leftBandwidth = left.attributes.BANDWIDTH;
            leftBandwidth = leftBandwidth || window_default().Number.MAX_VALUE;
            if (right.attributes.BANDWIDTH) rightBandwidth = right.attributes.BANDWIDTH;
            rightBandwidth = rightBandwidth || window_default().Number.MAX_VALUE;
            return leftBandwidth - rightBandwidth;
        };
        const comparePlaylistResolution = function(left, right) {
            let leftWidth;
            let rightWidth;
            if (left.attributes.RESOLUTION && left.attributes.RESOLUTION.width) leftWidth = left.attributes.RESOLUTION.width;
            leftWidth = leftWidth || window_default().Number.MAX_VALUE;
            if (right.attributes.RESOLUTION && right.attributes.RESOLUTION.width) rightWidth = right.attributes.RESOLUTION.width;
            rightWidth = rightWidth || window_default().Number.MAX_VALUE;
            if (leftWidth === rightWidth && left.attributes.BANDWIDTH && right.attributes.BANDWIDTH) return left.attributes.BANDWIDTH - right.attributes.BANDWIDTH;
            return leftWidth - rightWidth;
        };
        let simpleSelector = function(main, playerBandwidth, playerWidth, playerHeight, limitRenditionByPlayerDimensions, playlistController) {
            if (!main) return;
            const options = {
                bandwidth: playerBandwidth,
                width: playerWidth,
                height: playerHeight,
                limitRenditionByPlayerDimensions
            };
            let playlists = main.playlists;
            if (Playlist.isAudioOnly(main)) {
                playlists = playlistController.getAudioTrackPlaylists_();
                options.audioOnly = true;
            }
            let sortedPlaylistReps = playlists.map((playlist => {
                let bandwidth;
                const width = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.width;
                const height = playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height;
                bandwidth = playlist.attributes && playlist.attributes.BANDWIDTH;
                bandwidth = bandwidth || window_default().Number.MAX_VALUE;
                return {
                    bandwidth,
                    width,
                    height,
                    playlist
                };
            }));
            stableSort(sortedPlaylistReps, ((left, right) => left.bandwidth - right.bandwidth));
            sortedPlaylistReps = sortedPlaylistReps.filter((rep => !Playlist.isIncompatible(rep.playlist)));
            let enabledPlaylistReps = sortedPlaylistReps.filter((rep => Playlist.isEnabled(rep.playlist)));
            if (!enabledPlaylistReps.length) enabledPlaylistReps = sortedPlaylistReps.filter((rep => !Playlist.isDisabled(rep.playlist)));
            const bandwidthPlaylistReps = enabledPlaylistReps.filter((rep => rep.bandwidth * Config.BANDWIDTH_VARIANCE < playerBandwidth));
            let highestRemainingBandwidthRep = bandwidthPlaylistReps[bandwidthPlaylistReps.length - 1];
            const bandwidthBestRep = bandwidthPlaylistReps.filter((rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth))[0];
            if (limitRenditionByPlayerDimensions === false) {
                const chosenRep = bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
                if (chosenRep && chosenRep.playlist) {
                    let type = "sortedPlaylistReps";
                    if (bandwidthBestRep) type = "bandwidthBestRep";
                    if (enabledPlaylistReps[0]) type = "enabledPlaylistReps";
                    logFn(`choosing ${representationToString(chosenRep)} using ${type} with options`, options);
                    return chosenRep.playlist;
                }
                logFn("could not choose a playlist with options", options);
                return null;
            }
            const haveResolution = bandwidthPlaylistReps.filter((rep => rep.width && rep.height));
            stableSort(haveResolution, ((left, right) => left.width - right.width));
            const resolutionBestRepList = haveResolution.filter((rep => rep.width === playerWidth && rep.height === playerHeight));
            highestRemainingBandwidthRep = resolutionBestRepList[resolutionBestRepList.length - 1];
            const resolutionBestRep = resolutionBestRepList.filter((rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth))[0];
            let resolutionPlusOneList;
            let resolutionPlusOneSmallest;
            let resolutionPlusOneRep;
            if (!resolutionBestRep) {
                resolutionPlusOneList = haveResolution.filter((rep => rep.width > playerWidth || rep.height > playerHeight));
                resolutionPlusOneSmallest = resolutionPlusOneList.filter((rep => rep.width === resolutionPlusOneList[0].width && rep.height === resolutionPlusOneList[0].height));
                highestRemainingBandwidthRep = resolutionPlusOneSmallest[resolutionPlusOneSmallest.length - 1];
                resolutionPlusOneRep = resolutionPlusOneSmallest.filter((rep => rep.bandwidth === highestRemainingBandwidthRep.bandwidth))[0];
            }
            let leastPixelDiffRep;
            if (playlistController.leastPixelDiffSelector) {
                const leastPixelDiffList = haveResolution.map((rep => {
                    rep.pixelDiff = Math.abs(rep.width - playerWidth) + Math.abs(rep.height - playerHeight);
                    return rep;
                }));
                stableSort(leastPixelDiffList, ((left, right) => {
                    if (left.pixelDiff === right.pixelDiff) return right.bandwidth - left.bandwidth;
                    return left.pixelDiff - right.pixelDiff;
                }));
                leastPixelDiffRep = leastPixelDiffList[0];
            }
            const chosenRep = leastPixelDiffRep || resolutionPlusOneRep || resolutionBestRep || bandwidthBestRep || enabledPlaylistReps[0] || sortedPlaylistReps[0];
            if (chosenRep && chosenRep.playlist) {
                let type = "sortedPlaylistReps";
                if (leastPixelDiffRep) type = "leastPixelDiffRep"; else if (resolutionPlusOneRep) type = "resolutionPlusOneRep"; else if (resolutionBestRep) type = "resolutionBestRep"; else if (bandwidthBestRep) type = "bandwidthBestRep"; else if (enabledPlaylistReps[0]) type = "enabledPlaylistReps";
                logFn(`choosing ${representationToString(chosenRep)} using ${type} with options`, options);
                return chosenRep.playlist;
            }
            logFn("could not choose a playlist with options", options);
            return null;
        };
        const lastBandwidthSelector = function() {
            const pixelRatio = this.useDevicePixelRatio ? window_default().devicePixelRatio || 1 : 1;
            return simpleSelector(this.playlists.main, this.systemBandwidth, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);
        };
        const movingAverageBandwidthSelector = function(decay) {
            let average = -1;
            let lastSystemBandwidth = -1;
            if (decay < 0 || decay > 1) throw new Error("Moving average bandwidth decay must be between 0 and 1.");
            return function() {
                const pixelRatio = this.useDevicePixelRatio ? window_default().devicePixelRatio || 1 : 1;
                if (average < 0) {
                    average = this.systemBandwidth;
                    lastSystemBandwidth = this.systemBandwidth;
                }
                if (this.systemBandwidth > 0 && this.systemBandwidth !== lastSystemBandwidth) {
                    average = decay * this.systemBandwidth + (1 - decay) * average;
                    lastSystemBandwidth = this.systemBandwidth;
                }
                return simpleSelector(this.playlists.main, average, parseInt(safeGetComputedStyle(this.tech_.el(), "width"), 10) * pixelRatio, parseInt(safeGetComputedStyle(this.tech_.el(), "height"), 10) * pixelRatio, this.limitRenditionByPlayerDimensions, this.playlistController_);
            };
        };
        const minRebufferMaxBandwidthSelector = function(settings) {
            const {main, currentTime, bandwidth, duration, segmentDuration, timeUntilRebuffer, currentTimeline, syncController} = settings;
            const compatiblePlaylists = main.playlists.filter((playlist => !Playlist.isIncompatible(playlist)));
            let enabledPlaylists = compatiblePlaylists.filter(Playlist.isEnabled);
            if (!enabledPlaylists.length) enabledPlaylists = compatiblePlaylists.filter((playlist => !Playlist.isDisabled(playlist)));
            const bandwidthPlaylists = enabledPlaylists.filter(Playlist.hasAttribute.bind(null, "BANDWIDTH"));
            const rebufferingEstimates = bandwidthPlaylists.map((playlist => {
                const syncPoint = syncController.getSyncPoint(playlist, duration, currentTimeline, currentTime);
                const numRequests = syncPoint ? 1 : 2;
                const requestTimeEstimate = Playlist.estimateSegmentRequestTime(segmentDuration, bandwidth, playlist);
                const rebufferingImpact = requestTimeEstimate * numRequests - timeUntilRebuffer;
                return {
                    playlist,
                    rebufferingImpact
                };
            }));
            const noRebufferingPlaylists = rebufferingEstimates.filter((estimate => estimate.rebufferingImpact <= 0));
            stableSort(noRebufferingPlaylists, ((a, b) => comparePlaylistBandwidth(b.playlist, a.playlist)));
            if (noRebufferingPlaylists.length) return noRebufferingPlaylists[0];
            stableSort(rebufferingEstimates, ((a, b) => a.rebufferingImpact - b.rebufferingImpact));
            return rebufferingEstimates[0] || null;
        };
        const lowestBitrateCompatibleVariantSelector = function() {
            const playlists = this.playlists.main.playlists.filter(Playlist.isEnabled);
            stableSort(playlists, ((a, b) => comparePlaylistBandwidth(a, b)));
            const playlistsWithVideo = playlists.filter((playlist => !!codecsForPlaylist(this.playlists.main, playlist).video));
            return playlistsWithVideo[0] || null;
        };
        const concatSegments = segmentObj => {
            let offset = 0;
            let tempBuffer;
            if (segmentObj.bytes) {
                tempBuffer = new Uint8Array(segmentObj.bytes);
                segmentObj.segments.forEach((segment => {
                    tempBuffer.set(segment, offset);
                    offset += segment.byteLength;
                }));
            }
            return tempBuffer;
        };
        const createCaptionsTrackIfNotExists = function(inbandTextTracks, tech, captionStream) {
            if (!inbandTextTracks[captionStream]) {
                tech.trigger({
                    type: "usage",
                    name: "vhs-608"
                });
                let instreamId = captionStream;
                if (/^cc708_/.test(captionStream)) instreamId = "SERVICE" + captionStream.split("_")[1];
                const track = tech.textTracks().getTrackById(instreamId);
                if (track) inbandTextTracks[captionStream] = track; else {
                    const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
                    let label = captionStream;
                    let language = captionStream;
                    let def = false;
                    const captionService = captionServices[instreamId];
                    if (captionService) {
                        label = captionService.label;
                        language = captionService.language;
                        def = captionService.default;
                    }
                    inbandTextTracks[captionStream] = tech.addRemoteTextTrack({
                        kind: "captions",
                        id: instreamId,
                        default: def,
                        label,
                        language
                    }, false).track;
                }
            }
        };
        const addCaptionData = function({inbandTextTracks, captionArray, timestampOffset}) {
            if (!captionArray) return;
            const Cue = window_default().WebKitDataCue || window_default().VTTCue;
            captionArray.forEach((caption => {
                const track = caption.stream;
                inbandTextTracks[track].addCue(new Cue(caption.startTime + timestampOffset, caption.endTime + timestampOffset, caption.text));
            }));
        };
        const deprecateOldCue = function(cue) {
            Object.defineProperties(cue.frame, {
                id: {
                    get() {
                        videojs.log.warn("cue.frame.id is deprecated. Use cue.value.key instead.");
                        return cue.value.key;
                    }
                },
                value: {
                    get() {
                        videojs.log.warn("cue.frame.value is deprecated. Use cue.value.data instead.");
                        return cue.value.data;
                    }
                },
                privateData: {
                    get() {
                        videojs.log.warn("cue.frame.privateData is deprecated. Use cue.value.data instead.");
                        return cue.value.data;
                    }
                }
            });
        };
        const addMetadata = ({inbandTextTracks, metadataArray, timestampOffset, videoDuration}) => {
            if (!metadataArray) return;
            const Cue = window_default().WebKitDataCue || window_default().VTTCue;
            const metadataTrack = inbandTextTracks.metadataTrack_;
            if (!metadataTrack) return;
            metadataArray.forEach((metadata => {
                const time = metadata.cueTime + timestampOffset;
                if (typeof time !== "number" || window_default().isNaN(time) || time < 0 || !(time < 1 / 0)) return;
                metadata.frames.forEach((frame => {
                    const cue = new Cue(time, time, frame.value || frame.url || frame.data || "");
                    cue.frame = frame;
                    cue.value = frame;
                    deprecateOldCue(cue);
                    metadataTrack.addCue(cue);
                }));
            }));
            if (!metadataTrack.cues || !metadataTrack.cues.length) return;
            const cues = metadataTrack.cues;
            const cuesArray = [];
            for (let i = 0; i < cues.length; i++) if (cues[i]) cuesArray.push(cues[i]);
            const cuesGroupedByStartTime = cuesArray.reduce(((obj, cue) => {
                const timeSlot = obj[cue.startTime] || [];
                timeSlot.push(cue);
                obj[cue.startTime] = timeSlot;
                return obj;
            }), {});
            const sortedStartTimes = Object.keys(cuesGroupedByStartTime).sort(((a, b) => Number(a) - Number(b)));
            sortedStartTimes.forEach(((startTime, idx) => {
                const cueGroup = cuesGroupedByStartTime[startTime];
                const nextTime = Number(sortedStartTimes[idx + 1]) || videoDuration;
                cueGroup.forEach((cue => {
                    cue.endTime = nextTime;
                }));
            }));
        };
        const createMetadataTrackIfNotExists = (inbandTextTracks, dispatchType, tech) => {
            if (inbandTextTracks.metadataTrack_) return;
            inbandTextTracks.metadataTrack_ = tech.addRemoteTextTrack({
                kind: "metadata",
                label: "Timed Metadata"
            }, false).track;
            inbandTextTracks.metadataTrack_.inBandMetadataTrackDispatchType = dispatchType;
        };
        const removeCuesFromTrack = function(start, end, track) {
            let i;
            let cue;
            if (!track) return;
            if (!track.cues) return;
            i = track.cues.length;
            while (i--) {
                cue = track.cues[i];
                if (cue.startTime >= start && cue.endTime <= end) track.removeCue(cue);
            }
        };
        const removeDuplicateCuesFromTrack = function(track) {
            const cues = track.cues;
            if (!cues) return;
            for (let i = 0; i < cues.length; i++) {
                const duplicates = [];
                let occurrences = 0;
                for (let j = 0; j < cues.length; j++) if (cues[i].startTime === cues[j].startTime && cues[i].endTime === cues[j].endTime && cues[i].text === cues[j].text) {
                    occurrences++;
                    if (occurrences > 1) duplicates.push(cues[j]);
                }
                if (duplicates.length) duplicates.forEach((dupe => track.removeCue(dupe)));
            }
        };
        const gopsSafeToAlignWith = (buffer, currentTime, mapping) => {
            if (typeof currentTime === "undefined" || currentTime === null || !buffer.length) return [];
            const currentTimePts = Math.ceil((currentTime - mapping + 3) * clock.ONE_SECOND_IN_TS);
            let i;
            for (i = 0; i < buffer.length; i++) if (buffer[i].pts > currentTimePts) break;
            return buffer.slice(i);
        };
        const updateGopBuffer = (buffer, gops, replace) => {
            if (!gops.length) return buffer;
            if (replace) return gops.slice();
            const start = gops[0].pts;
            let i = 0;
            for (i; i < buffer.length; i++) if (buffer[i].pts >= start) break;
            return buffer.slice(0, i).concat(gops);
        };
        const removeGopBuffer = (buffer, start, end, mapping) => {
            const startPts = Math.ceil((start - mapping) * clock.ONE_SECOND_IN_TS);
            const endPts = Math.ceil((end - mapping) * clock.ONE_SECOND_IN_TS);
            const updatedBuffer = buffer.slice();
            let i = buffer.length;
            while (i--) if (buffer[i].pts <= endPts) break;
            if (i === -1) return updatedBuffer;
            let j = i + 1;
            while (j--) if (buffer[j].pts <= startPts) break;
            j = Math.max(j, 0);
            updatedBuffer.splice(j, i - j + 1);
            return updatedBuffer;
        };
        const shallowEqual = function(a, b) {
            if (!a && !b || !a && b || a && !b) return false;
            if (a === b) return true;
            const akeys = Object.keys(a).sort();
            const bkeys = Object.keys(b).sort();
            if (akeys.length !== bkeys.length) return false;
            for (let i = 0; i < akeys.length; i++) {
                const key = akeys[i];
                if (key !== bkeys[i]) return false;
                if (a[key] !== b[key]) return false;
            }
            return true;
        };
        const QUOTA_EXCEEDED_ERR = 22;
        const getSyncSegmentCandidate = function(currentTimeline, segments, targetTime) {
            segments = segments || [];
            const timelineSegments = [];
            let time = 0;
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                if (currentTimeline === segment.timeline) {
                    timelineSegments.push(i);
                    time += segment.duration;
                    if (time > targetTime) return i;
                }
            }
            if (timelineSegments.length === 0) return 0;
            return timelineSegments[timelineSegments.length - 1];
        };
        const MIN_BACK_BUFFER = 1;
        const CHECK_BUFFER_DELAY = 500;
        const finite = num => typeof num === "number" && isFinite(num);
        const MIN_SEGMENT_DURATION_TO_SAVE_STATS = 1 / 60;
        const illegalMediaSwitch = (loaderType, startingMedia, trackInfo) => {
            if (loaderType !== "main" || !startingMedia || !trackInfo) return null;
            if (!trackInfo.hasAudio && !trackInfo.hasVideo) return "Neither audio nor video found in segment.";
            if (startingMedia.hasVideo && !trackInfo.hasVideo) return "Only audio found in segment when we expected video." + " We can't switch to audio only from a stream that had video." + " To get rid of this message, please add codec information to the manifest.";
            if (!startingMedia.hasVideo && trackInfo.hasVideo) return "Video found in segment when we expected only audio." + " We can't switch to a stream with video from an audio only stream." + " To get rid of this message, please add codec information to the manifest.";
            return null;
        };
        const safeBackBufferTrimTime = (seekable, currentTime, targetDuration) => {
            let trimTime = currentTime - Config.BACK_BUFFER_LENGTH;
            if (seekable.length) trimTime = Math.max(trimTime, seekable.start(0));
            const maxTrimTime = currentTime - targetDuration;
            return Math.min(maxTrimTime, trimTime);
        };
        const segmentInfoString = segmentInfo => {
            const {startOfSegment, duration, segment, part, playlist: {mediaSequence: seq, id, segments = []}, mediaIndex: index, partIndex, timeline} = segmentInfo;
            const segmentLen = segments.length - 1;
            let selection = "mediaIndex/partIndex increment";
            if (segmentInfo.getMediaInfoForTime) selection = `getMediaInfoForTime (${segmentInfo.getMediaInfoForTime})`; else if (segmentInfo.isSyncRequest) selection = "getSyncSegmentCandidate (isSyncRequest)";
            if (segmentInfo.independent) selection += ` with independent ${segmentInfo.independent}`;
            const hasPartIndex = typeof partIndex === "number";
            const name = segmentInfo.segment.uri ? "segment" : "pre-segment";
            const zeroBasedPartCount = hasPartIndex ? getKnownPartCount({
                preloadSegment: segment
            }) - 1 : 0;
            return `${name} [${seq + index}/${seq + segmentLen}]` + (hasPartIndex ? ` part [${partIndex}/${zeroBasedPartCount}]` : "") + ` segment start/end [${segment.start} => ${segment.end}]` + (hasPartIndex ? ` part start/end [${part.start} => ${part.end}]` : "") + ` startOfSegment [${startOfSegment}]` + ` duration [${duration}]` + ` timeline [${timeline}]` + ` selected by [${selection}]` + ` playlist [${id}]`;
        };
        const timingInfoPropertyForMedia = mediaType => `${mediaType}TimingInfo`;
        const timestampOffsetForSegment = ({segmentTimeline, currentTimeline, startOfSegment, buffered, overrideCheck}) => {
            if (!overrideCheck && segmentTimeline === currentTimeline) return null;
            if (segmentTimeline < currentTimeline) return startOfSegment;
            return buffered.length ? buffered.end(buffered.length - 1) : startOfSegment;
        };
        const shouldWaitForTimelineChange = ({timelineChangeController, currentTimeline, segmentTimeline, loaderType, audioDisabled}) => {
            if (currentTimeline === segmentTimeline) return false;
            if (loaderType === "audio") {
                const lastMainTimelineChange = timelineChangeController.lastTimelineChange({
                    type: "main"
                });
                return !lastMainTimelineChange || lastMainTimelineChange.to !== segmentTimeline;
            }
            if (loaderType === "main" && audioDisabled) {
                const pendingAudioTimelineChange = timelineChangeController.pendingTimelineChange({
                    type: "audio"
                });
                if (pendingAudioTimelineChange && pendingAudioTimelineChange.to === segmentTimeline) return false;
                return true;
            }
            return false;
        };
        const mediaDuration = timingInfos => {
            let maxDuration = 0;
            [ "video", "audio" ].forEach((function(type) {
                const typeTimingInfo = timingInfos[`${type}TimingInfo`];
                if (!typeTimingInfo) return;
                const {start, end} = typeTimingInfo;
                let duration;
                if (typeof start === "bigint" || typeof end === "bigint") duration = window_default().BigInt(end) - window_default().BigInt(start); else if (typeof start === "number" && typeof end === "number") duration = end - start;
                if (typeof duration !== "undefined" && duration > maxDuration) maxDuration = duration;
            }));
            if (typeof maxDuration === "bigint" && maxDuration < Number.MAX_SAFE_INTEGER) maxDuration = Number(maxDuration);
            return maxDuration;
        };
        const segmentTooLong = ({segmentDuration, maxDuration}) => {
            if (!segmentDuration) return false;
            return Math.round(segmentDuration) > maxDuration + TIME_FUDGE_FACTOR;
        };
        const getTroublesomeSegmentDurationMessage = (segmentInfo, sourceType) => {
            if (sourceType !== "hls") return null;
            const segmentDuration = mediaDuration({
                audioTimingInfo: segmentInfo.audioTimingInfo,
                videoTimingInfo: segmentInfo.videoTimingInfo
            });
            if (!segmentDuration) return null;
            const targetDuration = segmentInfo.playlist.targetDuration;
            const isSegmentWayTooLong = segmentTooLong({
                segmentDuration,
                maxDuration: targetDuration * 2
            });
            const isSegmentSlightlyTooLong = segmentTooLong({
                segmentDuration,
                maxDuration: targetDuration
            });
            const segmentTooLongMessage = `Segment with index ${segmentInfo.mediaIndex} ` + `from playlist ${segmentInfo.playlist.id} ` + `has a duration of ${segmentDuration} ` + `when the reported duration is ${segmentInfo.duration} ` + `and the target duration is ${targetDuration}. ` + "For HLS content, a duration in excess of the target duration may result in " + "playback issues. See the HLS specification section on EXT-X-TARGETDURATION for " + "more details: " + "https://tools.ietf.org/html/draft-pantos-http-live-streaming-23#section-4.3.3.1";
            if (isSegmentWayTooLong || isSegmentSlightlyTooLong) return {
                severity: isSegmentWayTooLong ? "warn" : "info",
                message: segmentTooLongMessage
            };
            return null;
        };
        class SegmentLoader extends videojs.EventTarget {
            constructor(settings, options = {}) {
                super();
                if (!settings) throw new TypeError("Initialization settings are required");
                if (typeof settings.currentTime !== "function") throw new TypeError("No currentTime getter specified");
                if (!settings.mediaSource) throw new TypeError("No MediaSource specified");
                this.bandwidth = settings.bandwidth;
                this.throughput = {
                    rate: 0,
                    count: 0
                };
                this.roundTrip = NaN;
                this.resetStats_();
                this.mediaIndex = null;
                this.partIndex = null;
                this.hasPlayed_ = settings.hasPlayed;
                this.currentTime_ = settings.currentTime;
                this.seekable_ = settings.seekable;
                this.seeking_ = settings.seeking;
                this.duration_ = settings.duration;
                this.mediaSource_ = settings.mediaSource;
                this.vhs_ = settings.vhs;
                this.loaderType_ = settings.loaderType;
                this.currentMediaInfo_ = void 0;
                this.startingMediaInfo_ = void 0;
                this.segmentMetadataTrack_ = settings.segmentMetadataTrack;
                this.goalBufferLength_ = settings.goalBufferLength;
                this.sourceType_ = settings.sourceType;
                this.sourceUpdater_ = settings.sourceUpdater;
                this.inbandTextTracks_ = settings.inbandTextTracks;
                this.state_ = "INIT";
                this.timelineChangeController_ = settings.timelineChangeController;
                this.shouldSaveSegmentTimingInfo_ = true;
                this.parse708captions_ = settings.parse708captions;
                this.useDtsForTimestampOffset_ = settings.useDtsForTimestampOffset;
                this.captionServices_ = settings.captionServices;
                this.exactManifestTimings = settings.exactManifestTimings;
                this.checkBufferTimeout_ = null;
                this.error_ = void 0;
                this.currentTimeline_ = -1;
                this.pendingSegment_ = null;
                this.xhrOptions_ = null;
                this.pendingSegments_ = [];
                this.audioDisabled_ = false;
                this.isPendingTimestampOffset_ = false;
                this.gopBuffer_ = [];
                this.timeMapping_ = 0;
                this.safeAppend_ = videojs.browser.IE_VERSION >= 11;
                this.appendInitSegment_ = {
                    audio: true,
                    video: true
                };
                this.playlistOfLastInitSegment_ = {
                    audio: null,
                    video: null
                };
                this.callQueue_ = [];
                this.loadQueue_ = [];
                this.metadataQueue_ = {
                    id3: [],
                    caption: []
                };
                this.waitingOnRemove_ = false;
                this.quotaExceededErrorRetryTimeout_ = null;
                this.activeInitSegmentId_ = null;
                this.initSegments_ = {};
                this.cacheEncryptionKeys_ = settings.cacheEncryptionKeys;
                this.keyCache_ = {};
                this.decrypter_ = settings.decrypter;
                this.syncController_ = settings.syncController;
                this.syncPoint_ = {
                    segmentIndex: 0,
                    time: 0
                };
                this.transmuxer_ = this.createTransmuxer_();
                this.triggerSyncInfoUpdate_ = () => this.trigger("syncinfoupdate");
                this.syncController_.on("syncinfoupdate", this.triggerSyncInfoUpdate_);
                this.mediaSource_.addEventListener("sourceopen", (() => {
                    if (!this.isEndOfStream_()) this.ended_ = false;
                }));
                this.fetchAtBuffer_ = false;
                this.logger_ = logger(`SegmentLoader[${this.loaderType_}]`);
                Object.defineProperty(this, "state", {
                    get() {
                        return this.state_;
                    },
                    set(newState) {
                        if (newState !== this.state_) {
                            this.logger_(`${this.state_} -> ${newState}`);
                            this.state_ = newState;
                            this.trigger("statechange");
                        }
                    }
                });
                this.sourceUpdater_.on("ready", (() => {
                    if (this.hasEnoughInfoToAppend_()) this.processCallQueue_();
                }));
                if (this.loaderType_ === "main") this.timelineChangeController_.on("pendingtimelinechange", (() => {
                    if (this.hasEnoughInfoToAppend_()) this.processCallQueue_();
                }));
                if (this.loaderType_ === "audio") this.timelineChangeController_.on("timelinechange", (() => {
                    if (this.hasEnoughInfoToLoad_()) this.processLoadQueue_();
                    if (this.hasEnoughInfoToAppend_()) this.processCallQueue_();
                }));
            }
            createTransmuxer_() {
                return segmentTransmuxer.createTransmuxer({
                    remux: false,
                    alignGopsAtEnd: this.safeAppend_,
                    keepOriginalTimestamps: true,
                    parse708captions: this.parse708captions_,
                    captionServices: this.captionServices_
                });
            }
            resetStats_() {
                this.mediaBytesTransferred = 0;
                this.mediaRequests = 0;
                this.mediaRequestsAborted = 0;
                this.mediaRequestsTimedout = 0;
                this.mediaRequestsErrored = 0;
                this.mediaTransferDuration = 0;
                this.mediaSecondsLoaded = 0;
                this.mediaAppends = 0;
            }
            dispose() {
                this.trigger("dispose");
                this.state = "DISPOSED";
                this.pause();
                this.abort_();
                if (this.transmuxer_) this.transmuxer_.terminate();
                this.resetStats_();
                if (this.checkBufferTimeout_) window_default().clearTimeout(this.checkBufferTimeout_);
                if (this.syncController_ && this.triggerSyncInfoUpdate_) this.syncController_.off("syncinfoupdate", this.triggerSyncInfoUpdate_);
                this.off();
            }
            setAudio(enable) {
                this.audioDisabled_ = !enable;
                if (enable) this.appendInitSegment_.audio = true; else this.sourceUpdater_.removeAudio(0, this.duration_());
            }
            abort() {
                if (this.state !== "WAITING") {
                    if (this.pendingSegment_) this.pendingSegment_ = null;
                    return;
                }
                this.abort_();
                this.state = "READY";
                if (!this.paused()) this.monitorBuffer_();
            }
            abort_() {
                if (this.pendingSegment_ && this.pendingSegment_.abortRequests) this.pendingSegment_.abortRequests();
                this.pendingSegment_ = null;
                this.callQueue_ = [];
                this.loadQueue_ = [];
                this.metadataQueue_.id3 = [];
                this.metadataQueue_.caption = [];
                this.timelineChangeController_.clearPendingTimelineChange(this.loaderType_);
                this.waitingOnRemove_ = false;
                window_default().clearTimeout(this.quotaExceededErrorRetryTimeout_);
                this.quotaExceededErrorRetryTimeout_ = null;
            }
            checkForAbort_(requestId) {
                if (this.state === "APPENDING" && !this.pendingSegment_) {
                    this.state = "READY";
                    return true;
                }
                if (!this.pendingSegment_ || this.pendingSegment_.requestId !== requestId) return true;
                return false;
            }
            error(error) {
                if (typeof error !== "undefined") {
                    this.logger_("error occurred:", error);
                    this.error_ = error;
                }
                this.pendingSegment_ = null;
                return this.error_;
            }
            endOfStream() {
                this.ended_ = true;
                if (this.transmuxer_) segmentTransmuxer.reset(this.transmuxer_);
                this.gopBuffer_.length = 0;
                this.pause();
                this.trigger("ended");
            }
            buffered_() {
                const trackInfo = this.getMediaInfo_();
                if (!this.sourceUpdater_ || !trackInfo) return createTimeRanges();
                if (this.loaderType_ === "main") {
                    const {hasAudio, hasVideo, isMuxed} = trackInfo;
                    if (hasVideo && hasAudio && !this.audioDisabled_ && !isMuxed) return this.sourceUpdater_.buffered();
                    if (hasVideo) return this.sourceUpdater_.videoBuffered();
                }
                return this.sourceUpdater_.audioBuffered();
            }
            initSegmentForMap(map, set = false) {
                if (!map) return null;
                const id = initSegmentId(map);
                let storedMap = this.initSegments_[id];
                if (set && !storedMap && map.bytes) this.initSegments_[id] = storedMap = {
                    resolvedUri: map.resolvedUri,
                    byterange: map.byterange,
                    bytes: map.bytes,
                    tracks: map.tracks,
                    timescales: map.timescales
                };
                return storedMap || map;
            }
            segmentKey(key, set = false) {
                if (!key) return null;
                const id = segmentKeyId(key);
                let storedKey = this.keyCache_[id];
                if (this.cacheEncryptionKeys_ && set && !storedKey && key.bytes) this.keyCache_[id] = storedKey = {
                    resolvedUri: key.resolvedUri,
                    bytes: key.bytes
                };
                const result = {
                    resolvedUri: (storedKey || key).resolvedUri
                };
                if (storedKey) result.bytes = storedKey.bytes;
                return result;
            }
            couldBeginLoading_() {
                return this.playlist_ && !this.paused();
            }
            load() {
                this.monitorBuffer_();
                if (!this.playlist_) return;
                if (this.state === "INIT" && this.couldBeginLoading_()) return this.init_();
                if (!this.couldBeginLoading_() || this.state !== "READY" && this.state !== "INIT") return;
                this.state = "READY";
            }
            init_() {
                this.state = "READY";
                this.resetEverything();
                return this.monitorBuffer_();
            }
            playlist(newPlaylist, options = {}) {
                if (!newPlaylist) return;
                const oldPlaylist = this.playlist_;
                const segmentInfo = this.pendingSegment_;
                this.playlist_ = newPlaylist;
                this.xhrOptions_ = options;
                if (this.state === "INIT") {
                    newPlaylist.syncInfo = {
                        mediaSequence: newPlaylist.mediaSequence,
                        time: 0
                    };
                    if (this.loaderType_ === "main") this.syncController_.setDateTimeMappingForStart(newPlaylist);
                }
                let oldId = null;
                if (oldPlaylist) if (oldPlaylist.id) oldId = oldPlaylist.id; else if (oldPlaylist.uri) oldId = oldPlaylist.uri;
                this.logger_(`playlist update [${oldId} => ${newPlaylist.id || newPlaylist.uri}]`);
                this.trigger("syncinfoupdate");
                if (this.state === "INIT" && this.couldBeginLoading_()) return this.init_();
                if (!oldPlaylist || oldPlaylist.uri !== newPlaylist.uri) {
                    if (this.mediaIndex !== null) if (!newPlaylist.endList) this.resetLoader(); else this.resyncLoader();
                    this.currentMediaInfo_ = void 0;
                    this.trigger("playlistupdate");
                    return;
                }
                const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
                this.logger_(`live window shift [${mediaSequenceDiff}]`);
                if (this.mediaIndex !== null) {
                    this.mediaIndex -= mediaSequenceDiff;
                    if (this.mediaIndex < 0) {
                        this.mediaIndex = null;
                        this.partIndex = null;
                    } else {
                        const segment = this.playlist_.segments[this.mediaIndex];
                        if (this.partIndex && (!segment.parts || !segment.parts.length || !segment.parts[this.partIndex])) {
                            const mediaIndex = this.mediaIndex;
                            this.logger_(`currently processing part (index ${this.partIndex}) no longer exists.`);
                            this.resetLoader();
                            this.mediaIndex = mediaIndex;
                        }
                    }
                }
                if (segmentInfo) {
                    segmentInfo.mediaIndex -= mediaSequenceDiff;
                    if (segmentInfo.mediaIndex < 0) {
                        segmentInfo.mediaIndex = null;
                        segmentInfo.partIndex = null;
                    } else {
                        if (segmentInfo.mediaIndex >= 0) segmentInfo.segment = newPlaylist.segments[segmentInfo.mediaIndex];
                        if (segmentInfo.partIndex >= 0 && segmentInfo.segment.parts) segmentInfo.part = segmentInfo.segment.parts[segmentInfo.partIndex];
                    }
                }
                this.syncController_.saveExpiredSegmentInfo(oldPlaylist, newPlaylist);
            }
            pause() {
                if (this.checkBufferTimeout_) {
                    window_default().clearTimeout(this.checkBufferTimeout_);
                    this.checkBufferTimeout_ = null;
                }
            }
            paused() {
                return this.checkBufferTimeout_ === null;
            }
            resetEverything(done) {
                this.ended_ = false;
                this.activeInitSegmentId_ = null;
                this.appendInitSegment_ = {
                    audio: true,
                    video: true
                };
                this.resetLoader();
                this.remove(0, 1 / 0, done);
                if (this.transmuxer_) {
                    this.transmuxer_.postMessage({
                        action: "clearAllMp4Captions"
                    });
                    this.transmuxer_.postMessage({
                        action: "reset"
                    });
                }
            }
            resetLoader() {
                this.fetchAtBuffer_ = false;
                this.resyncLoader();
            }
            resyncLoader() {
                if (this.transmuxer_) segmentTransmuxer.reset(this.transmuxer_);
                this.mediaIndex = null;
                this.partIndex = null;
                this.syncPoint_ = null;
                this.isPendingTimestampOffset_ = false;
                this.callQueue_ = [];
                this.loadQueue_ = [];
                this.metadataQueue_.id3 = [];
                this.metadataQueue_.caption = [];
                this.abort();
                if (this.transmuxer_) this.transmuxer_.postMessage({
                    action: "clearParsedMp4Captions"
                });
            }
            remove(start, end, done = (() => {}), force = false) {
                if (end === 1 / 0) end = this.duration_();
                if (end <= start) {
                    this.logger_("skipping remove because end ${end} is <= start ${start}");
                    return;
                }
                if (!this.sourceUpdater_ || !this.getMediaInfo_()) {
                    this.logger_("skipping remove because no source updater or starting media info");
                    return;
                }
                let removesRemaining = 1;
                const removeFinished = () => {
                    removesRemaining--;
                    if (removesRemaining === 0) done();
                };
                if (force || !this.audioDisabled_) {
                    removesRemaining++;
                    this.sourceUpdater_.removeAudio(start, end, removeFinished);
                }
                if (force || this.loaderType_ === "main") {
                    this.gopBuffer_ = removeGopBuffer(this.gopBuffer_, start, end, this.timeMapping_);
                    removesRemaining++;
                    this.sourceUpdater_.removeVideo(start, end, removeFinished);
                }
                for (const track in this.inbandTextTracks_) removeCuesFromTrack(start, end, this.inbandTextTracks_[track]);
                removeCuesFromTrack(start, end, this.segmentMetadataTrack_);
                removeFinished();
            }
            monitorBuffer_() {
                if (this.checkBufferTimeout_) window_default().clearTimeout(this.checkBufferTimeout_);
                this.checkBufferTimeout_ = window_default().setTimeout(this.monitorBufferTick_.bind(this), 1);
            }
            monitorBufferTick_() {
                if (this.state === "READY") this.fillBuffer_();
                if (this.checkBufferTimeout_) window_default().clearTimeout(this.checkBufferTimeout_);
                this.checkBufferTimeout_ = window_default().setTimeout(this.monitorBufferTick_.bind(this), CHECK_BUFFER_DELAY);
            }
            fillBuffer_() {
                if (this.sourceUpdater_.updating()) return;
                const segmentInfo = this.chooseNextRequest_();
                if (!segmentInfo) return;
                if (typeof segmentInfo.timestampOffset === "number") {
                    this.isPendingTimestampOffset_ = false;
                    this.timelineChangeController_.pendingTimelineChange({
                        type: this.loaderType_,
                        from: this.currentTimeline_,
                        to: segmentInfo.timeline
                    });
                }
                this.loadSegment_(segmentInfo);
            }
            isEndOfStream_(mediaIndex = this.mediaIndex, playlist = this.playlist_, partIndex = this.partIndex) {
                if (!playlist || !this.mediaSource_) return false;
                const segment = typeof mediaIndex === "number" && playlist.segments[mediaIndex];
                const appendedLastSegment = mediaIndex + 1 === playlist.segments.length;
                const appendedLastPart = !segment || !segment.parts || partIndex + 1 === segment.parts.length;
                return playlist.endList && this.mediaSource_.readyState === "open" && appendedLastSegment && appendedLastPart;
            }
            chooseNextRequest_() {
                const buffered = this.buffered_();
                const bufferedEnd = lastBufferedEnd(buffered) || 0;
                const bufferedTime = timeAheadOf(buffered, this.currentTime_());
                const preloaded = !this.hasPlayed_() && bufferedTime >= 1;
                const haveEnoughBuffer = bufferedTime >= this.goalBufferLength_();
                const segments = this.playlist_.segments;
                if (!segments.length || preloaded || haveEnoughBuffer) return null;
                this.syncPoint_ = this.syncPoint_ || this.syncController_.getSyncPoint(this.playlist_, this.duration_(), this.currentTimeline_, this.currentTime_());
                const next = {
                    partIndex: null,
                    mediaIndex: null,
                    startOfSegment: null,
                    playlist: this.playlist_,
                    isSyncRequest: Boolean(!this.syncPoint_)
                };
                if (next.isSyncRequest) next.mediaIndex = getSyncSegmentCandidate(this.currentTimeline_, segments, bufferedEnd); else if (this.mediaIndex !== null) {
                    const segment = segments[this.mediaIndex];
                    const partIndex = typeof this.partIndex === "number" ? this.partIndex : -1;
                    next.startOfSegment = segment.end ? segment.end : bufferedEnd;
                    if (segment.parts && segment.parts[partIndex + 1]) {
                        next.mediaIndex = this.mediaIndex;
                        next.partIndex = partIndex + 1;
                    } else next.mediaIndex = this.mediaIndex + 1;
                } else {
                    const {segmentIndex, startTime, partIndex} = Playlist.getMediaInfoForTime({
                        exactManifestTimings: this.exactManifestTimings,
                        playlist: this.playlist_,
                        currentTime: this.fetchAtBuffer_ ? bufferedEnd : this.currentTime_(),
                        startingPartIndex: this.syncPoint_.partIndex,
                        startingSegmentIndex: this.syncPoint_.segmentIndex,
                        startTime: this.syncPoint_.time
                    });
                    next.getMediaInfoForTime = this.fetchAtBuffer_ ? `bufferedEnd ${bufferedEnd}` : `currentTime ${this.currentTime_()}`;
                    next.mediaIndex = segmentIndex;
                    next.startOfSegment = startTime;
                    next.partIndex = partIndex;
                }
                const nextSegment = segments[next.mediaIndex];
                let nextPart = nextSegment && typeof next.partIndex === "number" && nextSegment.parts && nextSegment.parts[next.partIndex];
                if (!nextSegment || typeof next.partIndex === "number" && !nextPart) return null;
                if (typeof next.partIndex !== "number" && nextSegment.parts) {
                    next.partIndex = 0;
                    nextPart = nextSegment.parts[0];
                }
                if (!bufferedTime && nextPart && !nextPart.independent) if (next.partIndex === 0) {
                    const lastSegment = segments[next.mediaIndex - 1];
                    const lastSegmentLastPart = lastSegment.parts && lastSegment.parts.length && lastSegment.parts[lastSegment.parts.length - 1];
                    if (lastSegmentLastPart && lastSegmentLastPart.independent) {
                        next.mediaIndex -= 1;
                        next.partIndex = lastSegment.parts.length - 1;
                        next.independent = "previous segment";
                    }
                } else if (nextSegment.parts[next.partIndex - 1].independent) {
                    next.partIndex -= 1;
                    next.independent = "previous part";
                }
                const ended = this.mediaSource_ && this.mediaSource_.readyState === "ended";
                if (next.mediaIndex >= segments.length - 1 && ended && !this.seeking_()) return null;
                return this.generateSegmentInfo_(next);
            }
            generateSegmentInfo_(options) {
                const {independent, playlist, mediaIndex, startOfSegment, isSyncRequest, partIndex, forceTimestampOffset, getMediaInfoForTime} = options;
                const segment = playlist.segments[mediaIndex];
                const part = typeof partIndex === "number" && segment.parts[partIndex];
                const segmentInfo = {
                    requestId: "segment-loader-" + Math.random(),
                    uri: part && part.resolvedUri || segment.resolvedUri,
                    mediaIndex,
                    partIndex: part ? partIndex : null,
                    isSyncRequest,
                    startOfSegment,
                    playlist,
                    bytes: null,
                    encryptedBytes: null,
                    timestampOffset: null,
                    timeline: segment.timeline,
                    duration: part && part.duration || segment.duration,
                    segment,
                    part,
                    byteLength: 0,
                    transmuxer: this.transmuxer_,
                    getMediaInfoForTime,
                    independent
                };
                const overrideCheck = typeof forceTimestampOffset !== "undefined" ? forceTimestampOffset : this.isPendingTimestampOffset_;
                segmentInfo.timestampOffset = this.timestampOffsetForSegment_({
                    segmentTimeline: segment.timeline,
                    currentTimeline: this.currentTimeline_,
                    startOfSegment,
                    buffered: this.buffered_(),
                    overrideCheck
                });
                const audioBufferedEnd = lastBufferedEnd(this.sourceUpdater_.audioBuffered());
                if (typeof audioBufferedEnd === "number") segmentInfo.audioAppendStart = audioBufferedEnd - this.sourceUpdater_.audioTimestampOffset();
                if (this.sourceUpdater_.videoBuffered().length) segmentInfo.gopsToAlignWith = gopsSafeToAlignWith(this.gopBuffer_, this.currentTime_() - this.sourceUpdater_.videoTimestampOffset(), this.timeMapping_);
                return segmentInfo;
            }
            timestampOffsetForSegment_(options) {
                return timestampOffsetForSegment(options);
            }
            earlyAbortWhenNeeded_(stats) {
                if (this.vhs_.tech_.paused() || !this.xhrOptions_.timeout || !this.playlist_.attributes.BANDWIDTH) return;
                if (Date.now() - (stats.firstBytesReceivedAt || Date.now()) < 1e3) return;
                const currentTime = this.currentTime_();
                const measuredBandwidth = stats.bandwidth;
                const segmentDuration = this.pendingSegment_.duration;
                const requestTimeRemaining = Playlist.estimateSegmentRequestTime(segmentDuration, measuredBandwidth, this.playlist_, stats.bytesReceived);
                const timeUntilRebuffer$1 = timeUntilRebuffer(this.buffered_(), currentTime, this.vhs_.tech_.playbackRate()) - 1;
                if (requestTimeRemaining <= timeUntilRebuffer$1) return;
                const switchCandidate = minRebufferMaxBandwidthSelector({
                    main: this.vhs_.playlists.main,
                    currentTime,
                    bandwidth: measuredBandwidth,
                    duration: this.duration_(),
                    segmentDuration,
                    timeUntilRebuffer: timeUntilRebuffer$1,
                    currentTimeline: this.currentTimeline_,
                    syncController: this.syncController_
                });
                if (!switchCandidate) return;
                const rebufferingImpact = requestTimeRemaining - timeUntilRebuffer$1;
                const timeSavedBySwitching = rebufferingImpact - switchCandidate.rebufferingImpact;
                let minimumTimeSaving = .5;
                if (timeUntilRebuffer$1 <= TIME_FUDGE_FACTOR) minimumTimeSaving = 1;
                if (!switchCandidate.playlist || switchCandidate.playlist.uri === this.playlist_.uri || timeSavedBySwitching < minimumTimeSaving) return;
                this.bandwidth = switchCandidate.playlist.attributes.BANDWIDTH * Config.BANDWIDTH_VARIANCE + 1;
                this.trigger("earlyabort");
            }
            handleAbort_(segmentInfo) {
                this.logger_(`Aborting ${segmentInfoString(segmentInfo)}`);
                this.mediaRequestsAborted += 1;
            }
            handleProgress_(event, simpleSegment) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                this.trigger("progress");
            }
            handleTrackInfo_(simpleSegment, trackInfo) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                if (this.checkForIllegalMediaSwitch(trackInfo)) return;
                trackInfo = trackInfo || {};
                if (!shallowEqual(this.currentMediaInfo_, trackInfo)) {
                    this.appendInitSegment_ = {
                        audio: true,
                        video: true
                    };
                    this.startingMediaInfo_ = trackInfo;
                    this.currentMediaInfo_ = trackInfo;
                    this.logger_("trackinfo update", trackInfo);
                    this.trigger("trackinfo");
                }
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                this.pendingSegment_.trackInfo = trackInfo;
                if (this.hasEnoughInfoToAppend_()) this.processCallQueue_();
            }
            handleTimingInfo_(simpleSegment, mediaType, timeType, time) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                const segmentInfo = this.pendingSegment_;
                const timingInfoProperty = timingInfoPropertyForMedia(mediaType);
                segmentInfo[timingInfoProperty] = segmentInfo[timingInfoProperty] || {};
                segmentInfo[timingInfoProperty][timeType] = time;
                this.logger_(`timinginfo: ${mediaType} - ${timeType} - ${time}`);
                if (this.hasEnoughInfoToAppend_()) this.processCallQueue_();
            }
            handleCaptions_(simpleSegment, captionData) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                if (captionData.length === 0) {
                    this.logger_("SegmentLoader received no captions from a caption event");
                    return;
                }
                const segmentInfo = this.pendingSegment_;
                if (!segmentInfo.hasAppendedData_) {
                    this.metadataQueue_.caption.push(this.handleCaptions_.bind(this, simpleSegment, captionData));
                    return;
                }
                const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
                const captionTracks = {};
                captionData.forEach((caption => {
                    captionTracks[caption.stream] = captionTracks[caption.stream] || {
                        startTime: 1 / 0,
                        captions: [],
                        endTime: 0
                    };
                    const captionTrack = captionTracks[caption.stream];
                    captionTrack.startTime = Math.min(captionTrack.startTime, caption.startTime + timestampOffset);
                    captionTrack.endTime = Math.max(captionTrack.endTime, caption.endTime + timestampOffset);
                    captionTrack.captions.push(caption);
                }));
                Object.keys(captionTracks).forEach((trackName => {
                    const {startTime, endTime, captions} = captionTracks[trackName];
                    const inbandTextTracks = this.inbandTextTracks_;
                    this.logger_(`adding cues from ${startTime} -> ${endTime} for ${trackName}`);
                    createCaptionsTrackIfNotExists(inbandTextTracks, this.vhs_.tech_, trackName);
                    removeCuesFromTrack(startTime, endTime, inbandTextTracks[trackName]);
                    addCaptionData({
                        captionArray: captions,
                        inbandTextTracks,
                        timestampOffset
                    });
                }));
                if (this.transmuxer_) this.transmuxer_.postMessage({
                    action: "clearParsedMp4Captions"
                });
            }
            handleId3_(simpleSegment, id3Frames, dispatchType) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                const segmentInfo = this.pendingSegment_;
                if (!segmentInfo.hasAppendedData_) {
                    this.metadataQueue_.id3.push(this.handleId3_.bind(this, simpleSegment, id3Frames, dispatchType));
                    return;
                }
                const timestampOffset = this.sourceUpdater_.videoTimestampOffset() === null ? this.sourceUpdater_.audioTimestampOffset() : this.sourceUpdater_.videoTimestampOffset();
                createMetadataTrackIfNotExists(this.inbandTextTracks_, dispatchType, this.vhs_.tech_);
                addMetadata({
                    inbandTextTracks: this.inbandTextTracks_,
                    metadataArray: id3Frames,
                    timestampOffset,
                    videoDuration: this.duration_()
                });
            }
            processMetadataQueue_() {
                this.metadataQueue_.id3.forEach((fn => fn()));
                this.metadataQueue_.caption.forEach((fn => fn()));
                this.metadataQueue_.id3 = [];
                this.metadataQueue_.caption = [];
            }
            processCallQueue_() {
                const callQueue = this.callQueue_;
                this.callQueue_ = [];
                callQueue.forEach((fun => fun()));
            }
            processLoadQueue_() {
                const loadQueue = this.loadQueue_;
                this.loadQueue_ = [];
                loadQueue.forEach((fun => fun()));
            }
            hasEnoughInfoToLoad_() {
                if (this.loaderType_ !== "audio") return true;
                const segmentInfo = this.pendingSegment_;
                if (!segmentInfo) return false;
                if (!this.getCurrentMediaInfo_()) return true;
                if (shouldWaitForTimelineChange({
                    timelineChangeController: this.timelineChangeController_,
                    currentTimeline: this.currentTimeline_,
                    segmentTimeline: segmentInfo.timeline,
                    loaderType: this.loaderType_,
                    audioDisabled: this.audioDisabled_
                })) return false;
                return true;
            }
            getCurrentMediaInfo_(segmentInfo = this.pendingSegment_) {
                return segmentInfo && segmentInfo.trackInfo || this.currentMediaInfo_;
            }
            getMediaInfo_(segmentInfo = this.pendingSegment_) {
                return this.getCurrentMediaInfo_(segmentInfo) || this.startingMediaInfo_;
            }
            getPendingSegmentPlaylist() {
                return this.pendingSegment_ ? this.pendingSegment_.playlist : null;
            }
            hasEnoughInfoToAppend_() {
                if (!this.sourceUpdater_.ready()) return false;
                if (this.waitingOnRemove_ || this.quotaExceededErrorRetryTimeout_) return false;
                const segmentInfo = this.pendingSegment_;
                const trackInfo = this.getCurrentMediaInfo_();
                if (!segmentInfo || !trackInfo) return false;
                const {hasAudio, hasVideo, isMuxed} = trackInfo;
                if (hasVideo && !segmentInfo.videoTimingInfo) return false;
                if (hasAudio && !this.audioDisabled_ && !isMuxed && !segmentInfo.audioTimingInfo) return false;
                if (shouldWaitForTimelineChange({
                    timelineChangeController: this.timelineChangeController_,
                    currentTimeline: this.currentTimeline_,
                    segmentTimeline: segmentInfo.timeline,
                    loaderType: this.loaderType_,
                    audioDisabled: this.audioDisabled_
                })) return false;
                return true;
            }
            handleData_(simpleSegment, result) {
                this.earlyAbortWhenNeeded_(simpleSegment.stats);
                if (this.checkForAbort_(simpleSegment.requestId)) return;
                if (this.callQueue_.length || !this.hasEnoughInfoToAppend_()) {
                    this.callQueue_.push(this.handleData_.bind(this, simpleSegment, result));
                    return;
                }
                const segmentInfo = this.pendingSegment_;
                this.setTimeMapping_(segmentInfo.timeline);
                this.updateMediaSecondsLoaded_(segmentInfo.part || segmentInfo.segment);
                if (this.mediaSource_.readyState === "closed") return;
                if (simpleSegment.map) {
                    simpleSegment.map = this.initSegmentForMap(simpleSegment.map, true);
                    segmentInfo.segment.map = simpleSegment.map;
                }
                if (simpleSegment.key) this.segmentKey(simpleSegment.key, true);
                segmentInfo.isFmp4 = simpleSegment.isFmp4;
                segmentInfo.timingInfo = segmentInfo.timingInfo || {};
                if (segmentInfo.isFmp4) {
                    this.trigger("fmp4");
                    segmentInfo.timingInfo.start = segmentInfo[timingInfoPropertyForMedia(result.type)].start;
                } else {
                    const trackInfo = this.getCurrentMediaInfo_();
                    const useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
                    let firstVideoFrameTimeForData;
                    if (useVideoTimingInfo) firstVideoFrameTimeForData = segmentInfo.videoTimingInfo.start;
                    segmentInfo.timingInfo.start = this.trueSegmentStart_({
                        currentStart: segmentInfo.timingInfo.start,
                        playlist: segmentInfo.playlist,
                        mediaIndex: segmentInfo.mediaIndex,
                        currentVideoTimestampOffset: this.sourceUpdater_.videoTimestampOffset(),
                        useVideoTimingInfo,
                        firstVideoFrameTimeForData,
                        videoTimingInfo: segmentInfo.videoTimingInfo,
                        audioTimingInfo: segmentInfo.audioTimingInfo
                    });
                }
                this.updateAppendInitSegmentStatus(segmentInfo, result.type);
                this.updateSourceBufferTimestampOffset_(segmentInfo);
                if (segmentInfo.isSyncRequest) {
                    this.updateTimingInfoEnd_(segmentInfo);
                    this.syncController_.saveSegmentTimingInfo({
                        segmentInfo,
                        shouldSaveTimelineMapping: this.loaderType_ === "main"
                    });
                    const next = this.chooseNextRequest_();
                    if (next.mediaIndex !== segmentInfo.mediaIndex || next.partIndex !== segmentInfo.partIndex) {
                        this.logger_("sync segment was incorrect, not appending");
                        return;
                    }
                    this.logger_("sync segment was correct, appending");
                }
                segmentInfo.hasAppendedData_ = true;
                this.processMetadataQueue_();
                this.appendData_(segmentInfo, result);
            }
            updateAppendInitSegmentStatus(segmentInfo, type) {
                if (this.loaderType_ === "main" && typeof segmentInfo.timestampOffset === "number" && !segmentInfo.changedTimestampOffset) this.appendInitSegment_ = {
                    audio: true,
                    video: true
                };
                if (this.playlistOfLastInitSegment_[type] !== segmentInfo.playlist) this.appendInitSegment_[type] = true;
            }
            getInitSegmentAndUpdateState_({type, initSegment, map, playlist}) {
                if (map) {
                    const id = initSegmentId(map);
                    if (this.activeInitSegmentId_ === id) return null;
                    initSegment = this.initSegmentForMap(map, true).bytes;
                    this.activeInitSegmentId_ = id;
                }
                if (initSegment && this.appendInitSegment_[type]) {
                    this.playlistOfLastInitSegment_[type] = playlist;
                    this.appendInitSegment_[type] = false;
                    this.activeInitSegmentId_ = null;
                    return initSegment;
                }
                return null;
            }
            handleQuotaExceededError_({segmentInfo, type, bytes}, error) {
                const audioBuffered = this.sourceUpdater_.audioBuffered();
                const videoBuffered = this.sourceUpdater_.videoBuffered();
                if (audioBuffered.length > 1) this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the audio buffer: " + timeRangesToArray(audioBuffered).join(", "));
                if (videoBuffered.length > 1) this.logger_("On QUOTA_EXCEEDED_ERR, found gaps in the video buffer: " + timeRangesToArray(videoBuffered).join(", "));
                const audioBufferStart = audioBuffered.length ? audioBuffered.start(0) : 0;
                const audioBufferEnd = audioBuffered.length ? audioBuffered.end(audioBuffered.length - 1) : 0;
                const videoBufferStart = videoBuffered.length ? videoBuffered.start(0) : 0;
                const videoBufferEnd = videoBuffered.length ? videoBuffered.end(videoBuffered.length - 1) : 0;
                if (audioBufferEnd - audioBufferStart <= MIN_BACK_BUFFER && videoBufferEnd - videoBufferStart <= MIN_BACK_BUFFER) {
                    this.logger_("On QUOTA_EXCEEDED_ERR, single segment too large to append to " + "buffer, triggering an error. " + `Appended byte length: ${bytes.byteLength}, ` + `audio buffer: ${timeRangesToArray(audioBuffered).join(", ")}, ` + `video buffer: ${timeRangesToArray(videoBuffered).join(", ")}, `);
                    this.error({
                        message: "Quota exceeded error with append of a single segment of content",
                        excludeUntil: 1 / 0
                    });
                    this.trigger("error");
                    return;
                }
                this.waitingOnRemove_ = true;
                this.callQueue_.push(this.appendToSourceBuffer_.bind(this, {
                    segmentInfo,
                    type,
                    bytes
                }));
                const currentTime = this.currentTime_();
                const timeToRemoveUntil = currentTime - MIN_BACK_BUFFER;
                this.logger_(`On QUOTA_EXCEEDED_ERR, removing audio/video from 0 to ${timeToRemoveUntil}`);
                this.remove(0, timeToRemoveUntil, (() => {
                    this.logger_(`On QUOTA_EXCEEDED_ERR, retrying append in ${MIN_BACK_BUFFER}s`);
                    this.waitingOnRemove_ = false;
                    this.quotaExceededErrorRetryTimeout_ = window_default().setTimeout((() => {
                        this.logger_("On QUOTA_EXCEEDED_ERR, re-processing call queue");
                        this.quotaExceededErrorRetryTimeout_ = null;
                        this.processCallQueue_();
                    }), MIN_BACK_BUFFER * 1e3);
                }), true);
            }
            handleAppendError_({segmentInfo, type, bytes}, error) {
                if (!error) return;
                if (error.code === QUOTA_EXCEEDED_ERR) {
                    this.handleQuotaExceededError_({
                        segmentInfo,
                        type,
                        bytes
                    });
                    return;
                }
                this.logger_("Received non QUOTA_EXCEEDED_ERR on append", error);
                this.error(`${type} append of ${bytes.length}b failed for segment ` + `#${segmentInfo.mediaIndex} in playlist ${segmentInfo.playlist.id}`);
                this.trigger("appenderror");
            }
            appendToSourceBuffer_({segmentInfo, type, initSegment, data, bytes}) {
                if (!bytes) {
                    const segments = [ data ];
                    let byteLength = data.byteLength;
                    if (initSegment) {
                        segments.unshift(initSegment);
                        byteLength += initSegment.byteLength;
                    }
                    bytes = concatSegments({
                        bytes: byteLength,
                        segments
                    });
                }
                this.sourceUpdater_.appendBuffer({
                    segmentInfo,
                    type,
                    bytes
                }, this.handleAppendError_.bind(this, {
                    segmentInfo,
                    type,
                    bytes
                }));
            }
            handleSegmentTimingInfo_(type, requestId, segmentTimingInfo) {
                if (!this.pendingSegment_ || requestId !== this.pendingSegment_.requestId) return;
                const segment = this.pendingSegment_.segment;
                const timingInfoProperty = `${type}TimingInfo`;
                if (!segment[timingInfoProperty]) segment[timingInfoProperty] = {};
                segment[timingInfoProperty].transmuxerPrependedSeconds = segmentTimingInfo.prependedContentDuration || 0;
                segment[timingInfoProperty].transmuxedPresentationStart = segmentTimingInfo.start.presentation;
                segment[timingInfoProperty].transmuxedDecodeStart = segmentTimingInfo.start.decode;
                segment[timingInfoProperty].transmuxedPresentationEnd = segmentTimingInfo.end.presentation;
                segment[timingInfoProperty].transmuxedDecodeEnd = segmentTimingInfo.end.decode;
                segment[timingInfoProperty].baseMediaDecodeTime = segmentTimingInfo.baseMediaDecodeTime;
            }
            appendData_(segmentInfo, result) {
                const {type, data} = result;
                if (!data || !data.byteLength) return;
                if (type === "audio" && this.audioDisabled_) return;
                const initSegment = this.getInitSegmentAndUpdateState_({
                    type,
                    initSegment: result.initSegment,
                    playlist: segmentInfo.playlist,
                    map: segmentInfo.isFmp4 ? segmentInfo.segment.map : null
                });
                this.appendToSourceBuffer_({
                    segmentInfo,
                    type,
                    initSegment,
                    data
                });
            }
            loadSegment_(segmentInfo) {
                this.state = "WAITING";
                this.pendingSegment_ = segmentInfo;
                this.trimBackBuffer_(segmentInfo);
                if (typeof segmentInfo.timestampOffset === "number") if (this.transmuxer_) this.transmuxer_.postMessage({
                    action: "clearAllMp4Captions"
                });
                if (!this.hasEnoughInfoToLoad_()) {
                    this.loadQueue_.push((() => {
                        const options = _extends({}, segmentInfo, {
                            forceTimestampOffset: true
                        });
                        _extends(segmentInfo, this.generateSegmentInfo_(options));
                        this.isPendingTimestampOffset_ = false;
                        this.updateTransmuxerAndRequestSegment_(segmentInfo);
                    }));
                    return;
                }
                this.updateTransmuxerAndRequestSegment_(segmentInfo);
            }
            updateTransmuxerAndRequestSegment_(segmentInfo) {
                if (this.shouldUpdateTransmuxerTimestampOffset_(segmentInfo.timestampOffset)) {
                    this.gopBuffer_.length = 0;
                    segmentInfo.gopsToAlignWith = [];
                    this.timeMapping_ = 0;
                    this.transmuxer_.postMessage({
                        action: "reset"
                    });
                    this.transmuxer_.postMessage({
                        action: "setTimestampOffset",
                        timestampOffset: segmentInfo.timestampOffset
                    });
                }
                const simpleSegment = this.createSimplifiedSegmentObj_(segmentInfo);
                const isEndOfStream = this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex);
                const isWalkingForward = this.mediaIndex !== null;
                const isDiscontinuity = segmentInfo.timeline !== this.currentTimeline_ && segmentInfo.timeline > 0;
                const isEndOfTimeline = isEndOfStream || isWalkingForward && isDiscontinuity;
                this.logger_(`Requesting ${segmentInfoString(segmentInfo)}`);
                if (simpleSegment.map && !simpleSegment.map.bytes) {
                    this.logger_("going to request init segment.");
                    this.appendInitSegment_ = {
                        video: true,
                        audio: true
                    };
                }
                segmentInfo.abortRequests = mediaSegmentRequest({
                    xhr: this.vhs_.xhr,
                    xhrOptions: this.xhrOptions_,
                    decryptionWorker: this.decrypter_,
                    segment: simpleSegment,
                    abortFn: this.handleAbort_.bind(this, segmentInfo),
                    progressFn: this.handleProgress_.bind(this),
                    trackInfoFn: this.handleTrackInfo_.bind(this),
                    timingInfoFn: this.handleTimingInfo_.bind(this),
                    videoSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "video", segmentInfo.requestId),
                    audioSegmentTimingInfoFn: this.handleSegmentTimingInfo_.bind(this, "audio", segmentInfo.requestId),
                    captionsFn: this.handleCaptions_.bind(this),
                    isEndOfTimeline,
                    endedTimelineFn: () => {
                        this.logger_("received endedtimeline callback");
                    },
                    id3Fn: this.handleId3_.bind(this),
                    dataFn: this.handleData_.bind(this),
                    doneFn: this.segmentRequestFinished_.bind(this),
                    onTransmuxerLog: ({message, level, stream}) => {
                        this.logger_(`${segmentInfoString(segmentInfo)} logged from transmuxer stream ${stream} as a ${level}: ${message}`);
                    }
                });
            }
            trimBackBuffer_(segmentInfo) {
                const removeToTime = safeBackBufferTrimTime(this.seekable_(), this.currentTime_(), this.playlist_.targetDuration || 10);
                if (removeToTime > 0) this.remove(0, removeToTime);
            }
            createSimplifiedSegmentObj_(segmentInfo) {
                const segment = segmentInfo.segment;
                const part = segmentInfo.part;
                const simpleSegment = {
                    resolvedUri: part ? part.resolvedUri : segment.resolvedUri,
                    byterange: part ? part.byterange : segment.byterange,
                    requestId: segmentInfo.requestId,
                    transmuxer: segmentInfo.transmuxer,
                    audioAppendStart: segmentInfo.audioAppendStart,
                    gopsToAlignWith: segmentInfo.gopsToAlignWith,
                    part: segmentInfo.part
                };
                const previousSegment = segmentInfo.playlist.segments[segmentInfo.mediaIndex - 1];
                if (previousSegment && previousSegment.timeline === segment.timeline) if (previousSegment.videoTimingInfo) simpleSegment.baseStartTime = previousSegment.videoTimingInfo.transmuxedDecodeEnd; else if (previousSegment.audioTimingInfo) simpleSegment.baseStartTime = previousSegment.audioTimingInfo.transmuxedDecodeEnd;
                if (segment.key) {
                    const iv = segment.key.iv || new Uint32Array([ 0, 0, 0, segmentInfo.mediaIndex + segmentInfo.playlist.mediaSequence ]);
                    simpleSegment.key = this.segmentKey(segment.key);
                    simpleSegment.key.iv = iv;
                }
                if (segment.map) simpleSegment.map = this.initSegmentForMap(segment.map);
                return simpleSegment;
            }
            saveTransferStats_(stats) {
                this.mediaRequests += 1;
                if (stats) {
                    this.mediaBytesTransferred += stats.bytesReceived;
                    this.mediaTransferDuration += stats.roundTripTime;
                }
            }
            saveBandwidthRelatedStats_(duration, stats) {
                this.pendingSegment_.byteLength = stats.bytesReceived;
                if (duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
                    this.logger_(`Ignoring segment's bandwidth because its duration of ${duration}` + ` is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);
                    return;
                }
                this.bandwidth = stats.bandwidth;
                this.roundTrip = stats.roundTripTime;
            }
            handleTimeout_() {
                this.mediaRequestsTimedout += 1;
                this.bandwidth = 1;
                this.roundTrip = NaN;
                this.trigger("bandwidthupdate");
                this.trigger("timeout");
            }
            segmentRequestFinished_(error, simpleSegment, result) {
                if (this.callQueue_.length) {
                    this.callQueue_.push(this.segmentRequestFinished_.bind(this, error, simpleSegment, result));
                    return;
                }
                this.saveTransferStats_(simpleSegment.stats);
                if (!this.pendingSegment_) return;
                if (simpleSegment.requestId !== this.pendingSegment_.requestId) return;
                if (error) {
                    this.pendingSegment_ = null;
                    this.state = "READY";
                    if (error.code === REQUEST_ERRORS.ABORTED) return;
                    this.pause();
                    if (error.code === REQUEST_ERRORS.TIMEOUT) {
                        this.handleTimeout_();
                        return;
                    }
                    this.mediaRequestsErrored += 1;
                    this.error(error);
                    this.trigger("error");
                    return;
                }
                const segmentInfo = this.pendingSegment_;
                this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
                segmentInfo.endOfAllRequests = simpleSegment.endOfAllRequests;
                if (result.gopInfo) this.gopBuffer_ = updateGopBuffer(this.gopBuffer_, result.gopInfo, this.safeAppend_);
                this.state = "APPENDING";
                this.trigger("appending");
                this.waitForAppendsToComplete_(segmentInfo);
            }
            setTimeMapping_(timeline) {
                const timelineMapping = this.syncController_.mappingForTimeline(timeline);
                if (timelineMapping !== null) this.timeMapping_ = timelineMapping;
            }
            updateMediaSecondsLoaded_(segment) {
                if (typeof segment.start === "number" && typeof segment.end === "number") this.mediaSecondsLoaded += segment.end - segment.start; else this.mediaSecondsLoaded += segment.duration;
            }
            shouldUpdateTransmuxerTimestampOffset_(timestampOffset) {
                if (timestampOffset === null) return false;
                if (this.loaderType_ === "main" && timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) return true;
                if (!this.audioDisabled_ && timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) return true;
                return false;
            }
            trueSegmentStart_({currentStart, playlist, mediaIndex, firstVideoFrameTimeForData, currentVideoTimestampOffset, useVideoTimingInfo, videoTimingInfo, audioTimingInfo}) {
                if (typeof currentStart !== "undefined") return currentStart;
                if (!useVideoTimingInfo) return audioTimingInfo.start;
                const previousSegment = playlist.segments[mediaIndex - 1];
                if (mediaIndex === 0 || !previousSegment || typeof previousSegment.start === "undefined" || previousSegment.end !== firstVideoFrameTimeForData + currentVideoTimestampOffset) return firstVideoFrameTimeForData;
                return videoTimingInfo.start;
            }
            waitForAppendsToComplete_(segmentInfo) {
                const trackInfo = this.getCurrentMediaInfo_(segmentInfo);
                if (!trackInfo) {
                    this.error({
                        message: "No starting media returned, likely due to an unsupported media format.",
                        playlistExclusionDuration: 1 / 0
                    });
                    this.trigger("error");
                    return;
                }
                const {hasAudio, hasVideo, isMuxed} = trackInfo;
                const waitForVideo = this.loaderType_ === "main" && hasVideo;
                const waitForAudio = !this.audioDisabled_ && hasAudio && !isMuxed;
                segmentInfo.waitingOnAppends = 0;
                if (!segmentInfo.hasAppendedData_) {
                    if (!segmentInfo.timingInfo && typeof segmentInfo.timestampOffset === "number") this.isPendingTimestampOffset_ = true;
                    segmentInfo.timingInfo = {
                        start: 0
                    };
                    segmentInfo.waitingOnAppends++;
                    if (!this.isPendingTimestampOffset_) {
                        this.updateSourceBufferTimestampOffset_(segmentInfo);
                        this.processMetadataQueue_();
                    }
                    this.checkAppendsDone_(segmentInfo);
                    return;
                }
                if (waitForVideo) segmentInfo.waitingOnAppends++;
                if (waitForAudio) segmentInfo.waitingOnAppends++;
                if (waitForVideo) this.sourceUpdater_.videoQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
                if (waitForAudio) this.sourceUpdater_.audioQueueCallback(this.checkAppendsDone_.bind(this, segmentInfo));
            }
            checkAppendsDone_(segmentInfo) {
                if (this.checkForAbort_(segmentInfo.requestId)) return;
                segmentInfo.waitingOnAppends--;
                if (segmentInfo.waitingOnAppends === 0) this.handleAppendsDone_();
            }
            checkForIllegalMediaSwitch(trackInfo) {
                const illegalMediaSwitchError = illegalMediaSwitch(this.loaderType_, this.getCurrentMediaInfo_(), trackInfo);
                if (illegalMediaSwitchError) {
                    this.error({
                        message: illegalMediaSwitchError,
                        playlistExclusionDuration: 1 / 0
                    });
                    this.trigger("error");
                    return true;
                }
                return false;
            }
            updateSourceBufferTimestampOffset_(segmentInfo) {
                if (segmentInfo.timestampOffset === null || typeof segmentInfo.timingInfo.start !== "number" || segmentInfo.changedTimestampOffset || this.loaderType_ !== "main") return;
                let didChange = false;
                segmentInfo.timestampOffset -= this.getSegmentStartTimeForTimestampOffsetCalculation_({
                    videoTimingInfo: segmentInfo.segment.videoTimingInfo,
                    audioTimingInfo: segmentInfo.segment.audioTimingInfo,
                    timingInfo: segmentInfo.timingInfo
                });
                segmentInfo.changedTimestampOffset = true;
                if (segmentInfo.timestampOffset !== this.sourceUpdater_.videoTimestampOffset()) {
                    this.sourceUpdater_.videoTimestampOffset(segmentInfo.timestampOffset);
                    didChange = true;
                }
                if (segmentInfo.timestampOffset !== this.sourceUpdater_.audioTimestampOffset()) {
                    this.sourceUpdater_.audioTimestampOffset(segmentInfo.timestampOffset);
                    didChange = true;
                }
                if (didChange) this.trigger("timestampoffset");
            }
            getSegmentStartTimeForTimestampOffsetCalculation_({videoTimingInfo, audioTimingInfo, timingInfo}) {
                if (!this.useDtsForTimestampOffset_) return timingInfo.start;
                if (videoTimingInfo && typeof videoTimingInfo.transmuxedDecodeStart === "number") return videoTimingInfo.transmuxedDecodeStart;
                if (audioTimingInfo && typeof audioTimingInfo.transmuxedDecodeStart === "number") return audioTimingInfo.transmuxedDecodeStart;
                return timingInfo.start;
            }
            updateTimingInfoEnd_(segmentInfo) {
                segmentInfo.timingInfo = segmentInfo.timingInfo || {};
                const trackInfo = this.getMediaInfo_();
                const useVideoTimingInfo = this.loaderType_ === "main" && trackInfo && trackInfo.hasVideo;
                const prioritizedTimingInfo = useVideoTimingInfo && segmentInfo.videoTimingInfo ? segmentInfo.videoTimingInfo : segmentInfo.audioTimingInfo;
                if (!prioritizedTimingInfo) return;
                segmentInfo.timingInfo.end = typeof prioritizedTimingInfo.end === "number" ? prioritizedTimingInfo.end : prioritizedTimingInfo.start + segmentInfo.duration;
            }
            handleAppendsDone_() {
                if (this.pendingSegment_) this.trigger("appendsdone");
                if (!this.pendingSegment_) {
                    this.state = "READY";
                    if (!this.paused()) this.monitorBuffer_();
                    return;
                }
                const segmentInfo = this.pendingSegment_;
                this.updateTimingInfoEnd_(segmentInfo);
                if (this.shouldSaveSegmentTimingInfo_) this.syncController_.saveSegmentTimingInfo({
                    segmentInfo,
                    shouldSaveTimelineMapping: this.loaderType_ === "main"
                });
                const segmentDurationMessage = getTroublesomeSegmentDurationMessage(segmentInfo, this.sourceType_);
                if (segmentDurationMessage) if (segmentDurationMessage.severity === "warn") videojs.log.warn(segmentDurationMessage.message); else this.logger_(segmentDurationMessage.message);
                this.recordThroughput_(segmentInfo);
                this.pendingSegment_ = null;
                this.state = "READY";
                if (segmentInfo.isSyncRequest) {
                    this.trigger("syncinfoupdate");
                    if (!segmentInfo.hasAppendedData_) {
                        this.logger_(`Throwing away un-appended sync request ${segmentInfoString(segmentInfo)}`);
                        return;
                    }
                }
                this.logger_(`Appended ${segmentInfoString(segmentInfo)}`);
                this.addSegmentMetadataCue_(segmentInfo);
                this.fetchAtBuffer_ = true;
                if (this.currentTimeline_ !== segmentInfo.timeline) {
                    this.timelineChangeController_.lastTimelineChange({
                        type: this.loaderType_,
                        from: this.currentTimeline_,
                        to: segmentInfo.timeline
                    });
                    if (this.loaderType_ === "main" && !this.audioDisabled_) this.timelineChangeController_.lastTimelineChange({
                        type: "audio",
                        from: this.currentTimeline_,
                        to: segmentInfo.timeline
                    });
                }
                this.currentTimeline_ = segmentInfo.timeline;
                this.trigger("syncinfoupdate");
                const segment = segmentInfo.segment;
                const part = segmentInfo.part;
                const badSegmentGuess = segment.end && this.currentTime_() - segment.end > segmentInfo.playlist.targetDuration * 3;
                const badPartGuess = part && part.end && this.currentTime_() - part.end > segmentInfo.playlist.partTargetDuration * 3;
                if (badSegmentGuess || badPartGuess) {
                    this.logger_(`bad ${badSegmentGuess ? "segment" : "part"} ${segmentInfoString(segmentInfo)}`);
                    this.resetEverything();
                    return;
                }
                const isWalkingForward = this.mediaIndex !== null;
                if (isWalkingForward) this.trigger("bandwidthupdate");
                this.trigger("progress");
                this.mediaIndex = segmentInfo.mediaIndex;
                this.partIndex = segmentInfo.partIndex;
                if (this.isEndOfStream_(segmentInfo.mediaIndex, segmentInfo.playlist, segmentInfo.partIndex)) this.endOfStream();
                this.trigger("appended");
                if (segmentInfo.hasAppendedData_) this.mediaAppends++;
                if (!this.paused()) this.monitorBuffer_();
            }
            recordThroughput_(segmentInfo) {
                if (segmentInfo.duration < MIN_SEGMENT_DURATION_TO_SAVE_STATS) {
                    this.logger_(`Ignoring segment's throughput because its duration of ${segmentInfo.duration}` + ` is less than the min to record ${MIN_SEGMENT_DURATION_TO_SAVE_STATS}`);
                    return;
                }
                const rate = this.throughput.rate;
                const segmentProcessingTime = Date.now() - segmentInfo.endOfAllRequests + 1;
                const segmentProcessingThroughput = Math.floor(segmentInfo.byteLength / segmentProcessingTime * 8 * 1e3);
                this.throughput.rate += (segmentProcessingThroughput - rate) / ++this.throughput.count;
            }
            addSegmentMetadataCue_(segmentInfo) {
                if (!this.segmentMetadataTrack_) return;
                const segment = segmentInfo.segment;
                const start = segment.start;
                const end = segment.end;
                if (!finite(start) || !finite(end)) return;
                removeCuesFromTrack(start, end, this.segmentMetadataTrack_);
                const Cue = window_default().WebKitDataCue || window_default().VTTCue;
                const value = {
                    custom: segment.custom,
                    dateTimeObject: segment.dateTimeObject,
                    dateTimeString: segment.dateTimeString,
                    bandwidth: segmentInfo.playlist.attributes.BANDWIDTH,
                    resolution: segmentInfo.playlist.attributes.RESOLUTION,
                    codecs: segmentInfo.playlist.attributes.CODECS,
                    byteLength: segmentInfo.byteLength,
                    uri: segmentInfo.uri,
                    timeline: segmentInfo.timeline,
                    playlist: segmentInfo.playlist.id,
                    start,
                    end
                };
                const data = JSON.stringify(value);
                const cue = new Cue(start, end, data);
                cue.value = value;
                this.segmentMetadataTrack_.addCue(cue);
            }
        }
        function noop() {}
        const toTitleCase = function(string) {
            if (typeof string !== "string") return string;
            return string.replace(/./, (w => w.toUpperCase()));
        };
        const bufferTypes = [ "video", "audio" ];
        const updating = (type, sourceUpdater) => {
            const sourceBuffer = sourceUpdater[`${type}Buffer`];
            return sourceBuffer && sourceBuffer.updating || sourceUpdater.queuePending[type];
        };
        const nextQueueIndexOfType = (type, queue) => {
            for (let i = 0; i < queue.length; i++) {
                const queueEntry = queue[i];
                if (queueEntry.type === "mediaSource") return null;
                if (queueEntry.type === type) return i;
            }
            return null;
        };
        const shiftQueue = (type, sourceUpdater) => {
            if (sourceUpdater.queue.length === 0) return;
            let queueIndex = 0;
            let queueEntry = sourceUpdater.queue[queueIndex];
            if (queueEntry.type === "mediaSource") {
                if (!sourceUpdater.updating() && sourceUpdater.mediaSource.readyState !== "closed") {
                    sourceUpdater.queue.shift();
                    queueEntry.action(sourceUpdater);
                    if (queueEntry.doneFn) queueEntry.doneFn();
                    shiftQueue("audio", sourceUpdater);
                    shiftQueue("video", sourceUpdater);
                }
                return;
            }
            if (type === "mediaSource") return;
            if (!sourceUpdater.ready() || sourceUpdater.mediaSource.readyState === "closed" || updating(type, sourceUpdater)) return;
            if (queueEntry.type !== type) {
                queueIndex = nextQueueIndexOfType(type, sourceUpdater.queue);
                if (queueIndex === null) return;
                queueEntry = sourceUpdater.queue[queueIndex];
            }
            sourceUpdater.queue.splice(queueIndex, 1);
            sourceUpdater.queuePending[type] = queueEntry;
            queueEntry.action(type, sourceUpdater);
            if (!queueEntry.doneFn) {
                sourceUpdater.queuePending[type] = null;
                shiftQueue(type, sourceUpdater);
                return;
            }
        };
        const cleanupBuffer = (type, sourceUpdater) => {
            const buffer = sourceUpdater[`${type}Buffer`];
            const titleType = toTitleCase(type);
            if (!buffer) return;
            buffer.removeEventListener("updateend", sourceUpdater[`on${titleType}UpdateEnd_`]);
            buffer.removeEventListener("error", sourceUpdater[`on${titleType}Error_`]);
            sourceUpdater.codecs[type] = null;
            sourceUpdater[`${type}Buffer`] = null;
        };
        const inSourceBuffers = (mediaSource, sourceBuffer) => mediaSource && sourceBuffer && Array.prototype.indexOf.call(mediaSource.sourceBuffers, sourceBuffer) !== -1;
        const actions = {
            appendBuffer: (bytes, segmentInfo, onError) => (type, sourceUpdater) => {
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                sourceUpdater.logger_(`Appending segment ${segmentInfo.mediaIndex}'s ${bytes.length} bytes to ${type}Buffer`);
                try {
                    sourceBuffer.appendBuffer(bytes);
                } catch (e) {
                    sourceUpdater.logger_(`Error with code ${e.code} ` + (e.code === QUOTA_EXCEEDED_ERR ? "(QUOTA_EXCEEDED_ERR) " : "") + `when appending segment ${segmentInfo.mediaIndex} to ${type}Buffer`);
                    sourceUpdater.queuePending[type] = null;
                    onError(e);
                }
            },
            remove: (start, end) => (type, sourceUpdater) => {
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                sourceUpdater.logger_(`Removing ${start} to ${end} from ${type}Buffer`);
                try {
                    sourceBuffer.remove(start, end);
                } catch (e) {
                    sourceUpdater.logger_(`Remove ${start} to ${end} from ${type}Buffer failed`);
                }
            },
            timestampOffset: offset => (type, sourceUpdater) => {
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                sourceUpdater.logger_(`Setting ${type}timestampOffset to ${offset}`);
                sourceBuffer.timestampOffset = offset;
            },
            callback: callback => (type, sourceUpdater) => {
                callback();
            },
            endOfStream: error => sourceUpdater => {
                if (sourceUpdater.mediaSource.readyState !== "open") return;
                sourceUpdater.logger_(`Calling mediaSource endOfStream(${error || ""})`);
                try {
                    sourceUpdater.mediaSource.endOfStream(error);
                } catch (e) {
                    videojs.log.warn("Failed to call media source endOfStream", e);
                }
            },
            duration: duration => sourceUpdater => {
                sourceUpdater.logger_(`Setting mediaSource duration to ${duration}`);
                try {
                    sourceUpdater.mediaSource.duration = duration;
                } catch (e) {
                    videojs.log.warn("Failed to set media source duration", e);
                }
            },
            abort: () => (type, sourceUpdater) => {
                if (sourceUpdater.mediaSource.readyState !== "open") return;
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                sourceUpdater.logger_(`calling abort on ${type}Buffer`);
                try {
                    sourceBuffer.abort();
                } catch (e) {
                    videojs.log.warn(`Failed to abort on ${type}Buffer`, e);
                }
            },
            addSourceBuffer: (type, codec) => sourceUpdater => {
                const titleType = toTitleCase(type);
                const mime = getMimeForCodec(codec);
                sourceUpdater.logger_(`Adding ${type}Buffer with codec ${codec} to mediaSource`);
                const sourceBuffer = sourceUpdater.mediaSource.addSourceBuffer(mime);
                sourceBuffer.addEventListener("updateend", sourceUpdater[`on${titleType}UpdateEnd_`]);
                sourceBuffer.addEventListener("error", sourceUpdater[`on${titleType}Error_`]);
                sourceUpdater.codecs[type] = codec;
                sourceUpdater[`${type}Buffer`] = sourceBuffer;
            },
            removeSourceBuffer: type => sourceUpdater => {
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                cleanupBuffer(type, sourceUpdater);
                if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                sourceUpdater.logger_(`Removing ${type}Buffer with codec ${sourceUpdater.codecs[type]} from mediaSource`);
                try {
                    sourceUpdater.mediaSource.removeSourceBuffer(sourceBuffer);
                } catch (e) {
                    videojs.log.warn(`Failed to removeSourceBuffer ${type}Buffer`, e);
                }
            },
            changeType: codec => (type, sourceUpdater) => {
                const sourceBuffer = sourceUpdater[`${type}Buffer`];
                const mime = getMimeForCodec(codec);
                if (!inSourceBuffers(sourceUpdater.mediaSource, sourceBuffer)) return;
                if (sourceUpdater.codecs[type] === codec) return;
                sourceUpdater.logger_(`changing ${type}Buffer codec from ${sourceUpdater.codecs[type]} to ${codec}`);
                sourceBuffer.changeType(mime);
                sourceUpdater.codecs[type] = codec;
            }
        };
        const pushQueue = ({type, sourceUpdater, action, doneFn, name}) => {
            sourceUpdater.queue.push({
                type,
                action,
                doneFn,
                name
            });
            shiftQueue(type, sourceUpdater);
        };
        const onUpdateend = (type, sourceUpdater) => e => {
            if (sourceUpdater.queuePending[type]) {
                const doneFn = sourceUpdater.queuePending[type].doneFn;
                sourceUpdater.queuePending[type] = null;
                if (doneFn) doneFn(sourceUpdater[`${type}Error_`]);
            }
            shiftQueue(type, sourceUpdater);
        };
        class SourceUpdater extends videojs.EventTarget {
            constructor(mediaSource) {
                super();
                this.mediaSource = mediaSource;
                this.sourceopenListener_ = () => shiftQueue("mediaSource", this);
                this.mediaSource.addEventListener("sourceopen", this.sourceopenListener_);
                this.logger_ = logger("SourceUpdater");
                this.audioTimestampOffset_ = 0;
                this.videoTimestampOffset_ = 0;
                this.queue = [];
                this.queuePending = {
                    audio: null,
                    video: null
                };
                this.delayedAudioAppendQueue_ = [];
                this.videoAppendQueued_ = false;
                this.codecs = {};
                this.onVideoUpdateEnd_ = onUpdateend("video", this);
                this.onAudioUpdateEnd_ = onUpdateend("audio", this);
                this.onVideoError_ = e => {
                    this.videoError_ = e;
                };
                this.onAudioError_ = e => {
                    this.audioError_ = e;
                };
                this.createdSourceBuffers_ = false;
                this.initializedEme_ = false;
                this.triggeredReady_ = false;
            }
            initializedEme() {
                this.initializedEme_ = true;
                this.triggerReady();
            }
            hasCreatedSourceBuffers() {
                return this.createdSourceBuffers_;
            }
            hasInitializedAnyEme() {
                return this.initializedEme_;
            }
            ready() {
                return this.hasCreatedSourceBuffers() && this.hasInitializedAnyEme();
            }
            createSourceBuffers(codecs) {
                if (this.hasCreatedSourceBuffers()) return;
                this.addOrChangeSourceBuffers(codecs);
                this.createdSourceBuffers_ = true;
                this.trigger("createdsourcebuffers");
                this.triggerReady();
            }
            triggerReady() {
                if (this.ready() && !this.triggeredReady_) {
                    this.triggeredReady_ = true;
                    this.trigger("ready");
                }
            }
            addSourceBuffer(type, codec) {
                pushQueue({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: actions.addSourceBuffer(type, codec),
                    name: "addSourceBuffer"
                });
            }
            abort(type) {
                pushQueue({
                    type,
                    sourceUpdater: this,
                    action: actions.abort(type),
                    name: "abort"
                });
            }
            removeSourceBuffer(type) {
                if (!this.canRemoveSourceBuffer()) {
                    videojs.log.error("removeSourceBuffer is not supported!");
                    return;
                }
                pushQueue({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: actions.removeSourceBuffer(type),
                    name: "removeSourceBuffer"
                });
            }
            canRemoveSourceBuffer() {
                return !videojs.browser.IE_VERSION && !videojs.browser.IS_FIREFOX && window_default().MediaSource && window_default().MediaSource.prototype && typeof window_default().MediaSource.prototype.removeSourceBuffer === "function";
            }
            static canChangeType() {
                return window_default().SourceBuffer && window_default().SourceBuffer.prototype && typeof window_default().SourceBuffer.prototype.changeType === "function";
            }
            canChangeType() {
                return this.constructor.canChangeType();
            }
            changeType(type, codec) {
                if (!this.canChangeType()) {
                    videojs.log.error("changeType is not supported!");
                    return;
                }
                pushQueue({
                    type,
                    sourceUpdater: this,
                    action: actions.changeType(codec),
                    name: "changeType"
                });
            }
            addOrChangeSourceBuffers(codecs) {
                if (!codecs || typeof codecs !== "object" || Object.keys(codecs).length === 0) throw new Error("Cannot addOrChangeSourceBuffers to undefined codecs");
                Object.keys(codecs).forEach((type => {
                    const codec = codecs[type];
                    if (!this.hasCreatedSourceBuffers()) return this.addSourceBuffer(type, codec);
                    if (this.canChangeType()) this.changeType(type, codec);
                }));
            }
            appendBuffer(options, doneFn) {
                const {segmentInfo, type, bytes} = options;
                this.processedAppend_ = true;
                if (type === "audio" && this.videoBuffer && !this.videoAppendQueued_) {
                    this.delayedAudioAppendQueue_.push([ options, doneFn ]);
                    this.logger_(`delayed audio append of ${bytes.length} until video append`);
                    return;
                }
                const onError = doneFn;
                pushQueue({
                    type,
                    sourceUpdater: this,
                    action: actions.appendBuffer(bytes, segmentInfo || {
                        mediaIndex: -1
                    }, onError),
                    doneFn,
                    name: "appendBuffer"
                });
                if (type === "video") {
                    this.videoAppendQueued_ = true;
                    if (!this.delayedAudioAppendQueue_.length) return;
                    const queue = this.delayedAudioAppendQueue_.slice();
                    this.logger_(`queuing delayed audio ${queue.length} appendBuffers`);
                    this.delayedAudioAppendQueue_.length = 0;
                    queue.forEach((que => {
                        this.appendBuffer.apply(this, que);
                    }));
                }
            }
            audioBuffered() {
                if (!inSourceBuffers(this.mediaSource, this.audioBuffer)) return createTimeRanges();
                return this.audioBuffer.buffered ? this.audioBuffer.buffered : createTimeRanges();
            }
            videoBuffered() {
                if (!inSourceBuffers(this.mediaSource, this.videoBuffer)) return createTimeRanges();
                return this.videoBuffer.buffered ? this.videoBuffer.buffered : createTimeRanges();
            }
            buffered() {
                const video = inSourceBuffers(this.mediaSource, this.videoBuffer) ? this.videoBuffer : null;
                const audio = inSourceBuffers(this.mediaSource, this.audioBuffer) ? this.audioBuffer : null;
                if (audio && !video) return this.audioBuffered();
                if (video && !audio) return this.videoBuffered();
                return bufferIntersection(this.audioBuffered(), this.videoBuffered());
            }
            setDuration(duration, doneFn = noop) {
                pushQueue({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: actions.duration(duration),
                    name: "duration",
                    doneFn
                });
            }
            endOfStream(error = null, doneFn = noop) {
                if (typeof error !== "string") error = void 0;
                pushQueue({
                    type: "mediaSource",
                    sourceUpdater: this,
                    action: actions.endOfStream(error),
                    name: "endOfStream",
                    doneFn
                });
            }
            removeAudio(start, end, done = noop) {
                if (!this.audioBuffered().length || this.audioBuffered().end(0) === 0) {
                    done();
                    return;
                }
                pushQueue({
                    type: "audio",
                    sourceUpdater: this,
                    action: actions.remove(start, end),
                    doneFn: done,
                    name: "remove"
                });
            }
            removeVideo(start, end, done = noop) {
                if (!this.videoBuffered().length || this.videoBuffered().end(0) === 0) {
                    done();
                    return;
                }
                pushQueue({
                    type: "video",
                    sourceUpdater: this,
                    action: actions.remove(start, end),
                    doneFn: done,
                    name: "remove"
                });
            }
            updating() {
                if (updating("audio", this) || updating("video", this)) return true;
                return false;
            }
            audioTimestampOffset(offset) {
                if (typeof offset !== "undefined" && this.audioBuffer && this.audioTimestampOffset_ !== offset) {
                    pushQueue({
                        type: "audio",
                        sourceUpdater: this,
                        action: actions.timestampOffset(offset),
                        name: "timestampOffset"
                    });
                    this.audioTimestampOffset_ = offset;
                }
                return this.audioTimestampOffset_;
            }
            videoTimestampOffset(offset) {
                if (typeof offset !== "undefined" && this.videoBuffer && this.videoTimestampOffset !== offset) {
                    pushQueue({
                        type: "video",
                        sourceUpdater: this,
                        action: actions.timestampOffset(offset),
                        name: "timestampOffset"
                    });
                    this.videoTimestampOffset_ = offset;
                }
                return this.videoTimestampOffset_;
            }
            audioQueueCallback(callback) {
                if (!this.audioBuffer) return;
                pushQueue({
                    type: "audio",
                    sourceUpdater: this,
                    action: actions.callback(callback),
                    name: "callback"
                });
            }
            videoQueueCallback(callback) {
                if (!this.videoBuffer) return;
                pushQueue({
                    type: "video",
                    sourceUpdater: this,
                    action: actions.callback(callback),
                    name: "callback"
                });
            }
            dispose() {
                this.trigger("dispose");
                bufferTypes.forEach((type => {
                    this.abort(type);
                    if (this.canRemoveSourceBuffer()) this.removeSourceBuffer(type); else this[`${type}QueueCallback`]((() => cleanupBuffer(type, this)));
                }));
                this.videoAppendQueued_ = false;
                this.delayedAudioAppendQueue_.length = 0;
                if (this.sourceopenListener_) this.mediaSource.removeEventListener("sourceopen", this.sourceopenListener_);
                this.off();
            }
        }
        const uint8ToUtf8 = uintArray => decodeURIComponent(escape(String.fromCharCode.apply(null, uintArray)));
        const VTT_LINE_TERMINATORS = new Uint8Array("\n\n".split("").map((char => char.charCodeAt(0))));
        class NoVttJsError extends Error {
            constructor() {
                super("Trying to parse received VTT cues, but there is no WebVTT. Make sure vtt.js is loaded.");
            }
        }
        class VTTSegmentLoader extends SegmentLoader {
            constructor(settings, options = {}) {
                super(settings, options);
                this.mediaSource_ = null;
                this.subtitlesTrack_ = null;
                this.loaderType_ = "subtitle";
                this.featuresNativeTextTracks_ = settings.featuresNativeTextTracks;
                this.loadVttJs = settings.loadVttJs;
                this.shouldSaveSegmentTimingInfo_ = false;
            }
            createTransmuxer_() {
                return null;
            }
            buffered_() {
                if (!this.subtitlesTrack_ || !this.subtitlesTrack_.cues || !this.subtitlesTrack_.cues.length) return createTimeRanges();
                const cues = this.subtitlesTrack_.cues;
                const start = cues[0].startTime;
                const end = cues[cues.length - 1].startTime;
                return createTimeRanges([ [ start, end ] ]);
            }
            initSegmentForMap(map, set = false) {
                if (!map) return null;
                const id = initSegmentId(map);
                let storedMap = this.initSegments_[id];
                if (set && !storedMap && map.bytes) {
                    const combinedByteLength = VTT_LINE_TERMINATORS.byteLength + map.bytes.byteLength;
                    const combinedSegment = new Uint8Array(combinedByteLength);
                    combinedSegment.set(map.bytes);
                    combinedSegment.set(VTT_LINE_TERMINATORS, map.bytes.byteLength);
                    this.initSegments_[id] = storedMap = {
                        resolvedUri: map.resolvedUri,
                        byterange: map.byterange,
                        bytes: combinedSegment
                    };
                }
                return storedMap || map;
            }
            couldBeginLoading_() {
                return this.playlist_ && this.subtitlesTrack_ && !this.paused();
            }
            init_() {
                this.state = "READY";
                this.resetEverything();
                return this.monitorBuffer_();
            }
            track(track) {
                if (typeof track === "undefined") return this.subtitlesTrack_;
                this.subtitlesTrack_ = track;
                if (this.state === "INIT" && this.couldBeginLoading_()) this.init_();
                return this.subtitlesTrack_;
            }
            remove(start, end) {
                removeCuesFromTrack(start, end, this.subtitlesTrack_);
            }
            fillBuffer_() {
                const segmentInfo = this.chooseNextRequest_();
                if (!segmentInfo) return;
                if (this.syncController_.timestampOffsetForTimeline(segmentInfo.timeline) === null) {
                    const checkTimestampOffset = () => {
                        this.state = "READY";
                        if (!this.paused()) this.monitorBuffer_();
                    };
                    this.syncController_.one("timestampoffset", checkTimestampOffset);
                    this.state = "WAITING_ON_TIMELINE";
                    return;
                }
                this.loadSegment_(segmentInfo);
            }
            timestampOffsetForSegment_() {
                return null;
            }
            chooseNextRequest_() {
                return this.skipEmptySegments_(super.chooseNextRequest_());
            }
            skipEmptySegments_(segmentInfo) {
                while (segmentInfo && segmentInfo.segment.empty) {
                    if (segmentInfo.mediaIndex + 1 >= segmentInfo.playlist.segments.length) {
                        segmentInfo = null;
                        break;
                    }
                    segmentInfo = this.generateSegmentInfo_({
                        playlist: segmentInfo.playlist,
                        mediaIndex: segmentInfo.mediaIndex + 1,
                        startOfSegment: segmentInfo.startOfSegment + segmentInfo.duration,
                        isSyncRequest: segmentInfo.isSyncRequest
                    });
                }
                return segmentInfo;
            }
            stopForError(error) {
                this.error(error);
                this.state = "READY";
                this.pause();
                this.trigger("error");
            }
            segmentRequestFinished_(error, simpleSegment, result) {
                if (!this.subtitlesTrack_) {
                    this.state = "READY";
                    return;
                }
                this.saveTransferStats_(simpleSegment.stats);
                if (!this.pendingSegment_) {
                    this.state = "READY";
                    this.mediaRequestsAborted += 1;
                    return;
                }
                if (error) {
                    if (error.code === REQUEST_ERRORS.TIMEOUT) this.handleTimeout_();
                    if (error.code === REQUEST_ERRORS.ABORTED) this.mediaRequestsAborted += 1; else this.mediaRequestsErrored += 1;
                    this.stopForError(error);
                    return;
                }
                const segmentInfo = this.pendingSegment_;
                this.saveBandwidthRelatedStats_(segmentInfo.duration, simpleSegment.stats);
                if (simpleSegment.key) this.segmentKey(simpleSegment.key, true);
                this.state = "APPENDING";
                this.trigger("appending");
                const segment = segmentInfo.segment;
                if (segment.map) segment.map.bytes = simpleSegment.map.bytes;
                segmentInfo.bytes = simpleSegment.bytes;
                if (typeof window_default().WebVTT !== "function" && typeof this.loadVttJs === "function") {
                    this.state = "WAITING_ON_VTTJS";
                    this.loadVttJs().then((() => this.segmentRequestFinished_(error, simpleSegment, result)), (() => this.stopForError({
                        message: "Error loading vtt.js"
                    })));
                    return;
                }
                segment.requested = true;
                try {
                    this.parseVTTCues_(segmentInfo);
                } catch (e) {
                    this.stopForError({
                        message: e.message
                    });
                    return;
                }
                this.updateTimeMapping_(segmentInfo, this.syncController_.timelines[segmentInfo.timeline], this.playlist_);
                if (segmentInfo.cues.length) segmentInfo.timingInfo = {
                    start: segmentInfo.cues[0].startTime,
                    end: segmentInfo.cues[segmentInfo.cues.length - 1].endTime
                }; else segmentInfo.timingInfo = {
                    start: segmentInfo.startOfSegment,
                    end: segmentInfo.startOfSegment + segmentInfo.duration
                };
                if (segmentInfo.isSyncRequest) {
                    this.trigger("syncinfoupdate");
                    this.pendingSegment_ = null;
                    this.state = "READY";
                    return;
                }
                segmentInfo.byteLength = segmentInfo.bytes.byteLength;
                this.mediaSecondsLoaded += segment.duration;
                segmentInfo.cues.forEach((cue => {
                    this.subtitlesTrack_.addCue(this.featuresNativeTextTracks_ ? new (window_default().VTTCue)(cue.startTime, cue.endTime, cue.text) : cue);
                }));
                removeDuplicateCuesFromTrack(this.subtitlesTrack_);
                this.handleAppendsDone_();
            }
            handleData_() {}
            updateTimingInfoEnd_() {}
            parseVTTCues_(segmentInfo) {
                let decoder;
                let decodeBytesToString = false;
                if (typeof window_default().WebVTT !== "function") throw new NoVttJsError;
                if (typeof window_default().TextDecoder === "function") decoder = new (window_default().TextDecoder)("utf8"); else {
                    decoder = window_default().WebVTT.StringDecoder();
                    decodeBytesToString = true;
                }
                const parser = new (window_default().WebVTT.Parser)(window_default(), window_default().vttjs, decoder);
                segmentInfo.cues = [];
                segmentInfo.timestampmap = {
                    MPEGTS: 0,
                    LOCAL: 0
                };
                parser.oncue = segmentInfo.cues.push.bind(segmentInfo.cues);
                parser.ontimestampmap = map => {
                    segmentInfo.timestampmap = map;
                };
                parser.onparsingerror = error => {
                    videojs.log.warn("Error encountered when parsing cues: " + error.message);
                };
                if (segmentInfo.segment.map) {
                    let mapData = segmentInfo.segment.map.bytes;
                    if (decodeBytesToString) mapData = uint8ToUtf8(mapData);
                    parser.parse(mapData);
                }
                let segmentData = segmentInfo.bytes;
                if (decodeBytesToString) segmentData = uint8ToUtf8(segmentData);
                parser.parse(segmentData);
                parser.flush();
            }
            updateTimeMapping_(segmentInfo, mappingObj, playlist) {
                const segment = segmentInfo.segment;
                if (!mappingObj) return;
                if (!segmentInfo.cues.length) {
                    segment.empty = true;
                    return;
                }
                const timestampmap = segmentInfo.timestampmap;
                const diff = timestampmap.MPEGTS / clock.ONE_SECOND_IN_TS - timestampmap.LOCAL + mappingObj.mapping;
                segmentInfo.cues.forEach((cue => {
                    cue.startTime += diff;
                    cue.endTime += diff;
                }));
                if (!playlist.syncInfo) {
                    const firstStart = segmentInfo.cues[0].startTime;
                    const lastStart = segmentInfo.cues[segmentInfo.cues.length - 1].startTime;
                    playlist.syncInfo = {
                        mediaSequence: playlist.mediaSequence + segmentInfo.mediaIndex,
                        time: Math.min(firstStart, lastStart - segment.duration)
                    };
                }
            }
        }
        const findAdCue = function(track, mediaTime) {
            const cues = track.cues;
            for (let i = 0; i < cues.length; i++) {
                const cue = cues[i];
                if (mediaTime >= cue.adStartTime && mediaTime <= cue.adEndTime) return cue;
            }
            return null;
        };
        const updateAdCues = function(media, track, offset = 0) {
            if (!media.segments) return;
            let mediaTime = offset;
            let cue;
            for (let i = 0; i < media.segments.length; i++) {
                const segment = media.segments[i];
                if (!cue) cue = findAdCue(track, mediaTime + segment.duration / 2);
                if (cue) {
                    if ("cueIn" in segment) {
                        cue.endTime = mediaTime;
                        cue.adEndTime = mediaTime;
                        mediaTime += segment.duration;
                        cue = null;
                        continue;
                    }
                    if (mediaTime < cue.endTime) {
                        mediaTime += segment.duration;
                        continue;
                    }
                    cue.endTime += segment.duration;
                } else {
                    if ("cueOut" in segment) {
                        cue = new (window_default().VTTCue)(mediaTime, mediaTime + segment.duration, segment.cueOut);
                        cue.adStartTime = mediaTime;
                        cue.adEndTime = mediaTime + parseFloat(segment.cueOut);
                        track.addCue(cue);
                    }
                    if ("cueOutCont" in segment) {
                        const [adOffset, adTotal] = segment.cueOutCont.split("/").map(parseFloat);
                        cue = new (window_default().VTTCue)(mediaTime, mediaTime + segment.duration, "");
                        cue.adStartTime = mediaTime - adOffset;
                        cue.adEndTime = cue.adStartTime + adTotal;
                        track.addCue(cue);
                    }
                }
                mediaTime += segment.duration;
            }
        };
        const MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC = 86400;
        const syncPointStrategies = [ {
            name: "VOD",
            run: (syncController, playlist, duration, currentTimeline, currentTime) => {
                if (duration !== 1 / 0) {
                    const syncPoint = {
                        time: 0,
                        segmentIndex: 0,
                        partIndex: null
                    };
                    return syncPoint;
                }
                return null;
            }
        }, {
            name: "ProgramDateTime",
            run: (syncController, playlist, duration, currentTimeline, currentTime) => {
                if (!Object.keys(syncController.timelineToDatetimeMappings).length) return null;
                let syncPoint = null;
                let lastDistance = null;
                const partsAndSegments = getPartsAndSegments(playlist);
                currentTime = currentTime || 0;
                for (let i = 0; i < partsAndSegments.length; i++) {
                    const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
                    const partAndSegment = partsAndSegments[index];
                    const segment = partAndSegment.segment;
                    const datetimeMapping = syncController.timelineToDatetimeMappings[segment.timeline];
                    if (!datetimeMapping || !segment.dateTimeObject) continue;
                    const segmentTime = segment.dateTimeObject.getTime() / 1e3;
                    let start = segmentTime + datetimeMapping;
                    if (segment.parts && typeof partAndSegment.partIndex === "number") for (let z = 0; z < partAndSegment.partIndex; z++) start += segment.parts[z].duration;
                    const distance = Math.abs(currentTime - start);
                    if (lastDistance !== null && (distance === 0 || lastDistance < distance)) break;
                    lastDistance = distance;
                    syncPoint = {
                        time: start,
                        segmentIndex: partAndSegment.segmentIndex,
                        partIndex: partAndSegment.partIndex
                    };
                }
                return syncPoint;
            }
        }, {
            name: "Segment",
            run: (syncController, playlist, duration, currentTimeline, currentTime) => {
                let syncPoint = null;
                let lastDistance = null;
                currentTime = currentTime || 0;
                const partsAndSegments = getPartsAndSegments(playlist);
                for (let i = 0; i < partsAndSegments.length; i++) {
                    const index = playlist.endList || currentTime === 0 ? i : partsAndSegments.length - (i + 1);
                    const partAndSegment = partsAndSegments[index];
                    const segment = partAndSegment.segment;
                    const start = partAndSegment.part && partAndSegment.part.start || segment && segment.start;
                    if (segment.timeline === currentTimeline && typeof start !== "undefined") {
                        const distance = Math.abs(currentTime - start);
                        if (lastDistance !== null && lastDistance < distance) break;
                        if (!syncPoint || lastDistance === null || lastDistance >= distance) {
                            lastDistance = distance;
                            syncPoint = {
                                time: start,
                                segmentIndex: partAndSegment.segmentIndex,
                                partIndex: partAndSegment.partIndex
                            };
                        }
                    }
                }
                return syncPoint;
            }
        }, {
            name: "Discontinuity",
            run: (syncController, playlist, duration, currentTimeline, currentTime) => {
                let syncPoint = null;
                currentTime = currentTime || 0;
                if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) {
                    let lastDistance = null;
                    for (let i = 0; i < playlist.discontinuityStarts.length; i++) {
                        const segmentIndex = playlist.discontinuityStarts[i];
                        const discontinuity = playlist.discontinuitySequence + i + 1;
                        const discontinuitySync = syncController.discontinuities[discontinuity];
                        if (discontinuitySync) {
                            const distance = Math.abs(currentTime - discontinuitySync.time);
                            if (lastDistance !== null && lastDistance < distance) break;
                            if (!syncPoint || lastDistance === null || lastDistance >= distance) {
                                lastDistance = distance;
                                syncPoint = {
                                    time: discontinuitySync.time,
                                    segmentIndex,
                                    partIndex: null
                                };
                            }
                        }
                    }
                }
                return syncPoint;
            }
        }, {
            name: "Playlist",
            run: (syncController, playlist, duration, currentTimeline, currentTime) => {
                if (playlist.syncInfo) {
                    const syncPoint = {
                        time: playlist.syncInfo.time,
                        segmentIndex: playlist.syncInfo.mediaSequence - playlist.mediaSequence,
                        partIndex: null
                    };
                    return syncPoint;
                }
                return null;
            }
        } ];
        class SyncController extends videojs.EventTarget {
            constructor(options = {}) {
                super();
                this.timelines = [];
                this.discontinuities = [];
                this.timelineToDatetimeMappings = {};
                this.logger_ = logger("SyncController");
            }
            getSyncPoint(playlist, duration, currentTimeline, currentTime) {
                const syncPoints = this.runStrategies_(playlist, duration, currentTimeline, currentTime);
                if (!syncPoints.length) return null;
                return this.selectSyncPoint_(syncPoints, {
                    key: "time",
                    value: currentTime
                });
            }
            getExpiredTime(playlist, duration) {
                if (!playlist || !playlist.segments) return null;
                const syncPoints = this.runStrategies_(playlist, duration, playlist.discontinuitySequence, 0);
                if (!syncPoints.length) return null;
                const syncPoint = this.selectSyncPoint_(syncPoints, {
                    key: "segmentIndex",
                    value: 0
                });
                if (syncPoint.segmentIndex > 0) syncPoint.time *= -1;
                return Math.abs(syncPoint.time + sumDurations({
                    defaultDuration: playlist.targetDuration,
                    durationList: playlist.segments,
                    startIndex: syncPoint.segmentIndex,
                    endIndex: 0
                }));
            }
            runStrategies_(playlist, duration, currentTimeline, currentTime) {
                const syncPoints = [];
                for (let i = 0; i < syncPointStrategies.length; i++) {
                    const strategy = syncPointStrategies[i];
                    const syncPoint = strategy.run(this, playlist, duration, currentTimeline, currentTime);
                    if (syncPoint) {
                        syncPoint.strategy = strategy.name;
                        syncPoints.push({
                            strategy: strategy.name,
                            syncPoint
                        });
                    }
                }
                return syncPoints;
            }
            selectSyncPoint_(syncPoints, target) {
                let bestSyncPoint = syncPoints[0].syncPoint;
                let bestDistance = Math.abs(syncPoints[0].syncPoint[target.key] - target.value);
                let bestStrategy = syncPoints[0].strategy;
                for (let i = 1; i < syncPoints.length; i++) {
                    const newDistance = Math.abs(syncPoints[i].syncPoint[target.key] - target.value);
                    if (newDistance < bestDistance) {
                        bestDistance = newDistance;
                        bestSyncPoint = syncPoints[i].syncPoint;
                        bestStrategy = syncPoints[i].strategy;
                    }
                }
                this.logger_(`syncPoint for [${target.key}: ${target.value}] chosen with strategy` + ` [${bestStrategy}]: [time:${bestSyncPoint.time},` + ` segmentIndex:${bestSyncPoint.segmentIndex}` + (typeof bestSyncPoint.partIndex === "number" ? `,partIndex:${bestSyncPoint.partIndex}` : "") + "]");
                return bestSyncPoint;
            }
            saveExpiredSegmentInfo(oldPlaylist, newPlaylist) {
                const mediaSequenceDiff = newPlaylist.mediaSequence - oldPlaylist.mediaSequence;
                if (mediaSequenceDiff > MAX_MEDIA_SEQUENCE_DIFF_FOR_SYNC) {
                    videojs.log.warn(`Not saving expired segment info. Media sequence gap ${mediaSequenceDiff} is too large.`);
                    return;
                }
                for (let i = mediaSequenceDiff - 1; i >= 0; i--) {
                    const lastRemovedSegment = oldPlaylist.segments[i];
                    if (lastRemovedSegment && typeof lastRemovedSegment.start !== "undefined") {
                        newPlaylist.syncInfo = {
                            mediaSequence: oldPlaylist.mediaSequence + i,
                            time: lastRemovedSegment.start
                        };
                        this.logger_(`playlist refresh sync: [time:${newPlaylist.syncInfo.time},` + ` mediaSequence: ${newPlaylist.syncInfo.mediaSequence}]`);
                        this.trigger("syncinfoupdate");
                        break;
                    }
                }
            }
            setDateTimeMappingForStart(playlist) {
                this.timelineToDatetimeMappings = {};
                if (playlist.segments && playlist.segments.length && playlist.segments[0].dateTimeObject) {
                    const firstSegment = playlist.segments[0];
                    const playlistTimestamp = firstSegment.dateTimeObject.getTime() / 1e3;
                    this.timelineToDatetimeMappings[firstSegment.timeline] = -playlistTimestamp;
                }
            }
            saveSegmentTimingInfo({segmentInfo, shouldSaveTimelineMapping}) {
                const didCalculateSegmentTimeMapping = this.calculateSegmentTimeMapping_(segmentInfo, segmentInfo.timingInfo, shouldSaveTimelineMapping);
                const segment = segmentInfo.segment;
                if (didCalculateSegmentTimeMapping) {
                    this.saveDiscontinuitySyncInfo_(segmentInfo);
                    if (!segmentInfo.playlist.syncInfo) segmentInfo.playlist.syncInfo = {
                        mediaSequence: segmentInfo.playlist.mediaSequence + segmentInfo.mediaIndex,
                        time: segment.start
                    };
                }
                const dateTime = segment.dateTimeObject;
                if (segment.discontinuity && shouldSaveTimelineMapping && dateTime) this.timelineToDatetimeMappings[segment.timeline] = -dateTime.getTime() / 1e3;
            }
            timestampOffsetForTimeline(timeline) {
                if (typeof this.timelines[timeline] === "undefined") return null;
                return this.timelines[timeline].time;
            }
            mappingForTimeline(timeline) {
                if (typeof this.timelines[timeline] === "undefined") return null;
                return this.timelines[timeline].mapping;
            }
            calculateSegmentTimeMapping_(segmentInfo, timingInfo, shouldSaveTimelineMapping) {
                const segment = segmentInfo.segment;
                const part = segmentInfo.part;
                let mappingObj = this.timelines[segmentInfo.timeline];
                let start;
                let end;
                if (typeof segmentInfo.timestampOffset === "number") {
                    mappingObj = {
                        time: segmentInfo.startOfSegment,
                        mapping: segmentInfo.startOfSegment - timingInfo.start
                    };
                    if (shouldSaveTimelineMapping) {
                        this.timelines[segmentInfo.timeline] = mappingObj;
                        this.trigger("timestampoffset");
                        this.logger_(`time mapping for timeline ${segmentInfo.timeline}: ` + `[time: ${mappingObj.time}] [mapping: ${mappingObj.mapping}]`);
                    }
                    start = segmentInfo.startOfSegment;
                    end = timingInfo.end + mappingObj.mapping;
                } else if (mappingObj) {
                    start = timingInfo.start + mappingObj.mapping;
                    end = timingInfo.end + mappingObj.mapping;
                } else return false;
                if (part) {
                    part.start = start;
                    part.end = end;
                }
                if (!segment.start || start < segment.start) segment.start = start;
                segment.end = end;
                return true;
            }
            saveDiscontinuitySyncInfo_(segmentInfo) {
                const playlist = segmentInfo.playlist;
                const segment = segmentInfo.segment;
                if (segment.discontinuity) this.discontinuities[segment.timeline] = {
                    time: segment.start,
                    accuracy: 0
                }; else if (playlist.discontinuityStarts && playlist.discontinuityStarts.length) for (let i = 0; i < playlist.discontinuityStarts.length; i++) {
                    const segmentIndex = playlist.discontinuityStarts[i];
                    const discontinuity = playlist.discontinuitySequence + i + 1;
                    const mediaIndexDiff = segmentIndex - segmentInfo.mediaIndex;
                    const accuracy = Math.abs(mediaIndexDiff);
                    if (!this.discontinuities[discontinuity] || this.discontinuities[discontinuity].accuracy > accuracy) {
                        let time;
                        if (mediaIndexDiff < 0) time = segment.start - sumDurations({
                            defaultDuration: playlist.targetDuration,
                            durationList: playlist.segments,
                            startIndex: segmentInfo.mediaIndex,
                            endIndex: segmentIndex
                        }); else time = segment.end + sumDurations({
                            defaultDuration: playlist.targetDuration,
                            durationList: playlist.segments,
                            startIndex: segmentInfo.mediaIndex + 1,
                            endIndex: segmentIndex
                        });
                        this.discontinuities[discontinuity] = {
                            time,
                            accuracy
                        };
                    }
                }
            }
            dispose() {
                this.trigger("dispose");
                this.off();
            }
        }
        class TimelineChangeController extends videojs.EventTarget {
            constructor() {
                super();
                this.pendingTimelineChanges_ = {};
                this.lastTimelineChanges_ = {};
            }
            clearPendingTimelineChange(type) {
                this.pendingTimelineChanges_[type] = null;
                this.trigger("pendingtimelinechange");
            }
            pendingTimelineChange({type, from, to}) {
                if (typeof from === "number" && typeof to === "number") {
                    this.pendingTimelineChanges_[type] = {
                        type,
                        from,
                        to
                    };
                    this.trigger("pendingtimelinechange");
                }
                return this.pendingTimelineChanges_[type];
            }
            lastTimelineChange({type, from, to}) {
                if (typeof from === "number" && typeof to === "number") {
                    this.lastTimelineChanges_[type] = {
                        type,
                        from,
                        to
                    };
                    delete this.pendingTimelineChanges_[type];
                    this.trigger("timelinechange");
                }
                return this.lastTimelineChanges_[type];
            }
            dispose() {
                this.trigger("dispose");
                this.pendingTimelineChanges_ = {};
                this.lastTimelineChanges_ = {};
                this.off();
            }
        }
        const workerCode = transform(getWorkerString((function() {
            var Stream = function() {
                function Stream() {
                    this.listeners = {};
                }
                var _proto = Stream.prototype;
                _proto.on = function on(type, listener) {
                    if (!this.listeners[type]) this.listeners[type] = [];
                    this.listeners[type].push(listener);
                };
                _proto.off = function off(type, listener) {
                    if (!this.listeners[type]) return false;
                    var index = this.listeners[type].indexOf(listener);
                    this.listeners[type] = this.listeners[type].slice(0);
                    this.listeners[type].splice(index, 1);
                    return index > -1;
                };
                _proto.trigger = function trigger(type) {
                    var callbacks = this.listeners[type];
                    if (!callbacks) return;
                    if (arguments.length === 2) {
                        var length = callbacks.length;
                        for (var i = 0; i < length; ++i) callbacks[i].call(this, arguments[1]);
                    } else {
                        var args = Array.prototype.slice.call(arguments, 1);
                        var _length = callbacks.length;
                        for (var _i = 0; _i < _length; ++_i) callbacks[_i].apply(this, args);
                    }
                };
                _proto.dispose = function dispose() {
                    this.listeners = {};
                };
                _proto.pipe = function pipe(destination) {
                    this.on("data", (function(data) {
                        destination.push(data);
                    }));
                };
                return Stream;
            }();
            /*! @name pkcs7 @version 1.0.4 @license Apache-2.0 */            function unpad(padded) {
                return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
            }
            /*! @name aes-decrypter @version 4.0.1 @license Apache-2.0 */            const precompute = function() {
                const tables = [ [ [], [], [], [], [] ], [ [], [], [], [], [] ] ];
                const encTable = tables[0];
                const decTable = tables[1];
                const sbox = encTable[4];
                const sboxInv = decTable[4];
                let i;
                let x;
                let xInv;
                const d = [];
                const th = [];
                let x2;
                let x4;
                let x8;
                let s;
                let tEnc;
                let tDec;
                for (i = 0; i < 256; i++) th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
                for (x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
                    s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
                    s = s >> 8 ^ s & 255 ^ 99;
                    sbox[x] = s;
                    sboxInv[s] = x;
                    x8 = d[x4 = d[x2 = d[x]]];
                    tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
                    tEnc = d[s] * 257 ^ s * 16843008;
                    for (i = 0; i < 4; i++) {
                        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
                        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
                    }
                }
                for (i = 0; i < 5; i++) {
                    encTable[i] = encTable[i].slice(0);
                    decTable[i] = decTable[i].slice(0);
                }
                return tables;
            };
            let aesTables = null;
            class AES {
                constructor(key) {
                    if (!aesTables) aesTables = precompute();
                    this._tables = [ [ aesTables[0][0].slice(), aesTables[0][1].slice(), aesTables[0][2].slice(), aesTables[0][3].slice(), aesTables[0][4].slice() ], [ aesTables[1][0].slice(), aesTables[1][1].slice(), aesTables[1][2].slice(), aesTables[1][3].slice(), aesTables[1][4].slice() ] ];
                    let i;
                    let j;
                    let tmp;
                    const sbox = this._tables[0][4];
                    const decTable = this._tables[1];
                    const keyLen = key.length;
                    let rcon = 1;
                    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) throw new Error("Invalid aes key size");
                    const encKey = key.slice(0);
                    const decKey = [];
                    this._key = [ encKey, decKey ];
                    for (i = keyLen; i < 4 * keyLen + 28; i++) {
                        tmp = encKey[i - 1];
                        if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
                            tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
                            if (i % keyLen === 0) {
                                tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
                                rcon = rcon << 1 ^ (rcon >> 7) * 283;
                            }
                        }
                        encKey[i] = encKey[i - keyLen] ^ tmp;
                    }
                    for (j = 0; i; j++, i--) {
                        tmp = encKey[j & 3 ? i : i - 4];
                        if (i <= 4 || j < 4) decKey[j] = tmp; else decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
                    }
                }
                decrypt(encrypted0, encrypted1, encrypted2, encrypted3, out, offset) {
                    const key = this._key[1];
                    let a = encrypted0 ^ key[0];
                    let b = encrypted3 ^ key[1];
                    let c = encrypted2 ^ key[2];
                    let d = encrypted1 ^ key[3];
                    let a2;
                    let b2;
                    let c2;
                    const nInnerRounds = key.length / 4 - 2;
                    let i;
                    let kIndex = 4;
                    const table = this._tables[1];
                    const table0 = table[0];
                    const table1 = table[1];
                    const table2 = table[2];
                    const table3 = table[3];
                    const sbox = table[4];
                    for (i = 0; i < nInnerRounds; i++) {
                        a2 = table0[a >>> 24] ^ table1[b >> 16 & 255] ^ table2[c >> 8 & 255] ^ table3[d & 255] ^ key[kIndex];
                        b2 = table0[b >>> 24] ^ table1[c >> 16 & 255] ^ table2[d >> 8 & 255] ^ table3[a & 255] ^ key[kIndex + 1];
                        c2 = table0[c >>> 24] ^ table1[d >> 16 & 255] ^ table2[a >> 8 & 255] ^ table3[b & 255] ^ key[kIndex + 2];
                        d = table0[d >>> 24] ^ table1[a >> 16 & 255] ^ table2[b >> 8 & 255] ^ table3[c & 255] ^ key[kIndex + 3];
                        kIndex += 4;
                        a = a2;
                        b = b2;
                        c = c2;
                    }
                    for (i = 0; i < 4; i++) {
                        out[(3 & -i) + offset] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
                        a2 = a;
                        a = b;
                        b = c;
                        c = d;
                        d = a2;
                    }
                }
            }
            class AsyncStream extends Stream {
                constructor() {
                    super(Stream);
                    this.jobs = [];
                    this.delay = 1;
                    this.timeout_ = null;
                }
                processJob_() {
                    this.jobs.shift()();
                    if (this.jobs.length) this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay); else this.timeout_ = null;
                }
                push(job) {
                    this.jobs.push(job);
                    if (!this.timeout_) this.timeout_ = setTimeout(this.processJob_.bind(this), this.delay);
                }
            }
            const ntoh = function(word) {
                return word << 24 | (word & 65280) << 8 | (word & 16711680) >> 8 | word >>> 24;
            };
            const decrypt = function(encrypted, key, initVector) {
                const encrypted32 = new Int32Array(encrypted.buffer, encrypted.byteOffset, encrypted.byteLength >> 2);
                const decipher = new AES(Array.prototype.slice.call(key));
                const decrypted = new Uint8Array(encrypted.byteLength);
                const decrypted32 = new Int32Array(decrypted.buffer);
                let init0;
                let init1;
                let init2;
                let init3;
                let encrypted0;
                let encrypted1;
                let encrypted2;
                let encrypted3;
                let wordIx;
                init0 = initVector[0];
                init1 = initVector[1];
                init2 = initVector[2];
                init3 = initVector[3];
                for (wordIx = 0; wordIx < encrypted32.length; wordIx += 4) {
                    encrypted0 = ntoh(encrypted32[wordIx]);
                    encrypted1 = ntoh(encrypted32[wordIx + 1]);
                    encrypted2 = ntoh(encrypted32[wordIx + 2]);
                    encrypted3 = ntoh(encrypted32[wordIx + 3]);
                    decipher.decrypt(encrypted0, encrypted1, encrypted2, encrypted3, decrypted32, wordIx);
                    decrypted32[wordIx] = ntoh(decrypted32[wordIx] ^ init0);
                    decrypted32[wordIx + 1] = ntoh(decrypted32[wordIx + 1] ^ init1);
                    decrypted32[wordIx + 2] = ntoh(decrypted32[wordIx + 2] ^ init2);
                    decrypted32[wordIx + 3] = ntoh(decrypted32[wordIx + 3] ^ init3);
                    init0 = encrypted0;
                    init1 = encrypted1;
                    init2 = encrypted2;
                    init3 = encrypted3;
                }
                return decrypted;
            };
            class Decrypter {
                constructor(encrypted, key, initVector, done) {
                    const step = Decrypter.STEP;
                    const encrypted32 = new Int32Array(encrypted.buffer);
                    const decrypted = new Uint8Array(encrypted.byteLength);
                    let i = 0;
                    this.asyncStream_ = new AsyncStream;
                    this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
                    for (i = step; i < encrypted32.length; i += step) {
                        initVector = new Uint32Array([ ntoh(encrypted32[i - 4]), ntoh(encrypted32[i - 3]), ntoh(encrypted32[i - 2]), ntoh(encrypted32[i - 1]) ]);
                        this.asyncStream_.push(this.decryptChunk_(encrypted32.subarray(i, i + step), key, initVector, decrypted));
                    }
                    this.asyncStream_.push((function() {
                        done(null, unpad(decrypted));
                    }));
                }
                static get STEP() {
                    return 32e3;
                }
                decryptChunk_(encrypted, key, initVector, decrypted) {
                    return function() {
                        const bytes = decrypt(encrypted, key, initVector);
                        decrypted.set(bytes, encrypted.byteOffset);
                    };
                }
            }
            var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof __webpack_require__.g !== "undefined" ? __webpack_require__.g : typeof self !== "undefined" ? self : {};
            var win;
            if (typeof window !== "undefined") win = window; else if (typeof commonjsGlobal !== "undefined") win = commonjsGlobal; else if (typeof self !== "undefined") win = self; else win = {};
            var window_1 = win;
            var isArrayBufferView = function isArrayBufferView(obj) {
                if (ArrayBuffer.isView === "function") return ArrayBuffer.isView(obj);
                return obj && obj.buffer instanceof ArrayBuffer;
            };
            var BigInt = window_1.BigInt || Number;
            [ BigInt("0x1"), BigInt("0x100"), BigInt("0x10000"), BigInt("0x1000000"), BigInt("0x100000000"), BigInt("0x10000000000"), BigInt("0x1000000000000"), BigInt("0x100000000000000"), BigInt("0x10000000000000000") ];
            (function() {
                var a = new Uint16Array([ 65484 ]);
                var b = new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
                if (b[0] === 255) return "big";
                if (b[0] === 204) return "little";
                return "unknown";
            })();
            const createTransferableMessage = function(message) {
                const transferable = {};
                Object.keys(message).forEach((key => {
                    const value = message[key];
                    if (isArrayBufferView(value)) transferable[key] = {
                        bytes: value.buffer,
                        byteOffset: value.byteOffset,
                        byteLength: value.byteLength
                    }; else transferable[key] = value;
                }));
                return transferable;
            };
            self.onmessage = function(event) {
                const data = event.data;
                const encrypted = new Uint8Array(data.encrypted.bytes, data.encrypted.byteOffset, data.encrypted.byteLength);
                const key = new Uint32Array(data.key.bytes, data.key.byteOffset, data.key.byteLength / 4);
                const iv = new Uint32Array(data.iv.bytes, data.iv.byteOffset, data.iv.byteLength / 4);
                new Decrypter(encrypted, key, iv, (function(err, bytes) {
                    self.postMessage(createTransferableMessage({
                        source: data.source,
                        decrypted: bytes
                    }), [ bytes.buffer ]);
                }));
            };
        })));
        var Decrypter = factory(workerCode);
        const audioTrackKind_ = properties => {
            let kind = properties.default ? "main" : "alternative";
            if (properties.characteristics && properties.characteristics.indexOf("public.accessibility.describes-video") >= 0) kind = "main-desc";
            return kind;
        };
        const stopLoaders = (segmentLoader, mediaType) => {
            segmentLoader.abort();
            segmentLoader.pause();
            if (mediaType && mediaType.activePlaylistLoader) {
                mediaType.activePlaylistLoader.pause();
                mediaType.activePlaylistLoader = null;
            }
        };
        const startLoaders = (playlistLoader, mediaType) => {
            mediaType.activePlaylistLoader = playlistLoader;
            playlistLoader.load();
        };
        const onGroupChanged = (type, settings) => () => {
            const {segmentLoaders: {[type]: segmentLoader, main: mainSegmentLoader}, mediaTypes: {[type]: mediaType}} = settings;
            const activeTrack = mediaType.activeTrack();
            const activeGroup = mediaType.getActiveGroup();
            const previousActiveLoader = mediaType.activePlaylistLoader;
            const lastGroup = mediaType.lastGroup_;
            if (activeGroup && lastGroup && activeGroup.id === lastGroup.id) return;
            mediaType.lastGroup_ = activeGroup;
            mediaType.lastTrack_ = activeTrack;
            stopLoaders(segmentLoader, mediaType);
            if (!activeGroup || activeGroup.isMainPlaylist) return;
            if (!activeGroup.playlistLoader) {
                if (previousActiveLoader) mainSegmentLoader.resetEverything();
                return;
            }
            segmentLoader.resyncLoader();
            startLoaders(activeGroup.playlistLoader, mediaType);
        };
        const onGroupChanging = (type, settings) => () => {
            const {segmentLoaders: {[type]: segmentLoader}, mediaTypes: {[type]: mediaType}} = settings;
            mediaType.lastGroup_ = null;
            segmentLoader.abort();
            segmentLoader.pause();
        };
        const onTrackChanged = (type, settings) => () => {
            const {mainPlaylistLoader, segmentLoaders: {[type]: segmentLoader, main: mainSegmentLoader}, mediaTypes: {[type]: mediaType}} = settings;
            const activeTrack = mediaType.activeTrack();
            const activeGroup = mediaType.getActiveGroup();
            const previousActiveLoader = mediaType.activePlaylistLoader;
            const lastTrack = mediaType.lastTrack_;
            if (lastTrack && activeTrack && lastTrack.id === activeTrack.id) return;
            mediaType.lastGroup_ = activeGroup;
            mediaType.lastTrack_ = activeTrack;
            stopLoaders(segmentLoader, mediaType);
            if (!activeGroup) return;
            if (activeGroup.isMainPlaylist) {
                if (!activeTrack || !lastTrack || activeTrack.id === lastTrack.id) return;
                const pc = settings.vhs.playlistController_;
                const newPlaylist = pc.selectPlaylist();
                if (pc.media() === newPlaylist) return;
                mediaType.logger_(`track change. Switching main audio from ${lastTrack.id} to ${activeTrack.id}`);
                mainPlaylistLoader.pause();
                mainSegmentLoader.resetEverything();
                pc.fastQualityChange_(newPlaylist);
                return;
            }
            if (type === "AUDIO") {
                if (!activeGroup.playlistLoader) {
                    mainSegmentLoader.setAudio(true);
                    mainSegmentLoader.resetEverything();
                    return;
                }
                segmentLoader.setAudio(true);
                mainSegmentLoader.setAudio(false);
            }
            if (previousActiveLoader === activeGroup.playlistLoader) {
                startLoaders(activeGroup.playlistLoader, mediaType);
                return;
            }
            if (segmentLoader.track) segmentLoader.track(activeTrack);
            segmentLoader.resetEverything();
            startLoaders(activeGroup.playlistLoader, mediaType);
        };
        const onError = {
            AUDIO: (type, settings) => () => {
                const {segmentLoaders: {[type]: segmentLoader}, mediaTypes: {[type]: mediaType}, excludePlaylist} = settings;
                stopLoaders(segmentLoader, mediaType);
                const activeTrack = mediaType.activeTrack();
                const activeGroup = mediaType.activeGroup();
                const id = (activeGroup.filter((group => group.default))[0] || activeGroup[0]).id;
                const defaultTrack = mediaType.tracks[id];
                if (activeTrack === defaultTrack) {
                    excludePlaylist({
                        error: {
                            message: "Problem encountered loading the default audio track."
                        }
                    });
                    return;
                }
                videojs.log.warn("Problem encountered loading the alternate audio track." + "Switching back to default.");
                for (const trackId in mediaType.tracks) mediaType.tracks[trackId].enabled = mediaType.tracks[trackId] === defaultTrack;
                mediaType.onTrackChanged();
            },
            SUBTITLES: (type, settings) => () => {
                const {segmentLoaders: {[type]: segmentLoader}, mediaTypes: {[type]: mediaType}} = settings;
                videojs.log.warn("Problem encountered loading the subtitle track." + "Disabling subtitle track.");
                stopLoaders(segmentLoader, mediaType);
                const track = mediaType.activeTrack();
                if (track) track.mode = "disabled";
                mediaType.onTrackChanged();
            }
        };
        const setupListeners = {
            AUDIO: (type, playlistLoader, settings) => {
                if (!playlistLoader) return;
                const {tech, requestOptions, segmentLoaders: {[type]: segmentLoader}} = settings;
                playlistLoader.on("loadedmetadata", (() => {
                    const media = playlistLoader.media();
                    segmentLoader.playlist(media, requestOptions);
                    if (!tech.paused() || media.endList && tech.preload() !== "none") segmentLoader.load();
                }));
                playlistLoader.on("loadedplaylist", (() => {
                    segmentLoader.playlist(playlistLoader.media(), requestOptions);
                    if (!tech.paused()) segmentLoader.load();
                }));
                playlistLoader.on("error", onError[type](type, settings));
            },
            SUBTITLES: (type, playlistLoader, settings) => {
                const {tech, requestOptions, segmentLoaders: {[type]: segmentLoader}, mediaTypes: {[type]: mediaType}} = settings;
                playlistLoader.on("loadedmetadata", (() => {
                    const media = playlistLoader.media();
                    segmentLoader.playlist(media, requestOptions);
                    segmentLoader.track(mediaType.activeTrack());
                    if (!tech.paused() || media.endList && tech.preload() !== "none") segmentLoader.load();
                }));
                playlistLoader.on("loadedplaylist", (() => {
                    segmentLoader.playlist(playlistLoader.media(), requestOptions);
                    if (!tech.paused()) segmentLoader.load();
                }));
                playlistLoader.on("error", onError[type](type, settings));
            }
        };
        const initialize = {
            AUDIO: (type, settings) => {
                const {vhs, sourceType, segmentLoaders: {[type]: segmentLoader}, requestOptions, main: {mediaGroups}, mediaTypes: {[type]: {groups, tracks, logger_}}, mainPlaylistLoader} = settings;
                const audioOnlyMain = isAudioOnly(mainPlaylistLoader.main);
                if (!mediaGroups[type] || Object.keys(mediaGroups[type]).length === 0) {
                    mediaGroups[type] = {
                        main: {
                            default: {
                                default: true
                            }
                        }
                    };
                    if (audioOnlyMain) mediaGroups[type].main.default.playlists = mainPlaylistLoader.main.playlists;
                }
                for (const groupId in mediaGroups[type]) {
                    if (!groups[groupId]) groups[groupId] = [];
                    for (const variantLabel in mediaGroups[type][groupId]) {
                        let properties = mediaGroups[type][groupId][variantLabel];
                        let playlistLoader;
                        if (audioOnlyMain) {
                            logger_(`AUDIO group '${groupId}' label '${variantLabel}' is a main playlist`);
                            properties.isMainPlaylist = true;
                            playlistLoader = null;
                        } else if (sourceType === "vhs-json" && properties.playlists) playlistLoader = new PlaylistLoader(properties.playlists[0], vhs, requestOptions); else if (properties.resolvedUri) playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions); else if (properties.playlists && sourceType === "dash") playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader); else playlistLoader = null;
                        properties = video_es_merge({
                            id: variantLabel,
                            playlistLoader
                        }, properties);
                        setupListeners[type](type, properties.playlistLoader, settings);
                        groups[groupId].push(properties);
                        if (typeof tracks[variantLabel] === "undefined") {
                            const track = new videojs.AudioTrack({
                                id: variantLabel,
                                kind: audioTrackKind_(properties),
                                enabled: false,
                                language: properties.language,
                                default: properties.default,
                                label: variantLabel
                            });
                            tracks[variantLabel] = track;
                        }
                    }
                }
                segmentLoader.on("error", onError[type](type, settings));
            },
            SUBTITLES: (type, settings) => {
                const {tech, vhs, sourceType, segmentLoaders: {[type]: segmentLoader}, requestOptions, main: {mediaGroups}, mediaTypes: {[type]: {groups, tracks}}, mainPlaylistLoader} = settings;
                for (const groupId in mediaGroups[type]) {
                    if (!groups[groupId]) groups[groupId] = [];
                    for (const variantLabel in mediaGroups[type][groupId]) {
                        if (mediaGroups[type][groupId][variantLabel].forced) continue;
                        let properties = mediaGroups[type][groupId][variantLabel];
                        let playlistLoader;
                        if (sourceType === "hls") playlistLoader = new PlaylistLoader(properties.resolvedUri, vhs, requestOptions); else if (sourceType === "dash") {
                            const playlists = properties.playlists.filter((p => p.excludeUntil !== 1 / 0));
                            if (!playlists.length) return;
                            playlistLoader = new DashPlaylistLoader(properties.playlists[0], vhs, requestOptions, mainPlaylistLoader);
                        } else if (sourceType === "vhs-json") playlistLoader = new PlaylistLoader(properties.playlists ? properties.playlists[0] : properties.resolvedUri, vhs, requestOptions);
                        properties = video_es_merge({
                            id: variantLabel,
                            playlistLoader
                        }, properties);
                        setupListeners[type](type, properties.playlistLoader, settings);
                        groups[groupId].push(properties);
                        if (typeof tracks[variantLabel] === "undefined") {
                            const track = tech.addRemoteTextTrack({
                                id: variantLabel,
                                kind: "subtitles",
                                default: properties.default && properties.autoselect,
                                language: properties.language,
                                label: variantLabel
                            }, false).track;
                            tracks[variantLabel] = track;
                        }
                    }
                }
                segmentLoader.on("error", onError[type](type, settings));
            },
            "CLOSED-CAPTIONS": (type, settings) => {
                const {tech, main: {mediaGroups}, mediaTypes: {[type]: {groups, tracks}}} = settings;
                for (const groupId in mediaGroups[type]) {
                    if (!groups[groupId]) groups[groupId] = [];
                    for (const variantLabel in mediaGroups[type][groupId]) {
                        const properties = mediaGroups[type][groupId][variantLabel];
                        if (!/^(?:CC|SERVICE)/.test(properties.instreamId)) continue;
                        const captionServices = tech.options_.vhs && tech.options_.vhs.captionServices || {};
                        let newProps = {
                            label: variantLabel,
                            language: properties.language,
                            instreamId: properties.instreamId,
                            default: properties.default && properties.autoselect
                        };
                        if (captionServices[newProps.instreamId]) newProps = video_es_merge(newProps, captionServices[newProps.instreamId]);
                        if (newProps.default === void 0) delete newProps.default;
                        groups[groupId].push(video_es_merge({
                            id: variantLabel
                        }, properties));
                        if (typeof tracks[variantLabel] === "undefined") {
                            const track = tech.addRemoteTextTrack({
                                id: newProps.instreamId,
                                kind: "captions",
                                default: newProps.default,
                                language: newProps.language,
                                label: newProps.label
                            }, false).track;
                            tracks[variantLabel] = track;
                        }
                    }
                }
            }
        };
        const groupMatch = (list, media) => {
            for (let i = 0; i < list.length; i++) {
                if (playlistMatch(media, list[i])) return true;
                if (list[i].playlists && groupMatch(list[i].playlists, media)) return true;
            }
            return false;
        };
        const activeGroup = (type, settings) => track => {
            const {mainPlaylistLoader, mediaTypes: {[type]: {groups}}} = settings;
            const media = mainPlaylistLoader.media();
            if (!media) return null;
            let variants = null;
            if (media.attributes[type]) variants = groups[media.attributes[type]];
            const groupKeys = Object.keys(groups);
            if (!variants) if (type === "AUDIO" && groupKeys.length > 1 && isAudioOnly(settings.main)) for (let i = 0; i < groupKeys.length; i++) {
                const groupPropertyList = groups[groupKeys[i]];
                if (groupMatch(groupPropertyList, media)) {
                    variants = groupPropertyList;
                    break;
                }
            } else if (groups.main) variants = groups.main; else if (groupKeys.length === 1) variants = groups[groupKeys[0]];
            if (typeof track === "undefined") return variants;
            if (track === null || !variants) return null;
            return variants.filter((props => props.id === track.id))[0] || null;
        };
        const activeTrack = {
            AUDIO: (type, settings) => () => {
                const {mediaTypes: {[type]: {tracks}}} = settings;
                for (const id in tracks) if (tracks[id].enabled) return tracks[id];
                return null;
            },
            SUBTITLES: (type, settings) => () => {
                const {mediaTypes: {[type]: {tracks}}} = settings;
                for (const id in tracks) if (tracks[id].mode === "showing" || tracks[id].mode === "hidden") return tracks[id];
                return null;
            }
        };
        const getActiveGroup = (type, {mediaTypes}) => () => {
            const activeTrack_ = mediaTypes[type].activeTrack();
            if (!activeTrack_) return null;
            return mediaTypes[type].activeGroup(activeTrack_);
        };
        const setupMediaGroups = settings => {
            [ "AUDIO", "SUBTITLES", "CLOSED-CAPTIONS" ].forEach((type => {
                initialize[type](type, settings);
            }));
            const {mediaTypes, mainPlaylistLoader, tech, vhs, segmentLoaders: {["AUDIO"]: audioSegmentLoader, main: mainSegmentLoader}} = settings;
            [ "AUDIO", "SUBTITLES" ].forEach((type => {
                mediaTypes[type].activeGroup = activeGroup(type, settings);
                mediaTypes[type].activeTrack = activeTrack[type](type, settings);
                mediaTypes[type].onGroupChanged = onGroupChanged(type, settings);
                mediaTypes[type].onGroupChanging = onGroupChanging(type, settings);
                mediaTypes[type].onTrackChanged = onTrackChanged(type, settings);
                mediaTypes[type].getActiveGroup = getActiveGroup(type, settings);
            }));
            const audioGroup = mediaTypes.AUDIO.activeGroup();
            if (audioGroup) {
                const groupId = (audioGroup.filter((group => group.default))[0] || audioGroup[0]).id;
                mediaTypes.AUDIO.tracks[groupId].enabled = true;
                mediaTypes.AUDIO.onGroupChanged();
                mediaTypes.AUDIO.onTrackChanged();
                const activeAudioGroup = mediaTypes.AUDIO.getActiveGroup();
                if (!activeAudioGroup.playlistLoader) mainSegmentLoader.setAudio(true); else {
                    mainSegmentLoader.setAudio(false);
                    audioSegmentLoader.setAudio(true);
                }
            }
            mainPlaylistLoader.on("mediachange", (() => {
                [ "AUDIO", "SUBTITLES" ].forEach((type => mediaTypes[type].onGroupChanged()));
            }));
            mainPlaylistLoader.on("mediachanging", (() => {
                [ "AUDIO", "SUBTITLES" ].forEach((type => mediaTypes[type].onGroupChanging()));
            }));
            const onAudioTrackChanged = () => {
                mediaTypes.AUDIO.onTrackChanged();
                tech.trigger({
                    type: "usage",
                    name: "vhs-audio-change"
                });
            };
            tech.audioTracks().addEventListener("change", onAudioTrackChanged);
            tech.remoteTextTracks().addEventListener("change", mediaTypes.SUBTITLES.onTrackChanged);
            vhs.on("dispose", (() => {
                tech.audioTracks().removeEventListener("change", onAudioTrackChanged);
                tech.remoteTextTracks().removeEventListener("change", mediaTypes.SUBTITLES.onTrackChanged);
            }));
            tech.clearTracks("audio");
            for (const id in mediaTypes.AUDIO.tracks) tech.audioTracks().addTrack(mediaTypes.AUDIO.tracks[id]);
        };
        const createMediaTypes = () => {
            const mediaTypes = {};
            [ "AUDIO", "SUBTITLES", "CLOSED-CAPTIONS" ].forEach((type => {
                mediaTypes[type] = {
                    groups: {},
                    tracks: {},
                    activePlaylistLoader: null,
                    activeGroup: noop,
                    activeTrack: noop,
                    getActiveGroup: noop,
                    onGroupChanged: noop,
                    onTrackChanged: noop,
                    lastTrack_: null,
                    logger_: logger(`MediaGroups[${type}]`)
                };
            }));
            return mediaTypes;
        };
        const ABORT_EARLY_EXCLUSION_SECONDS = 60 * 2;
        let Vhs$1;
        const loaderStats = [ "mediaRequests", "mediaRequestsAborted", "mediaRequestsTimedout", "mediaRequestsErrored", "mediaTransferDuration", "mediaBytesTransferred", "mediaAppends" ];
        const sumLoaderStat = function(stat) {
            return this.audioSegmentLoader_[stat] + this.mainSegmentLoader_[stat];
        };
        const shouldSwitchToMedia = function({currentPlaylist, buffered, currentTime, nextPlaylist, bufferLowWaterLine, bufferHighWaterLine, duration, bufferBasedABR, log}) {
            if (!nextPlaylist) {
                videojs.log.warn("We received no playlist to switch to. Please check your stream.");
                return false;
            }
            const sharedLogLine = `allowing switch ${currentPlaylist && currentPlaylist.id || "null"} -> ${nextPlaylist.id}`;
            if (!currentPlaylist) {
                log(`${sharedLogLine} as current playlist is not set`);
                return true;
            }
            if (nextPlaylist.id === currentPlaylist.id) return false;
            const isBuffered = Boolean(findRange(buffered, currentTime).length);
            if (!currentPlaylist.endList) {
                if (!isBuffered && typeof currentPlaylist.partTargetDuration === "number") {
                    log(`not ${sharedLogLine} as current playlist is live llhls, but currentTime isn't in buffered.`);
                    return false;
                }
                log(`${sharedLogLine} as current playlist is live`);
                return true;
            }
            const forwardBuffer = timeAheadOf(buffered, currentTime);
            const maxBufferLowWaterLine = bufferBasedABR ? Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE : Config.MAX_BUFFER_LOW_WATER_LINE;
            if (duration < maxBufferLowWaterLine) {
                log(`${sharedLogLine} as duration < max low water line (${duration} < ${maxBufferLowWaterLine})`);
                return true;
            }
            const nextBandwidth = nextPlaylist.attributes.BANDWIDTH;
            const currBandwidth = currentPlaylist.attributes.BANDWIDTH;
            if (nextBandwidth < currBandwidth && (!bufferBasedABR || forwardBuffer < bufferHighWaterLine)) {
                let logLine = `${sharedLogLine} as next bandwidth < current bandwidth (${nextBandwidth} < ${currBandwidth})`;
                if (bufferBasedABR) logLine += ` and forwardBuffer < bufferHighWaterLine (${forwardBuffer} < ${bufferHighWaterLine})`;
                log(logLine);
                return true;
            }
            if ((!bufferBasedABR || nextBandwidth > currBandwidth) && forwardBuffer >= bufferLowWaterLine) {
                let logLine = `${sharedLogLine} as forwardBuffer >= bufferLowWaterLine (${forwardBuffer} >= ${bufferLowWaterLine})`;
                if (bufferBasedABR) logLine += ` and next bandwidth > current bandwidth (${nextBandwidth} > ${currBandwidth})`;
                log(logLine);
                return true;
            }
            log(`not ${sharedLogLine} as no switching criteria met`);
            return false;
        };
        class PlaylistController extends videojs.EventTarget {
            constructor(options) {
                super();
                const {src, withCredentials, tech, bandwidth, externVhs, useCueTags, playlistExclusionDuration, enableLowInitialPlaylist, sourceType, cacheEncryptionKeys, bufferBasedABR, leastPixelDiffSelector, captionServices} = options;
                if (!src) throw new Error("A non-empty playlist URL or JSON manifest string is required");
                let {maxPlaylistRetries} = options;
                if (maxPlaylistRetries === null || typeof maxPlaylistRetries === "undefined") maxPlaylistRetries = 1 / 0;
                Vhs$1 = externVhs;
                this.bufferBasedABR = Boolean(bufferBasedABR);
                this.leastPixelDiffSelector = Boolean(leastPixelDiffSelector);
                this.withCredentials = withCredentials;
                this.tech_ = tech;
                this.vhs_ = tech.vhs;
                this.sourceType_ = sourceType;
                this.useCueTags_ = useCueTags;
                this.playlistExclusionDuration = playlistExclusionDuration;
                this.maxPlaylistRetries = maxPlaylistRetries;
                this.enableLowInitialPlaylist = enableLowInitialPlaylist;
                if (this.useCueTags_) {
                    this.cueTagsTrack_ = this.tech_.addTextTrack("metadata", "ad-cues");
                    this.cueTagsTrack_.inBandMetadataTrackDispatchType = "";
                }
                this.requestOptions_ = {
                    withCredentials,
                    maxPlaylistRetries,
                    timeout: null
                };
                this.on("error", this.pauseLoading);
                this.mediaTypes_ = createMediaTypes();
                this.mediaSource = new (window_default().MediaSource);
                this.handleDurationChange_ = this.handleDurationChange_.bind(this);
                this.handleSourceOpen_ = this.handleSourceOpen_.bind(this);
                this.handleSourceEnded_ = this.handleSourceEnded_.bind(this);
                this.mediaSource.addEventListener("durationchange", this.handleDurationChange_);
                this.mediaSource.addEventListener("sourceopen", this.handleSourceOpen_);
                this.mediaSource.addEventListener("sourceended", this.handleSourceEnded_);
                this.seekable_ = createTimeRanges();
                this.hasPlayed_ = false;
                this.syncController_ = new SyncController(options);
                this.segmentMetadataTrack_ = tech.addRemoteTextTrack({
                    kind: "metadata",
                    label: "segment-metadata"
                }, false).track;
                this.decrypter_ = new Decrypter;
                this.sourceUpdater_ = new SourceUpdater(this.mediaSource);
                this.inbandTextTracks_ = {};
                this.timelineChangeController_ = new TimelineChangeController;
                const segmentLoaderSettings = {
                    vhs: this.vhs_,
                    parse708captions: options.parse708captions,
                    useDtsForTimestampOffset: options.useDtsForTimestampOffset,
                    captionServices,
                    mediaSource: this.mediaSource,
                    currentTime: this.tech_.currentTime.bind(this.tech_),
                    seekable: () => this.seekable(),
                    seeking: () => this.tech_.seeking(),
                    duration: () => this.duration(),
                    hasPlayed: () => this.hasPlayed_,
                    goalBufferLength: () => this.goalBufferLength(),
                    bandwidth,
                    syncController: this.syncController_,
                    decrypter: this.decrypter_,
                    sourceType: this.sourceType_,
                    inbandTextTracks: this.inbandTextTracks_,
                    cacheEncryptionKeys,
                    sourceUpdater: this.sourceUpdater_,
                    timelineChangeController: this.timelineChangeController_,
                    exactManifestTimings: options.exactManifestTimings
                };
                this.mainPlaylistLoader_ = this.sourceType_ === "dash" ? new DashPlaylistLoader(src, this.vhs_, this.requestOptions_) : new PlaylistLoader(src, this.vhs_, this.requestOptions_);
                this.setupMainPlaylistLoaderListeners_();
                this.mainSegmentLoader_ = new SegmentLoader(video_es_merge(segmentLoaderSettings, {
                    segmentMetadataTrack: this.segmentMetadataTrack_,
                    loaderType: "main"
                }), options);
                this.audioSegmentLoader_ = new SegmentLoader(video_es_merge(segmentLoaderSettings, {
                    loaderType: "audio"
                }), options);
                this.subtitleSegmentLoader_ = new VTTSegmentLoader(video_es_merge(segmentLoaderSettings, {
                    loaderType: "vtt",
                    featuresNativeTextTracks: this.tech_.featuresNativeTextTracks,
                    loadVttJs: () => new Promise(((resolve, reject) => {
                        function onLoad() {
                            tech.off("vttjserror", onError);
                            resolve();
                        }
                        function onError() {
                            tech.off("vttjsloaded", onLoad);
                            reject();
                        }
                        tech.one("vttjsloaded", onLoad);
                        tech.one("vttjserror", onError);
                        tech.addWebVttScript_();
                    }))
                }), options);
                this.setupSegmentLoaderListeners_();
                if (this.bufferBasedABR) {
                    this.mainPlaylistLoader_.one("loadedplaylist", (() => this.startABRTimer_()));
                    this.tech_.on("pause", (() => this.stopABRTimer_()));
                    this.tech_.on("play", (() => this.startABRTimer_()));
                }
                loaderStats.forEach((stat => {
                    this[stat + "_"] = sumLoaderStat.bind(this, stat);
                }));
                this.logger_ = logger("pc");
                this.triggeredFmp4Usage = false;
                if (this.tech_.preload() === "none") {
                    this.loadOnPlay_ = () => {
                        this.loadOnPlay_ = null;
                        this.mainPlaylistLoader_.load();
                    };
                    this.tech_.one("play", this.loadOnPlay_);
                } else this.mainPlaylistLoader_.load();
                this.timeToLoadedData__ = -1;
                this.mainAppendsToLoadedData__ = -1;
                this.audioAppendsToLoadedData__ = -1;
                const event = this.tech_.preload() === "none" ? "play" : "loadstart";
                this.tech_.one(event, (() => {
                    const timeToLoadedDataStart = Date.now();
                    this.tech_.one("loadeddata", (() => {
                        this.timeToLoadedData__ = Date.now() - timeToLoadedDataStart;
                        this.mainAppendsToLoadedData__ = this.mainSegmentLoader_.mediaAppends;
                        this.audioAppendsToLoadedData__ = this.audioSegmentLoader_.mediaAppends;
                    }));
                }));
            }
            mainAppendsToLoadedData_() {
                return this.mainAppendsToLoadedData__;
            }
            audioAppendsToLoadedData_() {
                return this.audioAppendsToLoadedData__;
            }
            appendsToLoadedData_() {
                const main = this.mainAppendsToLoadedData_();
                const audio = this.audioAppendsToLoadedData_();
                if (main === -1 || audio === -1) return -1;
                return main + audio;
            }
            timeToLoadedData_() {
                return this.timeToLoadedData__;
            }
            checkABR_(reason = "abr") {
                const nextPlaylist = this.selectPlaylist();
                if (nextPlaylist && this.shouldSwitchToMedia_(nextPlaylist)) this.switchMedia_(nextPlaylist, reason);
            }
            switchMedia_(playlist, cause, delay) {
                const oldMedia = this.media();
                const oldId = oldMedia && (oldMedia.id || oldMedia.uri);
                const newId = playlist.id || playlist.uri;
                if (oldId && oldId !== newId) {
                    this.logger_(`switch media ${oldId} -> ${newId} from ${cause}`);
                    this.tech_.trigger({
                        type: "usage",
                        name: `vhs-rendition-change-${cause}`
                    });
                }
                this.mainPlaylistLoader_.media(playlist, delay);
            }
            startABRTimer_() {
                this.stopABRTimer_();
                this.abrTimer_ = window_default().setInterval((() => this.checkABR_()), 250);
            }
            stopABRTimer_() {
                if (this.tech_.scrubbing && this.tech_.scrubbing()) return;
                window_default().clearInterval(this.abrTimer_);
                this.abrTimer_ = null;
            }
            getAudioTrackPlaylists_() {
                const main = this.main();
                const defaultPlaylists = main && main.playlists || [];
                if (!main || !main.mediaGroups || !main.mediaGroups.AUDIO) return defaultPlaylists;
                const AUDIO = main.mediaGroups.AUDIO;
                const groupKeys = Object.keys(AUDIO);
                let track;
                if (Object.keys(this.mediaTypes_.AUDIO.groups).length) track = this.mediaTypes_.AUDIO.activeTrack(); else {
                    const defaultGroup = AUDIO.main || groupKeys.length && AUDIO[groupKeys[0]];
                    for (const label in defaultGroup) if (defaultGroup[label].default) {
                        track = {
                            label
                        };
                        break;
                    }
                }
                if (!track) return defaultPlaylists;
                const playlists = [];
                for (const group in AUDIO) if (AUDIO[group][track.label]) {
                    const properties = AUDIO[group][track.label];
                    if (properties.playlists && properties.playlists.length) playlists.push.apply(playlists, properties.playlists); else if (properties.uri) playlists.push(properties); else if (main.playlists.length) for (let i = 0; i < main.playlists.length; i++) {
                        const playlist = main.playlists[i];
                        if (playlist.attributes && playlist.attributes.AUDIO && playlist.attributes.AUDIO === group) playlists.push(playlist);
                    }
                }
                if (!playlists.length) return defaultPlaylists;
                return playlists;
            }
            setupMainPlaylistLoaderListeners_() {
                this.mainPlaylistLoader_.on("loadedmetadata", (() => {
                    const media = this.mainPlaylistLoader_.media();
                    const requestTimeout = media.targetDuration * 1.5 * 1e3;
                    if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) this.requestOptions_.timeout = 0; else this.requestOptions_.timeout = requestTimeout;
                    if (media.endList && this.tech_.preload() !== "none") {
                        this.mainSegmentLoader_.playlist(media, this.requestOptions_);
                        this.mainSegmentLoader_.load();
                    }
                    setupMediaGroups({
                        sourceType: this.sourceType_,
                        segmentLoaders: {
                            AUDIO: this.audioSegmentLoader_,
                            SUBTITLES: this.subtitleSegmentLoader_,
                            main: this.mainSegmentLoader_
                        },
                        tech: this.tech_,
                        requestOptions: this.requestOptions_,
                        mainPlaylistLoader: this.mainPlaylistLoader_,
                        vhs: this.vhs_,
                        main: this.main(),
                        mediaTypes: this.mediaTypes_,
                        excludePlaylist: this.excludePlaylist.bind(this)
                    });
                    this.triggerPresenceUsage_(this.main(), media);
                    this.setupFirstPlay();
                    if (!this.mediaTypes_.AUDIO.activePlaylistLoader || this.mediaTypes_.AUDIO.activePlaylistLoader.media()) this.trigger("selectedinitialmedia"); else this.mediaTypes_.AUDIO.activePlaylistLoader.one("loadedmetadata", (() => {
                        this.trigger("selectedinitialmedia");
                    }));
                }));
                this.mainPlaylistLoader_.on("loadedplaylist", (() => {
                    if (this.loadOnPlay_) this.tech_.off("play", this.loadOnPlay_);
                    let updatedPlaylist = this.mainPlaylistLoader_.media();
                    if (!updatedPlaylist) {
                        this.excludeUnsupportedVariants_();
                        let selectedMedia;
                        if (this.enableLowInitialPlaylist) selectedMedia = this.selectInitialPlaylist();
                        if (!selectedMedia) selectedMedia = this.selectPlaylist();
                        if (!selectedMedia || !this.shouldSwitchToMedia_(selectedMedia)) return;
                        this.initialMedia_ = selectedMedia;
                        this.switchMedia_(this.initialMedia_, "initial");
                        const haveJsonSource = this.sourceType_ === "vhs-json" && this.initialMedia_.segments;
                        if (!haveJsonSource) return;
                        updatedPlaylist = this.initialMedia_;
                    }
                    this.handleUpdatedMediaPlaylist(updatedPlaylist);
                }));
                this.mainPlaylistLoader_.on("error", (() => {
                    const error = this.mainPlaylistLoader_.error;
                    this.excludePlaylist({
                        playlistToExclude: error.playlist,
                        error
                    });
                }));
                this.mainPlaylistLoader_.on("mediachanging", (() => {
                    this.mainSegmentLoader_.abort();
                    this.mainSegmentLoader_.pause();
                }));
                this.mainPlaylistLoader_.on("mediachange", (() => {
                    const media = this.mainPlaylistLoader_.media();
                    const requestTimeout = media.targetDuration * 1.5 * 1e3;
                    if (isLowestEnabledRendition(this.mainPlaylistLoader_.main, this.mainPlaylistLoader_.media())) this.requestOptions_.timeout = 0; else this.requestOptions_.timeout = requestTimeout;
                    this.mainPlaylistLoader_.load();
                    this.mainSegmentLoader_.playlist(media, this.requestOptions_);
                    this.mainSegmentLoader_.load();
                    this.tech_.trigger({
                        type: "mediachange",
                        bubbles: true
                    });
                }));
                this.mainPlaylistLoader_.on("playlistunchanged", (() => {
                    const updatedPlaylist = this.mainPlaylistLoader_.media();
                    if (updatedPlaylist.lastExcludeReason_ === "playlist-unchanged") return;
                    const playlistOutdated = this.stuckAtPlaylistEnd_(updatedPlaylist);
                    if (playlistOutdated) {
                        this.excludePlaylist({
                            error: {
                                message: "Playlist no longer updating.",
                                reason: "playlist-unchanged"
                            }
                        });
                        this.tech_.trigger("playliststuck");
                    }
                }));
                this.mainPlaylistLoader_.on("renditiondisabled", (() => {
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-rendition-disabled"
                    });
                }));
                this.mainPlaylistLoader_.on("renditionenabled", (() => {
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-rendition-enabled"
                    });
                }));
            }
            handleUpdatedMediaPlaylist(updatedPlaylist) {
                if (this.useCueTags_) this.updateAdCues_(updatedPlaylist);
                this.mainSegmentLoader_.playlist(updatedPlaylist, this.requestOptions_);
                this.updateDuration(!updatedPlaylist.endList);
                if (!this.tech_.paused()) {
                    this.mainSegmentLoader_.load();
                    if (this.audioSegmentLoader_) this.audioSegmentLoader_.load();
                }
            }
            triggerPresenceUsage_(main, media) {
                const mediaGroups = main.mediaGroups || {};
                let defaultDemuxed = true;
                const audioGroupKeys = Object.keys(mediaGroups.AUDIO);
                for (const mediaGroup in mediaGroups.AUDIO) for (const label in mediaGroups.AUDIO[mediaGroup]) {
                    const properties = mediaGroups.AUDIO[mediaGroup][label];
                    if (!properties.uri) defaultDemuxed = false;
                }
                if (defaultDemuxed) this.tech_.trigger({
                    type: "usage",
                    name: "vhs-demuxed"
                });
                if (Object.keys(mediaGroups.SUBTITLES).length) this.tech_.trigger({
                    type: "usage",
                    name: "vhs-webvtt"
                });
                if (Vhs$1.Playlist.isAes(media)) this.tech_.trigger({
                    type: "usage",
                    name: "vhs-aes"
                });
                if (audioGroupKeys.length && Object.keys(mediaGroups.AUDIO[audioGroupKeys[0]]).length > 1) this.tech_.trigger({
                    type: "usage",
                    name: "vhs-alternate-audio"
                });
                if (this.useCueTags_) this.tech_.trigger({
                    type: "usage",
                    name: "vhs-playlist-cue-tags"
                });
            }
            shouldSwitchToMedia_(nextPlaylist) {
                const currentPlaylist = this.mainPlaylistLoader_.media() || this.mainPlaylistLoader_.pendingMedia_;
                const currentTime = this.tech_.currentTime();
                const bufferLowWaterLine = this.bufferLowWaterLine();
                const bufferHighWaterLine = this.bufferHighWaterLine();
                const buffered = this.tech_.buffered();
                return shouldSwitchToMedia({
                    buffered,
                    currentTime,
                    currentPlaylist,
                    nextPlaylist,
                    bufferLowWaterLine,
                    bufferHighWaterLine,
                    duration: this.duration(),
                    bufferBasedABR: this.bufferBasedABR,
                    log: this.logger_
                });
            }
            setupSegmentLoaderListeners_() {
                this.mainSegmentLoader_.on("bandwidthupdate", (() => {
                    this.checkABR_("bandwidthupdate");
                    this.tech_.trigger("bandwidthupdate");
                }));
                this.mainSegmentLoader_.on("timeout", (() => {
                    if (this.bufferBasedABR) this.mainSegmentLoader_.load();
                }));
                if (!this.bufferBasedABR) this.mainSegmentLoader_.on("progress", (() => {
                    this.trigger("progress");
                }));
                this.mainSegmentLoader_.on("error", (() => {
                    const error = this.mainSegmentLoader_.error();
                    this.excludePlaylist({
                        playlistToExclude: error.playlist,
                        error
                    });
                }));
                this.mainSegmentLoader_.on("appenderror", (() => {
                    this.error = this.mainSegmentLoader_.error_;
                    this.trigger("error");
                }));
                this.mainSegmentLoader_.on("syncinfoupdate", (() => {
                    this.onSyncInfoUpdate_();
                }));
                this.mainSegmentLoader_.on("timestampoffset", (() => {
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-timestamp-offset"
                    });
                }));
                this.audioSegmentLoader_.on("syncinfoupdate", (() => {
                    this.onSyncInfoUpdate_();
                }));
                this.audioSegmentLoader_.on("appenderror", (() => {
                    this.error = this.audioSegmentLoader_.error_;
                    this.trigger("error");
                }));
                this.mainSegmentLoader_.on("ended", (() => {
                    this.logger_("main segment loader ended");
                    this.onEndOfStream();
                }));
                this.mainSegmentLoader_.on("earlyabort", (event => {
                    if (this.bufferBasedABR) return;
                    this.delegateLoaders_("all", [ "abort" ]);
                    this.excludePlaylist({
                        error: {
                            message: "Aborted early because there isn't enough bandwidth to complete " + "the request without rebuffering."
                        },
                        playlistExclusionDuration: ABORT_EARLY_EXCLUSION_SECONDS
                    });
                }));
                const updateCodecs = () => {
                    if (!this.sourceUpdater_.hasCreatedSourceBuffers()) return this.tryToCreateSourceBuffers_();
                    const codecs = this.getCodecsOrExclude_();
                    if (!codecs) return;
                    this.sourceUpdater_.addOrChangeSourceBuffers(codecs);
                };
                this.mainSegmentLoader_.on("trackinfo", updateCodecs);
                this.audioSegmentLoader_.on("trackinfo", updateCodecs);
                this.mainSegmentLoader_.on("fmp4", (() => {
                    if (!this.triggeredFmp4Usage) {
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-fmp4"
                        });
                        this.triggeredFmp4Usage = true;
                    }
                }));
                this.audioSegmentLoader_.on("fmp4", (() => {
                    if (!this.triggeredFmp4Usage) {
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-fmp4"
                        });
                        this.triggeredFmp4Usage = true;
                    }
                }));
                this.audioSegmentLoader_.on("ended", (() => {
                    this.logger_("audioSegmentLoader ended");
                    this.onEndOfStream();
                }));
            }
            mediaSecondsLoaded_() {
                return Math.max(this.audioSegmentLoader_.mediaSecondsLoaded + this.mainSegmentLoader_.mediaSecondsLoaded);
            }
            load() {
                this.mainSegmentLoader_.load();
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) this.audioSegmentLoader_.load();
                if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) this.subtitleSegmentLoader_.load();
            }
            fastQualityChange_(media = this.selectPlaylist()) {
                if (media === this.mainPlaylistLoader_.media()) {
                    this.logger_("skipping fastQualityChange because new media is same as old");
                    return;
                }
                this.switchMedia_(media, "fast-quality");
                this.mainSegmentLoader_.resetEverything((() => {
                    if (videojs.browser.IE_VERSION || videojs.browser.IS_EDGE) this.tech_.setCurrentTime(this.tech_.currentTime() + .04); else this.tech_.setCurrentTime(this.tech_.currentTime());
                }));
            }
            play() {
                if (this.setupFirstPlay()) return;
                if (this.tech_.ended()) this.tech_.setCurrentTime(0);
                if (this.hasPlayed_) this.load();
                const seekable = this.tech_.seekable();
                if (this.tech_.duration() === 1 / 0) if (this.tech_.currentTime() < seekable.start(0)) return this.tech_.setCurrentTime(seekable.end(seekable.length - 1));
            }
            setupFirstPlay() {
                const media = this.mainPlaylistLoader_.media();
                if (!media || this.tech_.paused() || this.hasPlayed_) return false;
                if (!media.endList) {
                    const seekable = this.seekable();
                    if (!seekable.length) return false;
                    if (videojs.browser.IE_VERSION && this.tech_.readyState() === 0) {
                        this.tech_.one("loadedmetadata", (() => {
                            this.trigger("firstplay");
                            this.tech_.setCurrentTime(seekable.end(0));
                            this.hasPlayed_ = true;
                        }));
                        return false;
                    }
                    this.trigger("firstplay");
                    this.tech_.setCurrentTime(seekable.end(0));
                }
                this.hasPlayed_ = true;
                this.load();
                return true;
            }
            handleSourceOpen_() {
                this.tryToCreateSourceBuffers_();
                if (this.tech_.autoplay()) {
                    const playPromise = this.tech_.play();
                    if (typeof playPromise !== "undefined" && typeof playPromise.then === "function") playPromise.then(null, (e => {}));
                }
                this.trigger("sourceopen");
            }
            handleSourceEnded_() {
                if (!this.inbandTextTracks_.metadataTrack_) return;
                const cues = this.inbandTextTracks_.metadataTrack_.cues;
                if (!cues || !cues.length) return;
                const duration = this.duration();
                cues[cues.length - 1].endTime = isNaN(duration) || Math.abs(duration) === 1 / 0 ? Number.MAX_VALUE : duration;
            }
            handleDurationChange_() {
                this.tech_.trigger("durationchange");
            }
            onEndOfStream() {
                let isEndOfStream = this.mainSegmentLoader_.ended_;
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                    const mainMediaInfo = this.mainSegmentLoader_.getCurrentMediaInfo_();
                    if (!mainMediaInfo || mainMediaInfo.hasVideo) isEndOfStream = isEndOfStream && this.audioSegmentLoader_.ended_; else isEndOfStream = this.audioSegmentLoader_.ended_;
                }
                if (!isEndOfStream) return;
                this.stopABRTimer_();
                this.sourceUpdater_.endOfStream();
            }
            stuckAtPlaylistEnd_(playlist) {
                const seekable = this.seekable();
                if (!seekable.length) return false;
                const expired = this.syncController_.getExpiredTime(playlist, this.duration());
                if (expired === null) return false;
                const absolutePlaylistEnd = Vhs$1.Playlist.playlistEnd(playlist, expired);
                const currentTime = this.tech_.currentTime();
                const buffered = this.tech_.buffered();
                if (!buffered.length) return absolutePlaylistEnd - currentTime <= SAFE_TIME_DELTA;
                const bufferedEnd = buffered.end(buffered.length - 1);
                return bufferedEnd - currentTime <= SAFE_TIME_DELTA && absolutePlaylistEnd - bufferedEnd <= SAFE_TIME_DELTA;
            }
            excludePlaylist({playlistToExclude = this.mainPlaylistLoader_.media(), error = {}, playlistExclusionDuration}) {
                playlistToExclude = playlistToExclude || this.mainPlaylistLoader_.media();
                playlistExclusionDuration = playlistExclusionDuration || error.playlistExclusionDuration || this.playlistExclusionDuration;
                if (!playlistToExclude) {
                    this.error = error;
                    if (this.mediaSource.readyState !== "open") this.trigger("error"); else this.sourceUpdater_.endOfStream("network");
                    return;
                }
                playlistToExclude.playlistErrors_++;
                const playlists = this.mainPlaylistLoader_.main.playlists;
                const enabledPlaylists = playlists.filter(isEnabled);
                const isFinalRendition = enabledPlaylists.length === 1 && enabledPlaylists[0] === playlistToExclude;
                if (playlists.length === 1 && playlistExclusionDuration !== 1 / 0) {
                    videojs.log.warn(`Problem encountered with playlist ${playlistToExclude.id}. ` + "Trying again since it is the only playlist.");
                    this.tech_.trigger("retryplaylist");
                    return this.mainPlaylistLoader_.load(isFinalRendition);
                }
                if (isFinalRendition) {
                    let reincluded = false;
                    playlists.forEach((playlist => {
                        if (playlist === playlistToExclude) return;
                        const excludeUntil = playlist.excludeUntil;
                        if (typeof excludeUntil !== "undefined" && excludeUntil !== 1 / 0) {
                            reincluded = true;
                            delete playlist.excludeUntil;
                        }
                    }));
                    if (reincluded) {
                        videojs.log.warn("Removing other playlists from the exclusion list because the last " + "rendition is about to be excluded.");
                        this.tech_.trigger("retryplaylist");
                    }
                }
                let excludeUntil;
                if (playlistToExclude.playlistErrors_ > this.maxPlaylistRetries) excludeUntil = 1 / 0; else excludeUntil = Date.now() + playlistExclusionDuration * 1e3;
                playlistToExclude.excludeUntil = excludeUntil;
                if (error.reason) playlistToExclude.lastExcludeReason_ = error.reason;
                this.tech_.trigger("excludeplaylist");
                this.tech_.trigger({
                    type: "usage",
                    name: "vhs-rendition-excluded"
                });
                const nextPlaylist = this.selectPlaylist();
                if (!nextPlaylist) {
                    this.error = "Playback cannot continue. No available working or supported playlists.";
                    this.trigger("error");
                    return;
                }
                const logFn = error.internal ? this.logger_ : videojs.log.warn;
                const errorMessage = error.message ? " " + error.message : "";
                logFn(`${error.internal ? "Internal problem" : "Problem"} encountered with playlist ${playlistToExclude.id}.` + `${errorMessage} Switching to playlist ${nextPlaylist.id}.`);
                if (nextPlaylist.attributes.AUDIO !== playlistToExclude.attributes.AUDIO) this.delegateLoaders_("audio", [ "abort", "pause" ]);
                if (nextPlaylist.attributes.SUBTITLES !== playlistToExclude.attributes.SUBTITLES) this.delegateLoaders_("subtitle", [ "abort", "pause" ]);
                this.delegateLoaders_("main", [ "abort", "pause" ]);
                const delayDuration = nextPlaylist.targetDuration / 2 * 1e3 || 5 * 1e3;
                const shouldDelay = typeof nextPlaylist.lastRequest === "number" && Date.now() - nextPlaylist.lastRequest <= delayDuration;
                return this.switchMedia_(nextPlaylist, "exclude", isFinalRendition || shouldDelay);
            }
            pauseLoading() {
                this.delegateLoaders_("all", [ "abort", "pause" ]);
                this.stopABRTimer_();
            }
            delegateLoaders_(filter, fnNames) {
                const loaders = [];
                const dontFilterPlaylist = filter === "all";
                if (dontFilterPlaylist || filter === "main") loaders.push(this.mainPlaylistLoader_);
                const mediaTypes = [];
                if (dontFilterPlaylist || filter === "audio") mediaTypes.push("AUDIO");
                if (dontFilterPlaylist || filter === "subtitle") {
                    mediaTypes.push("CLOSED-CAPTIONS");
                    mediaTypes.push("SUBTITLES");
                }
                mediaTypes.forEach((mediaType => {
                    const loader = this.mediaTypes_[mediaType] && this.mediaTypes_[mediaType].activePlaylistLoader;
                    if (loader) loaders.push(loader);
                }));
                [ "main", "audio", "subtitle" ].forEach((name => {
                    const loader = this[`${name}SegmentLoader_`];
                    if (loader && (filter === name || filter === "all")) loaders.push(loader);
                }));
                loaders.forEach((loader => fnNames.forEach((fnName => {
                    if (typeof loader[fnName] === "function") loader[fnName]();
                }))));
            }
            setCurrentTime(currentTime) {
                const buffered = findRange(this.tech_.buffered(), currentTime);
                if (!(this.mainPlaylistLoader_ && this.mainPlaylistLoader_.media())) return 0;
                if (!this.mainPlaylistLoader_.media().segments) return 0;
                if (buffered && buffered.length) return currentTime;
                this.mainSegmentLoader_.resetEverything();
                this.mainSegmentLoader_.abort();
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                    this.audioSegmentLoader_.resetEverything();
                    this.audioSegmentLoader_.abort();
                }
                if (this.mediaTypes_.SUBTITLES.activePlaylistLoader) {
                    this.subtitleSegmentLoader_.resetEverything();
                    this.subtitleSegmentLoader_.abort();
                }
                this.load();
            }
            duration() {
                if (!this.mainPlaylistLoader_) return 0;
                const media = this.mainPlaylistLoader_.media();
                if (!media) return 0;
                if (!media.endList) return 1 / 0;
                if (this.mediaSource) return this.mediaSource.duration;
                return Vhs$1.Playlist.duration(media);
            }
            seekable() {
                return this.seekable_;
            }
            onSyncInfoUpdate_() {
                let audioSeekable;
                if (!this.mainPlaylistLoader_) return;
                let media = this.mainPlaylistLoader_.media();
                if (!media) return;
                let expired = this.syncController_.getExpiredTime(media, this.duration());
                if (expired === null) return;
                const main = this.mainPlaylistLoader_.main;
                const mainSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main, media));
                if (mainSeekable.length === 0) return;
                if (this.mediaTypes_.AUDIO.activePlaylistLoader) {
                    media = this.mediaTypes_.AUDIO.activePlaylistLoader.media();
                    expired = this.syncController_.getExpiredTime(media, this.duration());
                    if (expired === null) return;
                    audioSeekable = Vhs$1.Playlist.seekable(media, expired, Vhs$1.Playlist.liveEdgeDelay(main, media));
                    if (audioSeekable.length === 0) return;
                }
                let oldEnd;
                let oldStart;
                if (this.seekable_ && this.seekable_.length) {
                    oldEnd = this.seekable_.end(0);
                    oldStart = this.seekable_.start(0);
                }
                if (!audioSeekable) this.seekable_ = mainSeekable; else if (audioSeekable.start(0) > mainSeekable.end(0) || mainSeekable.start(0) > audioSeekable.end(0)) this.seekable_ = mainSeekable; else this.seekable_ = createTimeRanges([ [ audioSeekable.start(0) > mainSeekable.start(0) ? audioSeekable.start(0) : mainSeekable.start(0), audioSeekable.end(0) < mainSeekable.end(0) ? audioSeekable.end(0) : mainSeekable.end(0) ] ]);
                if (this.seekable_ && this.seekable_.length) if (this.seekable_.end(0) === oldEnd && this.seekable_.start(0) === oldStart) return;
                this.logger_(`seekable updated [${printableRange(this.seekable_)}]`);
                this.tech_.trigger("seekablechanged");
            }
            updateDuration(isLive) {
                if (this.updateDuration_) {
                    this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
                    this.updateDuration_ = null;
                }
                if (this.mediaSource.readyState !== "open") {
                    this.updateDuration_ = this.updateDuration.bind(this, isLive);
                    this.mediaSource.addEventListener("sourceopen", this.updateDuration_);
                    return;
                }
                if (isLive) {
                    const seekable = this.seekable();
                    if (!seekable.length) return;
                    if (isNaN(this.mediaSource.duration) || this.mediaSource.duration < seekable.end(seekable.length - 1)) this.sourceUpdater_.setDuration(seekable.end(seekable.length - 1));
                    return;
                }
                const buffered = this.tech_.buffered();
                let duration = Vhs$1.Playlist.duration(this.mainPlaylistLoader_.media());
                if (buffered.length > 0) duration = Math.max(duration, buffered.end(buffered.length - 1));
                if (this.mediaSource.duration !== duration) this.sourceUpdater_.setDuration(duration);
            }
            dispose() {
                this.trigger("dispose");
                this.decrypter_.terminate();
                this.mainPlaylistLoader_.dispose();
                this.mainSegmentLoader_.dispose();
                if (this.loadOnPlay_) this.tech_.off("play", this.loadOnPlay_);
                [ "AUDIO", "SUBTITLES" ].forEach((type => {
                    const groups = this.mediaTypes_[type].groups;
                    for (const id in groups) groups[id].forEach((group => {
                        if (group.playlistLoader) group.playlistLoader.dispose();
                    }));
                }));
                this.audioSegmentLoader_.dispose();
                this.subtitleSegmentLoader_.dispose();
                this.sourceUpdater_.dispose();
                this.timelineChangeController_.dispose();
                this.stopABRTimer_();
                if (this.updateDuration_) this.mediaSource.removeEventListener("sourceopen", this.updateDuration_);
                this.mediaSource.removeEventListener("durationchange", this.handleDurationChange_);
                this.mediaSource.removeEventListener("sourceopen", this.handleSourceOpen_);
                this.mediaSource.removeEventListener("sourceended", this.handleSourceEnded_);
                this.off();
            }
            main() {
                return this.mainPlaylistLoader_.main;
            }
            media() {
                return this.mainPlaylistLoader_.media() || this.initialMedia_;
            }
            areMediaTypesKnown_() {
                const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
                const hasMainMediaInfo = !!this.mainSegmentLoader_.getCurrentMediaInfo_();
                const hasAudioMediaInfo = !usingAudioLoader ? true : !!this.audioSegmentLoader_.getCurrentMediaInfo_();
                if (!hasMainMediaInfo || !hasAudioMediaInfo) return false;
                return true;
            }
            getCodecsOrExclude_() {
                const media = {
                    main: this.mainSegmentLoader_.getCurrentMediaInfo_() || {},
                    audio: this.audioSegmentLoader_.getCurrentMediaInfo_() || {}
                };
                const playlist = this.mainSegmentLoader_.getPendingSegmentPlaylist() || this.media();
                media.video = media.main;
                const playlistCodecs = codecsForPlaylist(this.main(), playlist);
                const codecs = {};
                const usingAudioLoader = !!this.mediaTypes_.AUDIO.activePlaylistLoader;
                if (media.main.hasVideo) codecs.video = playlistCodecs.video || media.main.videoCodec || DEFAULT_VIDEO_CODEC;
                if (media.main.isMuxed) codecs.video += `,${playlistCodecs.audio || media.main.audioCodec || DEFAULT_AUDIO_CODEC}`;
                if (media.main.hasAudio && !media.main.isMuxed || media.audio.hasAudio || usingAudioLoader) {
                    codecs.audio = playlistCodecs.audio || media.main.audioCodec || media.audio.audioCodec || DEFAULT_AUDIO_CODEC;
                    media.audio.isFmp4 = media.main.hasAudio && !media.main.isMuxed ? media.main.isFmp4 : media.audio.isFmp4;
                }
                if (!codecs.audio && !codecs.video) {
                    this.excludePlaylist({
                        playlistToExclude: playlist,
                        error: {
                            message: "Could not determine codecs for playlist."
                        },
                        playlistExclusionDuration: 1 / 0
                    });
                    return;
                }
                const supportFunction = (isFmp4, codec) => isFmp4 ? browserSupportsCodec(codec) : muxerSupportsCodec(codec);
                const unsupportedCodecs = {};
                let unsupportedAudio;
                [ "video", "audio" ].forEach((function(type) {
                    if (codecs.hasOwnProperty(type) && !supportFunction(media[type].isFmp4, codecs[type])) {
                        const supporter = media[type].isFmp4 ? "browser" : "muxer";
                        unsupportedCodecs[supporter] = unsupportedCodecs[supporter] || [];
                        unsupportedCodecs[supporter].push(codecs[type]);
                        if (type === "audio") unsupportedAudio = supporter;
                    }
                }));
                if (usingAudioLoader && unsupportedAudio && playlist.attributes.AUDIO) {
                    const audioGroup = playlist.attributes.AUDIO;
                    this.main().playlists.forEach((variant => {
                        const variantAudioGroup = variant.attributes && variant.attributes.AUDIO;
                        if (variantAudioGroup === audioGroup && variant !== playlist) variant.excludeUntil = 1 / 0;
                    }));
                    this.logger_(`excluding audio group ${audioGroup} as ${unsupportedAudio} does not support codec(s): "${codecs.audio}"`);
                }
                if (Object.keys(unsupportedCodecs).length) {
                    const message = Object.keys(unsupportedCodecs).reduce(((acc, supporter) => {
                        if (acc) acc += ", ";
                        acc += `${supporter} does not support codec(s): "${unsupportedCodecs[supporter].join(",")}"`;
                        return acc;
                    }), "") + ".";
                    this.excludePlaylist({
                        playlistToExclude: playlist,
                        error: {
                            internal: true,
                            message
                        },
                        playlistExclusionDuration: 1 / 0
                    });
                    return;
                }
                if (this.sourceUpdater_.hasCreatedSourceBuffers() && !this.sourceUpdater_.canChangeType()) {
                    const switchMessages = [];
                    [ "video", "audio" ].forEach((type => {
                        const newCodec = (parseCodecs(this.sourceUpdater_.codecs[type] || "")[0] || {}).type;
                        const oldCodec = (parseCodecs(codecs[type] || "")[0] || {}).type;
                        if (newCodec && oldCodec && newCodec.toLowerCase() !== oldCodec.toLowerCase()) switchMessages.push(`"${this.sourceUpdater_.codecs[type]}" -> "${codecs[type]}"`);
                    }));
                    if (switchMessages.length) {
                        this.excludePlaylist({
                            playlistToExclude: playlist,
                            error: {
                                message: `Codec switching not supported: ${switchMessages.join(", ")}.`,
                                internal: true
                            },
                            playlistExclusionDuration: 1 / 0
                        });
                        return;
                    }
                }
                return codecs;
            }
            tryToCreateSourceBuffers_() {
                if (this.mediaSource.readyState !== "open" || this.sourceUpdater_.hasCreatedSourceBuffers()) return;
                if (!this.areMediaTypesKnown_()) return;
                const codecs = this.getCodecsOrExclude_();
                if (!codecs) return;
                this.sourceUpdater_.createSourceBuffers(codecs);
                const codecString = [ codecs.video, codecs.audio ].filter(Boolean).join(",");
                this.excludeIncompatibleVariants_(codecString);
            }
            excludeUnsupportedVariants_() {
                const playlists = this.main().playlists;
                const ids = [];
                Object.keys(playlists).forEach((key => {
                    const variant = playlists[key];
                    if (ids.indexOf(variant.id) !== -1) return;
                    ids.push(variant.id);
                    const codecs = codecsForPlaylist(this.main, variant);
                    const unsupported = [];
                    if (codecs.audio && !muxerSupportsCodec(codecs.audio) && !browserSupportsCodec(codecs.audio)) unsupported.push(`audio codec ${codecs.audio}`);
                    if (codecs.video && !muxerSupportsCodec(codecs.video) && !browserSupportsCodec(codecs.video)) unsupported.push(`video codec ${codecs.video}`);
                    if (codecs.text && codecs.text === "stpp.ttml.im1t") unsupported.push(`text codec ${codecs.text}`);
                    if (unsupported.length) {
                        variant.excludeUntil = 1 / 0;
                        this.logger_(`excluding ${variant.id} for unsupported: ${unsupported.join(", ")}`);
                    }
                }));
            }
            excludeIncompatibleVariants_(codecString) {
                const ids = [];
                const playlists = this.main().playlists;
                const codecs = unwrapCodecList(parseCodecs(codecString));
                const codecCount_ = codecCount(codecs);
                const videoDetails = codecs.video && parseCodecs(codecs.video)[0] || null;
                const audioDetails = codecs.audio && parseCodecs(codecs.audio)[0] || null;
                Object.keys(playlists).forEach((key => {
                    const variant = playlists[key];
                    if (ids.indexOf(variant.id) !== -1 || variant.excludeUntil === 1 / 0) return;
                    ids.push(variant.id);
                    const exclusionReasons = [];
                    const variantCodecs = codecsForPlaylist(this.mainPlaylistLoader_.main, variant);
                    const variantCodecCount = codecCount(variantCodecs);
                    if (!variantCodecs.audio && !variantCodecs.video) return;
                    if (variantCodecCount !== codecCount_) exclusionReasons.push(`codec count "${variantCodecCount}" !== "${codecCount_}"`);
                    if (!this.sourceUpdater_.canChangeType()) {
                        const variantVideoDetails = variantCodecs.video && parseCodecs(variantCodecs.video)[0] || null;
                        const variantAudioDetails = variantCodecs.audio && parseCodecs(variantCodecs.audio)[0] || null;
                        if (variantVideoDetails && videoDetails && variantVideoDetails.type.toLowerCase() !== videoDetails.type.toLowerCase()) exclusionReasons.push(`video codec "${variantVideoDetails.type}" !== "${videoDetails.type}"`);
                        if (variantAudioDetails && audioDetails && variantAudioDetails.type.toLowerCase() !== audioDetails.type.toLowerCase()) exclusionReasons.push(`audio codec "${variantAudioDetails.type}" !== "${audioDetails.type}"`);
                    }
                    if (exclusionReasons.length) {
                        variant.excludeUntil = 1 / 0;
                        this.logger_(`excluding ${variant.id}: ${exclusionReasons.join(" && ")}`);
                    }
                }));
            }
            updateAdCues_(media) {
                let offset = 0;
                const seekable = this.seekable();
                if (seekable.length) offset = seekable.start(0);
                updateAdCues(media, this.cueTagsTrack_, offset);
            }
            goalBufferLength() {
                const currentTime = this.tech_.currentTime();
                const initial = Config.GOAL_BUFFER_LENGTH;
                const rate = Config.GOAL_BUFFER_LENGTH_RATE;
                const max = Math.max(initial, Config.MAX_GOAL_BUFFER_LENGTH);
                return Math.min(initial + currentTime * rate, max);
            }
            bufferLowWaterLine() {
                const currentTime = this.tech_.currentTime();
                const initial = Config.BUFFER_LOW_WATER_LINE;
                const rate = Config.BUFFER_LOW_WATER_LINE_RATE;
                const max = Math.max(initial, Config.MAX_BUFFER_LOW_WATER_LINE);
                const newMax = Math.max(initial, Config.EXPERIMENTAL_MAX_BUFFER_LOW_WATER_LINE);
                return Math.min(initial + currentTime * rate, this.bufferBasedABR ? newMax : max);
            }
            bufferHighWaterLine() {
                return Config.BUFFER_HIGH_WATER_LINE;
            }
        }
        const enableFunction = (loader, playlistID, changePlaylistFn) => enable => {
            const playlist = loader.main.playlists[playlistID];
            const incompatible = isIncompatible(playlist);
            const currentlyEnabled = isEnabled(playlist);
            if (typeof enable === "undefined") return currentlyEnabled;
            if (enable) delete playlist.disabled; else playlist.disabled = true;
            if (enable !== currentlyEnabled && !incompatible) {
                changePlaylistFn();
                if (enable) loader.trigger("renditionenabled"); else loader.trigger("renditiondisabled");
            }
            return enable;
        };
        class Representation {
            constructor(vhsHandler, playlist, id) {
                const {playlistController_: pc} = vhsHandler;
                const qualityChangeFunction = pc.fastQualityChange_.bind(pc);
                if (playlist.attributes) {
                    const resolution = playlist.attributes.RESOLUTION;
                    this.width = resolution && resolution.width;
                    this.height = resolution && resolution.height;
                    this.bandwidth = playlist.attributes.BANDWIDTH;
                    this.frameRate = playlist.attributes["FRAME-RATE"];
                }
                this.codecs = codecsForPlaylist(pc.main(), playlist);
                this.playlist = playlist;
                this.id = id;
                this.enabled = enableFunction(vhsHandler.playlists, playlist.id, qualityChangeFunction);
            }
        }
        const renditionSelectionMixin = function(vhsHandler) {
            vhsHandler.representations = () => {
                const main = vhsHandler.playlistController_.main();
                const playlists = isAudioOnly(main) ? vhsHandler.playlistController_.getAudioTrackPlaylists_() : main.playlists;
                if (!playlists) return [];
                return playlists.filter((media => !isIncompatible(media))).map(((e, i) => new Representation(vhsHandler, e, e.id)));
            };
        };
        const timerCancelEvents = [ "seeking", "seeked", "pause", "playing", "error" ];
        class PlaybackWatcher {
            constructor(options) {
                this.playlistController_ = options.playlistController;
                this.tech_ = options.tech;
                this.seekable = options.seekable;
                this.allowSeeksWithinUnsafeLiveWindow = options.allowSeeksWithinUnsafeLiveWindow;
                this.liveRangeSafeTimeDelta = options.liveRangeSafeTimeDelta;
                this.media = options.media;
                this.consecutiveUpdates = 0;
                this.lastRecordedTime = null;
                this.checkCurrentTimeTimeout_ = null;
                this.logger_ = logger("PlaybackWatcher");
                this.logger_("initialize");
                const playHandler = () => this.monitorCurrentTime_();
                const canPlayHandler = () => this.monitorCurrentTime_();
                const waitingHandler = () => this.techWaiting_();
                const cancelTimerHandler = () => this.resetTimeUpdate_();
                const pc = this.playlistController_;
                const loaderTypes = [ "main", "subtitle", "audio" ];
                const loaderChecks = {};
                loaderTypes.forEach((type => {
                    loaderChecks[type] = {
                        reset: () => this.resetSegmentDownloads_(type),
                        updateend: () => this.checkSegmentDownloads_(type)
                    };
                    pc[`${type}SegmentLoader_`].on("appendsdone", loaderChecks[type].updateend);
                    pc[`${type}SegmentLoader_`].on("playlistupdate", loaderChecks[type].reset);
                    this.tech_.on([ "seeked", "seeking" ], loaderChecks[type].reset);
                }));
                const setSeekingHandlers = fn => {
                    [ "main", "audio" ].forEach((type => {
                        pc[`${type}SegmentLoader_`][fn]("appended", this.seekingAppendCheck_);
                    }));
                };
                this.seekingAppendCheck_ = () => {
                    if (this.fixesBadSeeks_()) {
                        this.consecutiveUpdates = 0;
                        this.lastRecordedTime = this.tech_.currentTime();
                        setSeekingHandlers("off");
                    }
                };
                this.clearSeekingAppendCheck_ = () => setSeekingHandlers("off");
                this.watchForBadSeeking_ = () => {
                    this.clearSeekingAppendCheck_();
                    setSeekingHandlers("on");
                };
                this.tech_.on("seeked", this.clearSeekingAppendCheck_);
                this.tech_.on("seeking", this.watchForBadSeeking_);
                this.tech_.on("waiting", waitingHandler);
                this.tech_.on(timerCancelEvents, cancelTimerHandler);
                this.tech_.on("canplay", canPlayHandler);
                this.tech_.one("play", playHandler);
                this.dispose = () => {
                    this.clearSeekingAppendCheck_();
                    this.logger_("dispose");
                    this.tech_.off("waiting", waitingHandler);
                    this.tech_.off(timerCancelEvents, cancelTimerHandler);
                    this.tech_.off("canplay", canPlayHandler);
                    this.tech_.off("play", playHandler);
                    this.tech_.off("seeking", this.watchForBadSeeking_);
                    this.tech_.off("seeked", this.clearSeekingAppendCheck_);
                    loaderTypes.forEach((type => {
                        pc[`${type}SegmentLoader_`].off("appendsdone", loaderChecks[type].updateend);
                        pc[`${type}SegmentLoader_`].off("playlistupdate", loaderChecks[type].reset);
                        this.tech_.off([ "seeked", "seeking" ], loaderChecks[type].reset);
                    }));
                    if (this.checkCurrentTimeTimeout_) window_default().clearTimeout(this.checkCurrentTimeTimeout_);
                    this.resetTimeUpdate_();
                };
            }
            monitorCurrentTime_() {
                this.checkCurrentTime_();
                if (this.checkCurrentTimeTimeout_) window_default().clearTimeout(this.checkCurrentTimeTimeout_);
                this.checkCurrentTimeTimeout_ = window_default().setTimeout(this.monitorCurrentTime_.bind(this), 250);
            }
            resetSegmentDownloads_(type) {
                const loader = this.playlistController_[`${type}SegmentLoader_`];
                if (this[`${type}StalledDownloads_`] > 0) this.logger_(`resetting possible stalled download count for ${type} loader`);
                this[`${type}StalledDownloads_`] = 0;
                this[`${type}Buffered_`] = loader.buffered_();
            }
            checkSegmentDownloads_(type) {
                const pc = this.playlistController_;
                const loader = pc[`${type}SegmentLoader_`];
                const buffered = loader.buffered_();
                const isBufferedDifferent = isRangeDifferent(this[`${type}Buffered_`], buffered);
                this[`${type}Buffered_`] = buffered;
                if (isBufferedDifferent) {
                    this.resetSegmentDownloads_(type);
                    return;
                }
                this[`${type}StalledDownloads_`]++;
                this.logger_(`found #${this[`${type}StalledDownloads_`]} ${type} appends that did not increase buffer (possible stalled download)`, {
                    playlistId: loader.playlist_ && loader.playlist_.id,
                    buffered: timeRangesToArray(buffered)
                });
                if (this[`${type}StalledDownloads_`] < 10) return;
                this.logger_(`${type} loader stalled download exclusion`);
                this.resetSegmentDownloads_(type);
                this.tech_.trigger({
                    type: "usage",
                    name: `vhs-${type}-download-exclusion`
                });
                if (type === "subtitle") return;
                pc.excludePlaylist({
                    error: {
                        message: `Excessive ${type} segment downloading detected.`
                    },
                    playlistExclusionDuration: 1 / 0
                });
            }
            checkCurrentTime_() {
                if (this.tech_.paused() || this.tech_.seeking()) return;
                const currentTime = this.tech_.currentTime();
                const buffered = this.tech_.buffered();
                if (this.lastRecordedTime === currentTime && (!buffered.length || currentTime + SAFE_TIME_DELTA >= buffered.end(buffered.length - 1))) return this.techWaiting_();
                if (this.consecutiveUpdates >= 5 && currentTime === this.lastRecordedTime) {
                    this.consecutiveUpdates++;
                    this.waiting_();
                } else if (currentTime === this.lastRecordedTime) this.consecutiveUpdates++; else {
                    this.consecutiveUpdates = 0;
                    this.lastRecordedTime = currentTime;
                }
            }
            resetTimeUpdate_() {
                this.consecutiveUpdates = 0;
            }
            fixesBadSeeks_() {
                const seeking = this.tech_.seeking();
                if (!seeking) return false;
                const seekable = this.seekable();
                const currentTime = this.tech_.currentTime();
                const isAfterSeekableRange = this.afterSeekableWindow_(seekable, currentTime, this.media(), this.allowSeeksWithinUnsafeLiveWindow);
                let seekTo;
                if (isAfterSeekableRange) {
                    const seekableEnd = seekable.end(seekable.length - 1);
                    seekTo = seekableEnd;
                }
                if (this.beforeSeekableWindow_(seekable, currentTime)) {
                    const seekableStart = seekable.start(0);
                    seekTo = seekableStart + (seekableStart === seekable.end(0) ? 0 : SAFE_TIME_DELTA);
                }
                if (typeof seekTo !== "undefined") {
                    this.logger_(`Trying to seek outside of seekable at time ${currentTime} with ` + `seekable range ${printableRange(seekable)}. Seeking to ` + `${seekTo}.`);
                    this.tech_.setCurrentTime(seekTo);
                    return true;
                }
                const sourceUpdater = this.playlistController_.sourceUpdater_;
                const buffered = this.tech_.buffered();
                const audioBuffered = sourceUpdater.audioBuffer ? sourceUpdater.audioBuffered() : null;
                const videoBuffered = sourceUpdater.videoBuffer ? sourceUpdater.videoBuffered() : null;
                const media = this.media();
                const minAppendedDuration = media.partTargetDuration ? media.partTargetDuration : (media.targetDuration - TIME_FUDGE_FACTOR) * 2;
                const bufferedToCheck = [ audioBuffered, videoBuffered ];
                for (let i = 0; i < bufferedToCheck.length; i++) {
                    if (!bufferedToCheck[i]) continue;
                    const timeAhead = timeAheadOf(bufferedToCheck[i], currentTime);
                    if (timeAhead < minAppendedDuration) return false;
                }
                const nextRange = findNextRange(buffered, currentTime);
                if (nextRange.length === 0) return false;
                seekTo = nextRange.start(0) + SAFE_TIME_DELTA;
                this.logger_(`Buffered region starts (${nextRange.start(0)}) ` + ` just beyond seek point (${currentTime}). Seeking to ${seekTo}.`);
                this.tech_.setCurrentTime(seekTo);
                return true;
            }
            waiting_() {
                if (this.techWaiting_()) return;
                const currentTime = this.tech_.currentTime();
                const buffered = this.tech_.buffered();
                const currentRange = findRange(buffered, currentTime);
                if (currentRange.length && currentTime + 3 <= currentRange.end(0)) {
                    this.resetTimeUpdate_();
                    this.tech_.setCurrentTime(currentTime);
                    this.logger_(`Stopped at ${currentTime} while inside a buffered region ` + `[${currentRange.start(0)} -> ${currentRange.end(0)}]. Attempting to resume ` + "playback by seeking to the current time.");
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-unknown-waiting"
                    });
                    return;
                }
            }
            techWaiting_() {
                const seekable = this.seekable();
                const currentTime = this.tech_.currentTime();
                if (this.tech_.seeking()) return true;
                if (this.beforeSeekableWindow_(seekable, currentTime)) {
                    const livePoint = seekable.end(seekable.length - 1);
                    this.logger_(`Fell out of live window at time ${currentTime}. Seeking to ` + `live point (seekable end) ${livePoint}`);
                    this.resetTimeUpdate_();
                    this.tech_.setCurrentTime(livePoint);
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-live-resync"
                    });
                    return true;
                }
                const sourceUpdater = this.tech_.vhs.playlistController_.sourceUpdater_;
                const buffered = this.tech_.buffered();
                const videoUnderflow = this.videoUnderflow_({
                    audioBuffered: sourceUpdater.audioBuffered(),
                    videoBuffered: sourceUpdater.videoBuffered(),
                    currentTime
                });
                if (videoUnderflow) {
                    this.resetTimeUpdate_();
                    this.tech_.setCurrentTime(currentTime);
                    this.tech_.trigger({
                        type: "usage",
                        name: "vhs-video-underflow"
                    });
                    return true;
                }
                const nextRange = findNextRange(buffered, currentTime);
                if (nextRange.length > 0) {
                    this.logger_(`Stopped at ${currentTime} and seeking to ${nextRange.start(0)}`);
                    this.resetTimeUpdate_();
                    this.skipTheGap_(currentTime);
                    return true;
                }
                return false;
            }
            afterSeekableWindow_(seekable, currentTime, playlist, allowSeeksWithinUnsafeLiveWindow = false) {
                if (!seekable.length) return false;
                let allowedEnd = seekable.end(seekable.length - 1) + SAFE_TIME_DELTA;
                const isLive = !playlist.endList;
                if (isLive && allowSeeksWithinUnsafeLiveWindow) allowedEnd = seekable.end(seekable.length - 1) + playlist.targetDuration * 3;
                if (currentTime > allowedEnd) return true;
                return false;
            }
            beforeSeekableWindow_(seekable, currentTime) {
                if (seekable.length && seekable.start(0) > 0 && currentTime < seekable.start(0) - this.liveRangeSafeTimeDelta) return true;
                return false;
            }
            videoUnderflow_({videoBuffered, audioBuffered, currentTime}) {
                if (!videoBuffered) return;
                let gap;
                if (videoBuffered.length && audioBuffered.length) {
                    const lastVideoRange = findRange(videoBuffered, currentTime - 3);
                    const videoRange = findRange(videoBuffered, currentTime);
                    const audioRange = findRange(audioBuffered, currentTime);
                    if (audioRange.length && !videoRange.length && lastVideoRange.length) gap = {
                        start: lastVideoRange.end(0),
                        end: audioRange.end(0)
                    };
                } else {
                    const nextRange = findNextRange(videoBuffered, currentTime);
                    if (!nextRange.length) gap = this.gapFromVideoUnderflow_(videoBuffered, currentTime);
                }
                if (gap) {
                    this.logger_(`Encountered a gap in video from ${gap.start} to ${gap.end}. ` + `Seeking to current time ${currentTime}`);
                    return true;
                }
                return false;
            }
            skipTheGap_(scheduledCurrentTime) {
                const buffered = this.tech_.buffered();
                const currentTime = this.tech_.currentTime();
                const nextRange = findNextRange(buffered, currentTime);
                this.resetTimeUpdate_();
                if (nextRange.length === 0 || currentTime !== scheduledCurrentTime) return;
                this.logger_("skipTheGap_:", "currentTime:", currentTime, "scheduled currentTime:", scheduledCurrentTime, "nextRange start:", nextRange.start(0));
                this.tech_.setCurrentTime(nextRange.start(0) + TIME_FUDGE_FACTOR);
                this.tech_.trigger({
                    type: "usage",
                    name: "vhs-gap-skip"
                });
            }
            gapFromVideoUnderflow_(buffered, currentTime) {
                const gaps = findGaps(buffered);
                for (let i = 0; i < gaps.length; i++) {
                    const start = gaps.start(i);
                    const end = gaps.end(i);
                    if (currentTime - start < 4 && currentTime - start > 2) return {
                        start,
                        end
                    };
                }
                return null;
            }
        }
        const defaultOptions = {
            errorInterval: 30,
            getSource(next) {
                const tech = this.tech({
                    IWillNotUseThisInPlugins: true
                });
                const sourceObj = tech.currentSource_ || this.currentSource();
                return next(sourceObj);
            }
        };
        const initPlugin = function(player, options) {
            let lastCalled = 0;
            let seekTo = 0;
            const localOptions = video_es_merge(defaultOptions, options);
            player.ready((() => {
                player.trigger({
                    type: "usage",
                    name: "vhs-error-reload-initialized"
                });
            }));
            const loadedMetadataHandler = function() {
                if (seekTo) player.currentTime(seekTo);
            };
            const setSource = function(sourceObj) {
                if (sourceObj === null || sourceObj === void 0) return;
                seekTo = player.duration() !== 1 / 0 && player.currentTime() || 0;
                player.one("loadedmetadata", loadedMetadataHandler);
                player.src(sourceObj);
                player.trigger({
                    type: "usage",
                    name: "vhs-error-reload"
                });
                player.play();
            };
            const errorHandler = function() {
                if (Date.now() - lastCalled < localOptions.errorInterval * 1e3) {
                    player.trigger({
                        type: "usage",
                        name: "vhs-error-reload-canceled"
                    });
                    return;
                }
                if (!localOptions.getSource || typeof localOptions.getSource !== "function") {
                    videojs.log.error("ERROR: reloadSourceOnError - The option getSource must be a function!");
                    return;
                }
                lastCalled = Date.now();
                return localOptions.getSource.call(player, setSource);
            };
            const cleanupEvents = function() {
                player.off("loadedmetadata", loadedMetadataHandler);
                player.off("error", errorHandler);
                player.off("dispose", cleanupEvents);
            };
            const reinitPlugin = function(newOptions) {
                cleanupEvents();
                initPlugin(player, newOptions);
            };
            player.on("error", errorHandler);
            player.on("dispose", cleanupEvents);
            player.reloadSourceOnError = reinitPlugin;
        };
        const reloadSourceOnError = function(options) {
            initPlugin(this, options);
        };
        var version$4 = "3.0.2";
        var version$3 = "6.3.0";
        var version$2 = "1.0.1";
        var version$1 = "6.0.0";
        var video_es_version = "4.0.1";
        const Vhs = {
            PlaylistLoader,
            Playlist,
            utils,
            STANDARD_PLAYLIST_SELECTOR: lastBandwidthSelector,
            INITIAL_PLAYLIST_SELECTOR: lowestBitrateCompatibleVariantSelector,
            lastBandwidthSelector,
            movingAverageBandwidthSelector,
            comparePlaylistBandwidth,
            comparePlaylistResolution,
            xhr: xhrFactory()
        };
        Object.keys(Config).forEach((prop => {
            Object.defineProperty(Vhs, prop, {
                get() {
                    videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);
                    return Config[prop];
                },
                set(value) {
                    videojs.log.warn(`using Vhs.${prop} is UNSAFE be sure you know what you are doing`);
                    if (typeof value !== "number" || value < 0) {
                        videojs.log.warn(`value of Vhs.${prop} must be greater than or equal to 0`);
                        return;
                    }
                    Config[prop] = value;
                }
            });
        }));
        const LOCAL_STORAGE_KEY = "videojs-vhs";
        const handleVhsMediaChange = function(qualityLevels, playlistLoader) {
            const newPlaylist = playlistLoader.media();
            let selectedIndex = -1;
            for (let i = 0; i < qualityLevels.length; i++) if (qualityLevels[i].id === newPlaylist.id) {
                selectedIndex = i;
                break;
            }
            qualityLevels.selectedIndex_ = selectedIndex;
            qualityLevels.trigger({
                selectedIndex,
                type: "change"
            });
        };
        const handleVhsLoadedMetadata = function(qualityLevels, vhs) {
            vhs.representations().forEach((rep => {
                qualityLevels.addQualityLevel(rep);
            }));
            handleVhsMediaChange(qualityLevels, vhs.playlists);
        };
        Vhs.canPlaySource = function() {
            return videojs.log.warn("VHS is no longer a tech. Please remove it from " + "your player's techOrder.");
        };
        const emeKeySystems = (keySystemOptions, mainPlaylist, audioPlaylist) => {
            if (!keySystemOptions) return keySystemOptions;
            let codecs = {};
            if (mainPlaylist && mainPlaylist.attributes && mainPlaylist.attributes.CODECS) codecs = unwrapCodecList(parseCodecs(mainPlaylist.attributes.CODECS));
            if (audioPlaylist && audioPlaylist.attributes && audioPlaylist.attributes.CODECS) codecs.audio = audioPlaylist.attributes.CODECS;
            const videoContentType = getMimeForCodec(codecs.video);
            const audioContentType = getMimeForCodec(codecs.audio);
            const keySystemContentTypes = {};
            for (const keySystem in keySystemOptions) {
                keySystemContentTypes[keySystem] = {};
                if (audioContentType) keySystemContentTypes[keySystem].audioContentType = audioContentType;
                if (videoContentType) keySystemContentTypes[keySystem].videoContentType = videoContentType;
                if (mainPlaylist.contentProtection && mainPlaylist.contentProtection[keySystem] && mainPlaylist.contentProtection[keySystem].pssh) keySystemContentTypes[keySystem].pssh = mainPlaylist.contentProtection[keySystem].pssh;
                if (typeof keySystemOptions[keySystem] === "string") keySystemContentTypes[keySystem].url = keySystemOptions[keySystem];
            }
            return video_es_merge(keySystemOptions, keySystemContentTypes);
        };
        const getAllPsshKeySystemsOptions = (playlists, keySystems) => playlists.reduce(((keySystemsArr, playlist) => {
            if (!playlist.contentProtection) return keySystemsArr;
            const keySystemsOptions = keySystems.reduce(((keySystemsObj, keySystem) => {
                const keySystemOptions = playlist.contentProtection[keySystem];
                if (keySystemOptions && keySystemOptions.pssh) keySystemsObj[keySystem] = {
                    pssh: keySystemOptions.pssh
                };
                return keySystemsObj;
            }), {});
            if (Object.keys(keySystemsOptions).length) keySystemsArr.push(keySystemsOptions);
            return keySystemsArr;
        }), []);
        const waitForKeySessionCreation = ({player, sourceKeySystems, audioMedia, mainPlaylists}) => {
            if (!player.eme.initializeMediaKeys) return Promise.resolve();
            const playlists = audioMedia ? mainPlaylists.concat([ audioMedia ]) : mainPlaylists;
            const keySystemsOptionsArr = getAllPsshKeySystemsOptions(playlists, Object.keys(sourceKeySystems));
            const initializationFinishedPromises = [];
            const keySessionCreatedPromises = [];
            keySystemsOptionsArr.forEach((keySystemsOptions => {
                keySessionCreatedPromises.push(new Promise(((resolve, reject) => {
                    player.tech_.one("keysessioncreated", resolve);
                })));
                initializationFinishedPromises.push(new Promise(((resolve, reject) => {
                    player.eme.initializeMediaKeys({
                        keySystems: keySystemsOptions
                    }, (err => {
                        if (err) {
                            reject(err);
                            return;
                        }
                        resolve();
                    }));
                })));
            }));
            return Promise.race([ Promise.all(initializationFinishedPromises), Promise.race(keySessionCreatedPromises) ]);
        };
        const setupEmeOptions = ({player, sourceKeySystems, media, audioMedia}) => {
            const sourceOptions = emeKeySystems(sourceKeySystems, media, audioMedia);
            if (!sourceOptions) return false;
            player.currentSource().keySystems = sourceOptions;
            if (sourceOptions && !player.eme) {
                videojs.log.warn("DRM encrypted source cannot be decrypted without a DRM plugin");
                return false;
            }
            return true;
        };
        const getVhsLocalStorage = () => {
            if (!window_default().localStorage) return null;
            const storedObject = window_default().localStorage.getItem(LOCAL_STORAGE_KEY);
            if (!storedObject) return null;
            try {
                return JSON.parse(storedObject);
            } catch (e) {
                return null;
            }
        };
        const updateVhsLocalStorage = options => {
            if (!window_default().localStorage) return false;
            let objectToStore = getVhsLocalStorage();
            objectToStore = objectToStore ? video_es_merge(objectToStore, options) : options;
            try {
                window_default().localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(objectToStore));
            } catch (e) {
                return false;
            }
            return objectToStore;
        };
        const expandDataUri = dataUri => {
            if (dataUri.toLowerCase().indexOf("data:application/vnd.videojs.vhs+json,") === 0) return JSON.parse(dataUri.substring(dataUri.indexOf(",") + 1));
            return dataUri;
        };
        Vhs.supportsNativeHls = function() {
            if (!document_default() || !document_default().createElement) return false;
            const video = document_default().createElement("video");
            if (!videojs.getTech("Html5").isSupported()) return false;
            const canPlay = [ "application/vnd.apple.mpegurl", "audio/mpegurl", "audio/x-mpegurl", "application/x-mpegurl", "video/x-mpegurl", "video/mpegurl", "application/mpegurl" ];
            return canPlay.some((function(canItPlay) {
                return /maybe|probably/i.test(video.canPlayType(canItPlay));
            }));
        }();
        Vhs.supportsNativeDash = function() {
            if (!document_default() || !document_default().createElement || !videojs.getTech("Html5").isSupported()) return false;
            return /maybe|probably/i.test(document_default().createElement("video").canPlayType("application/dash+xml"));
        }();
        Vhs.supportsTypeNatively = type => {
            if (type === "hls") return Vhs.supportsNativeHls;
            if (type === "dash") return Vhs.supportsNativeDash;
            return false;
        };
        Vhs.isSupported = function() {
            return videojs.log.warn("VHS is no longer a tech. Please remove it from " + "your player's techOrder.");
        };
        const Component = videojs.getComponent("Component");
        class VhsHandler extends Component {
            constructor(source, tech, options) {
                super(tech, options.vhs);
                if (typeof options.initialBandwidth === "number") this.options_.bandwidth = options.initialBandwidth;
                this.logger_ = logger("VhsHandler");
                if (tech.options_ && tech.options_.playerId) {
                    const _player = videojs.getPlayer(tech.options_.playerId);
                    this.player_ = _player;
                }
                this.tech_ = tech;
                this.source_ = source;
                this.stats = {};
                this.ignoreNextSeekingEvent_ = false;
                this.setOptions_();
                if (this.options_.overrideNative && tech.overrideNativeAudioTracks && tech.overrideNativeVideoTracks) {
                    tech.overrideNativeAudioTracks(true);
                    tech.overrideNativeVideoTracks(true);
                } else if (this.options_.overrideNative && (tech.featuresNativeVideoTracks || tech.featuresNativeAudioTracks)) throw new Error("Overriding native VHS requires emulated tracks. " + "See https://git.io/vMpjB");
                this.on(document_default(), [ "fullscreenchange", "webkitfullscreenchange", "mozfullscreenchange", "MSFullscreenChange" ], (event => {
                    const fullscreenElement = document_default().fullscreenElement || document_default().webkitFullscreenElement || document_default().mozFullScreenElement || document_default().msFullscreenElement;
                    if (fullscreenElement && fullscreenElement.contains(this.tech_.el())) this.playlistController_.fastQualityChange_(); else this.playlistController_.checkABR_();
                }));
                this.on(this.tech_, "seeking", (function() {
                    if (this.ignoreNextSeekingEvent_) {
                        this.ignoreNextSeekingEvent_ = false;
                        return;
                    }
                    this.setCurrentTime(this.tech_.currentTime());
                }));
                this.on(this.tech_, "error", (function() {
                    if (this.tech_.error() && this.playlistController_) this.playlistController_.pauseLoading();
                }));
                this.on(this.tech_, "play", this.play);
            }
            setOptions_() {
                this.options_.withCredentials = this.options_.withCredentials || false;
                this.options_.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions === false ? false : true;
                this.options_.useDevicePixelRatio = this.options_.useDevicePixelRatio || false;
                this.options_.useBandwidthFromLocalStorage = typeof this.source_.useBandwidthFromLocalStorage !== "undefined" ? this.source_.useBandwidthFromLocalStorage : this.options_.useBandwidthFromLocalStorage || false;
                this.options_.useNetworkInformationApi = this.options_.useNetworkInformationApi || false;
                this.options_.useDtsForTimestampOffset = this.options_.useDtsForTimestampOffset || false;
                this.options_.customTagParsers = this.options_.customTagParsers || [];
                this.options_.customTagMappers = this.options_.customTagMappers || [];
                this.options_.cacheEncryptionKeys = this.options_.cacheEncryptionKeys || false;
                this.options_.llhls = this.options_.llhls === false ? false : true;
                this.options_.bufferBasedABR = this.options_.bufferBasedABR || false;
                if (typeof this.options_.playlistExclusionDuration !== "number") this.options_.playlistExclusionDuration = 5 * 60;
                if (typeof this.options_.bandwidth !== "number") if (this.options_.useBandwidthFromLocalStorage) {
                    const storedObject = getVhsLocalStorage();
                    if (storedObject && storedObject.bandwidth) {
                        this.options_.bandwidth = storedObject.bandwidth;
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-bandwidth-from-local-storage"
                        });
                    }
                    if (storedObject && storedObject.throughput) {
                        this.options_.throughput = storedObject.throughput;
                        this.tech_.trigger({
                            type: "usage",
                            name: "vhs-throughput-from-local-storage"
                        });
                    }
                }
                if (typeof this.options_.bandwidth !== "number") this.options_.bandwidth = Config.INITIAL_BANDWIDTH;
                this.options_.enableLowInitialPlaylist = this.options_.enableLowInitialPlaylist && this.options_.bandwidth === Config.INITIAL_BANDWIDTH;
                [ "withCredentials", "useDevicePixelRatio", "limitRenditionByPlayerDimensions", "bandwidth", "customTagParsers", "customTagMappers", "cacheEncryptionKeys", "playlistSelector", "initialPlaylistSelector", "bufferBasedABR", "liveRangeSafeTimeDelta", "llhls", "useNetworkInformationApi", "useDtsForTimestampOffset", "exactManifestTimings", "leastPixelDiffSelector" ].forEach((option => {
                    if (typeof this.source_[option] !== "undefined") this.options_[option] = this.source_[option];
                }));
                this.limitRenditionByPlayerDimensions = this.options_.limitRenditionByPlayerDimensions;
                this.useDevicePixelRatio = this.options_.useDevicePixelRatio;
            }
            src(src, type) {
                if (!src) return;
                this.setOptions_();
                this.options_.src = expandDataUri(this.source_.src);
                this.options_.tech = this.tech_;
                this.options_.externVhs = Vhs;
                this.options_.sourceType = simpleTypeFromSourceType(type);
                this.options_.seekTo = time => {
                    this.tech_.setCurrentTime(time);
                };
                this.playlistController_ = new PlaylistController(this.options_);
                const playbackWatcherOptions = video_es_merge({
                    liveRangeSafeTimeDelta: SAFE_TIME_DELTA
                }, this.options_, {
                    seekable: () => this.seekable(),
                    media: () => this.playlistController_.media(),
                    playlistController: this.playlistController_
                });
                this.playbackWatcher_ = new PlaybackWatcher(playbackWatcherOptions);
                this.playlistController_.on("error", (() => {
                    const player = videojs.players[this.tech_.options_.playerId];
                    let error = this.playlistController_.error;
                    if (typeof error === "object" && !error.code) error.code = 3; else if (typeof error === "string") error = {
                        message: error,
                        code: 3
                    };
                    player.error(error);
                }));
                const defaultSelector = this.options_.bufferBasedABR ? Vhs.movingAverageBandwidthSelector(.55) : Vhs.STANDARD_PLAYLIST_SELECTOR;
                this.playlistController_.selectPlaylist = this.selectPlaylist ? this.selectPlaylist.bind(this) : defaultSelector.bind(this);
                this.playlistController_.selectInitialPlaylist = Vhs.INITIAL_PLAYLIST_SELECTOR.bind(this);
                this.playlists = this.playlistController_.mainPlaylistLoader_;
                this.mediaSource = this.playlistController_.mediaSource;
                Object.defineProperties(this, {
                    selectPlaylist: {
                        get() {
                            return this.playlistController_.selectPlaylist;
                        },
                        set(selectPlaylist) {
                            this.playlistController_.selectPlaylist = selectPlaylist.bind(this);
                        }
                    },
                    throughput: {
                        get() {
                            return this.playlistController_.mainSegmentLoader_.throughput.rate;
                        },
                        set(throughput) {
                            this.playlistController_.mainSegmentLoader_.throughput.rate = throughput;
                            this.playlistController_.mainSegmentLoader_.throughput.count = 1;
                        }
                    },
                    bandwidth: {
                        get() {
                            let playerBandwidthEst = this.playlistController_.mainSegmentLoader_.bandwidth;
                            const networkInformation = window_default().navigator.connection || window_default().navigator.mozConnection || window_default().navigator.webkitConnection;
                            const tenMbpsAsBitsPerSecond = 1e7;
                            if (this.options_.useNetworkInformationApi && networkInformation) {
                                const networkInfoBandwidthEstBitsPerSec = networkInformation.downlink * 1e3 * 1e3;
                                if (networkInfoBandwidthEstBitsPerSec >= tenMbpsAsBitsPerSecond && playerBandwidthEst >= tenMbpsAsBitsPerSecond) playerBandwidthEst = Math.max(playerBandwidthEst, networkInfoBandwidthEstBitsPerSec); else playerBandwidthEst = networkInfoBandwidthEstBitsPerSec;
                            }
                            return playerBandwidthEst;
                        },
                        set(bandwidth) {
                            this.playlistController_.mainSegmentLoader_.bandwidth = bandwidth;
                            this.playlistController_.mainSegmentLoader_.throughput = {
                                rate: 0,
                                count: 0
                            };
                        }
                    },
                    systemBandwidth: {
                        get() {
                            const invBandwidth = 1 / (this.bandwidth || 1);
                            let invThroughput;
                            if (this.throughput > 0) invThroughput = 1 / this.throughput; else invThroughput = 0;
                            const systemBitrate = Math.floor(1 / (invBandwidth + invThroughput));
                            return systemBitrate;
                        },
                        set() {
                            videojs.log.error('The "systemBandwidth" property is read-only');
                        }
                    }
                });
                if (this.options_.bandwidth) this.bandwidth = this.options_.bandwidth;
                if (this.options_.throughput) this.throughput = this.options_.throughput;
                Object.defineProperties(this.stats, {
                    bandwidth: {
                        get: () => this.bandwidth || 0,
                        enumerable: true
                    },
                    mediaRequests: {
                        get: () => this.playlistController_.mediaRequests_() || 0,
                        enumerable: true
                    },
                    mediaRequestsAborted: {
                        get: () => this.playlistController_.mediaRequestsAborted_() || 0,
                        enumerable: true
                    },
                    mediaRequestsTimedout: {
                        get: () => this.playlistController_.mediaRequestsTimedout_() || 0,
                        enumerable: true
                    },
                    mediaRequestsErrored: {
                        get: () => this.playlistController_.mediaRequestsErrored_() || 0,
                        enumerable: true
                    },
                    mediaTransferDuration: {
                        get: () => this.playlistController_.mediaTransferDuration_() || 0,
                        enumerable: true
                    },
                    mediaBytesTransferred: {
                        get: () => this.playlistController_.mediaBytesTransferred_() || 0,
                        enumerable: true
                    },
                    mediaSecondsLoaded: {
                        get: () => this.playlistController_.mediaSecondsLoaded_() || 0,
                        enumerable: true
                    },
                    mediaAppends: {
                        get: () => this.playlistController_.mediaAppends_() || 0,
                        enumerable: true
                    },
                    mainAppendsToLoadedData: {
                        get: () => this.playlistController_.mainAppendsToLoadedData_() || 0,
                        enumerable: true
                    },
                    audioAppendsToLoadedData: {
                        get: () => this.playlistController_.audioAppendsToLoadedData_() || 0,
                        enumerable: true
                    },
                    appendsToLoadedData: {
                        get: () => this.playlistController_.appendsToLoadedData_() || 0,
                        enumerable: true
                    },
                    timeToLoadedData: {
                        get: () => this.playlistController_.timeToLoadedData_() || 0,
                        enumerable: true
                    },
                    buffered: {
                        get: () => timeRangesToArray(this.tech_.buffered()),
                        enumerable: true
                    },
                    currentTime: {
                        get: () => this.tech_.currentTime(),
                        enumerable: true
                    },
                    currentSource: {
                        get: () => this.tech_.currentSource_,
                        enumerable: true
                    },
                    currentTech: {
                        get: () => this.tech_.name_,
                        enumerable: true
                    },
                    duration: {
                        get: () => this.tech_.duration(),
                        enumerable: true
                    },
                    main: {
                        get: () => this.playlists.main,
                        enumerable: true
                    },
                    playerDimensions: {
                        get: () => this.tech_.currentDimensions(),
                        enumerable: true
                    },
                    seekable: {
                        get: () => timeRangesToArray(this.tech_.seekable()),
                        enumerable: true
                    },
                    timestamp: {
                        get: () => Date.now(),
                        enumerable: true
                    },
                    videoPlaybackQuality: {
                        get: () => this.tech_.getVideoPlaybackQuality(),
                        enumerable: true
                    }
                });
                this.tech_.one("canplay", this.playlistController_.setupFirstPlay.bind(this.playlistController_));
                this.tech_.on("bandwidthupdate", (() => {
                    if (this.options_.useBandwidthFromLocalStorage) updateVhsLocalStorage({
                        bandwidth: this.bandwidth,
                        throughput: Math.round(this.throughput)
                    });
                }));
                this.playlistController_.on("selectedinitialmedia", (() => {
                    renditionSelectionMixin(this);
                }));
                this.playlistController_.sourceUpdater_.on("createdsourcebuffers", (() => {
                    this.setupEme_();
                }));
                this.on(this.playlistController_, "progress", (function() {
                    this.tech_.trigger("progress");
                }));
                this.on(this.playlistController_, "firstplay", (function() {
                    this.ignoreNextSeekingEvent_ = true;
                }));
                this.setupQualityLevels_();
                if (!this.tech_.el()) return;
                this.mediaSourceUrl_ = window_default().URL.createObjectURL(this.playlistController_.mediaSource);
                this.tech_.src(this.mediaSourceUrl_);
            }
            createKeySessions_() {
                const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
                this.logger_("waiting for EME key session creation");
                waitForKeySessionCreation({
                    player: this.player_,
                    sourceKeySystems: this.source_.keySystems,
                    audioMedia: audioPlaylistLoader && audioPlaylistLoader.media(),
                    mainPlaylists: this.playlists.main.playlists
                }).then((() => {
                    this.logger_("created EME key session");
                    this.playlistController_.sourceUpdater_.initializedEme();
                })).catch((err => {
                    this.logger_("error while creating EME key session", err);
                    this.player_.error({
                        message: "Failed to initialize media keys for EME",
                        code: 3
                    });
                }));
            }
            handleWaitingForKey_() {
                this.logger_("waitingforkey fired, attempting to create any new key sessions");
                this.createKeySessions_();
            }
            setupEme_() {
                const audioPlaylistLoader = this.playlistController_.mediaTypes_.AUDIO.activePlaylistLoader;
                const didSetupEmeOptions = setupEmeOptions({
                    player: this.player_,
                    sourceKeySystems: this.source_.keySystems,
                    media: this.playlists.media(),
                    audioMedia: audioPlaylistLoader && audioPlaylistLoader.media()
                });
                this.player_.tech_.on("keystatuschange", (e => {
                    if (e.status !== "output-restricted") return;
                    const mainPlaylist = this.playlistController_.main();
                    if (!mainPlaylist || !mainPlaylist.playlists) return;
                    const excludedHDPlaylists = [];
                    mainPlaylist.playlists.forEach((playlist => {
                        if (playlist && playlist.attributes && playlist.attributes.RESOLUTION && playlist.attributes.RESOLUTION.height >= 720) if (!playlist.excludeUntil || playlist.excludeUntil < 1 / 0) {
                            playlist.excludeUntil = 1 / 0;
                            excludedHDPlaylists.push(playlist);
                        }
                    }));
                    if (excludedHDPlaylists.length) {
                        videojs.log.warn('DRM keystatus changed to "output-restricted." Removing the following HD playlists ' + "that will most likely fail to play and clearing the buffer. " + "This may be due to HDCP restrictions on the stream and the capabilities of the current device.", ...excludedHDPlaylists);
                        this.playlistController_.fastQualityChange_();
                    }
                }));
                this.handleWaitingForKey_ = this.handleWaitingForKey_.bind(this);
                this.player_.tech_.on("waitingforkey", this.handleWaitingForKey_);
                if (videojs.browser.IE_VERSION === 11 || !didSetupEmeOptions) {
                    this.playlistController_.sourceUpdater_.initializedEme();
                    return;
                }
                this.createKeySessions_();
            }
            setupQualityLevels_() {
                const player = videojs.players[this.tech_.options_.playerId];
                if (!player || !player.qualityLevels || this.qualityLevels_) return;
                this.qualityLevels_ = player.qualityLevels();
                this.playlistController_.on("selectedinitialmedia", (() => {
                    handleVhsLoadedMetadata(this.qualityLevels_, this);
                }));
                this.playlists.on("mediachange", (() => {
                    handleVhsMediaChange(this.qualityLevels_, this.playlists);
                }));
            }
            static version() {
                return {
                    "@videojs/http-streaming": version$4,
                    "mux.js": version$3,
                    "mpd-parser": version$2,
                    "m3u8-parser": version$1,
                    "aes-decrypter": video_es_version
                };
            }
            version() {
                return this.constructor.version();
            }
            canChangeType() {
                return SourceUpdater.canChangeType();
            }
            play() {
                this.playlistController_.play();
            }
            setCurrentTime(currentTime) {
                this.playlistController_.setCurrentTime(currentTime);
            }
            duration() {
                return this.playlistController_.duration();
            }
            seekable() {
                return this.playlistController_.seekable();
            }
            dispose() {
                if (this.playbackWatcher_) this.playbackWatcher_.dispose();
                if (this.playlistController_) this.playlistController_.dispose();
                if (this.qualityLevels_) this.qualityLevels_.dispose();
                if (this.tech_ && this.tech_.vhs) delete this.tech_.vhs;
                if (this.mediaSourceUrl_ && window_default().URL.revokeObjectURL) {
                    window_default().URL.revokeObjectURL(this.mediaSourceUrl_);
                    this.mediaSourceUrl_ = null;
                }
                if (this.tech_) this.tech_.off("waitingforkey", this.handleWaitingForKey_);
                super.dispose();
            }
            convertToProgramTime(time, callback) {
                return getProgramTime({
                    playlist: this.playlistController_.media(),
                    time,
                    callback
                });
            }
            seekToProgramTime(programTime, callback, pauseAfterSeek = true, retryCount = 2) {
                return seekToProgramTime({
                    programTime,
                    playlist: this.playlistController_.media(),
                    retryCount,
                    pauseAfterSeek,
                    seekTo: this.options_.seekTo,
                    tech: this.options_.tech,
                    callback
                });
            }
        }
        const VhsSourceHandler = {
            name: "videojs-http-streaming",
            VERSION: version$4,
            canHandleSource(srcObj, options = {}) {
                const localOptions = video_es_merge(videojs.options, options);
                return VhsSourceHandler.canPlayType(srcObj.type, localOptions);
            },
            handleSource(source, tech, options = {}) {
                const localOptions = video_es_merge(videojs.options, options);
                tech.vhs = new VhsHandler(source, tech, localOptions);
                tech.vhs.xhr = xhrFactory();
                tech.vhs.src(source.src, source.type);
                return tech.vhs;
            },
            canPlayType(type, options) {
                const simpleType = simpleTypeFromSourceType(type);
                if (!simpleType) return "";
                const overrideNative = VhsSourceHandler.getOverrideNative(options);
                const supportsTypeNatively = Vhs.supportsTypeNatively(simpleType);
                const canUseMsePlayback = !supportsTypeNatively || overrideNative;
                return canUseMsePlayback ? "maybe" : "";
            },
            getOverrideNative(options = {}) {
                const {vhs = {}} = options;
                const defaultOverrideNative = !(videojs.browser.IS_ANY_SAFARI || videojs.browser.IS_IOS);
                const {overrideNative = defaultOverrideNative} = vhs;
                return overrideNative;
            }
        };
        const supportsNativeMediaSources = () => browserSupportsCodec("avc1.4d400d,mp4a.40.2");
        if (supportsNativeMediaSources()) videojs.getTech("Html5").registerSourceHandler(VhsSourceHandler, 0);
        videojs.VhsHandler = VhsHandler;
        videojs.VhsSourceHandler = VhsSourceHandler;
        videojs.Vhs = Vhs;
        if (!videojs.use) videojs.registerComponent("Vhs", Vhs);
        videojs.options.vhs = videojs.options.vhs || {};
        if (!videojs.getPlugin || !videojs.getPlugin("reloadSourceOnError")) videojs.registerPlugin("reloadSourceOnError", reloadSourceOnError);
        window["FLS"] = true;
        isWebp();
        menuInit();
        spollers();
        formFieldsInit({
            viewPass: true,
            autoHeight: false
        });
        formSubmit();
        pageNavigation();
    })();
})();